/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../Typedefs/jquery/jquery.d.ts"/> 
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    (function (VisualDataRoleKind) {
        /** Indicates that the role should be bound to something that evaluates to a grouping of values. */
        VisualDataRoleKind[VisualDataRoleKind["Grouping"] = 0] = "Grouping";
        /** Indicates that the role should be bound to something that evaluates to a single value in a scope. */
        VisualDataRoleKind[VisualDataRoleKind["Measure"] = 1] = "Measure";
        /** Indicates that the role can be bound to either Grouping or Measure. */
        VisualDataRoleKind[VisualDataRoleKind["GroupingOrMeasure"] = 2] = "GroupingOrMeasure";
    })(powerbi.VisualDataRoleKind || (powerbi.VisualDataRoleKind = {}));
    var VisualDataRoleKind = powerbi.VisualDataRoleKind;
    (function (VisualDataChangeOperationKind) {
        VisualDataChangeOperationKind[VisualDataChangeOperationKind["Create"] = 0] = "Create";
        VisualDataChangeOperationKind[VisualDataChangeOperationKind["Append"] = 1] = "Append";
    })(powerbi.VisualDataChangeOperationKind || (powerbi.VisualDataChangeOperationKind = {}));
    var VisualDataChangeOperationKind = powerbi.VisualDataChangeOperationKind;
    (function (VisualUpdateType) {
        VisualUpdateType[VisualUpdateType["Data"] = 2] = "Data";
        VisualUpdateType[VisualUpdateType["Resize"] = 4] = "Resize";
        VisualUpdateType[VisualUpdateType["ViewMode"] = 8] = "ViewMode";
        VisualUpdateType[VisualUpdateType["Style"] = 16] = "Style";
        VisualUpdateType[VisualUpdateType["ResizeEnd"] = 32] = "ResizeEnd";
    })(powerbi.VisualUpdateType || (powerbi.VisualUpdateType = {}));
    var VisualUpdateType = powerbi.VisualUpdateType;
    (function (VisualPermissions) {
    })(powerbi.VisualPermissions || (powerbi.VisualPermissions = {}));
    var VisualPermissions = powerbi.VisualPermissions;
    var visuals;
    (function (visuals) {
        var telemetry;
        (function (telemetry) {
            (function (ErrorSource) {
                ErrorSource[ErrorSource["PowerBI"] = 0] = "PowerBI";
                ErrorSource[ErrorSource["External"] = 1] = "External";
                ErrorSource[ErrorSource["User"] = 2] = "User";
            })(telemetry.ErrorSource || (telemetry.ErrorSource = {}));
            var ErrorSource = telemetry.ErrorSource;
        })(telemetry = visuals.telemetry || (visuals.telemetry = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));


;/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../Typedefs/jquery/jquery.d.ts"/>
///<reference path="../../Typedefs/globalize/globalize.d.ts"/>
///<reference path="../../Typedefs/lodash/lodash.d.ts"/>
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var telemetry;
        (function (telemetry) {
            /**
             * Creates a client-side Guid string.
             * @returns A string representation of a Guid.
             */
            function generateGuid() {
                var guid = "", idx = 0;
                for (idx = 0; idx < 32; idx += 1) {
                    var guidDigitsItem = Math.random() * 16 | 0;
                    switch (idx) {
                        case 8:
                        case 12:
                        case 16:
                        case 20:
                            guid += "-";
                            break;
                    }
                    guid += guidDigitsItem.toString(16);
                }
                return guid;
            }
            telemetry.generateGuid = generateGuid;
        })(telemetry = visuals.telemetry || (visuals.telemetry = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var telemetry;
        (function (telemetry) {
            telemetry.ExtensibilityVisualApiUsage = function (name, apiVersion, custom, parentId, isError, errorSource, errorCode) {
                if (isError === void 0) { isError = false; }
                if (errorSource === void 0) { errorSource = undefined; }
                if (errorCode === void 0) { errorCode = undefined; }
                var info = {
                    name: name,
                    apiVersion: apiVersion,
                    custom: custom,
                    parentId: parentId,
                    isError: isError,
                    errorSource: errorSource,
                    errorCode: errorCode,
                };
                var event = {
                    name: 'PBI.Extensibility.VisualApiUsage',
                    category: 1 /* CustomerAction */,
                    time: Date.now(),
                    id: telemetry.generateGuid(),
                    getFormattedInfoObject: function () {
                        var formattedObject = {
                            name: info.name,
                            apiVersion: info.apiVersion,
                            custom: info.custom,
                            parentId: info.parentId,
                            isError: info.isError,
                        };
                        if (typeof info.errorSource !== 'undefined') {
                            formattedObject['errorSource'] = telemetry.ErrorSource[info.errorSource];
                        }
                        if (typeof info.errorCode !== 'undefined') {
                            formattedObject['errorCode'] = info.errorCode;
                        }
                        return formattedObject;
                    },
                    info: info,
                    privateFields: [],
                    orgInfoFields: []
                };
                if (typeof telemetry.ExtensibilityVisualApiUsageLoggers !== 'undefined') {
                    event.loggers = telemetry.ExtensibilityVisualApiUsageLoggers;
                }
                return event;
            };
            telemetry.VisualException = function (visualType, isCustom, apiVersion, source, lineNumber, columnNumber, stack, message) {
                var info = {
                    visualType: visualType,
                    isCustom: isCustom,
                    apiVersion: apiVersion,
                    source: source,
                    lineNumber: lineNumber,
                    columnNumber: columnNumber,
                    stack: stack,
                    message: message,
                };
                var event = {
                    name: 'PBI.VisualException',
                    category: 2 /* CriticalError */,
                    time: Date.now(),
                    id: telemetry.generateGuid(),
                    getFormattedInfoObject: function () {
                        var formattedObject = {
                            visualType: info.visualType,
                            isCustom: info.isCustom,
                            apiVersion: info.apiVersion,
                            source: info.source,
                            lineNumber: info.lineNumber,
                            columnNumber: info.columnNumber,
                            stack: info.stack,
                            message: info.message,
                        };
                        return formattedObject;
                    },
                    info: info,
                    privateFields: [],
                    orgInfoFields: []
                };
                if (typeof telemetry.VisualExceptionLoggers !== 'undefined') {
                    event.loggers = telemetry.VisualExceptionLoggers;
                }
                return event;
            };
        })(telemetry = visuals.telemetry || (visuals.telemetry = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var extensibility;
    (function (extensibility) {
        ;
        var SelectionManager = (function () {
            function SelectionManager(options) {
                this.hostServices = options.hostServices;
                this.selectedIds = [];
                this.promiseFactory = this.hostServices.promiseFactory();
            }
            SelectionManager.prototype.select = function (selectionId, multiSelect) {
                if (multiSelect === void 0) { multiSelect = false; }
                var deferred = this.promiseFactory.defer();
                if (this.hostServices.shouldRetainSelection()) {
                    this.sendSelectionToHost([selectionId]);
                }
                else {
                    this.selectInternal(selectionId, multiSelect);
                    this.sendSelectionToHost(this.selectedIds);
                }
                deferred.resolve(this.selectedIds);
                return deferred.promise;
            };
            SelectionManager.prototype.showContextMenu = function (selectionId, position) {
                var deferred = this.promiseFactory.defer();
                this.sendContextMenuToHost(selectionId, position);
                deferred.resolve(null);
                return deferred.promise;
            };
            SelectionManager.prototype.hasSelection = function () {
                return this.selectedIds.length > 0;
            };
            SelectionManager.prototype.clear = function () {
                var deferred = this.promiseFactory.defer();
                this.selectedIds = [];
                this.sendSelectionToHost([]);
                deferred.resolve(null);
                return deferred.promise;
            };
            SelectionManager.prototype.getSelectionIds = function () {
                return this.selectedIds;
            };
            SelectionManager.prototype.sendSelectionToHost = function (ids) {
                var selectArgs = {
                    data: ids
                        .filter(function (value) { return value.hasIdentity(); })
                        .map(function (value) { return value.getSelector(); })
                };
                var data2 = this.getSelectorsByColumn(ids);
                if (!_.isEmpty(data2))
                    selectArgs.data2 = data2;
                this.hostServices.onSelect(selectArgs);
            };
            SelectionManager.prototype.sendContextMenuToHost = function (selectionId, position) {
                var selectors = this.getSelectorsByColumn([selectionId]);
                if (_.isEmpty(selectors))
                    return;
                var args = {
                    data: selectors,
                    position: position
                };
                this.hostServices.onContextMenu(args);
            };
            SelectionManager.prototype.getSelectorsByColumn = function (selectionIds) {
                return _(selectionIds)
                    .filter(function (value) { return value.hasIdentity; })
                    .map(function (value) { return value.getSelectorsByColumn(); })
                    .compact()
                    .value();
            };
            SelectionManager.prototype.selectInternal = function (selectionId, multiSelect) {
                if (SelectionManager.containsSelection(this.selectedIds, selectionId)) {
                    this.selectedIds = multiSelect
                        ? this.selectedIds.filter(function (d) { return !selectionId.equals(d); })
                        : this.selectedIds.length > 1
                            ? [selectionId] : [];
                }
                else {
                    if (multiSelect)
                        this.selectedIds.push(selectionId);
                    else
                        this.selectedIds = [selectionId];
                }
            };
            SelectionManager.containsSelection = function (list, id) {
                return list.some(function (d) { return id.equals(d); });
            };
            return SelectionManager;
        }());
        extensibility.SelectionManager = SelectionManager;
    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var extensibility;
    (function (extensibility) {
        /**
         * This class is designed to simplify the creation of SelectionId objects
         * It allows chaining to build up an object before calling 'create' to build a SelectionId
         */
        var SelectionIdBuilder = (function () {
            function SelectionIdBuilder() {
            }
            SelectionIdBuilder.prototype.withCategory = function (categoryColumn, index) {
                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)
                    this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];
                return this;
            };
            SelectionIdBuilder.prototype.withSeries = function (seriesColumn, valueColumn) {
                if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)
                    this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;
                return this;
            };
            SelectionIdBuilder.prototype.withMeasure = function (measureId) {
                this.measure = measureId;
                return this;
            };
            SelectionIdBuilder.prototype.createSelectionId = function () {
                return powerbi.visuals.SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);
            };
            SelectionIdBuilder.prototype.ensureDataMap = function () {
                if (!this.dataMap)
                    this.dataMap = {};
                return this.dataMap;
            };
            return SelectionIdBuilder;
        }());
        extensibility.SelectionIdBuilder = SelectionIdBuilder;
    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var extensibility;
    (function (extensibility) {
        var ExtensibilityVisualApiUsage = powerbi.visuals.telemetry.ExtensibilityVisualApiUsage;
        //TODO: refactor this into a service
        extensibility.visualApiVersions = [];
        function createVisualAdapter(visualPlugin, telemetryService) {
            var visualTelemetryInfo = {
                name: visualPlugin.name,
                apiVersion: visualPlugin.apiVersion,
                custom: !!visualPlugin.custom
            };
            return new extensibility.VisualSafeExecutionWrapper(new VisualAdapter(visualPlugin, telemetryService), visualTelemetryInfo, telemetryService);
        }
        extensibility.createVisualAdapter = createVisualAdapter;
        var VisualAdapter = (function () {
            function VisualAdapter(visualPlugin, telemetryService) {
                this.telemetryService = telemetryService;
                this.plugin = visualPlugin;
                var version = visualPlugin.apiVersion;
                var versionIndex = this.getVersionIndex(version);
                var isError = false;
                if (!version) {
                    this.legacy = true;
                }
                else if (versionIndex > -1) {
                    this.apiVersionIndex = versionIndex;
                    this.legacy = false;
                }
                else {
                    debug.assertFail("The API version '" + version + "' is invalid.");
                    isError = true;
                }
                if (this.telemetryService) {
                    this.telemetryService.logEvent(ExtensibilityVisualApiUsage, this.plugin.name, this.plugin.apiVersion, !!this.plugin.custom, undefined, isError, powerbi.visuals.telemetry.ErrorSource.User);
                }
            }
            VisualAdapter.prototype.init = function (options) {
                options.element.empty();
                if (this.legacy) {
                    this.visual = this.plugin.create();
                    this.visualLegacy.init(options);
                }
                else {
                    var host = extensibility.visualApiVersions[this.apiVersionIndex].hostAdapter(options.host);
                    this.visual = this.plugin.create({
                        element: options.element.get(0),
                        host: host
                    });
                    this.overloadMethods();
                }
            };
            VisualAdapter.prototype.update = function (options) {
                if (options.type & powerbi.VisualUpdateType.Resize && this.visualHasMethod('onResizing')) {
                    this.onResizing(options.viewport, options.resizeMode);
                }
                else if (this.visualHasMethod('update')) {
                    this.visualLegacy.update(options);
                }
                else {
                    if (!options.type || options.type & powerbi.VisualUpdateType.Data) {
                        this.onDataChanged(_.pick(options, ['dataViews', 'operationKind']));
                    }
                    if (options.type & powerbi.VisualUpdateType.ViewMode) {
                        this.onViewModeChanged(options.viewMode);
                    }
                }
            };
            VisualAdapter.prototype.destroy = function () {
                if (this.visualHasMethod('destroy')) {
                    this.visualLegacy.destroy();
                }
            };
            VisualAdapter.prototype.enumerateObjectInstances = function (options) {
                if (!this.visualHasMethod('enumerateObjectInstances')) {
                    return;
                }
                return this.visualLegacy.enumerateObjectInstances(options);
            };
            VisualAdapter.prototype.onResizing = function (finalViewport, resizeMode) {
                if (this.visualHasMethod('onResizing')) {
                    this.visualLegacy.onResizing(finalViewport, resizeMode);
                }
            };
            VisualAdapter.prototype.onDataChanged = function (options) {
                if (this.visualHasMethod('onDataChanged')) {
                    this.visualLegacy.onDataChanged(options);
                }
            };
            VisualAdapter.prototype.onViewModeChanged = function (viewMode) {
                if (this.visualHasMethod('onViewModeChanged')) {
                    this.visualLegacy.onViewModeChanged(viewMode);
                }
            };
            VisualAdapter.prototype.onClearSelection = function () {
                if (this.visualHasMethod('onClearSelection')) {
                    this.visualLegacy.onClearSelection();
                }
            };
            VisualAdapter.prototype.canResizeTo = function (viewport) {
                if (this.visualHasMethod('canResizeTo')) {
                    return this.visualLegacy.canResizeTo(viewport);
                }
            };
            VisualAdapter.prototype.unwrap = function () {
                return this.visual;
            };
            Object.defineProperty(VisualAdapter.prototype, "visualNew", {
                get: function () {
                    if (this.legacy)
                        return;
                    return this.visual;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VisualAdapter.prototype, "visualLegacy", {
                get: function () {
                    if (!this.legacy)
                        return;
                    return this.visual;
                },
                enumerable: true,
                configurable: true
            });
            VisualAdapter.prototype.visualHasMethod = function (methodName) {
                var visual = this.legacy ? this.visualLegacy : this.visualNew;
                return visual && _.isFunction(visual[methodName]);
            };
            VisualAdapter.prototype.getVersionIndex = function (version) {
                if (version) {
                    var versionCount = extensibility.visualApiVersions.length;
                    for (var i = 0; i < versionCount; i++) {
                        if (extensibility.visualApiVersions[i].version === version) {
                            return i;
                        }
                    }
                }
                return -1;
            };
            VisualAdapter.prototype.overloadMethods = function () {
                var overloads = this.getCompiledOverloads();
                for (var key in overloads) {
                    this[key] = overloads[key];
                }
            };
            VisualAdapter.prototype.getCompiledOverloads = function () {
                var overloads = {};
                var versionIndex = this.apiVersionIndex;
                var visualNew = this.visualNew;
                for (var i = 0; i <= versionIndex; i++) {
                    var overloadFactory = extensibility.visualApiVersions[i].overloads;
                    if (_.isFunction(overloadFactory)) {
                        _.assign(overloads, overloadFactory(visualNew));
                    }
                }
                return overloads;
            };
            return VisualAdapter;
        }());
        extensibility.VisualAdapter = VisualAdapter;
    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var extensibility;
    (function (extensibility) {
        var VisualException = powerbi.visuals.telemetry.VisualException;
        var VisualSafeExecutionWrapper = (function () {
            function VisualSafeExecutionWrapper(wrappedVisual, visualInfo, telemetryService, silent) {
                this.wrappedVisual = wrappedVisual;
                this.visualInfo = visualInfo;
                this.telemetryService = telemetryService;
                this.silent = silent;
            }
            VisualSafeExecutionWrapper.prototype.init = function (options) {
                var _this = this;
                if (this.wrappedVisual.init) {
                    this.executeSafely(function () { return _this.wrappedVisual.init(options); });
                }
            };
            VisualSafeExecutionWrapper.prototype.destroy = function () {
                var _this = this;
                if (this.wrappedVisual.destroy)
                    this.executeSafely(function () { return _this.wrappedVisual.destroy(); });
            };
            VisualSafeExecutionWrapper.prototype.update = function (options) {
                var _this = this;
                if (this.wrappedVisual.update)
                    this.executeSafely(function () { return _this.wrappedVisual.update(options); });
            };
            VisualSafeExecutionWrapper.prototype.onResizing = function (finalViewport, resizeMode) {
                var _this = this;
                if (this.wrappedVisual.onResizing)
                    this.executeSafely(function () { return _this.wrappedVisual.onResizing(finalViewport, resizeMode); });
            };
            VisualSafeExecutionWrapper.prototype.onDataChanged = function (options) {
                var _this = this;
                if (this.wrappedVisual.onDataChanged)
                    this.executeSafely(function () { return _this.wrappedVisual.onDataChanged(options); });
            };
            VisualSafeExecutionWrapper.prototype.onViewModeChanged = function (viewMode) {
                var _this = this;
                if (this.wrappedVisual.onViewModeChanged)
                    this.executeSafely(function () { return _this.wrappedVisual.onViewModeChanged(viewMode); });
            };
            VisualSafeExecutionWrapper.prototype.onClearSelection = function () {
                var _this = this;
                if (this.wrappedVisual.onClearSelection)
                    this.executeSafely(function () { return _this.wrappedVisual.onClearSelection(); });
            };
            VisualSafeExecutionWrapper.prototype.canResizeTo = function (viewport) {
                var _this = this;
                if (this.wrappedVisual.canResizeTo)
                    return this.executeSafely(function () { return _this.wrappedVisual.canResizeTo(viewport); });
            };
            VisualSafeExecutionWrapper.prototype.enumerateObjectInstances = function (options) {
                var _this = this;
                if (this.wrappedVisual.enumerateObjectInstances)
                    return this.executeSafely(function () { return _this.wrappedVisual.enumerateObjectInstances(options); });
            };
            VisualSafeExecutionWrapper.prototype.unwrap = function () {
                var visual = this.wrappedVisual;
                return visual.unwrap ? visual.unwrap() : visual;
            };
            VisualSafeExecutionWrapper.prototype.isCustomVisual = function () {
                return this.visualInfo.custom;
            };
            VisualSafeExecutionWrapper.prototype.executeSafely = function (callback) {
                try {
                    return callback();
                }
                catch (exception) {
                    if (!this.silent) {
                        console.error("Visual exception", exception.stack || exception);
                    }
                    if (this.telemetryService) {
                        this.telemetryService.logEvent(VisualException, this.visualInfo.name, this.visualInfo.custom, this.visualInfo.apiVersion, exception.fileName, exception.lineNumber, exception.columnNumber, exception.stack, exception.message);
                    }
                }
            };
            return VisualSafeExecutionWrapper;
        }());
        extensibility.VisualSafeExecutionWrapper = VisualSafeExecutionWrapper;
    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var extensibility;
    (function (extensibility) {
        var v100;
        (function (v100) {
            var overloadFactory = function (visual) {
                return {
                    update: function (options) {
                        if (visual.update) {
                            var type = options.type || powerbi.VisualUpdateType.Data;
                            if (type & powerbi.VisualUpdateType.Resize && options.resizeMode === 2 /* Resized */) {
                                type |= powerbi.VisualUpdateType.ResizeEnd;
                            }
                            visual.update({
                                viewport: options.viewport,
                                dataViews: options.dataViews,
                                type: type
                            });
                        }
                    },
                    destroy: function () {
                        if (visual.destroy) {
                            visual.destroy();
                        }
                    },
                    enumerateObjectInstances: function (options) {
                        if (visual.enumerateObjectInstances) {
                            return visual.enumerateObjectInstances(options);
                        }
                    }
                };
            };
            var hostAdapter = function (host) {
                return {};
            };
            extensibility.visualApiVersions.push({
                version: '1.0.0',
                overloads: overloadFactory,
                hostAdapter: hostAdapter
            });
        })(v100 = extensibility.v100 || (extensibility.v100 = {}));
    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var extensibility;
    (function (extensibility) {
        var v110;
        (function (v110) {
            var hostAdapter = function (host) {
                return {
                    createSelectionIdBuilder: function () { return new powerbi.visuals.SelectionIdBuilder(); },
                    createSelectionManager: function () { return new extensibility.SelectionManager({ hostServices: host }); }
                };
            };
            extensibility.visualApiVersions.push({
                version: '1.1.0',
                hostAdapter: hostAdapter
            });
        })(v110 = extensibility.v110 || (extensibility.v110 = {}));
    })(extensibility = powerbi.extensibility || (powerbi.extensibility = {}));
})(powerbi || (powerbi = {}));


;/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../Typedefs/jquery/jquery.d.ts"/>
///<reference path="../../Typedefs/d3/d3.d.ts"/>
///<reference path="../../Typedefs/lodash/lodash.d.ts"/> 
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * DOM constants.
     */
    var DOMConstants;
    (function (DOMConstants) {
        /**
         * Integer codes corresponding to individual keys on the keyboard.
         */
        DOMConstants.escKeyCode = 27;
        DOMConstants.enterKeyCode = 13;
        DOMConstants.tabKeyCode = 9;
        DOMConstants.upArrowKeyCode = 38;
        DOMConstants.downArrowKeyCode = 40;
        DOMConstants.leftArrowKeyCode = 37;
        DOMConstants.rightArrowKeyCode = 39;
        DOMConstants.homeKeyCode = 36;
        DOMConstants.endKeyCode = 35;
        DOMConstants.backSpaceKeyCode = 8;
        DOMConstants.deleteKeyCode = 46;
        DOMConstants.spaceKeyCode = 32;
        DOMConstants.shiftKeyCode = 16;
        DOMConstants.ctrlKeyCode = 17;
        DOMConstants.altKeyCode = 18;
        DOMConstants.aKeyCode = 65;
        DOMConstants.cKeyCode = 67;
        DOMConstants.sKeyCode = 83;
        DOMConstants.vKeyCode = 86;
        DOMConstants.wKeyCode = 87;
        DOMConstants.xKeyCode = 88;
        DOMConstants.yKeyCode = 89;
        DOMConstants.zKeyCode = 90;
        /**
         * DOM Elements.
         */
        DOMConstants.DocumentBody = 'body';
        DOMConstants.Anchor = 'a';
        DOMConstants.EditableTextElements = ':text, textarea';
        DOMConstants.EditableNumericElements = '[type="number"]';
        /**
         * DOM Attributes and values.
         */
        DOMConstants.disabledAttributeOrValue = 'disabled';
        DOMConstants.readonlyAttributeOrValue = 'readonly';
        DOMConstants.idAttribute = 'id';
        DOMConstants.styleAttribute = 'style';
        DOMConstants.hrefAttribute = 'href';
        DOMConstants.targetAttribute = 'target';
        DOMConstants.blankValue = '_blank';
        DOMConstants.selfValue = '_self';
        DOMConstants.classAttribute = 'class';
        DOMConstants.titleAttribute = 'title';
        DOMConstants.srcAttribute = 'src';
        /**
         * DOM event names.
         */
        DOMConstants.contextmenuEventName = 'contextmenu';
        DOMConstants.blurEventName = 'blur';
        DOMConstants.keyUpEventName = 'keyup';
        DOMConstants.inputEventName = 'input';
        DOMConstants.changeEventName = 'change';
        DOMConstants.cutEventName = 'cut';
        DOMConstants.keyDownEventName = 'keydown';
        DOMConstants.mouseMoveEventName = 'mousemove';
        DOMConstants.mouseDownEventName = 'mousedown';
        DOMConstants.mouseEnterEventName = 'mouseenter';
        DOMConstants.mouseLeaveEventName = 'mouseleave';
        DOMConstants.mouseOverEventName = 'mouseover';
        DOMConstants.mouseOutEventName = 'mouseout';
        DOMConstants.mouseClickEventName = 'click';
        DOMConstants.pasteEventName = 'paste';
        DOMConstants.scrollEventName = 'scroll';
        DOMConstants.dropEventName = 'drop';
        DOMConstants.focusEventName = 'focus';
        DOMConstants.focusInEventName = 'focusin';
        DOMConstants.focusOutEventName = 'focusout';
        DOMConstants.selectEventName = 'select';
        DOMConstants.messageEventName = 'message';
        DOMConstants.loadEventName = 'load';
        DOMConstants.beforeUnload = 'beforeunload';
        /**
         * Common DOM event combination names.
         */
        DOMConstants.inputAndSelectEventNames = 'input, select';
    })(DOMConstants = jsCommon.DOMConstants || (jsCommon.DOMConstants = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    (function (PowerBIErrorResourceType) {
        PowerBIErrorResourceType[PowerBIErrorResourceType["ResourceCodeReference"] = 0] = "ResourceCodeReference";
        PowerBIErrorResourceType[PowerBIErrorResourceType["EmbeddedString"] = 1] = "EmbeddedString";
    })(powerbi.PowerBIErrorResourceType || (powerbi.PowerBIErrorResourceType = {}));
    var PowerBIErrorResourceType = powerbi.PowerBIErrorResourceType;
    var ServiceErrorToClientError = (function () {
        function ServiceErrorToClientError(serviceError) {
            this.m_serviceError = serviceError;
        }
        Object.defineProperty(ServiceErrorToClientError.prototype, "code", {
            get: function () {
                return ServiceErrorToClientError.codeName;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServiceErrorToClientError.prototype, "ignorable", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ServiceErrorToClientError.prototype, "requestId", {
            get: function () {
                return this.httpRequestId;
            },
            set: function (value) {
                this.httpRequestId = value;
            },
            enumerable: true,
            configurable: true
        });
        ServiceErrorToClientError.prototype.getDetails = function (resourceProvider) {
            var errorDetails;
            if (this.m_serviceError.statusCode === 6 /* ExecuteSemanticQueryTransformError */) {
                errorDetails = PowerBIErrorDetailHelper.GetDetailsFromTransformError(resourceProvider, this.m_serviceError);
            }
            else {
                errorDetails = PowerBIErrorDetailHelper.GetDetailsFromServerErrorStatusCode(resourceProvider, this.m_serviceError.statusCode);
            }
            PowerBIErrorDetailHelper.addAdditionalInfo(errorDetails, this.m_serviceError.errorDetails, resourceProvider);
            PowerBIErrorDetailHelper.addMessageAndStackTrace(errorDetails, this.m_serviceError.message || null, this.m_serviceError.stackTrace || null, resourceProvider);
            return errorDetails;
        };
        ServiceErrorToClientError.codeName = 'ServiceErrorToClientError';
        return ServiceErrorToClientError;
    }());
    powerbi.ServiceErrorToClientError = ServiceErrorToClientError;
    var PowerBIErrorDetailHelper = (function () {
        function PowerBIErrorDetailHelper() {
        }
        PowerBIErrorDetailHelper.addAdditionalInfo = function (errorDetails, pbiErrorDetails, localize) {
            if (pbiErrorDetails) {
                for (var i = 0; i < pbiErrorDetails.length; i++) {
                    var element = pbiErrorDetails[i];
                    var localizedCode = localize.getOptional(PowerBIErrorDetailHelper.serverErrorPrefix + element.code);
                    var additionErrorInfoKeyValuePair = {
                        errorInfoKey: localizedCode ? localizedCode : element.code,
                        errorInfoValue: element.detail.type === PowerBIErrorResourceType.ResourceCodeReference ? localize.get(PowerBIErrorDetailHelper.serverErrorPrefix + element.detail.value) : element.detail.value
                    };
                    errorDetails.additionalErrorInfo.push(additionErrorInfoKeyValuePair);
                }
            }
            return errorDetails;
        };
        PowerBIErrorDetailHelper.addMessageAndStackTrace = function (errorDetails, message, stackTrace, localize) {
            if (message) {
                var additionErrorInfoKeyValuePair = {
                    errorInfoKey: localize.get("AdditionalErrorInfo_ErrorDetailsText"),
                    errorInfoValue: message
                };
                errorDetails.additionalErrorInfo.push(additionErrorInfoKeyValuePair);
            }
            if (stackTrace) {
                var additionErrorInfoKeyValuePair = {
                    errorInfoKey: localize.get("AdditionalErrorInfo_StackTraceText"),
                    errorInfoValue: stackTrace
                };
                errorDetails.additionalErrorInfo.push(additionErrorInfoKeyValuePair);
            }
            return errorDetails;
        };
        PowerBIErrorDetailHelper.GetDetailsFromTransformError = function (localize, serviceError) {
            var message = localize.get('ServiceError_CannotLoadVisual');
            var key = localize.get('ServiceError_CannotLoadVisual');
            var val = serviceError.message;
            var additionalInfo = [];
            additionalInfo.push({ errorInfoKey: key, errorInfoValue: val, });
            var errorDetails = {
                message: message,
                additionalErrorInfo: additionalInfo,
            };
            return errorDetails;
        };
        PowerBIErrorDetailHelper.GetDetailsFromServerErrorStatusCode = function (localize, statusCode) {
            // TODO: Localize
            var message = "";
            var key = "";
            var val = "";
            switch (statusCode) {
                case 2 /* CsdlConvertXmlToConceptualSchema */:
                    message = localize.get('ServiceError_ModelCannotLoad');
                    key = localize.get('ServiceError_ModelConvertFailureKey');
                    val = localize.get('ServiceError_ModelConvertFailureValue');
                    break;
                case 3 /* CsdlCreateClientSchema */:
                    message = localize.get('ServiceError_ModelCannotLoad');
                    key = localize.get('ServiceError_ModelCreationFailureKey');
                    val = localize.get('ServiceError_ModelCreationFailureValue');
                    break;
                case 1 /* CsdlFetching */:
                    message = localize.get('ServiceError_ModelCannotLoad');
                    key = localize.get('ServiceError_ModelFetchingFailureKey');
                    val = localize.get('ServiceError_ModelFetchingFailureValue');
                    break;
                case 4 /* ExecuteSemanticQueryError */:
                    message = localize.get('ServiceError_CannotLoadVisual');
                    key = localize.get('ServiceError_ExecuteSemanticQueryErrorKey');
                    val = localize.get('ServiceError_ExecuteSemanticQueryErrorValue');
                    break;
                case 5 /* ExecuteSemanticQueryInvalidStreamFormat */:
                    message = localize.get('ServiceError_CannotLoadVisual');
                    key = localize.get('ServiceError_ExecuteSemanticQueryInvalidStreamFormatKey');
                    val = localize.get('ServiceError_ExecuteSemanticQueryInvalidStreamFormatValue');
                    break;
                case 0 /* GeneralError */:
                default:
                    message = localize.get('ServiceError_GeneralError');
                    key = localize.get('ServiceError_GeneralErrorKey');
                    val = localize.get('ServiceError_GeneralErrorValue');
                    break;
            }
            var additionalInfo = [];
            additionalInfo.push({ errorInfoKey: key, errorInfoValue: val, });
            var errorDetails = {
                message: message,
                additionalErrorInfo: additionalInfo,
            };
            return errorDetails;
        };
        PowerBIErrorDetailHelper.serverErrorPrefix = "ServerError_";
        return PowerBIErrorDetailHelper;
    }());
    powerbi.PowerBIErrorDetailHelper = PowerBIErrorDetailHelper;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    powerbi.CategoryTypes = {
        Address: "Address",
        City: "City",
        Continent: "Continent",
        CountryRegion: "Country",
        County: "County",
        Longitude: "Longitude",
        Latitude: "Latitude",
        Place: "Place",
        PostalCode: "PostalCode",
        StateOrProvince: "StateOrProvince"
    };
    function createGeoTaggingAnalyzerService(getLocalized) {
        return new GeoTaggingAnalyzerService(getLocalized);
    }
    powerbi.createGeoTaggingAnalyzerService = createGeoTaggingAnalyzerService;
    var EnglishBackup = {
        GeotaggingString_Continent: "continent",
        GeotaggingString_Continents: "continents",
        GeotaggingString_Country: "country",
        GeotaggingString_Countries: "countries",
        GeotaggingString_State: "state",
        GeotaggingString_States: "states",
        GeotaggingString_City: "city",
        GeotaggingString_Cities: "cities",
        GeotaggingString_Town: "town",
        GeotaggingString_Towns: "towns",
        GeotaggingString_Province: "province",
        GeotaggingString_Provinces: "provinces",
        GeotaggingString_County: "county",
        GeotaggingString_Counties: "counties",
        GeotaggingString_Village: "village",
        GeotaggingString_Villages: "villages",
        GeotaggingString_Post: "post",
        GeotaggingString_Zip: "zip",
        GeotaggingString_Code: "code",
        GeotaggingString_Place: "place",
        GeotaggingString_Places: "places",
        GeotaggingString_Address: "address",
        GeotaggingString_Addresses: "addresses",
        GeotaggingString_Street: "street",
        GeotaggingString_Streets: "streets",
        GeotaggingString_Longitude: "longitude",
        GeotaggingString_Longitude_Short: "lon",
        GeotaggingString_Latitude: "latitude",
        GeotaggingString_Latitude_Short: "lat",
        GeotaggingString_PostalCode: "postal code",
        GeotaggingString_PostalCodes: "postal codes",
        GeotaggingString_ZipCode: "zip code",
        GeotaggingString_ZipCodes: "zip codes",
        GeotaggingString_Territory: "territory",
        GeotaggingString_Territories: "territories",
        GeotaggingString_VRMBackCompat_CountryRegion: "CountryRegion",
        GeotaggingString_VRMBackCompat_StateOrProvince: "StateOrProvince",
    };
    var GeoTaggingAnalyzerService = (function () {
        function GeoTaggingAnalyzerService(getLocalized) {
            this.GeotaggingString_VRMBackCompat_CountryRegion = "CountryRegion";
            this.GeotaggingString_VRMBackCompat_StateOrProvince = "StateOrProvince";
            this.GeotaggingString_Continent = getLocalized("GeotaggingString_Continent").toLowerCase();
            this.GeotaggingString_Continents = getLocalized("GeotaggingString_Continents").toLowerCase();
            this.GeotaggingString_Country = getLocalized("GeotaggingString_Country").toLowerCase();
            this.GeotaggingString_Countries = getLocalized("GeotaggingString_Countries").toLowerCase();
            this.GeotaggingString_State = getLocalized("GeotaggingString_State").toLowerCase();
            this.GeotaggingString_States = getLocalized("GeotaggingString_States").toLowerCase();
            this.GeotaggingString_City = getLocalized("GeotaggingString_City").toLowerCase();
            this.GeotaggingString_Cities = getLocalized("GeotaggingString_Cities").toLowerCase();
            this.GeotaggingString_Town = getLocalized("GeotaggingString_Town").toLowerCase();
            this.GeotaggingString_Towns = getLocalized("GeotaggingString_Towns").toLowerCase();
            this.GeotaggingString_Province = getLocalized("GeotaggingString_Province").toLowerCase();
            this.GeotaggingString_Provinces = getLocalized("GeotaggingString_Provinces").toLowerCase();
            this.GeotaggingString_County = getLocalized("GeotaggingString_County").toLowerCase();
            this.GeotaggingString_Counties = getLocalized("GeotaggingString_Counties").toLowerCase();
            this.GeotaggingString_Village = getLocalized("GeotaggingString_Village").toLowerCase();
            this.GeotaggingString_Villages = getLocalized("GeotaggingString_Villages").toLowerCase();
            this.GeotaggingString_Post = getLocalized("GeotaggingString_Post").toLowerCase();
            this.GeotaggingString_Zip = getLocalized("GeotaggingString_Zip").toLowerCase();
            this.GeotaggingString_Code = getLocalized("GeotaggingString_Code").toLowerCase();
            this.GeotaggingString_Place = getLocalized("GeotaggingString_Place").toLowerCase();
            this.GeotaggingString_Places = getLocalized("GeotaggingString_Places").toLowerCase();
            this.GeotaggingString_Address = getLocalized("GeotaggingString_Address").toLowerCase();
            this.GeotaggingString_Addresses = getLocalized("GeotaggingString_Addresses").toLowerCase();
            this.GeotaggingString_Street = getLocalized("GeotaggingString_Street").toLowerCase();
            this.GeotaggingString_Streets = getLocalized("GeotaggingString_Streets").toLowerCase();
            this.GeotaggingString_Longitude = getLocalized("GeotaggingString_Longitude").toLowerCase();
            this.GeotaggingString_Longitude_Short = getLocalized("GeotaggingString_Longitude_Short").toLowerCase();
            this.GeotaggingString_Latitude = getLocalized("GeotaggingString_Latitude").toLowerCase();
            this.GeotaggingString_Latitude_Short = getLocalized("GeotaggingString_Latitude_Short").toLowerCase();
            this.GeotaggingString_PostalCode = getLocalized("GeotaggingString_PostalCode").toLowerCase();
            this.GeotaggingString_PostalCodes = getLocalized("GeotaggingString_PostalCodes").toLowerCase();
            this.GeotaggingString_ZipCode = getLocalized("GeotaggingString_ZipCode").toLowerCase();
            this.GeotaggingString_ZipCodes = getLocalized("GeotaggingString_ZipCodes").toLowerCase();
            this.GeotaggingString_Territory = getLocalized("GeotaggingString_Territory").toLowerCase();
            this.GeotaggingString_Territories = getLocalized("GeotaggingString_Territories").toLowerCase();
        }
        GeoTaggingAnalyzerService.prototype.isLongitudeOrLatitude = function (fieldRefName) {
            return this.isLongitude(fieldRefName) ||
                this.isLatitude(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeographic = function (fieldRefName) {
            return this.isLongitudeOrLatitude(fieldRefName) ||
                this.isGeocodable(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeocodable = function (fieldRefName) {
            return this.isAddress(fieldRefName) ||
                this.isCity(fieldRefName) ||
                this.isContinent(fieldRefName) ||
                this.isCountry(fieldRefName) ||
                this.isCounty(fieldRefName) ||
                this.isStateOrProvince(fieldRefName) ||
                this.isPlace(fieldRefName) ||
                this.isPostalCode(fieldRefName) ||
                this.isTerritory(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeoshapable = function (fieldRefName) {
            return this.isCity(fieldRefName) ||
                this.isCountry(fieldRefName) ||
                this.isCounty(fieldRefName) ||
                this.isStateOrProvince(fieldRefName) ||
                this.isPostalCode(fieldRefName) ||
                this.isTerritory(fieldRefName) ||
                this.isGeoshapableEnglish(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isGeoshapableEnglish = function (fieldRefName) {
            return this.isEnglishCity(fieldRefName) ||
                this.isEnglishCountry(fieldRefName) ||
                this.isEnglishCounty(fieldRefName) ||
                this.isEnglishStateOrProvince(fieldRefName) ||
                this.isEnglishPostalCode(fieldRefName) ||
                this.isEnglishTerritory(fieldRefName);
        };
        GeoTaggingAnalyzerService.prototype.isAddress = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Address,
                this.GeotaggingString_Addresses,
                this.GeotaggingString_Street,
                this.GeotaggingString_Streets
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isPlace = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Place,
                this.GeotaggingString_Places
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isCity = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_City,
                this.GeotaggingString_Cities,
                this.GeotaggingString_Town,
                this.GeotaggingString_Towns,
                this.GeotaggingString_Village,
                this.GeotaggingString_Villages
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isStateOrProvince = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_State,
                this.GeotaggingString_States,
                this.GeotaggingString_Province,
                this.GeotaggingString_Provinces,
                this.GeotaggingString_VRMBackCompat_StateOrProvince,
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isCountry = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Country,
                this.GeotaggingString_Countries,
                this.GeotaggingString_VRMBackCompat_CountryRegion
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isCounty = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_County,
                this.GeotaggingString_Counties
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isContinent = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Continent,
                this.GeotaggingString_Continents
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isPostalCode = function (fieldRefName) {
            var result = (GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Post,
                this.GeotaggingString_Zip])
                && GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Code])) ||
                GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                    this.GeotaggingString_PostalCode,
                    this.GeotaggingString_PostalCodes,
                    this.GeotaggingString_ZipCode,
                    this.GeotaggingString_ZipCodes
                ]);
            //Check again for strings without whitespace
            if (!result) {
                var whiteSpaceRegex = /\s+/;
                var fieldNameWithoutWhitespace = fieldRefName.replace(whiteSpaceRegex, "");
                result = GeoTaggingAnalyzerService.hasMatches(fieldNameWithoutWhitespace, [
                    this.GeotaggingString_PostalCode.replace(whiteSpaceRegex, ''),
                    this.GeotaggingString_PostalCodes.replace(whiteSpaceRegex, ''),
                    this.GeotaggingString_ZipCode.replace(whiteSpaceRegex, ''),
                    this.GeotaggingString_ZipCodes.replace(whiteSpaceRegex, '')
                ]);
            }
            return result;
        };
        GeoTaggingAnalyzerService.prototype.isLongitude = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Longitude])
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Longitude_Short], true /* useStrict */);
        };
        GeoTaggingAnalyzerService.prototype.isLatitude = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Latitude])
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Latitude_Short], true /* useStrict */);
        };
        GeoTaggingAnalyzerService.prototype.isTerritory = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                this.GeotaggingString_Territory,
                this.GeotaggingString_Territories
            ]);
        };
        GeoTaggingAnalyzerService.hasMatches = function (fieldName, possibleMatches, useStrict) {
            var nonWordRegex = /\W/;
            var value = fieldName.toLowerCase();
            for (var i = 0, len = possibleMatches.length; i < len; i++) {
                var possibleMatch = possibleMatches[i].toLowerCase();
                if (!useStrict) {
                    if (value.indexOf(possibleMatch) > -1)
                        return true;
                }
                else {
                    var indexofpossibleMatch = value.indexOf(possibleMatch);
                    if (indexofpossibleMatch > -1) {
                        var wordEndFlag = void 0, wordBeginFlag = void 0;
                        wordEndFlag = wordBeginFlag = true;
                        if (indexofpossibleMatch - 1 > 0)
                            wordBeginFlag = nonWordRegex.test(value[indexofpossibleMatch - 1]);
                        if (indexofpossibleMatch + possibleMatch.length < value.length)
                            wordEndFlag = nonWordRegex.test(value[indexofpossibleMatch + possibleMatch.length]);
                        if (wordBeginFlag && wordEndFlag)
                            return true;
                    }
                }
            }
            return false;
        };
        GeoTaggingAnalyzerService.prototype.getFieldType = function (fieldName) {
            if (fieldName == null)
                return undefined;
            if (this.isLatitude(fieldName))
                return powerbi.CategoryTypes.Latitude;
            if (this.isLongitude(fieldName))
                return powerbi.CategoryTypes.Longitude;
            if (this.isPostalCode(fieldName))
                return powerbi.CategoryTypes.PostalCode;
            if (this.isAddress(fieldName))
                return powerbi.CategoryTypes.Address;
            if (this.isPlace(fieldName))
                return powerbi.CategoryTypes.Place;
            if (this.isCity(fieldName))
                return powerbi.CategoryTypes.City;
            if (this.isCountry(fieldName))
                return powerbi.CategoryTypes.CountryRegion;
            if (this.isCounty(fieldName))
                return powerbi.CategoryTypes.County;
            if (this.isStateOrProvince(fieldName))
                return powerbi.CategoryTypes.StateOrProvince;
            if (this.isContinent(fieldName))
                return powerbi.CategoryTypes.Continent;
            return this.getEnglishFieldType(fieldName);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishAddress = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Address,
                EnglishBackup.GeotaggingString_Addresses,
                EnglishBackup.GeotaggingString_Street,
                EnglishBackup.GeotaggingString_Streets
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishPlace = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Place,
                EnglishBackup.GeotaggingString_Places
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishCity = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_City,
                EnglishBackup.GeotaggingString_Cities,
                EnglishBackup.GeotaggingString_Town,
                EnglishBackup.GeotaggingString_Towns,
                EnglishBackup.GeotaggingString_Village,
                EnglishBackup.GeotaggingString_Villages
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishStateOrProvince = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_State,
                EnglishBackup.GeotaggingString_States,
                EnglishBackup.GeotaggingString_Province,
                EnglishBackup.GeotaggingString_Provinces,
                EnglishBackup.GeotaggingString_VRMBackCompat_StateOrProvince,
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishCountry = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Country,
                EnglishBackup.GeotaggingString_Countries,
                EnglishBackup.GeotaggingString_VRMBackCompat_CountryRegion
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishCounty = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_County,
                EnglishBackup.GeotaggingString_Counties
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishContinent = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Continent,
                EnglishBackup.GeotaggingString_Continents
            ]);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishPostalCode = function (fieldRefName) {
            var result = (GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Post,
                EnglishBackup.GeotaggingString_Zip])
                && GeoTaggingAnalyzerService.hasMatches(fieldRefName, [this.GeotaggingString_Code])) ||
                GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                    EnglishBackup.GeotaggingString_PostalCode,
                    EnglishBackup.GeotaggingString_PostalCodes,
                    EnglishBackup.GeotaggingString_ZipCode,
                    EnglishBackup.GeotaggingString_ZipCodes
                ]);
            //Check again for strings without whitespace
            if (!result) {
                var whiteSpaceRegexPattern = new RegExp('\s');
                result = GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                    EnglishBackup.GeotaggingString_PostalCode.replace(whiteSpaceRegexPattern, ''),
                    EnglishBackup.GeotaggingString_PostalCodes.replace(whiteSpaceRegexPattern, ''),
                    EnglishBackup.GeotaggingString_ZipCode.replace(whiteSpaceRegexPattern, ''),
                    EnglishBackup.GeotaggingString_ZipCodes.replace(whiteSpaceRegexPattern, '')
                ]);
            }
            return result;
        };
        GeoTaggingAnalyzerService.prototype.isEnglishLongitude = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Longitude])
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Longitude_Short], true /* useStrict */);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishLatitude = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Latitude])
                || GeoTaggingAnalyzerService.hasMatches(fieldRefName, [EnglishBackup.GeotaggingString_Latitude_Short], true /* useStrict */);
        };
        GeoTaggingAnalyzerService.prototype.isEnglishTerritory = function (fieldRefName) {
            return GeoTaggingAnalyzerService.hasMatches(fieldRefName, [
                EnglishBackup.GeotaggingString_Territory,
                EnglishBackup.GeotaggingString_Territories
            ]);
        };
        GeoTaggingAnalyzerService.prototype.getEnglishFieldType = function (fieldName) {
            if (fieldName == null)
                return undefined;
            if (this.isEnglishLatitude(fieldName))
                return powerbi.CategoryTypes.Latitude;
            if (this.isEnglishLongitude(fieldName))
                return powerbi.CategoryTypes.Longitude;
            if (this.isEnglishPostalCode(fieldName))
                return powerbi.CategoryTypes.PostalCode;
            if (this.isEnglishAddress(fieldName))
                return powerbi.CategoryTypes.Address;
            if (this.isEnglishPlace(fieldName))
                return powerbi.CategoryTypes.Place;
            if (this.isEnglishCity(fieldName))
                return powerbi.CategoryTypes.City;
            if (this.isEnglishCountry(fieldName))
                return powerbi.CategoryTypes.CountryRegion;
            if (this.isEnglishCounty(fieldName))
                return powerbi.CategoryTypes.County;
            if (this.isEnglishStateOrProvince(fieldName))
                return powerbi.CategoryTypes.StateOrProvince;
            if (this.isEnglishContinent(fieldName))
                return powerbi.CategoryTypes.Continent;
            return undefined;
        };
        return GeoTaggingAnalyzerService;
    }());
    powerbi.GeoTaggingAnalyzerService = GeoTaggingAnalyzerService;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
if (typeof DEBUG === 'undefined')
    var DEBUG = true;
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /**
     this base class should be derived to give a generic error message but with a unique error code.
     */
    var UnknownClientError = (function () {
        function UnknownClientError(code) {
            debug.assertValue(code, 'code');
            this.errorCode = code;
        }
        Object.defineProperty(UnknownClientError.prototype, "code", {
            get: function () {
                return this.errorCode;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UnknownClientError.prototype, "ignorable", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        UnknownClientError.prototype.getDetails = function (resourceProvider) {
            var details = {
                message: resourceProvider.get('ClientError_UnknownClientErrorValue'),
                additionalErrorInfo: [{ errorInfoKey: resourceProvider.get('ClientError_UnknownClientErrorKey'), errorInfoValue: resourceProvider.get('ClientError_UnknownClientErrorValue'), }],
            };
            return details;
        };
        return UnknownClientError;
    }());
    powerbi.UnknownClientError = UnknownClientError;
    var HttpClientError = (function () {
        function HttpClientError(httpStatusCode, requestId) {
            debug.assertValue(httpStatusCode, 'httpStatusCode');
            debug.assertValue(requestId, 'requestId');
            this.httpStatusCode = httpStatusCode;
            this.httpRequestId = requestId;
        }
        Object.defineProperty(HttpClientError.prototype, "code", {
            get: function () {
                return 'HttpClientError';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HttpClientError.prototype, "ignorable", {
            get: function () {
                return false;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HttpClientError.prototype, "requestId", {
            get: function () {
                return this.httpRequestId;
            },
            enumerable: true,
            configurable: true
        });
        HttpClientError.prototype.getDetails = function (resourceProvider) {
            // Use a general error message for a HTTP request failure, since we currently do not know of any specifc error cases at this point in time.
            var details = {
                message: null,
                additionalErrorInfo: [
                    { errorInfoKey: resourceProvider.get('DsrError_Key'), errorInfoValue: resourceProvider.get('DsrError_UnknownErrorValue') },
                    { errorInfoKey: resourceProvider.get('ClientError_HttpResponseStatusCodeKey'), errorInfoValue: this.httpStatusCode.toString() }],
            };
            return details;
        };
        return HttpClientError;
    }());
    powerbi.HttpClientError = HttpClientError;
    var IgnorableClientError = (function () {
        function IgnorableClientError() {
        }
        Object.defineProperty(IgnorableClientError.prototype, "code", {
            get: function () {
                return 'IgnorableClientError';
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(IgnorableClientError.prototype, "ignorable", {
            get: function () {
                return true;
            },
            enumerable: true,
            configurable: true
        });
        IgnorableClientError.prototype.getDetails = function (resourceProvider) {
            var details = {
                message: '',
                additionalErrorInfo: [],
            };
            return details;
        };
        return IgnorableClientError;
    }());
    powerbi.IgnorableClientError = IgnorableClientError;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var ArrayExtensions;
    (function (ArrayExtensions) {
        /**
         * Returns items that exist in target and other.
         */
        function intersect(target, other) {
            var result = [];
            for (var i = target.length - 1; i >= 0; --i) {
                if (other.indexOf(target[i]) !== -1) {
                    result.push(target[i]);
                }
            }
            return result;
        }
        ArrayExtensions.intersect = intersect;
        /**
         * Return elements exists in target but not exists in other.
         */
        function diff(target, other) {
            var result = [];
            for (var i = target.length - 1; i >= 0; --i) {
                var value = target[i];
                if (other.indexOf(value) === -1) {
                    result.push(value);
                }
            }
            return result;
        }
        ArrayExtensions.diff = diff;
        /**
         * Return an array with only the distinct items in the source.
         */
        function distinct(source) {
            var result = [];
            for (var i = 0, len = source.length; i < len; i++) {
                var value = source[i];
                if (result.indexOf(value) === -1) {
                    result.push(value);
                }
            }
            return result;
        }
        ArrayExtensions.distinct = distinct;
        /**
         * Pushes content of source onto target,
         * for parts of course that do not already exist in target.
         */
        function union(target, source) {
            for (var i = 0, len = source.length; i < len; ++i) {
                unionSingle(target, source[i]);
            }
        }
        ArrayExtensions.union = union;
        /**
         * Pushes value onto target, if value does not already exist in target.
         */
        function unionSingle(target, value) {
            if (target.indexOf(value) < 0) {
                target.push(value);
            }
        }
        ArrayExtensions.unionSingle = unionSingle;
        /**
         * Returns an array with a range of items from source,
         * including the startIndex & endIndex.
         */
        function range(source, startIndex, endIndex) {
            debug.assert(startIndex >= 0 && startIndex < source.length, 'startIndex is out of range.');
            debug.assert(endIndex >= 0 && endIndex < source.length, 'endIndex is out of range.');
            var result = [];
            for (var i = startIndex; i <= endIndex; ++i) {
                result.push(source[i]);
            }
            return result;
        }
        ArrayExtensions.range = range;
        /**
         * Returns an array that includes items from source, up to the specified count.
         */
        function take(source, count) {
            debug.assert(count >= 0, 'Count is negative.');
            debug.assert(count <= source.length, 'Count is too large.');
            var result = [];
            for (var i = 0; i < count; ++i) {
                result.push(source[i]);
            }
            return result;
        }
        ArrayExtensions.take = take;
        function copy(source) {
            debug.assertValue(source, 'source');
            return take(source, source.length);
        }
        ArrayExtensions.copy = copy;
        /**
         * Returns a value indicating whether the arrays have the same values in the same sequence.
         */
        function sequenceEqual(left, right, comparison) {
            debug.assertValue(comparison, 'comparison');
            if (left === right) {
                return true;
            }
            if (!!left !== !!right) {
                return false;
            }
            var len = left.length;
            if (len !== right.length) {
                return false;
            }
            var i = 0;
            while (i < len && comparison(left[i], right[i])) {
                ++i;
            }
            return i === len;
        }
        ArrayExtensions.sequenceEqual = sequenceEqual;
        /**
         * Returns null if the specified array is empty.
         * Otherwise returns the specified array.
         */
        function emptyToNull(array) {
            if (array && array.length === 0) {
                return null;
            }
            return array;
        }
        ArrayExtensions.emptyToNull = emptyToNull;
        function indexOf(array, predicate) {
            debug.assertValue(array, 'array');
            debug.assertValue(predicate, 'predicate');
            for (var i = 0, len = array.length; i < len; ++i) {
                if (predicate(array[i])) {
                    return i;
                }
            }
            return -1;
        }
        ArrayExtensions.indexOf = indexOf;
        /**
         * Returns a copy of the array rotated by the specified offset.
         */
        function rotate(array, offset) {
            if (offset === 0)
                return array.slice();
            var rotated = array.slice(offset);
            Array.prototype.push.apply(rotated, array.slice(0, offset));
            return rotated;
        }
        ArrayExtensions.rotate = rotate;
        function createWithId() {
            return extendWithId([]);
        }
        ArrayExtensions.createWithId = createWithId;
        function extendWithId(array) {
            debug.assertValue(array, 'array');
            var extended = array;
            extended.withId = withId;
            return extended;
        }
        ArrayExtensions.extendWithId = extendWithId;
        /**
         * Finds and returns the first item with a matching ID.
         */
        function findWithId(array, id) {
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (item.id === id)
                    return item;
            }
        }
        ArrayExtensions.findWithId = findWithId;
        function withId(id) {
            return ArrayExtensions.findWithId(this, id);
        }
        function createWithName() {
            return extendWithName([]);
        }
        ArrayExtensions.createWithName = createWithName;
        function extendWithName(array) {
            debug.assertValue(array, 'array');
            var extended = array;
            extended.withName = withName;
            return extended;
        }
        ArrayExtensions.extendWithName = extendWithName;
        function findItemWithName(array, name) {
            var index = indexWithName(array, name);
            if (index >= 0)
                return array[index];
        }
        ArrayExtensions.findItemWithName = findItemWithName;
        function indexWithName(array, name) {
            for (var i = 0, len = array.length; i < len; i++) {
                var item = array[i];
                if (item.name === name)
                    return i;
            }
            return -1;
        }
        ArrayExtensions.indexWithName = indexWithName;
        /**
         * Inserts a number in sorted order into a list of numbers already in sorted order.
         * @returns True if the item was added, false if it already existed.
         */
        function insertSorted(list, value) {
            debug.assertValue(list, 'list');
            debug.assertValue(value, 'value');
            var len = list.length;
            // NOTE: iterate backwards because incoming values tend to be sorted already.
            for (var i = len - 1; i >= 0; i--) {
                var diff_1 = list[i] - value;
                if (diff_1 === 0)
                    return false;
                if (diff_1 > 0)
                    continue;
                // diff < 0
                list.splice(i + 1, 0, value);
                return true;
            }
            list.unshift(value);
            return true;
        }
        ArrayExtensions.insertSorted = insertSorted;
        /**
         * Removes the first occurrence of a value from a list if it exists.
         * @returns True if the value was removed, false if it did not exist in the list.
         */
        function removeFirst(list, value) {
            var index = list.indexOf(value);
            if (index < 0)
                return false;
            list.splice(index, 1);
            return true;
        }
        ArrayExtensions.removeFirst = removeFirst;
        /**
         * Finds and returns the first item with a matching name.
         */
        function withName(name) {
            var array = this;
            return findItemWithName(array, name);
        }
        /**
         * Deletes all items from the array.
         */
        function clear(array) {
            if (!array)
                return;
            while (array.length > 0)
                array.pop();
        }
        ArrayExtensions.clear = clear;
        function isUndefinedOrEmpty(array) {
            if (!array || array.length === 0) {
                return true;
            }
            return false;
        }
        ArrayExtensions.isUndefinedOrEmpty = isUndefinedOrEmpty;
        function swap(array, firstIndex, secondIndex) {
            var temp = array[firstIndex];
            array[firstIndex] = array[secondIndex];
            array[secondIndex] = temp;
        }
        ArrayExtensions.swap = swap;
        function isInArray(array, lookupItem, compareCallback) {
            return _.any(array, function (item) { return compareCallback(item, lookupItem); });
        }
        ArrayExtensions.isInArray = isInArray;
        /** Checks if the given object is an Array, and looking all the way up the prototype chain. */
        function isArrayOrInheritedArray(obj) {
            debug.assertValue(obj, 'obj');
            var nextPrototype = obj;
            while (nextPrototype != null) {
                if (_.isArray(nextPrototype))
                    return true;
                nextPrototype = Object.getPrototypeOf(nextPrototype);
            }
            return false;
        }
        ArrayExtensions.isArrayOrInheritedArray = isArrayOrInheritedArray;
    })(ArrayExtensions = jsCommon.ArrayExtensions || (jsCommon.ArrayExtensions = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var InJs;
(function (InJs) {
    var DomFactory;
    (function (DomFactory) {
        function div() {
            return $('<div/>');
        }
        DomFactory.div = div;
        function span() {
            return $('<span/>');
        }
        DomFactory.span = span;
        function checkbox() {
            return $('<input type="checkbox"/>');
        }
        DomFactory.checkbox = checkbox;
        function ul() {
            return $('<ul/>');
        }
        DomFactory.ul = ul;
        function li() {
            return $('<li/>');
        }
        DomFactory.li = li;
        function button() {
            return $('<input type="button"/>');
        }
        DomFactory.button = button;
        function select() {
            return $('<select/>');
        }
        DomFactory.select = select;
        function textBox() {
            return $('<input type="text"/>');
        }
        DomFactory.textBox = textBox;
        function img() {
            return $('<img/>');
        }
        DomFactory.img = img;
        function iframe() {
            return $('<iframe/>');
        }
        DomFactory.iframe = iframe;
    })(DomFactory = InJs.DomFactory || (InJs.DomFactory = {}));
})(InJs || (InJs = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /**
     * Module Double contains a set of constants and precision based utility methods
     * for dealing with doubles and their decimal garbage in the javascript.
     */
    var Double;
    (function (Double) {
        // Constants.
        Double.MIN_VALUE = -Number.MAX_VALUE;
        Double.MAX_VALUE = Number.MAX_VALUE;
        Double.MIN_EXP = -308;
        Double.MAX_EXP = 308;
        Double.EPSILON = 1E-323;
        Double.DEFAULT_PRECISION = 0.0001;
        Double.DEFAULT_PRECISION_IN_DECIMAL_DIGITS = 12;
        Double.LOG_E_10 = Math.log(10);
        Double.POSITIVE_POWERS = [
            1E0, 1E1, 1E2, 1E3, 1E4, 1E5, 1E6, 1E7, 1E8, 1E9, 1E10, 1E11, 1E12, 1E13, 1E14, 1E15, 1E16, 1E17, 1E18, 1E19, 1E20, 1E21, 1E22, 1E23, 1E24, 1E25, 1E26, 1E27, 1E28, 1E29, 1E30, 1E31, 1E32, 1E33, 1E34, 1E35, 1E36, 1E37, 1E38, 1E39, 1E40, 1E41, 1E42, 1E43, 1E44, 1E45, 1E46, 1E47, 1E48, 1E49, 1E50, 1E51, 1E52, 1E53, 1E54, 1E55, 1E56, 1E57, 1E58, 1E59, 1E60, 1E61, 1E62, 1E63, 1E64, 1E65, 1E66, 1E67, 1E68, 1E69, 1E70, 1E71, 1E72, 1E73, 1E74, 1E75, 1E76, 1E77, 1E78, 1E79, 1E80, 1E81, 1E82, 1E83, 1E84, 1E85, 1E86, 1E87, 1E88, 1E89, 1E90, 1E91, 1E92, 1E93, 1E94, 1E95, 1E96, 1E97, 1E98, 1E99,
            1E100, 1E101, 1E102, 1E103, 1E104, 1E105, 1E106, 1E107, 1E108, 1E109, 1E110, 1E111, 1E112, 1E113, 1E114, 1E115, 1E116, 1E117, 1E118, 1E119, 1E120, 1E121, 1E122, 1E123, 1E124, 1E125, 1E126, 1E127, 1E128, 1E129, 1E130, 1E131, 1E132, 1E133, 1E134, 1E135, 1E136, 1E137, 1E138, 1E139, 1E140, 1E141, 1E142, 1E143, 1E144, 1E145, 1E146, 1E147, 1E148, 1E149, 1E150, 1E151, 1E152, 1E153, 1E154, 1E155, 1E156, 1E157, 1E158, 1E159, 1E160, 1E161, 1E162, 1E163, 1E164, 1E165, 1E166, 1E167, 1E168, 1E169, 1E170, 1E171, 1E172, 1E173, 1E174, 1E175, 1E176, 1E177, 1E178, 1E179, 1E180, 1E181, 1E182, 1E183, 1E184, 1E185, 1E186, 1E187, 1E188, 1E189, 1E190, 1E191, 1E192, 1E193, 1E194, 1E195, 1E196, 1E197, 1E198, 1E199,
            1E200, 1E201, 1E202, 1E203, 1E204, 1E205, 1E206, 1E207, 1E208, 1E209, 1E210, 1E211, 1E212, 1E213, 1E214, 1E215, 1E216, 1E217, 1E218, 1E219, 1E220, 1E221, 1E222, 1E223, 1E224, 1E225, 1E226, 1E227, 1E228, 1E229, 1E230, 1E231, 1E232, 1E233, 1E234, 1E235, 1E236, 1E237, 1E238, 1E239, 1E240, 1E241, 1E242, 1E243, 1E244, 1E245, 1E246, 1E247, 1E248, 1E249, 1E250, 1E251, 1E252, 1E253, 1E254, 1E255, 1E256, 1E257, 1E258, 1E259, 1E260, 1E261, 1E262, 1E263, 1E264, 1E265, 1E266, 1E267, 1E268, 1E269, 1E270, 1E271, 1E272, 1E273, 1E274, 1E275, 1E276, 1E277, 1E278, 1E279, 1E280, 1E281, 1E282, 1E283, 1E284, 1E285, 1E286, 1E287, 1E288, 1E289, 1E290, 1E291, 1E292, 1E293, 1E294, 1E295, 1E296, 1E297, 1E298, 1E299,
            1E300, 1E301, 1E302, 1E303, 1E304, 1E305, 1E306, 1E307, 1E308];
        Double.NEGATIVE_POWERS = [
            1E0, 1E-1, 1E-2, 1E-3, 1E-4, 1E-5, 1E-6, 1E-7, 1E-8, 1E-9, 1E-10, 1E-11, 1E-12, 1E-13, 1E-14, 1E-15, 1E-16, 1E-17, 1E-18, 1E-19, 1E-20, 1E-21, 1E-22, 1E-23, 1E-24, 1E-25, 1E-26, 1E-27, 1E-28, 1E-29, 1E-30, 1E-31, 1E-32, 1E-33, 1E-34, 1E-35, 1E-36, 1E-37, 1E-38, 1E-39, 1E-40, 1E-41, 1E-42, 1E-43, 1E-44, 1E-45, 1E-46, 1E-47, 1E-48, 1E-49, 1E-50, 1E-51, 1E-52, 1E-53, 1E-54, 1E-55, 1E-56, 1E-57, 1E-58, 1E-59, 1E-60, 1E-61, 1E-62, 1E-63, 1E-64, 1E-65, 1E-66, 1E-67, 1E-68, 1E-69, 1E-70, 1E-71, 1E-72, 1E-73, 1E-74, 1E-75, 1E-76, 1E-77, 1E-78, 1E-79, 1E-80, 1E-81, 1E-82, 1E-83, 1E-84, 1E-85, 1E-86, 1E-87, 1E-88, 1E-89, 1E-90, 1E-91, 1E-92, 1E-93, 1E-94, 1E-95, 1E-96, 1E-97, 1E-98, 1E-99,
            1E-100, 1E-101, 1E-102, 1E-103, 1E-104, 1E-105, 1E-106, 1E-107, 1E-108, 1E-109, 1E-110, 1E-111, 1E-112, 1E-113, 1E-114, 1E-115, 1E-116, 1E-117, 1E-118, 1E-119, 1E-120, 1E-121, 1E-122, 1E-123, 1E-124, 1E-125, 1E-126, 1E-127, 1E-128, 1E-129, 1E-130, 1E-131, 1E-132, 1E-133, 1E-134, 1E-135, 1E-136, 1E-137, 1E-138, 1E-139, 1E-140, 1E-141, 1E-142, 1E-143, 1E-144, 1E-145, 1E-146, 1E-147, 1E-148, 1E-149, 1E-150, 1E-151, 1E-152, 1E-153, 1E-154, 1E-155, 1E-156, 1E-157, 1E-158, 1E-159, 1E-160, 1E-161, 1E-162, 1E-163, 1E-164, 1E-165, 1E-166, 1E-167, 1E-168, 1E-169, 1E-170, 1E-171, 1E-172, 1E-173, 1E-174, 1E-175, 1E-176, 1E-177, 1E-178, 1E-179, 1E-180, 1E-181, 1E-182, 1E-183, 1E-184, 1E-185, 1E-186, 1E-187, 1E-188, 1E-189, 1E-190, 1E-191, 1E-192, 1E-193, 1E-194, 1E-195, 1E-196, 1E-197, 1E-198, 1E-199,
            1E-200, 1E-201, 1E-202, 1E-203, 1E-204, 1E-205, 1E-206, 1E-207, 1E-208, 1E-209, 1E-210, 1E-211, 1E-212, 1E-213, 1E-214, 1E-215, 1E-216, 1E-217, 1E-218, 1E-219, 1E-220, 1E-221, 1E-222, 1E-223, 1E-224, 1E-225, 1E-226, 1E-227, 1E-228, 1E-229, 1E-230, 1E-231, 1E-232, 1E-233, 1E-234, 1E-235, 1E-236, 1E-237, 1E-238, 1E-239, 1E-240, 1E-241, 1E-242, 1E-243, 1E-244, 1E-245, 1E-246, 1E-247, 1E-248, 1E-249, 1E-250, 1E-251, 1E-252, 1E-253, 1E-254, 1E-255, 1E-256, 1E-257, 1E-258, 1E-259, 1E-260, 1E-261, 1E-262, 1E-263, 1E-264, 1E-265, 1E-266, 1E-267, 1E-268, 1E-269, 1E-270, 1E-271, 1E-272, 1E-273, 1E-274, 1E-275, 1E-276, 1E-277, 1E-278, 1E-279, 1E-280, 1E-281, 1E-282, 1E-283, 1E-284, 1E-285, 1E-286, 1E-287, 1E-288, 1E-289, 1E-290, 1E-291, 1E-292, 1E-293, 1E-294, 1E-295, 1E-296, 1E-297, 1E-298, 1E-299,
            1E-300, 1E-301, 1E-302, 1E-303, 1E-304, 1E-305, 1E-306, 1E-307, 1E-308, 1E-309, 1E-310, 1E-311, 1E-312, 1E-313, 1E-314, 1E-315, 1E-316, 1E-317, 1E-318, 1E-319, 1E-320, 1E-321, 1E-322, 1E-323, 1E-324];
        /**
         * Returns powers of 10.
         * Unlike the Math.pow this function produces no decimal garbage.
         * @param exp Exponent.
         */
        function pow10(exp) {
            debug.assertValue(exp, "exp");
            // Positive & zero
            if (exp >= 0) {
                if (exp < Double.POSITIVE_POWERS.length) {
                    return Double.POSITIVE_POWERS[exp];
                }
                else {
                    return Infinity;
                }
            }
            // Negative
            exp = -exp;
            if (exp > 0 && exp < Double.NEGATIVE_POWERS.length) {
                return Double.NEGATIVE_POWERS[exp];
            }
            else {
                return 0;
            }
        }
        Double.pow10 = pow10;
        /**
         * Returns the 10 base logarithm of the number.
         * Unlike Math.log function this produces integer results with no decimal garbage.
         * @param val Positive value or zero.
         */
        function log10(val) {
            debug.assert(val >= 0, "val");
            // Fast Log10() algorithm 
            if (val > 1 && val < 1E16) {
                if (val < 1E8) {
                    if (val < 1E4) {
                        if (val < 1E2) {
                            if (val < 1E1) {
                                return 0;
                            }
                            else {
                                return 1;
                            }
                        }
                        else {
                            if (val < 1E3) {
                                return 2;
                            }
                            else {
                                return 3;
                            }
                        }
                    }
                    else {
                        if (val < 1E6) {
                            if (val < 1E5) {
                                return 4;
                            }
                            else {
                                return 5;
                            }
                        }
                        else {
                            if (val < 1E7) {
                                return 6;
                            }
                            else {
                                return 7;
                            }
                        }
                    }
                }
                else {
                    if (val < 1E12) {
                        if (val < 1E10) {
                            if (val < 1E9) {
                                return 8;
                            }
                            else {
                                return 9;
                            }
                        }
                        else {
                            if (val < 1E11) {
                                return 10;
                            }
                            else {
                                return 11;
                            }
                        }
                    }
                    else {
                        if (val < 1E14) {
                            if (val < 1E13) {
                                return 12;
                            }
                            else {
                                return 13;
                            }
                        }
                        else {
                            if (val < 1E15) {
                                return 14;
                            }
                            else {
                                return 15;
                            }
                        }
                    }
                }
            }
            if (val > 1E-16 && val < 1) {
                if (val < 1E-8) {
                    if (val < 1E-12) {
                        if (val < 1E-14) {
                            if (val < 1E-15) {
                                return -16;
                            }
                            else {
                                return -15;
                            }
                        }
                        else {
                            if (val < 1E-13) {
                                return -14;
                            }
                            else {
                                return -13;
                            }
                        }
                    }
                    else {
                        if (val < 1E-10) {
                            if (val < 1E-11) {
                                return -12;
                            }
                            else {
                                return -11;
                            }
                        }
                        else {
                            if (val < 1E-9) {
                                return -10;
                            }
                            else {
                                return -9;
                            }
                        }
                    }
                }
                else {
                    if (val < 1E-4) {
                        if (val < 1E-6) {
                            if (val < 1E-7) {
                                return -8;
                            }
                            else {
                                return -7;
                            }
                        }
                        else {
                            if (val < 1E-5) {
                                return -6;
                            }
                            else {
                                return -5;
                            }
                        }
                    }
                    else {
                        if (val < 1E-2) {
                            if (val < 1E-3) {
                                return -4;
                            }
                            else {
                                return -3;
                            }
                        }
                        else {
                            if (val < 1E-1) {
                                return -2;
                            }
                            else {
                                return -1;
                            }
                        }
                    }
                }
            }
            // JS Math provides only natural log function so we need to calc the 10 base logarithm:
            // logb(x) = logk(x)/logk(b); 
            var log10 = Math.log(val) / Double.LOG_E_10;
            return Double.floorWithPrecision(log10);
        }
        Double.log10 = log10;
        /**
         * Returns a power of 10 representing precision of the number based on the number of meaningful decimal digits.
         * For example the precision of 56,263.3767 with the 6 meaningful decimal digit is 0.1.
         * @param x Value.
         * @param decimalDigits How many decimal digits are meaningfull.
         */
        function getPrecision(x, decimalDigits) {
            if (decimalDigits === undefined) {
                decimalDigits = Double.DEFAULT_PRECISION_IN_DECIMAL_DIGITS;
            }
            else {
                debug.assert(decimalDigits >= 0, "decimalDigits");
            }
            if (!x) {
                return undefined;
            }
            var exp = Double.log10(Math.abs(x));
            if (exp < Double.MIN_EXP) {
                return 0;
            }
            var precisionExp = Math.max(exp - decimalDigits, -Double.NEGATIVE_POWERS.length + 1);
            return Double.pow10(precisionExp);
        }
        Double.getPrecision = getPrecision;
        /**
         * Checks if a delta between 2 numbers is less than provided precision.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function equalWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x === y || Math.abs(x - y) < precision;
        }
        Double.equalWithPrecision = equalWithPrecision;
        /**
         * Checks if a first value is less than another taking
         * into account the loose precision based equality.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function lessWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x < y && Math.abs(x - y) > precision;
        }
        Double.lessWithPrecision = lessWithPrecision;
        /**
         * Checks if a first value is less or equal than another taking
         * into account the loose precision based equality.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function lessOrEqualWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x < y || Math.abs(x - y) < precision;
        }
        Double.lessOrEqualWithPrecision = lessOrEqualWithPrecision;
        /**
         * Checks if a first value is greater than another taking
         * into account the loose precision based equality.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function greaterWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x > y && Math.abs(x - y) > precision;
        }
        Double.greaterWithPrecision = greaterWithPrecision;
        /**
         * Checks if a first value is greater or equal to another taking
         * into account the loose precision based equality.
         * @param x One value.
         * @param y Another value.
         * @param precision Precision value.
         */
        function greaterOrEqualWithPrecision(x, y, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            return x > y || Math.abs(x - y) < precision;
        }
        Double.greaterOrEqualWithPrecision = greaterOrEqualWithPrecision;
        /**
         * Floors the number unless it's withing the precision distance from the higher int.
         * @param x One value.
         * @param precision Precision value.
         */
        function floorWithPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            var roundX = Math.round(x);
            if (Math.abs(x - roundX) < precision) {
                return roundX;
            }
            else {
                return Math.floor(x);
            }
        }
        Double.floorWithPrecision = floorWithPrecision;
        /**
         * Ceils the number unless it's withing the precision distance from the lower int.
         * @param x One value.
         * @param precision Precision value.
         */
        function ceilWithPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            var roundX = Math.round(x);
            if (Math.abs(x - roundX) < precision) {
                return roundX;
            }
            else {
                return Math.ceil(x);
            }
        }
        Double.ceilWithPrecision = ceilWithPrecision;
        /**
         * Floors the number to the provided precision.
         * For example 234,578 floored to 1,000 precision is 234,000.
         * @param x One value.
         * @param precision Precision value.
         */
        function floorToPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            //Precision must be a Power of 10
            return Math.floor(x / precision) * precision;
        }
        Double.floorToPrecision = floorToPrecision;
        /**
         * Ceils the number to the provided precision.
         * For example 234,578 floored to 1,000 precision is 235,000.
         * @param x One value.
         * @param precision Precision value.
         */
        function ceilToPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            //Precision must be a Power of 10
            return Math.ceil(x / precision) * precision;
        }
        Double.ceilToPrecision = ceilToPrecision;
        /**
         * Rounds the number to the provided precision.
         * For example 234,578 floored to 1,000 precision is 235,000.
         * @param x One value.
         * @param precision Precision value.
         */
        function roundToPrecision(x, precision) {
            precision = applyDefault(precision, Double.DEFAULT_PRECISION);
            debug.assert(precision >= 0, "precision");
            if (precision === 0 || x === 0) {
                return x;
            }
            //Precision must be a Power of 10
            var result = Math.round(x / precision) * precision;
            var decimalDigits = Math.round(Double.log10(Math.abs(x)) - Double.log10(precision)) + 1;
            if (decimalDigits > 0 && decimalDigits < 16) {
                result = parseFloat(result.toPrecision(decimalDigits));
            }
            return result;
        }
        Double.roundToPrecision = roundToPrecision;
        /**
         * Returns the value making sure that it's restricted to the provided range.
         * @param x One value.
         * @param min Range min boundary.
         * @param max Range max boundary.
         */
        function ensureInRange(x, min, max) {
            debug.assert(min <= max, "min must be less or equal to max");
            if (x === undefined || x === null) {
                return x;
            }
            if (x < min) {
                return min;
            }
            if (x > max) {
                return max;
            }
            return x;
        }
        Double.ensureInRange = ensureInRange;
        /**
         * Rounds the value - this method is actually faster than Math.round - used in the graphics utils.
         * @param x Value to round.
         */
        function round(x) {
            debug.assert(x >= 0, "x must be greater or equal to 0");
            return (0.5 + x) << 0;
        }
        Double.round = round;
        /**
         * Projects the value from the source range into the target range.
         * @param value Value to project.
         * @param fromMin Minimum of the source range.
         * @param toMin Minimum of the target range.
         * @param toMax Maximum of the target range.
         */
        function project(value, fromMin, fromSize, toMin, toSize) {
            if (fromSize === 0 || toSize === 0) {
                if (fromMin <= value && value <= fromMin + fromSize) {
                    return toMin;
                }
                else {
                    return NaN;
                }
            }
            var relativeX = (value - fromMin) / fromSize;
            var projectedX = toMin + relativeX * toSize;
            return projectedX;
        }
        Double.project = project;
        /**
         * Removes decimal noise.
         * @param value Value to be processed.
         */
        function removeDecimalNoise(value) {
            return roundToPrecision(value, getPrecision(value));
        }
        Double.removeDecimalNoise = removeDecimalNoise;
        /**
         * Checks whether the number is integer.
         * @param value Value to be checked.
         */
        function isInteger(value) {
            return value !== null && value % 1 === 0;
        }
        Double.isInteger = isInteger;
        /**
         * Dividing by increment will give us count of increments
         * Round out the rough edges into even integer
         * Multiply back by increment to get rounded value
         * e.g. Rounder.toIncrement(0.647291, 0.05) => 0.65
         * @param value - value to round to nearest increment
         * @param increment - smallest increment to round toward
         */
        function toIncrement(value, increment) {
            return Math.round(value / increment) * increment;
        }
        Double.toIncrement = toIncrement;
    })(Double = powerbi.Double || (powerbi.Double = {}));
    function applyDefault(value, defaultValue) {
        return value !== undefined ? value : defaultValue;
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var Double = powerbi.Double;
    var Color;
    (function (Color) {
        function rotate(rgbString, rotateFactor) {
            if (rotateFactor === 0)
                return rgbString;
            var originalRgb = parseColorString(rgbString);
            var originalHsv = rgbToHsv(originalRgb);
            var rotatedHsv = rotateHsv(originalHsv, rotateFactor);
            var rotatedRgb = hsvToRgb(rotatedHsv);
            return hexString(rotatedRgb);
        }
        Color.rotate = rotate;
        function normalizeToHexString(color) {
            var rgb = parseColorString(color);
            return hexString(rgb);
        }
        Color.normalizeToHexString = normalizeToHexString;
        function parseColorString(color) {
            debug.assertValue(color, 'color');
            if (color.indexOf('#') >= 0) {
                if (color.length === 7) {
                    // #RRGGBB
                    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(color);
                    if (result == null || result.length < 4)
                        return;
                    return {
                        R: parseInt(result[1], 16),
                        G: parseInt(result[2], 16),
                        B: parseInt(result[3], 16),
                    };
                }
                else if (color.length === 4) {
                    // #RGB
                    var result = /^#?([a-f\d])([a-f\d])([a-f\d])$/i.exec(color);
                    if (result == null || result.length < 4)
                        return;
                    return {
                        R: parseInt(result[1] + result[1], 16),
                        G: parseInt(result[2] + result[2], 16),
                        B: parseInt(result[3] + result[3], 16),
                    };
                }
            }
            else if (color.indexOf('rgb(') >= 0) {
                // rgb(R, G, B)
                var result = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/.exec(color);
                if (result == null || result.length < 4)
                    return;
                return {
                    R: parseInt(result[1], 10),
                    G: parseInt(result[2], 10),
                    B: parseInt(result[3], 10),
                };
            }
            else if (color.indexOf('rgba(') >= 0) {
                // rgba(R, G, B, A)
                var result = /^rgba\((\d+),\s*(\d+),\s*(\d+),\s*(\d*(?:\.\d+)?)\)$/.exec(color);
                if (result == null || result.length < 5)
                    return;
                return {
                    R: parseInt(result[1], 10),
                    G: parseInt(result[2], 10),
                    B: parseInt(result[3], 10),
                    A: parseFloat(result[4]),
                };
            }
        }
        Color.parseColorString = parseColorString;
        function rgbToHsv(rgbColor) {
            var s, h;
            var r = rgbColor.R / 255, g = rgbColor.G / 255, b = rgbColor.B / 255;
            var min = Math.min(r, Math.min(g, b));
            var max = Math.max(r, Math.max(g, b));
            var v = max;
            var delta = max - min;
            if (max === 0 || delta === 0) {
                // R, G, and B must be 0.0, or all the same.
                // In this case, S is 0.0, and H is undefined.
                // Using H = 0.0 is as good as any...
                s = 0;
                h = 0;
            }
            else {
                s = delta / max;
                if (r === max) {
                    // Between Yellow and Magenta
                    h = (g - b) / delta;
                }
                else if (g === max) {
                    // Between Cyan and Yellow
                    h = 2 + (b - r) / delta;
                }
                else {
                    // Between Magenta and Cyan
                    h = 4 + (r - g) / delta;
                }
            }
            // Scale h to be between 0.0 and 1.
            // This may require adding 1, if the value
            // is negative.
            h /= 6;
            if (h < 0) {
                h += 1;
            }
            return {
                H: h,
                S: s,
                V: v,
            };
        }
        function hsvToRgb(hsvColor) {
            var r, g, b;
            var h = hsvColor.H, s = hsvColor.S, v = hsvColor.V;
            if (s === 0) {
                // If s is 0, all colors are the same.
                // This is some flavor of gray.
                r = v;
                g = v;
                b = v;
            }
            else {
                var p = void 0, q = void 0, t = void 0, fractionalSector = void 0, sectorNumber = void 0, sectorPos = void 0;
                // The color wheel consists of 6 sectors.
                // Figure out which sector you//re in.
                sectorPos = h * 6;
                sectorNumber = Math.floor(sectorPos);
                // get the fractional part of the sector.
                // That is, how many degrees into the sector
                // are you?
                fractionalSector = sectorPos - sectorNumber;
                // Calculate values for the three axes
                // of the color.
                p = v * (1.0 - s);
                q = v * (1.0 - (s * fractionalSector));
                t = v * (1.0 - (s * (1 - fractionalSector)));
                // Assign the fractional colors to r, g, and b
                // based on the sector the angle is in.
                switch (sectorNumber) {
                    case 0:
                        r = v;
                        g = t;
                        b = p;
                        break;
                    case 1:
                        r = q;
                        g = v;
                        b = p;
                        break;
                    case 2:
                        r = p;
                        g = v;
                        b = t;
                        break;
                    case 3:
                        r = p;
                        g = q;
                        b = v;
                        break;
                    case 4:
                        r = t;
                        g = p;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = p;
                        b = q;
                        break;
                }
            }
            return {
                R: Math.floor(r * 255),
                G: Math.floor(g * 255),
                B: Math.floor(b * 255),
            };
        }
        function rotateHsv(hsvColor, rotateFactor) {
            var newH = hsvColor.H + rotateFactor;
            return {
                H: newH > 1 ? newH - 1 : newH,
                S: hsvColor.S,
                V: hsvColor.V,
            };
        }
        function darken(color, diff) {
            var flooredNumber = Math.floor(diff);
            return {
                R: Math.max(0, color.R - flooredNumber),
                G: Math.max(0, color.G - flooredNumber),
                B: Math.max(0, color.B - flooredNumber),
            };
        }
        Color.darken = darken;
        function rgbString(color) {
            if (color.A == null)
                return "rgb(" + color.R + "," + color.G + "," + color.B + ")";
            return "rgba(" + color.R + "," + color.G + "," + color.B + "," + color.A + ")";
        }
        Color.rgbString = rgbString;
        function hexString(color) {
            return "#" + componentToHex(color.R) + componentToHex(color.G) + componentToHex(color.B);
        }
        Color.hexString = hexString;
        function componentToHex(hexComponent) {
            var clamped = Double.ensureInRange(hexComponent, 0, 255);
            var hex = clamped.toString(16).toUpperCase();
            return hex.length === 1 ? "0" + hex : hex;
        }
    })(Color = jsCommon.Color || (jsCommon.Color = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * CSS constants.
     */
    var CssConstants;
    (function (CssConstants) {
        function createClassAndSelector(className) {
            return {
                class: className,
                selector: '.' + className,
            };
        }
        CssConstants.createClassAndSelector = createClassAndSelector;
        CssConstants.styleAttribute = 'style';
        CssConstants.pixelUnits = 'px';
        CssConstants.heightProperty = 'height';
        CssConstants.widthProperty = 'width';
        CssConstants.topProperty = 'top';
        CssConstants.bottomProperty = 'bottom';
        CssConstants.leftProperty = 'left';
        CssConstants.rightProperty = 'right';
        CssConstants.marginTopProperty = 'margin-top';
        CssConstants.marginLeftProperty = 'margin-left';
        CssConstants.displayProperty = 'display';
        CssConstants.backgroundProperty = 'background';
        CssConstants.backgroundColorProperty = 'background-color';
        CssConstants.backgroundRepeatProperty = 'background-repeat';
        CssConstants.backgroundSizeProperty = 'background-size';
        CssConstants.backgroundImageProperty = 'background-image';
        CssConstants.textShadowProperty = 'text-shadow';
        CssConstants.textAlignProperty = 'text-align';
        CssConstants.borderTopWidthProperty = 'border-top-width';
        CssConstants.borderBottomWidthProperty = 'border-bottom-width';
        CssConstants.borderLeftWidthProperty = 'border-left-width';
        CssConstants.borderRightWidthProperty = 'border-right-width';
        CssConstants.fontSizeProperty = 'font-size';
        CssConstants.fontWeightProperty = 'font-weight';
        CssConstants.colorProperty = 'color';
        CssConstants.opacityProperty = 'opacity';
        CssConstants.paddingLeftProperty = 'padding-left';
        CssConstants.paddingRightProperty = 'padding-right';
        CssConstants.positionProperty = 'position';
        CssConstants.maxWidthProperty = 'max-width';
        CssConstants.minWidthProperty = 'min-width';
        CssConstants.overflowProperty = 'overflow';
        CssConstants.overflowXProperty = 'overflow-x';
        CssConstants.overflowYProperty = 'overflow-y';
        CssConstants.transformProperty = 'transform';
        CssConstants.webkitTransformProperty = '-webkit-transform';
        CssConstants.cursorProperty = 'cursor';
        CssConstants.visibilityProperty = 'visibility';
        CssConstants.absoluteValue = 'absolute';
        CssConstants.zeroPixelValue = '0px';
        CssConstants.autoValue = 'auto';
        CssConstants.hiddenValue = 'hidden';
        CssConstants.noneValue = 'none';
        CssConstants.blockValue = 'block';
        CssConstants.inlineBlockValue = 'inline-block';
        CssConstants.transparentValue = 'transparent';
        CssConstants.boldValue = 'bold';
        CssConstants.visibleValue = 'visible';
        CssConstants.tableRowValue = 'table-row';
        CssConstants.coverValue = 'cover';
        CssConstants.pointerValue = 'pointer';
        CssConstants.scrollValue = 'scroll';
    })(CssConstants = jsCommon.CssConstants || (jsCommon.CssConstants = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/**
 * Defines a Debug object. Calls to any functions in this object removed by the minifier.
 * The functions within this class are not minified away, so we use the preprocessor-style
 * comments to have the minifier remove those as well.
 */
///#DEBUG
var debug;
(function (debug) {
    /**
     * Asserts that the condition is true, fails otherwise.
     */
    function assert(condition, message) {
        if (condition !== true) {
            assertFail(message || ('condition: ' + condition));
        }
    }
    debug.assert = assert;
    /**
     * Asserts that the value is neither null nor undefined, fails otherwise.
     */
    function assertValue(value, message) {
        if (value === null || value === undefined) {
            assertFail(message || ('condition: ' + value));
        }
    }
    debug.assertValue = assertValue;
    /**
     * Asserts that the value is neither null nor undefined, and has a length property that returns greater than zero, fails otherwise.
     */
    function assertNonEmpty(value, message) {
        if (!(value != null && value.length > 0)) {
            assertFail(message || ('condition: ' + value));
        }
    }
    debug.assertNonEmpty = assertNonEmpty;
    /**
     * Makes no assertion on the given value.
     * This is documentation/placeholder that a value is possibly null or undefined (unlike assertValue).
     */
    function assertAnyValue(value, message) {
    }
    debug.assertAnyValue = assertAnyValue;
    function assertFail(message) {
        (debug.assertFailFunction || alert)('Debug Assert failed: ' + message);
    }
    debug.assertFail = assertFail;
})(debug || (debug = {}));
///#ENDDEBUG 
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var Errors;
    (function (Errors) {
        function infoNavAppAlreadyPresent() {
            return {
                name: 'infoNavAppAlreadyPresent',
                message: 'Cannot initialize embedded scenario when the InfoNav App is already present in this context',
                stack: getExceptionStackTrace()
            };
        }
        Errors.infoNavAppAlreadyPresent = infoNavAppAlreadyPresent;
        function invalidOperation(message) {
            return {
                name: 'invalidOperation',
                message: message,
                stack: getExceptionStackTrace()
            };
        }
        Errors.invalidOperation = invalidOperation;
        function argument(argumentName, message) {
            return {
                name: 'invalidArgumentError',
                argument: argumentName,
                message: message,
                stack: getExceptionStackTrace()
            };
        }
        Errors.argument = argument;
        function argumentNull(argumentName) {
            return {
                name: 'argumentNull',
                argument: argumentName,
                message: 'Argument was null',
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentNull = argumentNull;
        function argumentUndefined(argumentName) {
            return {
                name: 'argumentUndefined',
                argument: argumentName,
                message: 'Argument was undefined',
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentUndefined = argumentUndefined;
        function argumentOutOfRange(argumentName) {
            return {
                name: 'argumentOutOfRange',
                argument: argumentName,
                message: 'Argument was out of range',
                stack: getExceptionStackTrace()
            };
        }
        Errors.argumentOutOfRange = argumentOutOfRange;
        function pureVirtualMethodException(className, methodName) {
            return {
                name: 'pureVirtualMethodException',
                message: 'This method must be overriden by the derived class:' + className + '.' + methodName,
                stack: getExceptionStackTrace()
            };
        }
        Errors.pureVirtualMethodException = pureVirtualMethodException;
        function notImplementedException(message) {
            return {
                name: 'notImplementedException',
                message: message,
                stack: getExceptionStackTrace()
            };
        }
        Errors.notImplementedException = notImplementedException;
        function getExceptionStackTrace() {
            return getStackTrace(/*leadingFramesToRemove*/ 2);
        }
    })(Errors = jsCommon.Errors || (jsCommon.Errors = {}));
    /**
     * Captures the stack trace, if available.
     * It optionally takes the number of frames to remove from the stack trace.
     * By default, it removes the last frame to consider the calling type's
     * constructor and the temporary error used to capture the stack trace (below).
     * More levels can be requested as needed e..g. when an error is created
     * from a helper method. <Min requirement: IE10, Chrome, Firefox, Opera>.
     */
    function getStackTrace(leadingFramesToRemove) {
        if (leadingFramesToRemove === void 0) { leadingFramesToRemove = 1; }
        var stackTrace, stackSegments;
        try {
            // needs to throw for stack trace to work in IE
            throw new Error();
        }
        catch (error) {
            stackTrace = error.stack;
            if (stackTrace != null) {
                stackSegments = stackTrace.split('\n');
                stackSegments.splice(1, leadingFramesToRemove);
                // Finally
                stackTrace = stackSegments.join('\n');
            }
        }
        return stackTrace;
    }
    jsCommon.getStackTrace = getStackTrace;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
$.fn.multiline = function (text) {
    this.text(text);
    this.html(this.html().replace(/\n/g, '<br/>'));
    return this;
};
$.fn.togglePanelControl = function () {
    return this.each(function () {
        $(this).addClass("ui-accordion ui-accordion-icons ui-widget ui-helper-reset")
            .find(".accordionHeader")
            .addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-top ui-corner-bottom")
            .hover(function () {
            $(this).toggleClass("ui-state-hover");
        })
            .prepend('<span class="ui-icon ui-icon-triangle-1-e"></span>')
            .click(function () {
            $(this)
                .toggleClass("ui-accordion-header-active ui-state-active ui-state-default ui-corner-bottom")
                .find("> .ui-icon").toggleClass("ui-icon-triangle-1-e ui-icon-triangle-1-s").end()
                .next().slideToggle();
            return false;
        })
            .next()
            .addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom")
            .hide();
    });
};
var jsCommon;
(function (jsCommon) {
    var JQueryConstants;
    (function (JQueryConstants) {
        JQueryConstants.VisibleSelector = ':visible';
    })(JQueryConstants = jsCommon.JQueryConstants || (jsCommon.JQueryConstants = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Represents a lazily instantiated value.
     */
    var Lazy = (function () {
        function Lazy(factoryMethod) {
            jsCommon.Utility.throwIfNullOrUndefined(factoryMethod, this, 'constructor', 'factoryMethod');
            this.factoryMethod = factoryMethod;
        }
        Lazy.prototype.getValue = function () {
            if (this.factoryMethod !== null) {
                this.value = this.factoryMethod();
                // Optimization: Release the factoryMethod, as it could be holding a large object graph.
                this.factoryMethod = null;
            }
            return this.value;
        };
        return Lazy;
    }());
    jsCommon.Lazy = Lazy;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var Prototype;
    (function (Prototype) {
        /**
         * Returns a new object with the provided obj as its prototype.
         */
        function inherit(obj, extension) {
            debug.assertValue(obj, 'obj');
            function wrapCtor() { }
            ;
            wrapCtor.prototype = obj;
            var inherited = new wrapCtor();
            if (extension)
                extension(inherited);
            return inherited;
        }
        Prototype.inherit = inherit;
        /**
         * Returns a new object with the provided obj as its prototype
         * if, and only if, the prototype has not been previously set
         */
        function inheritSingle(obj) {
            debug.assertValue(obj, 'obj');
            var proto = Object.getPrototypeOf(obj);
            if (proto === Object.prototype || proto === Array.prototype)
                obj = inherit(obj);
            return obj;
        }
        Prototype.inheritSingle = inheritSingle;
        /**
         * Uses the provided callback function to selectively replace contents in the provided array.
         * @return A new array with those values overriden
         * or undefined if no overrides are necessary.
         */
        function overrideArray(prototype, override) {
            if (!prototype)
                return;
            var overwritten;
            for (var i = 0, len = prototype.length; i < len; i++) {
                var value = override(prototype[i]);
                if (value) {
                    if (!overwritten)
                        overwritten = inherit(prototype);
                    overwritten[i] = value;
                }
            }
            return overwritten;
        }
        Prototype.overrideArray = overrideArray;
    })(Prototype = powerbi.Prototype || (powerbi.Prototype = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var Formatting;
    (function (Formatting) {
        var regexCache;
        /**
         * Translate .NET format into something supported by jQuery.Globalize.
         */
        function findDateFormat(value, format, cultureName) {
            switch (format) {
                case "m":
                    // Month + day
                    format = "M";
                    break;
                case "O":
                case "o":
                    // Roundtrip
                    format = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fff'0000'";
                    break;
                case "R":
                case "r":
                    // RFC1123 pattern - - time must be converted to UTC before formatting 
                    value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                    format = "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'";
                    break;
                case "s":
                    // Sortable - should use invariant culture
                    format = "S";
                    break;
                case "u":
                    // Universal sortable - should convert to UTC before applying the "yyyy'-'MM'-'dd HH':'mm':'ss'Z' format.
                    value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                    format = "yyyy'-'MM'-'dd HH':'mm':'ss'Z'";
                    break;
                case "U":
                    // Universal full - the pattern is same as F but the time must be converted to UTC before formatting
                    value = new Date(value.getUTCFullYear(), value.getUTCMonth(), value.getUTCDate(), value.getUTCHours(), value.getUTCMinutes(), value.getUTCSeconds(), value.getUTCMilliseconds());
                    format = "F";
                    break;
                case "y":
                case "Y":
                    // Year and month
                    switch (cultureName) {
                        case "default":
                        case "en":
                        case "en-US":
                            format = "MMMM, yyyy"; // Fix the default year-month pattern for english
                            break;
                        default:
                            format = "Y"; // For other cultures - use the localized pattern
                    }
                    break;
            }
            return { value: value, format: format };
        }
        Formatting.findDateFormat = findDateFormat;
        /**
         * Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize.
         */
        function fixDateTimeFormat(format) {
            // Fix for the "K" format (timezone): 
            //The js dates don't have a kind property so we'll support only local kind which is equavalent to zzz format.
            format = format.replace(/%K/g, "zzz");
            format = format.replace(/K/g, "zzz");
            format = format.replace(/fffffff/g, "fff0000");
            format = format.replace(/ffffff/g, "fff000");
            format = format.replace(/fffff/g, "fff00");
            format = format.replace(/ffff/g, "fff0");
            // Fix for the 5 digit year: "yyyyy" format. 
            //The Globalize doesn't support dates greater than 9999 so we replace the "yyyyy" with "0yyyy".
            format = format.replace(/yyyyy/g, "0yyyy");
            // Fix for the 3 digit year: "yyy" format. 
            //The Globalize doesn't support this formatting so we need to replace it with the 4 digit year "yyyy" format.
            format = format.replace(/(^y|^)yyy(^y|$)/g, "yyyy");
            if (!regexCache) {
                // Creating Regexes for cases "Using single format specifier" 
                //- http://msdn.microsoft.com/en-us/library/8kb3ddd4.aspx#UsingSingleSpecifiers
                // This is not supported from The Globalize.
                // The case covers all single "%" lead specifier (like "%d" but not %dd) 
                // The cases as single "%d" are filtered in if the bellow.
                // (?!S) where S is the specifier make sure that we only one symbol for specifier.
                regexCache = ["d", "f", "F", "g", "h", "H", "K", "m", "M", "s", "t", "y", "z", ":", "/"].map(function (s) {
                    return { r: new RegExp("\%" + s + "(?!" + s + ")", "g"), s: s };
                });
            }
            if (format.indexOf("%") !== -1 && format.length > 2) {
                for (var i = 0; i < regexCache.length; i++) {
                    format = format.replace(regexCache[i].r, regexCache[i].s);
                }
            }
            return format;
        }
        Formatting.fixDateTimeFormat = fixDateTimeFormat;
    })(Formatting = jsCommon.Formatting || (jsCommon.Formatting = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var doc = document, headElement = doc.head, firstScriptInHeadElement = headElement.getElementsByTagName('script')[0], linkElement = doc.createElement('link'), scriptElement = doc.createElement('script'), styleSheetLoaded = [], javaScriptFilesLoaded = [], javaScriptFilesLoading = [];
    linkElement.setAttribute('rel', 'stylesheet');
    function requires(dependency, to) {
        if (to === void 0) { to = $.noop; }
        loadStyleSheets(dependency.cssFiles || []);
        var scriptsToRun = dependency.javaScriptFilesWithCallback || [];
        if (dependency.javaScriptFiles) {
            for (var i = 0, len = dependency.javaScriptFiles.length; i < len; ++i) {
                scriptsToRun.push({ javascriptFile: dependency.javaScriptFiles[i] });
            }
        }
        loadJavaScriptFiles(scriptsToRun, to);
    }
    jsCommon.requires = requires;
    /**
     * Private Helpers.
     */
    function loadStyleSheets(hrefList) {
        hrefList.forEach(function (href) {
            if (styleSheetLoaded.indexOf(href) === -1) {
                styleSheetLoaded.push(href);
                loadStyleSheet(href);
            }
        });
    }
    function loadJavaScriptFiles(scripts, callback) {
        var loadingCount = scripts.length, parsingCount = loadingCount, sourceCodeList = [];
        function parseIfLoadingComplete() {
            if (!--loadingCount) {
                parseJavaScriptSourceCodes(scripts, sourceCodeList);
            }
        }
        function makeCallbackIfParsingComplete() {
            if (!--parsingCount) {
                callback();
            }
        }
        scripts.forEach(function (script, index) {
            var file = script.javascriptFile;
            if (javaScriptFilesLoaded.indexOf(file) === -1) {
                if (file in javaScriptFilesLoading) {
                    javaScriptFilesLoading[file].push(function () {
                        parseIfLoadingComplete();
                        makeCallbackIfParsingComplete();
                    });
                }
                else {
                    javaScriptFilesLoading[file] = [function () {
                            makeCallbackIfParsingComplete();
                        }];
                    if (isExternalUrl(file)) {
                        sourceCodeList[index] = script;
                        parseIfLoadingComplete();
                    }
                    else {
                        loadJavaScriptSourceCode(file, function (sourceCode) {
                            sourceCodeList[index] = { javascriptFile: sourceCode };
                            parseIfLoadingComplete();
                        });
                    }
                }
            }
            else {
                parseIfLoadingComplete();
                makeCallbackIfParsingComplete();
            }
        });
    }
    function loadStyleSheet(href) {
        var link = linkElement.cloneNode();
        link.href = href;
        if (firstScriptInHeadElement) {
            headElement.insertBefore(link, firstScriptInHeadElement);
        }
        else {
            headElement.appendChild(link);
        }
    }
    function loadJavaScriptSourceCode(src, onload) {
        webGet(src, function () {
            onload(this.responseText);
        });
    }
    function parseJavaScript(script, onComplete) {
        if (onComplete === void 0) { onComplete = $.noop; }
        if (!script) {
            onComplete();
            return;
        }
        var sourceCodeOrFileName = script.javascriptFile;
        var targetCallback = onComplete;
        if (script.onLoadCallback) {
            var promiseAsCallback = function () {
                script.onLoadCallback().then(onComplete);
            };
            targetCallback = promiseAsCallback;
        }
        isExternalUrl(sourceCodeOrFileName)
            ? loadExternalJavaScriptFile(sourceCodeOrFileName, targetCallback)
            : parseInternalJavaScriptCode(sourceCodeOrFileName, targetCallback);
    }
    function parseInternalJavaScriptCode(sourceCode, onComplete) {
        if (onComplete === void 0) { onComplete = $.noop; }
        var script;
        if (sourceCode) {
            script = scriptElement.cloneNode();
            script.setAttribute('type', 'text/javascript');
            script.innerHTML = sourceCode;
            headElement.appendChild(script);
        }
        setTimeout(onComplete, 0);
    }
    function loadExternalJavaScriptFile(src, onload) {
        var script;
        if (src) {
            script = scriptElement.cloneNode();
            script.setAttribute('src', src);
            script.setAttribute('charset', 'utf-8');
            script.onload = onload;
            headElement.appendChild(script);
        }
    }
    function parseJavaScriptSourceCodes(scripts, sourceCodeList) {
        asyncLoop(sourceCodeList, parseJavaScript, /*on all files parsed*/ function () {
            scripts.forEach(function (script) {
                var file = script.javascriptFile;
                var listeners = javaScriptFilesLoading[file];
                if (listeners) {
                    listeners.forEach(function (listener) {
                        listener();
                    });
                }
                delete javaScriptFilesLoading[file];
                if (javaScriptFilesLoaded.indexOf(file) === -1) {
                    javaScriptFilesLoaded.push(file);
                }
            });
        });
    }
    function webGet(src, onload, onerror) {
        var xhr = new XMLHttpRequest();
        try {
            xhr.open('GET', src, true);
            xhr.onload = onload;
            xhr.onerror = onerror;
            xhr.send(null);
        }
        catch (e) {
        }
    }
    function isExternalUrl(url) {
        var origin = location.protocol + '//' + location.host + '/';
        return /^http[s]?:\/\/.+/i.test(url) && url.indexOf(origin) !== 0;
    }
    function _() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
    }
    function asyncSteps() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        if (args.length === 0) {
            return;
        }
        var steps = [], i = args.length;
        while (i--) {
            (function (j) {
                steps[j] = function () {
                    args[j](steps[j + 1] || _);
                };
            })(i);
        }
        steps[0]();
    }
    function asyncLoop(enumerable, func, callback) {
        var steps = [], i = 0, len = enumerable.length;
        for (; i < len - 1; i++) {
            (function (i) {
                steps[i] = function (next) {
                    func(enumerable[i], next);
                };
            }(i));
        }
        steps[len - 1] = function (next) {
            func(enumerable[len - 1], callback);
        };
        asyncSteps.apply(null, steps);
    }
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    function createJQueryPromiseFactory() {
        return new JQueryPromiseFactory();
    }
    powerbi.createJQueryPromiseFactory = createJQueryPromiseFactory;
    /**
     * jQuery-based implementation of IPromiseFactory.
     * This is useful for cases when Angular is not present, or when immediate promise resolving (not tied to Angular digest cycle) is desired.
     */
    var JQueryPromiseFactory = (function () {
        function JQueryPromiseFactory() {
        }
        JQueryPromiseFactory.prototype.defer = function () {
            return new JQueryDeferredWrapper($.Deferred());
        };
        JQueryPromiseFactory.prototype.reject = function (reason) {
            var deferred = this.defer();
            deferred.reject(reason);
            return deferred.promise;
        };
        JQueryPromiseFactory.prototype.resolve = function (value) {
            var deferred = this.defer();
            deferred.resolve(value);
            return deferred.promise;
        };
        JQueryPromiseFactory.prototype.all = function (promises) {
            var unwrappedPromises = jQuery.map(promises, function (value) {
                return value && value.promise ? value.promise : value;
            });
            return new JQueryPromiseWrapper($.when.apply($, unwrappedPromises));
        };
        JQueryPromiseFactory.prototype.when = function (value) {
            var unwrappedPromise = value && value.promise ? value.promise : value;
            return new JQueryPromiseWrapper($.when(unwrappedPromise));
        };
        return JQueryPromiseFactory;
    }());
    /**
     * Implements IDeferred via a wrapped a jQuery Deferred.
     */
    var JQueryDeferredWrapper = (function () {
        function JQueryDeferredWrapper(deferred) {
            debug.assertValue(deferred, 'deferred');
            this.deferred = deferred;
            this.promise = new JQueryPromiseWrapper(deferred.promise());
        }
        JQueryDeferredWrapper.prototype.resolve = function (value) {
            this.deferred.resolve(value);
        };
        JQueryDeferredWrapper.prototype.reject = function (reason) {
            this.deferred.reject(reason);
        };
        return JQueryDeferredWrapper;
    }());
    /**
     * Implements IDeferred via a wrapped a jQuery Promise.
     */
    var JQueryPromiseWrapper = (function () {
        function JQueryPromiseWrapper(promise) {
            debug.assertValue(promise, 'promise');
            this.promise = promise;
        }
        JQueryPromiseWrapper.prototype.then = function (a, b) {
            return new JQueryPromiseWrapper(this.promise.then(JQueryPromiseWrapper.wrapCallback(a), JQueryPromiseWrapper.wrapCallback(b)));
        };
        JQueryPromiseWrapper.prototype.catch = function (callback) {
            return this.then(null, callback);
        };
        JQueryPromiseWrapper.prototype.finally = function (callback) {
            this.promise.always(JQueryPromiseWrapper.wrapCallback(callback));
            return this;
        };
        /**
         * Wraps a callback, which may return a IPromise.
         */
        JQueryPromiseWrapper.wrapCallback = function (callback) {
            if (callback)
                return function (arg) {
                    var value = callback(arg);
                    // If the callback returns a Promise, unwrap that to allow jQuery to chain.
                    if (value instanceof JQueryPromiseWrapper)
                        return value.promise;
                    return value;
                };
            return callback;
        };
        return JQueryPromiseWrapper;
    }());
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var LocalStorageService = (function () {
        function LocalStorageService() {
        }
        LocalStorageService.prototype.getData = function (key) {
            try {
                if (localStorage) {
                    var value = localStorage[key];
                    if (value) {
                        return JSON.parse(value);
                    }
                }
            }
            catch (exception) { }
            return null;
        };
        LocalStorageService.prototype.setData = function (key, data) {
            try {
                if (localStorage) {
                    localStorage[key] = JSON.stringify(data);
                }
            }
            catch (e) { }
        };
        return LocalStorageService;
    }());
    var EphemeralStorageService = (function () {
        function EphemeralStorageService(clearCacheInterval) {
            this.cache = {};
            this.clearCacheInterval = (clearCacheInterval != null)
                ? clearCacheInterval
                : EphemeralStorageService.defaultClearCacheInterval;
            this.clearCache();
        }
        EphemeralStorageService.prototype.getData = function (key) {
            return this.cache[key];
        };
        EphemeralStorageService.prototype.setData = function (key, data) {
            var _this = this;
            this.cache[key] = data;
            if (this.clearCacheTimerId == null) {
                this.clearCacheTimerId = setTimeout(function () { return _this.clearCache(); }, this.clearCacheInterval);
            }
        };
        EphemeralStorageService.prototype.clearCache = function () {
            this.cache = {};
            this.clearCacheTimerId = undefined;
        };
        EphemeralStorageService.defaultClearCacheInterval = (1000 * 60 * 60 * 24); // 1 day
        return EphemeralStorageService;
    }());
    powerbi.EphemeralStorageService = EphemeralStorageService;
    powerbi.localStorageService = new LocalStorageService();
    powerbi.ephemeralStorageService = new EphemeralStorageService();
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var WordBreaker;
    (function (WordBreaker) {
        var SPACE = ' ';
        var BREAKERS_REGEX = /[\s\n]+/g;
        function search(index, content, backward) {
            if (backward) {
                for (var i = index - 1; i > -1; i--) {
                    if (hasBreakers(content[i]))
                        return i + 1;
                }
            }
            else {
                for (var i = index, ilen = content.length; i < ilen; i++) {
                    if (hasBreakers(content[i]))
                        return i;
                }
            }
            return backward ? 0 : content.length;
        }
        /**
         * Find the word nearest the cursor specified within content
         * @param index - point within content to search forward/backward from
         * @param content - string to search
        */
        function find(index, content) {
            debug.assert(index >= 0 && index <= content.length, 'index within content string bounds');
            var result = { start: 0, end: 0 };
            if (content.length === 0)
                return result;
            result.start = search(index, content, true);
            result.end = search(index, content, false);
            return result;
        }
        WordBreaker.find = find;
        /**
         * Test for presence of breakers within content
         * @param content - string to test
        */
        function hasBreakers(content) {
            BREAKERS_REGEX.lastIndex = 0;
            return BREAKERS_REGEX.test(content);
        }
        WordBreaker.hasBreakers = hasBreakers;
        /**
         * Count the number of pieces when broken by BREAKERS_REGEX
         * ~2.7x faster than WordBreaker.split(content).length
         * @param content - string to break and count
        */
        function wordCount(content) {
            var count = 1;
            BREAKERS_REGEX.lastIndex = 0;
            BREAKERS_REGEX.exec(content);
            while (BREAKERS_REGEX.lastIndex !== 0) {
                count++;
                BREAKERS_REGEX.exec(content);
            }
            return count;
        }
        WordBreaker.wordCount = wordCount;
        function getMaxWordWidth(content, textWidthMeasurer, properties) {
            var words = split(content);
            var maxWidth = 0;
            for (var _i = 0, words_1 = words; _i < words_1.length; _i++) {
                var w = words_1[_i];
                properties.text = w;
                maxWidth = Math.max(maxWidth, textWidthMeasurer(properties));
            }
            return maxWidth;
        }
        WordBreaker.getMaxWordWidth = getMaxWordWidth;
        function split(content) {
            return content.split(BREAKERS_REGEX);
        }
        function getWidth(content, properties, textWidthMeasurer) {
            properties.text = content;
            return textWidthMeasurer(properties);
        }
        function truncate(content, properties, truncator, maxWidth) {
            properties.text = content;
            return truncator(properties, maxWidth);
        }
        /**
         * Split content by breakers (words) and greedy fit as many words
         * into each index in the result based on max width and number of lines
         * e.g. Each index in result corresponds to a line of content
         *      when used by AxisHelper.LabelLayoutStrategy.wordBreak
         * @param content - string to split
         * @param properties - text properties to be used by @param:textWidthMeasurer
         * @param textWidthMeasurer - function to calculate width of given text content
         * @param maxWidth - maximum allowed width of text content in each result
         * @param maxNumLines - maximum number of results we will allow, valid values must be greater than 0
         * @param truncator - (optional) if specified, used as a function to truncate content to a given width
        */
        function splitByWidth(content, properties, textWidthMeasurer, maxWidth, maxNumLines, truncator) {
            // Default truncator returns string as-is
            truncator = truncator ? truncator : function (properties, maxWidth) { return properties.text; };
            var result = [];
            var words = split(content);
            var usedWidth = 0;
            var wordsInLine = [];
            for (var _i = 0, words_2 = words; _i < words_2.length; _i++) {
                var word = words_2[_i];
                // Last line? Just add whatever is left
                if ((maxNumLines > 0) && (result.length >= maxNumLines - 1)) {
                    wordsInLine.push(word);
                    continue;
                }
                // Determine width if we add this word
                // Account for SPACE we will add when joining...
                var wordWidth = wordsInLine.length === 0
                    ? getWidth(word, properties, textWidthMeasurer)
                    : getWidth(SPACE + word, properties, textWidthMeasurer);
                // If width would exceed max width,
                // then push used words and start new split result
                if (usedWidth + wordWidth > maxWidth) {
                    // Word alone exceeds max width, just add it.
                    if (wordsInLine.length === 0) {
                        result.push(truncate(word, properties, truncator, maxWidth));
                        usedWidth = 0;
                        wordsInLine = [];
                        continue;
                    }
                    result.push(truncate(wordsInLine.join(SPACE), properties, truncator, maxWidth));
                    usedWidth = 0;
                    wordsInLine = [];
                }
                // ...otherwise, add word and continue
                wordsInLine.push(word);
                usedWidth += wordWidth;
            }
            // Push remaining words onto result
            result.push(truncate(wordsInLine.join(SPACE), properties, truncator, maxWidth));
            return result;
        }
        WordBreaker.splitByWidth = splitByWidth;
    })(WordBreaker = jsCommon.WordBreaker || (jsCommon.WordBreaker = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var TextMeasurementService;
    (function (TextMeasurementService) {
        var ellipsis = '…';
        var OverflowingText = jsCommon.CssConstants.createClassAndSelector('overflowingText');
        var spanElement;
        var svgTextElement;
        var canvasCtx;
        /**
         * Idempotent function for adding the elements to the DOM.
         */
        function ensureDOM() {
            if (spanElement)
                return;
            spanElement = $('<span/>');
            $('body').append(spanElement);
            //The style hides the svg element from the canvas, preventing canvas from scrolling down to show svg black square.
            svgTextElement = d3.select($('body').get(0))
                .append('svg')
                .style({
                'height': '0px',
                'width': '0px',
                'position': 'absolute'
            })
                .append('text');
            canvasCtx = $('<canvas/>').get(0).getContext("2d");
        }
        /**
         * Removes spanElement from DOM.
         */
        function removeSpanElement() {
            if (spanElement && spanElement.remove) {
                spanElement.remove();
            }
            spanElement = null;
        }
        TextMeasurementService.removeSpanElement = removeSpanElement;
        /**
         * This method measures the width of the text with the given SVG text properties.
         * @param textProperties The text properties to use for text measurement.
         */
        function measureSvgTextWidth(textProperties) {
            debug.assertValue(textProperties, 'textProperties');
            debug.assert(_.isEmpty(textProperties.fontSize) || textProperties.fontSize.indexOf("px") !== -1, "TextProperties' text size should be in px.");
            ensureDOM();
            canvasCtx.font = textProperties.fontSize + ' ' + textProperties.fontFamily;
            return canvasCtx.measureText(textProperties.text).width;
        }
        TextMeasurementService.measureSvgTextWidth = measureSvgTextWidth;
        /**
         * This method return the rect with the given SVG text properties.
         * @param textProperties The text properties to use for text measurement.
         */
        function measureSvgTextRect(textProperties) {
            debug.assertValue(textProperties, 'textProperties');
            debug.assert(_.isEmpty(textProperties.fontSize) || textProperties.fontSize.indexOf("px") !== -1, "TextProperties' text size should be in px.");
            ensureDOM();
            svgTextElement.style(null);
            svgTextElement
                .text(textProperties.text)
                .attr({
                'visibility': 'hidden',
                'font-family': textProperties.fontFamily,
                'font-size': textProperties.fontSize,
                'font-weight': textProperties.fontWeight,
                'font-style': textProperties.fontStyle,
                'white-space': textProperties.whiteSpace || 'nowrap'
            });
            // We're expecting the browser to give a synchronous measurement here
            // We're using SVGTextElement because it works across all browsers 
            return svgTextElement.node().getBBox();
        }
        TextMeasurementService.measureSvgTextRect = measureSvgTextRect;
        /**
         * This method measures the height of the text with the given SVG text properties.
         * @param textProperties The text properties to use for text measurement.
         */
        function measureSvgTextHeight(textProperties) {
            return measureSvgTextRect(textProperties).height;
        }
        TextMeasurementService.measureSvgTextHeight = measureSvgTextHeight;
        /**
         * This method returns the text Rect with the given SVG text properties.
         * Does NOT return text width; obliterates text value
         * @param {TextProperties} textProperties - The text properties to use for text measurement
         */
        function estimateSvgTextRect(textProperties) {
            debug.assertValue(textProperties, 'textProperties');
            debug.assert(_.isEmpty(textProperties.fontSize) || textProperties.fontSize.indexOf("px") !== -1, "TextProperties' text size should be in px.");
            var propertiesKey = textProperties.fontFamily + textProperties.fontSize;
            var rect = powerbi.ephemeralStorageService.getData(propertiesKey);
            if (rect == null) {
                // To estimate we check the height of a particular character, once it is cached, subsequent
                // calls should always get the height from the cache (regardless of the text).
                var estimatedTextProperties = {
                    fontFamily: textProperties.fontFamily,
                    fontSize: textProperties.fontSize,
                    text: "M",
                };
                rect = TextMeasurementService.measureSvgTextRect(estimatedTextProperties);
                // NOTE: In some cases (disconnected/hidden DOM) we may provide incorrect measurement results (zero sized bounding-box), so
                // we only store values in the cache if we are confident they are correct.
                if (rect.height > 0)
                    powerbi.ephemeralStorageService.setData(propertiesKey, rect);
            }
            return rect;
        }
        /**
         * This method returns the text Rect with the given SVG text properties.
         * @param {TextProperties} textProperties - The text properties to use for text measurement
         */
        function estimateSvgTextBaselineDelta(textProperties) {
            var rect = estimateSvgTextRect(textProperties);
            return rect.y + rect.height;
        }
        TextMeasurementService.estimateSvgTextBaselineDelta = estimateSvgTextBaselineDelta;
        /**
         * This method estimates the height of the text with the given SVG text properties.
         * @param {TextProperties} textProperties - The text properties to use for text measurement
         */
        function estimateSvgTextHeight(textProperties, tightFightForNumeric) {
            if (tightFightForNumeric === void 0) { tightFightForNumeric = false; }
            var height = estimateSvgTextRect(textProperties).height;
            //TODO: replace it with new baseline calculation
            if (tightFightForNumeric)
                height *= 0.7;
            return height;
        }
        TextMeasurementService.estimateSvgTextHeight = estimateSvgTextHeight;
        /**
         * This method measures the width of the svgElement.
         * @param svgElement The SVGTextElement to be measured.
         */
        function measureSvgTextElementWidth(svgElement) {
            debug.assertValue(svgElement, 'svgElement');
            return measureSvgTextWidth(getSvgMeasurementProperties(svgElement));
        }
        TextMeasurementService.measureSvgTextElementWidth = measureSvgTextElementWidth;
        /**
         * This method fetches the text measurement properties of the given DOM element.
         * @param element The selector for the DOM Element.
         */
        function getMeasurementProperties(element) {
            debug.assertValue(element, 'element');
            return {
                text: element.val() || element.text(),
                fontFamily: element.css('font-family'),
                fontSize: element.css('font-size'),
                fontWeight: element.css('font-weight'),
                fontStyle: element.css('font-style'),
                whiteSpace: element.css('white-space')
            };
        }
        TextMeasurementService.getMeasurementProperties = getMeasurementProperties;
        /**
         * This method fetches the text measurement properties of the given SVG text element.
         * @param svgElement The SVGTextElement to be measured.
         */
        function getSvgMeasurementProperties(svgElement) {
            debug.assertValue(svgElement, 'svgElement');
            var style = window.getComputedStyle(svgElement, null);
            return {
                text: svgElement.textContent,
                fontFamily: style.fontFamily,
                fontSize: style.fontSize,
                fontWeight: style.fontWeight,
                fontStyle: style.fontStyle,
                whiteSpace: style.whiteSpace
            };
        }
        TextMeasurementService.getSvgMeasurementProperties = getSvgMeasurementProperties;
        /**
         * This method returns the width of a div element.
         * @param element The div element.
         */
        function getDivElementWidth(element) {
            debug.assert(element.is('div'), 'Given element is not a div type. Cannot get width');
            return getComputedStyle(element[0]).width;
        }
        TextMeasurementService.getDivElementWidth = getDivElementWidth;
        /**
         * Compares labels text size to the available size and renders ellipses when the available size is smaller.
         * @param textProperties The text properties (including text content) to use for text measurement.
         * @param maxWidth The maximum width available for rendering the text.
         */
        function getTailoredTextOrDefault(textProperties, maxWidth) {
            debug.assertValue(textProperties, 'properties');
            debug.assertValue(textProperties.text, 'properties.text');
            debug.assert(_.isEmpty(textProperties.fontSize) || textProperties.fontSize.indexOf("px") !== -1, "TextProperties' text size should be in px.");
            ensureDOM();
            var strLength = textProperties.text.length;
            if (strLength === 0)
                return textProperties.text;
            var width = measureSvgTextWidth(textProperties);
            if (width < maxWidth)
                return textProperties.text;
            // Create a copy of the textProperties so we don't modify the one that's passed in.
            var copiedTextProperties = powerbi.Prototype.inherit(textProperties);
            // Take the properties and apply them to svgTextElement
            // Then, do the binary search to figure out the substring we want
            // Set the substring on textElement argument
            var text = copiedTextProperties.text = ellipsis + copiedTextProperties.text;
            var min = 1;
            var max = text.length;
            var i = ellipsis.length;
            while (min <= max) {
                // num | 0 prefered to Math.floor(num) for performance benefits
                i = (min + max) / 2 | 0;
                copiedTextProperties.text = text.substr(0, i);
                width = measureSvgTextWidth(copiedTextProperties);
                if (maxWidth > width)
                    min = i + 1;
                else if (maxWidth < width)
                    max = i - 1;
                else
                    break;
            }
            // Since the search algorithm almost never finds an exact match,
            // it will pick one of the closest two, which could result in a
            // value bigger with than 'maxWidth' thus we need to go back by 
            // one to guarantee a smaller width than 'maxWidth'.
            copiedTextProperties.text = text.substr(0, i);
            width = measureSvgTextWidth(copiedTextProperties);
            if (width > maxWidth)
                i--;
            return text.substr(ellipsis.length, i - ellipsis.length) + ellipsis;
        }
        TextMeasurementService.getTailoredTextOrDefault = getTailoredTextOrDefault;
        /**
         * Compares labels text size to the available size and renders ellipses when the available size is smaller.
         * @param textElement The SVGTextElement containing the text to render.
         * @param maxWidth The maximum width available for rendering the text.
         */
        function svgEllipsis(textElement, maxWidth) {
            debug.assertValue(textElement, 'textElement');
            var properties = getSvgMeasurementProperties(textElement);
            var originalText = properties.text;
            var tailoredText = getTailoredTextOrDefault(properties, maxWidth);
            if (originalText !== tailoredText) {
                textElement.textContent = tailoredText;
            }
        }
        TextMeasurementService.svgEllipsis = svgEllipsis;
        /**
         * Word break textContent of <text> SVG element into <tspan>s
         * Each tspan will be the height of a single line of text
         * @param textElement - the SVGTextElement containing the text to wrap
         * @param maxWidth - the maximum width available
         * @param maxHeight - the maximum height available (defaults to single line)
         * @param linePadding - (optional) padding to add to line height
         */
        function wordBreak(textElement, maxWidth, maxHeight, linePadding) {
            if (linePadding === void 0) { linePadding = 0; }
            debug.assertValue(textElement, 'textElement');
            var properties = getSvgMeasurementProperties(textElement);
            var height = estimateSvgTextHeight(properties) + linePadding;
            var maxNumLines = Math.max(1, Math.floor(maxHeight / height));
            var node = d3.select(textElement);
            // Save y of parent textElement to apply as first tspan dy
            var firstDY = node.attr('y');
            // Store and clear text content
            var labelText = textElement.textContent;
            textElement.textContent = null;
            // Append a tspan for each word broken section
            var words = jsCommon.WordBreaker.splitByWidth(labelText, properties, measureSvgTextWidth, maxWidth, maxNumLines);
            for (var i = 0, ilen = words.length; i < ilen; i++) {
                properties.text = words[i];
                node
                    .append('tspan')
                    .attr({
                    'x': 0,
                    'dy': i === 0 ? firstDY : height,
                })
                    .text(getTailoredTextOrDefault(properties, maxWidth));
            }
        }
        TextMeasurementService.wordBreak = wordBreak;
        /**
         * Word break textContent of span element into <span>s
         * Each span will be the height of a single line of text
         * @param textElement - the element containing the text to wrap
         * @param maxWidth - the maximum width available
         * @param maxHeight - the maximum height available (defaults to single line)
         * @param linePadding - (optional) padding to add to line height
         */
        function wordBreakOverflowingText(textElement, maxWidth, maxHeight, linePadding) {
            if (linePadding === void 0) { linePadding = 0; }
            debug.assertValue(textElement, 'textElement');
            var properties = getSvgMeasurementProperties(textElement);
            var height = estimateSvgTextHeight(properties) + linePadding;
            var maxNumLines = Math.max(1, Math.floor(maxHeight / height));
            // Store and clear text content
            var labelText = textElement.textContent;
            textElement.textContent = null;
            // Append a span for each word broken section
            var words = jsCommon.WordBreaker.splitByWidth(labelText, properties, measureSvgTextWidth, maxWidth, maxNumLines);
            // splitByWidth() occasionally returns unnecessary empty strings, so get rid of them.
            // TODO: Fix splitByWidth.
            words = _.compact(words);
            var spanItem = d3.select(textElement)
                .selectAll(OverflowingText.selector)
                .data(words, function (d) { return $.inArray(d, words); });
            spanItem
                .enter()
                .append("span")
                .classed(OverflowingText.class, true)
                .text(function (d) { return d; })
                .style("width", jsCommon.PixelConverter.toString(maxWidth));
        }
        TextMeasurementService.wordBreakOverflowingText = wordBreakOverflowingText;
    })(TextMeasurementService = powerbi.TextMeasurementService || (powerbi.TextMeasurementService = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Responsible for throttling input function.
     */
    var ThrottleUtility = (function () {
        function ThrottleUtility(delay) {
            this.timerFactory = jsCommon.TimerPromiseFactory.instance;
            this.delay = 0;
            if (delay) {
                this.delay = delay;
            }
        }
        ThrottleUtility.prototype.run = function (fn) {
            var _this = this;
            if (!this.fn) {
                this.fn = fn;
                this.timerFactory.create(this.delay).done(function () { return _this.timerComplete(_this.fn); });
            }
            else {
                this.fn = fn;
            }
        };
        /**
         * Note: Public for testing purpose.
         */
        ThrottleUtility.prototype.timerComplete = function (fn) {
            // run fn
            fn();
            // clear fn
            this.fn = null;
        };
        return ThrottleUtility;
    }());
    jsCommon.ThrottleUtility = ThrottleUtility;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Responsible for creating timer promises.
     */
    var TimerPromiseFactory = (function () {
        function TimerPromiseFactory() {
        }
        /**
         * {@inheritDoc}
         */
        TimerPromiseFactory.prototype.create = function (delayInMs) {
            debug.assertValue(delayInMs, 'delayInMs');
            debug.assert(delayInMs >= 0, 'delayInMs must be a positive value.');
            var deferred = $.Deferred();
            window.setTimeout(function () { return deferred.resolve(); }, delayInMs);
            return deferred;
        };
        TimerPromiseFactory.instance = new TimerPromiseFactory();
        return TimerPromiseFactory;
    }());
    jsCommon.TimerPromiseFactory = TimerPromiseFactory;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Http Status code we are interested.
     */
    (function (HttpStatusCode) {
        HttpStatusCode[HttpStatusCode["OK"] = 200] = "OK";
        HttpStatusCode[HttpStatusCode["BadRequest"] = 400] = "BadRequest";
        HttpStatusCode[HttpStatusCode["Unauthorized"] = 401] = "Unauthorized";
        HttpStatusCode[HttpStatusCode["Forbidden"] = 403] = "Forbidden";
        HttpStatusCode[HttpStatusCode["RequestEntityTooLarge"] = 413] = "RequestEntityTooLarge";
    })(jsCommon.HttpStatusCode || (jsCommon.HttpStatusCode = {}));
    var HttpStatusCode = jsCommon.HttpStatusCode;
    /**
     * Other HTTP Constants.
     */
    var HttpConstants;
    (function (HttpConstants) {
        HttpConstants.ApplicationOctetStream = 'application/octet-stream';
        HttpConstants.MultiPartFormData = 'multipart/form-data';
    })(HttpConstants = jsCommon.HttpConstants || (jsCommon.HttpConstants = {}));
    /**
     * Extensions to String class.
     */
    var StringExtensions;
    (function (StringExtensions) {
        var HtmlTagRegex = new RegExp('[<>]', 'g');
        function format() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var s = args[0];
            if (isNullOrUndefinedOrWhiteSpaceString(s))
                return s;
            for (var i = 0; i < args.length - 1; i++) {
                var reg = new RegExp("\\{" + i + "\\}", "gm");
                s = s.replace(reg, args[i + 1]);
            }
            return s;
        }
        StringExtensions.format = format;
        /**
         * Compares two strings for equality, ignoring case.
         */
        function equalIgnoreCase(a, b) {
            return StringExtensions.normalizeCase(a) === StringExtensions.normalizeCase(b);
        }
        StringExtensions.equalIgnoreCase = equalIgnoreCase;
        function startsWithIgnoreCase(a, b) {
            var normalizedSearchString = StringExtensions.normalizeCase(b);
            return StringExtensions.normalizeCase(a).indexOf(normalizedSearchString) === 0;
        }
        StringExtensions.startsWithIgnoreCase = startsWithIgnoreCase;
        function startsWith(a, b) {
            return a.indexOf(b) === 0;
        }
        StringExtensions.startsWith = startsWith;
        /** Determines whether a string contains a specified substring (while ignoring case). */
        function containsIgnoreCase(source, substring) {
            if (source == null)
                return false;
            return source.toLowerCase().indexOf(substring.toLowerCase().toString()) !== -1;
        }
        StringExtensions.containsIgnoreCase = containsIgnoreCase;
        /**
         * Normalizes case for a string.
         * Used by equalIgnoreCase method.
         */
        function normalizeCase(value) {
            Utility.throwIfNullOrUndefined(value, StringExtensions, 'normalizeCase', 'value');
            return value.toUpperCase();
        }
        StringExtensions.normalizeCase = normalizeCase;
        /**
         * Is string null or empty or undefined?
         * @return True if the value is null or undefined or empty string,
         * otherwise false.
         */
        function isNullOrEmpty(value) {
            return (value == null) || (value.length === 0);
        }
        StringExtensions.isNullOrEmpty = isNullOrEmpty;
        /**
         * Returns true if the string is null, undefined, empty, or only includes white spaces.
         * @return True if the str is null, undefined, empty, or only includes white spaces,
         * otherwise false.
         */
        function isNullOrUndefinedOrWhiteSpaceString(str) {
            return StringExtensions.isNullOrEmpty(str) || StringExtensions.isNullOrEmpty(str.trim());
        }
        StringExtensions.isNullOrUndefinedOrWhiteSpaceString = isNullOrUndefinedOrWhiteSpaceString;
        /**
         * Returns a value indicating whether the str contains any whitespace.
         */
        function containsWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, this, 'containsWhitespace', 'str');
            var expr = /\s/;
            return expr.test(str);
        }
        StringExtensions.containsWhitespace = containsWhitespace;
        /**
         * Returns a value indicating whether the str is a whitespace string.
         */
        function isWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, this, 'isWhitespace', 'str');
            return str.trim() === '';
        }
        StringExtensions.isWhitespace = isWhitespace;
        /**
         * Returns the string with any trailing whitespace from str removed.
         */
        function trimTrailingWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, this, 'trimTrailingWhitespace', 'str');
            return str.replace(/\s+$/, '');
        }
        StringExtensions.trimTrailingWhitespace = trimTrailingWhitespace;
        /**
         * Returns the string with any leading and trailing whitespace from str removed.
         */
        function trimWhitespace(str) {
            Utility.throwIfNullOrUndefined(str, this, 'trimWhitespace', 'str');
            return str.replace(/^\s+/, '').replace(/\s+$/, '');
        }
        StringExtensions.trimWhitespace = trimWhitespace;
        /**
         * Returns length difference between the two provided strings.
         */
        function getLengthDifference(left, right) {
            Utility.throwIfNullOrUndefined(left, this, 'getLengthDifference', 'left');
            Utility.throwIfNullOrUndefined(right, this, 'getLengthDifference', 'right');
            return Math.abs(left.length - right.length);
        }
        StringExtensions.getLengthDifference = getLengthDifference;
        /**
         * Repeat char or string several times.
         * @param char The string to repeat.
         * @param count How many times to repeat the string.
         */
        function repeat(char, count) {
            var result = "";
            for (var i = 0; i < count; i++) {
                result += char;
            }
            return result;
        }
        StringExtensions.repeat = repeat;
        /**
         * Replace all the occurrences of the textToFind in the text with the textToReplace.
         * @param text The original string.
         * @param textToFind Text to find in the original string.
         * @param textToReplace New text replacing the textToFind.
         */
        function replaceAll(text, textToFind, textToReplace) {
            if (!textToFind)
                return text;
            var pattern = escapeStringForRegex(textToFind);
            return text.replace(new RegExp(pattern, 'gi'), textToReplace);
        }
        StringExtensions.replaceAll = replaceAll;
        function ensureUniqueNames(names) {
            debug.assertValue(names, 'names');
            var usedNames = {};
            // Make sure we are giving fair chance for all columns to stay with their original name
            // First we fill the used names map to contain all the original unique names from the list.
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                usedNames[name_1] = false;
            }
            var uniqueNames = [];
            // Now we go over all names and find a unique name for each
            for (var _a = 0, names_2 = names; _a < names_2.length; _a++) {
                var name_2 = names_2[_a];
                var uniqueName = name_2;
                // If the (original) column name is already taken lets try to find another name
                if (usedNames[uniqueName]) {
                    var counter = 0;
                    // Find a name that is not already in the map
                    while (usedNames[uniqueName] !== undefined) {
                        uniqueName = name_2 + "." + (++counter);
                    }
                }
                uniqueNames.push(uniqueName);
                usedNames[uniqueName] = true;
            }
            return uniqueNames;
        }
        StringExtensions.ensureUniqueNames = ensureUniqueNames;
        /**
         * Returns a name that is not specified in the values.
         */
        function findUniqueName(usedNames, baseName) {
            debug.assertValue(usedNames, 'usedNames');
            debug.assertValue(baseName, 'baseName');
            // Find a unique name
            var i = 0, uniqueName = baseName;
            while (usedNames[uniqueName]) {
                uniqueName = baseName + (++i);
            }
            return uniqueName;
        }
        StringExtensions.findUniqueName = findUniqueName;
        function constructCommaSeparatedList(list, resourceProvider, maxValue) {
            if (!list || list.length === 0)
                return '';
            if (maxValue === null || maxValue === undefined)
                maxValue = Number.MAX_VALUE;
            var length = Math.min(maxValue, list.length);
            var replacedList = [];
            // Only need to replace user entries of {0} and {1} since we build the list in pairs.
            for (var j = 0; j < 2; j++) {
                var targetValue = '{' + j + '}';
                var replaceValue = '_|_<' + j + '>_|_';
                for (var i = 0; i < length; i++) {
                    if (list[i].indexOf(targetValue) > -1) {
                        list[i] = list[i].replace(targetValue, replaceValue);
                        replacedList.push({ targetValue: targetValue, replaceValue: replaceValue });
                    }
                }
            }
            var commaSeparatedList = '';
            for (var i = 0; i < length; i++) {
                if (i === 0)
                    commaSeparatedList = list[i];
                else
                    commaSeparatedList = StringExtensions.format(resourceProvider.get('FilterRestatement_Comma'), commaSeparatedList, list[i]);
            }
            for (var i = 0; i < replacedList.length; i++) {
                commaSeparatedList = commaSeparatedList.replace(replacedList[i].replaceValue, replacedList[i].targetValue);
            }
            return commaSeparatedList;
        }
        StringExtensions.constructCommaSeparatedList = constructCommaSeparatedList;
        function escapeStringForRegex(s) {
            return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1');
        }
        StringExtensions.escapeStringForRegex = escapeStringForRegex;
        /**
         * Remove file name reserved characters <>:"/\|?* from input string.
         */
        function normalizeFileName(fileName) {
            debug.assertValue(fileName, 'fileName');
            return fileName.replace(/[\<\>\:"\/\\\|\?*]/g, '');
        }
        StringExtensions.normalizeFileName = normalizeFileName;
        /**
         * Similar to JSON.stringify, but strips away escape sequences so that the resulting
         * string is human-readable (and parsable by JSON formatting/validating tools).
         */
        function stringifyAsPrettyJSON(object) {
            //let specialCharacterRemover = (key: string, value: string) => value.replace(/[^\w\s]/gi, '');
            return JSON.stringify(object /*, specialCharacterRemover*/);
        }
        StringExtensions.stringifyAsPrettyJSON = stringifyAsPrettyJSON;
        /**
         * Derive a CLS-compliant name from a specified string.  If no allowed characters are present, return a fallback string instead.
         * TODO (6708134): this should have a fully Unicode-aware implementation
         */
        function deriveClsCompliantName(input, fallback) {
            debug.assertValue(input, 'input');
            var result = input.replace(/^[^A-Za-z]*/g, '').replace(/[ :\.\/\\\-\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000]/g, '_').replace(/[\W]/g, '');
            return result.length > 0 ? result : fallback;
        }
        StringExtensions.deriveClsCompliantName = deriveClsCompliantName;
        /** Performs cheap sanitization by stripping away HTML tag (<>) characters. */
        function stripTagDelimiters(s) {
            return s.replace(HtmlTagRegex, '');
        }
        StringExtensions.stripTagDelimiters = stripTagDelimiters;
    })(StringExtensions = jsCommon.StringExtensions || (jsCommon.StringExtensions = {}));
    /**
     * The general utility class.
     */
    var Utility = (function () {
        function Utility() {
        }
        /**
         * Ensures the specified value is not null or undefined. Throws a relevent exception if it is.
         * @param value The value to check.
         * @param context The context from which the check originated.
         * @param methodName The name of the method that initiated the check.
         * @param parameterName The parameter name of the value to check.
         */
        Utility.throwIfNullOrUndefined = function (value, context, methodName, parameterName) {
            if (value === null) {
                Utility.throwException(jsCommon.Errors.argumentNull(Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
            else if (typeof (value) === Utility.Undefined) {
                Utility.throwException(jsCommon.Errors.argumentUndefined(Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
        };
        /**
         * Ensures the specified value is not null, undefined or empty. Throws a relevent exception if it is.
         * @param value The value to check.
         * @param context The context from which the check originated.
         * @param methodName The name of the method that initiated the check.
         * @param parameterName The parameter name of the value to check.
         */
        Utility.throwIfNullOrEmpty = function (value, context, methodName, parameterName) {
            Utility.throwIfNullOrUndefined(value, context, methodName, parameterName);
            if (!value.length) {
                Utility.throwException(jsCommon.Errors.argumentOutOfRange(Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
        };
        /**
         * Ensures the specified string is not null, undefined or empty. Throws a relevent exception if it is.
         * @param value The value to check.
         * @param context The context from which the check originated.
         * @param methodName The name of the method that initiated the check.
         * @param parameterName The parameter name of the value to check.
         */
        Utility.throwIfNullOrEmptyString = function (value, context, methodName, parameterName) {
            Utility.throwIfNullOrUndefined(value, context, methodName, parameterName);
            if (value.length < 1) {
                Utility.throwException(jsCommon.Errors.argumentOutOfRange(Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
        };
        /**
         * Ensures the specified value is not null, undefined, whitespace or empty. Throws a relevent exception if it is.
         * @param value The value to check.
         * @param context The context from which the check originated.
         * @param methodName The name of the method that initiated the check.
         * @param parameterName The parameter name of the value to check.
         */
        Utility.throwIfNullEmptyOrWhitespaceString = function (value, context, methodName, parameterName) {
            Utility.throwIfNullOrUndefined(value, context, methodName, parameterName);
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(value)) {
                Utility.throwException(jsCommon.Errors.argumentOutOfRange(Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
        };
        /**
         * Ensures the specified condition is true. Throws relevant exception if it isn't.
         * @param condition The condition to check.
         * @param context The context from which the check originated.
         * @param methodName The name of the method that initiated the check.
         * @param parameterName The parameter name against which the condition is checked.
         */
        Utility.throwIfNotTrue = function (condition, context, methodName, parameterName) {
            if (!condition) {
                Utility.throwException(jsCommon.Errors.argument(parameterName, Utility.getComponentName(context) + methodName + '.' + parameterName));
            }
        };
        /**
         * Checks whether the provided value is a 'string'.
         * @param value The value to test.
         */
        Utility.isString = function (value) {
            return ((typeof value) === 'string');
        };
        /**
         * Checks whether the provided value is a 'boolean'.
         * @param value The value to test.
         */
        Utility.isBoolean = function (value) {
            return ((typeof value) === 'boolean');
        };
        /**
         * Checks whether the provided value is a 'number'.
         * @param value The value to test.
         */
        Utility.isNumber = function (value) {
            return ((typeof value) === 'number');
        };
        /**
         * Checks whether the provided value is a Date instance.
         * @param value The value to test.
         */
        Utility.isDate = function (value) {
            return Utility.isObject(value) && (value instanceof Date);
        };
        /**
         * Checks whether the provided value is an 'object'.
         * @param value The value to test.
         */
        Utility.isObject = function (value) {
            return (value != null) && ((typeof value) === 'object');
        };
        /**
         * Checks whether the provided value is null or undefined.
         * @param value The value to test.
         */
        Utility.isNullOrUndefined = function (value) {
            return (value === null) || (typeof (value) === Utility.Undefined);
        };
        /**
         * Combine a base url and a path.
         * @param baseUrl The base url.
         * @param path The path to add on to the base url.
         * @returns The combined url.
         */
        Utility.urlCombine = function (baseUrl, path) {
            Utility.throwIfNullOrUndefined(baseUrl, null, "urlCombine", "baseUrl");
            Utility.throwIfNullOrUndefined(path, null, "urlCombine", "path");
            // should any of the components be empty, fail gracefuly - this is important when using the test page
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(path)) {
                return baseUrl;
            }
            if (StringExtensions.isNullOrUndefinedOrWhiteSpaceString(baseUrl)) {
                return path;
            }
            var finalUrl = baseUrl;
            if (finalUrl.charAt(finalUrl.length - 1) === '/') {
                if (path.charAt(0) === '/')
                    path = path.slice(1);
            }
            else {
                if (path.charAt(0) !== '/')
                    path = '/' + path;
            }
            return finalUrl + path;
        };
        Utility.getAbsoluteUri = function (path) {
            Utility.throwIfNullOrUndefined(path, null, "getAbsoluteUri", "path");
            var url = path;
            // Make absolute
            if (url && url.indexOf('http') === -1) {
                url = Utility.urlCombine(clusterUri, url);
            }
            return url;
        };
        Utility.getStaticResourceUri = function (path) {
            Utility.throwIfNullOrUndefined(path, null, "getStaticResourceUri", "path");
            var url = path;
            // Make absolute
            if (url && url.indexOf('http') === -1) {
                url = jsCommon.Utility.urlCombine(Utility.staticContentLocation, url);
            }
            return url;
        };
        Utility.getComponentName = function (context) {
            return !context ? '' : (typeof context).toString() + '.';
        };
        Utility.throwException = function (e) {
            jsCommon.Trace.error(StringExtensions.format("Throwing exception: {0}", JSON.stringify(e)), 
            /*includeStackTrace*/ e.stack != null ? false : true);
            throw e;
        };
        Utility.createClassSelector = function (className) {
            Utility.throwIfNullOrEmptyString(className, null, 'CreateClassSelector', 'className');
            return '.' + className;
        };
        Utility.createIdSelector = function (id) {
            Utility.throwIfNullOrEmptyString(id, null, 'CreateIdSelector', 'id');
            return '#' + id;
        };
        /**
         * Creates a client-side Guid string.
         * @returns A string representation of a Guid.
         */
        Utility.generateGuid = function () {
            var guid = "", idx = 0;
            for (idx = 0; idx < 32; idx += 1) {
                var guidDigitsItem = Math.random() * 16 | 0;
                switch (idx) {
                    case 8:
                    case 12:
                    case 16:
                    case 20:
                        guid += "-";
                        break;
                }
                guid += guidDigitsItem.toString(16);
            }
            return guid;
        };
        /**
         * Try extract a cookie from {@link document.cookie} identified by key.
         */
        Utility.getCookieValue = function (key) {
            // the cookie is of the format <key1=value1>; <key2=value2>. Split by ';', then by '=' 
            // to search for the key
            var keyValuePairs = document.cookie.split(';');
            for (var i = 0; i < keyValuePairs.length; i++) {
                var keyValue = keyValuePairs[i];
                var split = keyValue.split('=');
                if (split.length > 0 && split[0].trim() === key) {
                    return keyValue.substr(keyValue.indexOf('=') + 1);
                }
            }
            return null;
        };
        /**
         * Extracts the protocol://hostname section of a url.
         * @param url The URL from which to extract the section.
         * @returns The protocol://hostname portion of the given URL.
         */
        Utility.getDomainForUrl = function (url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return hrefObject.prop('protocol') + '//' + hrefObject.prop('hostname');
        };
        /**
         * Extracts the hostname and absolute path sections of a url.
         * @param url The URL from which to extract the section.
         * @returns The hostname and absolute path portion of the given URL.
         */
        Utility.getHostNameForUrl = function (url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return Utility.urlCombine(hrefObject.prop('hostname'), hrefObject.prop('pathname'));
        };
        /**
         * Return the original url with query string stripped.
         * @param url The URL from which to extract the section.
         * @returns the original url with query string stripped.
         */
        Utility.getUrlWithoutQueryString = function (url) {
            var hrefObject = Utility.getHrefObjectFromUrl(url);
            return hrefObject.prop('protocol') + '//' + Utility.urlCombine(hrefObject.prop('host'), hrefObject.prop('pathname'));
        };
        /**
         * Extracts the protocol section of a url.
         * @param url The URL from which to extract the section.
         * @returns The protocol for the current URL.
         */
        Utility.getProtocolFromUrl = function (url) {
            return Utility.getHrefObjectFromUrl(url).prop('protocol').replace(':', '');
        };
        /**
         * Returns a formatted href object from a URL.
         * @param url The URL used to generate the object.
         * @returns A jQuery object with the url.
         */
        Utility.getHrefObjectFromUrl = function (url) {
            var aObject = $('<a>');
            aObject = aObject.prop('href', url);
            return aObject;
        };
        /**
         * Converts a WCF representation of a dictionary to a JavaScript dictionary.
         * @param wcfDictionary The WCF dictionary to convert.
         * @returns The native JavaScript representation of this dictionary.
         */
        Utility.convertWcfToJsDictionary = function (wcfDictionary) {
            // convert the WCF JSON representation of a dictionary
            // to JS dictionary.
            // WCF representation: [{"Key": Key, "Value": Value}..]
            // JS representation: [Key: Value ..]
            var result = {};
            for (var i = 0; i < wcfDictionary.length; i++) {
                var keyValuePair = wcfDictionary[i];
                result[keyValuePair['Key']] = keyValuePair['Value'];
            }
            return result;
        };
        Utility.getDateFromWcfJsonString = function (jsonDate, fromUtcMilliseconds) {
            if (StringExtensions.isNullOrEmpty(jsonDate)) {
                return null;
            }
            var begIndex = jsonDate.indexOf('(');
            var endIndex = jsonDate.indexOf(')');
            if (begIndex !== -1 && endIndex !== -1) {
                var milliseconds = parseInt(jsonDate.substring(begIndex + 1, endIndex), 10);
                if (fromUtcMilliseconds) {
                    return new Date(milliseconds);
                }
                else {
                    var retValue = new Date(0);
                    retValue.setUTCMilliseconds(milliseconds);
                    return retValue;
                }
            }
            return null;
        };
        /**
         * Get the outer html of the given jquery object.
         * @param content The jquery object.
         * @returns The entire html representation of the object.
         */
        Utility.getOuterHtml = function (content) {
            return $('<div>').append(content).html();
        };
        /**
         * Comparison Method: Compares two integer numbers.
         * @param a An integer value.
         * @param b An integer value.
         * @returns The comparison result.
         */
        Utility.compareInt = function (a, b) {
            return a - b;
        };
        /**
         * Return the index of the smallest value in a numerical array.
         * @param a A numeric array.
         * @returns The index of the smallest value in the array.
         */
        Utility.getIndexOfMinValue = function (a) {
            var retValue = 0;
            var currentMinValue = a[0];
            for (var i = 0; i < a.length; i++) {
                if (a[i] < currentMinValue) {
                    currentMinValue = a[i];
                    retValue = i;
                }
            }
            return retValue;
        };
        /**
         * Extracts a url from a background image attribute in the format of: url('www.foobar.com/image.png').
         * @param input The value of the background-image attribute.
         * @returns The extracted url.
         */
        Utility.extractUrlFromCssBackgroundImage = function (input) {
            return input.replace(/"/g, "").replace(/url\(|\)$/ig, "");
        };
        /**
         * Verifies image data url of images.
         */
        Utility.isValidImageDataUrl = function (url) {
            var regex = new RegExp('data:(image\/(png|jpg|jpeg|gif|svg))');
            return regex.test(url);
        };
        /**
         * Downloads a content string as a file.
         * @param content Content stream.
         * @param fileName File name to use.
         */
        Utility.saveAsFile = function (content, fileName) {
            var contentBlob = new Blob([content], { type: HttpConstants.ApplicationOctetStream });
            var url = window['webkitURL'] || URL;
            var urlLink = url.createObjectURL(contentBlob);
            var fileNameLink = fileName || urlLink;
            // IE support, use msSaveOrOpenBlob API
            if (window.navigator.msSaveOrOpenBlob) {
                window.navigator.msSaveOrOpenBlob(contentBlob, fileNameLink);
                return;
            }
            // WebKit-based browser support requires generating an anchor tag with
            // download attribute set to blob store and triggering a click event to invoke 
            // a download to file action
            var hyperlink = document.createElement('a');
            hyperlink.href = urlLink;
            hyperlink.target = '_blank';
            hyperlink['download'] = fileNameLink;
            document.body.appendChild(hyperlink);
            hyperlink.click();
            document.body.removeChild(hyperlink);
        };
        /**
         * Helper method to get the simple type name from a typed object.
         * @param obj The typed object.
         * @returns The simple type name for the object.
         */
        Utility.getType = function (obj) {
            Utility.throwIfNullEmptyOrWhitespaceString(obj.__type, this, 'getType', 'obj');
            var parts = obj.__type.split(":");
            if (parts.length !== 2) {
                jsCommon.Errors.argument("obj.__type", "Type String not in expected format [Type]#[Namespace]: " + obj.__type);
            }
            if (parts[1] !== Utility.TypeNamespace) {
                jsCommon.Errors.argument("obj.__type", "Type Namespace not expected: " + parts[1]);
            }
            return parts[0];
        };
        /**
         * Check if an element supports a specific event type.
         * @param eventName The name of the event.
         * @param element The element to test for event support.
         * @returns Whether the even is supported on the provided element.
         */
        Utility.isEventSupported = function (eventName, element) {
            eventName = 'on' + eventName;
            var isSupported = (eventName in element);
            if (!isSupported) {
                // if we can't use setAttribute try a generic element
                if (!element.setAttribute) {
                    element = document.createElement('div');
                }
                if (element.setAttribute && element.removeAttribute) {
                    element.setAttribute(eventName, '');
                    isSupported = typeof element[eventName] === 'function';
                    // if the property was created - remove it
                    if (typeof element[eventName] !== 'undefined') {
                        element[eventName] = null;
                    }
                    element.removeAttribute(eventName);
                }
            }
            element = null;
            return isSupported;
        };
        Utility.toPixel = function (pixelAmount) {
            Utility.throwIfNullOrUndefined(pixelAmount, this, "toPixel", "pixelAmount");
            return pixelAmount.toString() + jsCommon.CssConstants.pixelUnits;
        };
        Utility.getPropertyCount = function (object) {
            Utility.throwIfNullOrUndefined(object, this, "getPropertyCount", "object");
            return Object.getOwnPropertyNames(object).length;
        };
        /**
         * Check if an element supports a specific event type.
         * @param filePath File path.
         * @returns File extension.
         */
        Utility.getFileExtension = function (filePath) {
            if (filePath) {
                var index = filePath.lastIndexOf('.');
                if (index >= 0)
                    return filePath.substr(index + 1);
            }
            return '';
        };
        /**
         * Extract the filename out of a full path delimited by '\' or '/'.
         * @param filePath File path.
         * @returns filename File name.
         */
        Utility.extractFileNameFromPath = function (filePath) {
            return filePath.replace(/^.*[\\\/]/, '');
        };
        /**
         * This method indicates whether window.clipboardData is supported.
         * For example, clipboard support for Windows Store apps is currently disabled
         * since window.clipboardData is unsupported (it raises access denied error)
         * since clipboard in Windows Store is being
         * achieved through Windows.ApplicationModel.DataTransfer.Clipboard class.
         */
        Utility.canUseClipboard = function () {
            return (typeof MSApp === "undefined");
        };
        Utility.is64BitOperatingSystem = function () {
            return navigator.userAgent.indexOf("WOW64") !== -1 ||
                navigator.userAgent.indexOf("Win64") !== -1;
        };
        Utility.parseNumber = function (value, defaultValue) {
            if (value === null)
                return null;
            if (value === undefined)
                return defaultValue;
            var result = Number(value);
            if (isFinite(result))
                return result;
            if (isNaN(result) && !(typeof value === "number" || value === "NaN"))
                return defaultValue;
            return result;
        };
        Utility.getURLParamValue = function (name) {
            var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
            if (results == null) {
                return null;
            }
            else {
                return results[1] || 0;
            }
        };
        /**
         * Return local timezone.
         * This function uses summer and winter offset to determine local time zone.
         * The result localTimeZoneString must be a subset of the strings used by server,
         * as documented here: https://msdn.microsoft.com/en-us/library/gg154758.aspx (Dynamic Daylight Savings Time (Compact 2013)).
         * @return Local timezone string or UTC if timezone cannot be found.
         */
        Utility.getLocalTimeZoneString = function () {
            var timeSummer = new Date(Date.UTC(2005, 6, 30, 0, 0, 0, 0));
            var summerOffset = -1 * timeSummer.getTimezoneOffset();
            var timeWinter = new Date(Date.UTC(2005, 12, 30, 0, 0, 0, 0));
            var winterOffset = -1 * timeWinter.getTimezoneOffset();
            var localTimeZoneString;
            if (-720 === summerOffset && -720 === winterOffset) {
                localTimeZoneString = 'Dateline Standard Time';
            }
            else if (-660 === summerOffset && -660 === winterOffset) {
                localTimeZoneString = 'UTC-11';
            }
            else if (-660 === summerOffset && -660 === winterOffset) {
                localTimeZoneString = 'Samoa Standard Time';
            }
            else if (-600 === summerOffset && -600 === winterOffset) {
                localTimeZoneString = 'Hawaiian Standard Time';
            }
            else if (-480 === summerOffset && -540 === winterOffset) {
                localTimeZoneString = 'Alaskan Standard Time';
            }
            else if (-420 === summerOffset && -480 === winterOffset) {
                localTimeZoneString = 'Pacific Standard Time';
            }
            else if (-420 === summerOffset && -420 === winterOffset) {
                localTimeZoneString = 'US Mountain Standard Time';
            }
            else if (-360 === summerOffset && -420 === winterOffset) {
                localTimeZoneString = 'Mountain Standard Time';
            }
            else if (-360 === summerOffset && -360 === winterOffset) {
                localTimeZoneString = 'Central America Standard Time';
            }
            else if (-300 === summerOffset && -360 === winterOffset) {
                localTimeZoneString = 'Central Standard Time';
            }
            else if (-300 === summerOffset && -300 === winterOffset) {
                localTimeZoneString = 'SA Pacific Standard Time';
            }
            else if (-240 === summerOffset && -300 === winterOffset) {
                localTimeZoneString = 'Eastern Standard Time';
            }
            else if (-270 === summerOffset && -270 === winterOffset) {
                localTimeZoneString = 'Venezuela Standard Time';
            }
            else if (-240 === summerOffset && -240 === winterOffset) {
                localTimeZoneString = 'SA Western Standard Time';
            }
            else if (-240 === summerOffset && -180 === winterOffset) {
                localTimeZoneString = 'Central Brazilian Standard Time';
            }
            else if (-180 === summerOffset && -240 === winterOffset) {
                localTimeZoneString = 'Atlantic Standard Time';
            }
            else if (-180 === summerOffset && -180 === winterOffset) {
                localTimeZoneString = 'Montevideo Standard Time';
            }
            else if (-180 === summerOffset && -120 === winterOffset) {
                localTimeZoneString = 'E. South America Standard Time';
            }
            else if (-150 === summerOffset && -210 === winterOffset) {
                localTimeZoneString = 'Mid-Atlantic Standard Time';
            }
            else if (-120 === summerOffset && -120 === winterOffset) {
                localTimeZoneString = 'SA Eastern Standard Time';
            }
            else if (0 === summerOffset && 0 === winterOffset) {
                localTimeZoneString = 'UTC';
            }
            else if (60 === summerOffset && 0 === winterOffset) {
                localTimeZoneString = 'GMT Standard Time';
            }
            else if (60 === summerOffset && 120 === winterOffset) {
                localTimeZoneString = 'Namibia Standard Time';
            }
            else if (120 === summerOffset && 60 === winterOffset) {
                localTimeZoneString = 'Romance Standard Time';
            }
            else if (120 === summerOffset && 120 === winterOffset) {
                localTimeZoneString = 'South Africa Standard Time';
            }
            else if (180 === summerOffset && 120 === winterOffset) {
                localTimeZoneString = 'GTB Standard Time';
            }
            else if (180 === summerOffset && 180 === winterOffset) {
                localTimeZoneString = 'E. Africa Standard Time';
            }
            else if (240 === summerOffset && 180 === winterOffset) {
                localTimeZoneString = 'Russian Standard Time';
            }
            else if (240 === summerOffset && 240 === winterOffset) {
                localTimeZoneString = 'Arabian Standard Time';
            }
            else if (270 === summerOffset && 210 === winterOffset) {
                localTimeZoneString = 'Iran Standard Time';
            }
            else if (270 === summerOffset && 270 === winterOffset) {
                localTimeZoneString = 'Afghanistan Standard Time';
            }
            else if (300 === summerOffset && 240 === winterOffset) {
                localTimeZoneString = 'Pakistan Standard Time';
            }
            else if (300 === summerOffset && 300 === winterOffset) {
                localTimeZoneString = 'West Asia Standard Time';
            }
            else if (330 === summerOffset && 330 === winterOffset) {
                localTimeZoneString = 'India Standard Time';
            }
            else if (345 === summerOffset && 345 === winterOffset) {
                localTimeZoneString = 'Nepal Standard Time';
            }
            else if (360 === summerOffset && 300 === winterOffset) {
                localTimeZoneString = 'N. Central Asia Standard Time';
            }
            else if (360 === summerOffset && 360 === winterOffset) {
                localTimeZoneString = 'Central Asia Standard Time';
            }
            else if (390 === summerOffset && 390 === winterOffset) {
                localTimeZoneString = 'Myanmar Standard Time';
            }
            else if (420 === summerOffset && 360 === winterOffset) {
                localTimeZoneString = 'North Asia Standard Time';
            }
            else if (420 === summerOffset && 420 === winterOffset) {
                localTimeZoneString = 'SE Asia Standard Time';
            }
            else if (480 === summerOffset && 420 === winterOffset) {
                localTimeZoneString = 'North Asia East Standard Time';
            }
            else if (480 === summerOffset && 480 === winterOffset) {
                localTimeZoneString = 'China Standard Time';
            }
            else if (540 === summerOffset && 480 === winterOffset) {
                localTimeZoneString = 'Yakutsk Standard Time';
            }
            else if (540 === summerOffset && 540 === winterOffset) {
                localTimeZoneString = 'Tokyo Standard Time';
            }
            else if (570 === summerOffset && 570 === winterOffset) {
                localTimeZoneString = 'Cen. Australia Standard Time';
            }
            else if (600 === summerOffset && 600 === winterOffset) {
                localTimeZoneString = 'E. Australia Standard Time';
            }
            else if (600 === summerOffset && 660 === winterOffset) {
                localTimeZoneString = 'AUS Eastern Standard Time';
            }
            else if (660 === summerOffset && 600 === winterOffset) {
                localTimeZoneString = 'Tasmania Standard Time';
            }
            else if (660 === summerOffset && 660 === winterOffset) {
                localTimeZoneString = 'West Pacific Standard Time';
            }
            else if (690 === summerOffset && 690 === winterOffset) {
                localTimeZoneString = 'Central Pacific Standard Time';
            }
            else if (720 === summerOffset && 660 === winterOffset) {
                localTimeZoneString = 'Magadan Standard Time';
            }
            else if (720 === summerOffset && 720 === winterOffset) {
                localTimeZoneString = 'Fiji Standard Time';
            }
            else if (720 === summerOffset && 780 === winterOffset) {
                localTimeZoneString = 'New Zealand Standard Time';
            }
            else if (780 === summerOffset && 780 === winterOffset) {
                localTimeZoneString = 'Tonga Standard Time';
            }
            else {
                localTimeZoneString = 'UTC';
            }
            return localTimeZoneString;
        };
        Utility.TypeNamespace = 'http://schemas.microsoft.com/sqlbi/2013/01/NLRuntimeService';
        Utility.JsonContentType = 'application/json';
        Utility.JpegContentType = 'image/jpeg';
        Utility.XJavascriptContentType = 'application/x-javascript';
        Utility.JsonDataType = 'json';
        Utility.BlobDataType = 'blob';
        Utility.HttpGetMethod = 'GET';
        Utility.HttpPostMethod = 'POST';
        Utility.HttpPutMethod = 'PUT';
        Utility.HttpDeleteMethod = 'DELETE';
        Utility.HttpContentTypeHeader = 'Content-Type';
        Utility.HttpAcceptHeader = 'Accept';
        Utility.Undefined = 'undefined';
        Utility.staticContentLocation = window.location.protocol + '//' + window.location.host;
        return Utility;
    }());
    jsCommon.Utility = Utility;
    var VersionUtility = (function () {
        function VersionUtility() {
        }
        /**
         * Compares 2 version strings.
         * @param versionA The first version string.
         * @param versionB The second version string.
         * @returns A result for the comparison.
         */
        VersionUtility.compareVersions = function (versionA, versionB) {
            var a = versionA.split('.').map(parseFloat);
            var b = versionB.split('.').map(parseFloat);
            var versionParts = Math.max(a.length, b.length);
            for (var i = 0; i < versionParts; i++) {
                var partA = a[i] || 0;
                var partB = b[i] || 0;
                if (partA > partB)
                    return 1;
                if (partA < partB)
                    return -1;
            }
            return 0;
        };
        return VersionUtility;
    }());
    jsCommon.VersionUtility = VersionUtility;
    var PerformanceUtil;
    (function (PerformanceUtil) {
        var PerfMarker = (function () {
            function PerfMarker(name) {
                this._name = name;
                this._start = PerfMarker.begin(name);
            }
            PerfMarker.begin = function (name) {
                if (window.performance === undefined || performance.mark === undefined)
                    return;
                if (console.time) {
                    console.time(name);
                }
                name = 'Begin ' + name;
                performance.mark(name);
                return name;
            };
            PerfMarker.prototype.end = function () {
                if (window.performance === undefined || performance.mark === undefined || performance.measure === undefined)
                    return;
                var name = this._name;
                var end = 'End ' + name;
                performance.mark(end);
                performance.measure(name, this._start, end);
                if (console.timeEnd) {
                    console.timeEnd(name);
                }
            };
            return PerfMarker;
        }());
        PerformanceUtil.PerfMarker = PerfMarker;
        function create(name) {
            return new PerfMarker(name);
        }
        PerformanceUtil.create = create;
    })(PerformanceUtil = jsCommon.PerformanceUtil || (jsCommon.PerformanceUtil = {}));
    var DeferUtility;
    (function (DeferUtility) {
        /**
         * Wraps a callback and returns a new function.
         * The function can be called many times but the callback
         * will only be executed once on the next frame.
         * Use this to throttle big UI updates and access to DOM.
         */
        function deferUntilNextFrame(callback) {
            var isWaiting, args, context;
            if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = function (func) { return setTimeout(func, 1000 / 50); };
            }
            return function () {
                if (!isWaiting) {
                    isWaiting = true;
                    args = arguments;
                    context = this;
                    window.requestAnimationFrame(function () {
                        isWaiting = false;
                        callback.apply(context, args);
                    });
                }
            };
        }
        DeferUtility.deferUntilNextFrame = deferUntilNextFrame;
    })(DeferUtility = jsCommon.DeferUtility || (jsCommon.DeferUtility = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var TraceItem = (function () {
        function TraceItem(text, type, sessionId, requestId) {
            this.text = text;
            this.type = type;
            this.sessionId = sessionId;
            this.requestId = requestId;
            this.timeStamp = new Date();
        }
        TraceItem.prototype.toString = function () {
            var resultString = '';
            resultString += (jsCommon.StringExtensions.format('{0} ({1}): {2}', TraceItem.traceTypeStrings[this.type], this.timeStamp.toUTCString(), this.text));
            if (this.requestId)
                resultString += ('\n(Request id: ' + this.requestId + ')');
            return resultString;
        };
        TraceItem.traceTypeStrings = [
            'INFORMATION',
            'VERBOSE',
            'WARNING',
            'ERROR',
            'EXPECTEDERROR',
            'UNEXPECTEDERROR',
            'FATAL',
        ];
        return TraceItem;
    }());
    jsCommon.TraceItem = TraceItem;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var UrlUtils;
    (function (UrlUtils) {
        var urlRegex = /http[s]?:\/\/(\S)+/gi;
        function isValidUrl(value) {
            if (jsCommon.StringExtensions.isNullOrEmpty(value))
                return false;
            var match = jsCommon.RegExpExtensions.run(urlRegex, value);
            if (!!match && match.index === 0)
                return true;
            return false;
        }
        UrlUtils.isValidUrl = isValidUrl;
        /* Tests whether a URL is valid.
         * @param url The url to be tested.
         * @returns Whether the provided url is valid.
         **/
        function isValidImageUrl(url) {
            // VSTS: 7252099 / 7112236
            // For now, passes for any valid Url
            return isValidUrl(url);
        }
        UrlUtils.isValidImageUrl = isValidImageUrl;
        function findAllValidUrls(text) {
            if (jsCommon.StringExtensions.isNullOrEmpty(text))
                return [];
            // Find all urls in the text.
            // TODO: This could potentially be expensive, maybe include a cap here for text with many urls?
            var urlRanges = [];
            var matches;
            var start = 0;
            while ((matches = jsCommon.RegExpExtensions.run(urlRegex, text, start)) !== null) {
                var url = matches[0];
                var end = matches.index + url.length;
                urlRanges.push({
                    start: matches.index,
                    end: end,
                    text: url,
                });
                start = end;
            }
            return urlRanges;
        }
        UrlUtils.findAllValidUrls = findAllValidUrls;
        function getBase64ContentFromDataUri(uri) {
            if (uri.indexOf('data:') !== 0)
                throw new Error("Expected data uri");
            // Locate the base 64 content from the URL (e.g. "data:image/png;base64,xxxxx=")
            var base64Token = ";base64,";
            var indexBase64TokenStart = uri.indexOf(base64Token);
            if (indexBase64TokenStart < 0)
                throw new Error("Expected base 64 content in data url");
            var indexBase64Start = indexBase64TokenStart + base64Token.length;
            return uri.substr(indexBase64Start, uri.length - indexBase64Start);
        }
        UrlUtils.getBase64ContentFromDataUri = getBase64ContentFromDataUri;
    })(UrlUtils = jsCommon.UrlUtils || (jsCommon.UrlUtils = {}));
})(jsCommon || (jsCommon = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var jsCommon;
(function (jsCommon) {
    var BrowserUtils;
    (function (BrowserUtils) {
        function isChrome() {
            var vendorName = window.navigator.vendor || "";
            var userAgent = window.navigator.userAgent.toLowerCase();
            return vendorName.toLowerCase().indexOf('google') > -1 &&
                userAgent.indexOf('chrome') > -1 &&
                userAgent.indexOf('edge') === -1 &&
                userAgent.indexOf('opr') === -1;
        }
        BrowserUtils.isChrome = isChrome;
        function isInternetExplorerOrEdge() {
            var userAgent = window.navigator.userAgent.toLowerCase();
            return userAgent.indexOf('msie') > -1
                || userAgent.indexOf('trident') > -1
                || userAgent.indexOf('edge') > -1;
        }
        BrowserUtils.isInternetExplorerOrEdge = isInternetExplorerOrEdge;
        /**
         * Get the current version of IE
         * @returns The version of Internet Explorer or a 0 (indicating the use of another browser).
         */
        function getInternetExplorerVersion() {
            var retValue = 0;
            if (navigator.appName === 'Microsoft Internet Explorer' || window.navigator.userAgent.indexOf('MSIE') >= 0) {
                var re = new RegExp('MSIE ([0-9]{1,}[\\.0-9]{0,})');
                var result = re.exec(window.navigator.userAgent);
                if (result) {
                    retValue = parseFloat(result[1]);
                }
            }
            return retValue;
        }
        BrowserUtils.getInternetExplorerVersion = getInternetExplorerVersion;
    })(BrowserUtils = jsCommon.BrowserUtils || (jsCommon.BrowserUtils = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * Extensions for Enumerations.
     */
    var EnumExtensions;
    (function (EnumExtensions) {
        /**
         * Gets a value indicating whether the value has the bit flags set.
         */
        function hasFlag(value, flag) {
            debug.assert(!!flag, 'flag must be specified and nonzero.');
            return (value & flag) === flag;
        }
        EnumExtensions.hasFlag = hasFlag;
        /**
         * Sets a value of a flag without modifying any other flags.
         */
        function setFlag(value, flag) {
            debug.assert(!!flag, "flag must be specified and nonzero.");
            return value |= flag;
        }
        EnumExtensions.setFlag = setFlag;
        /**
         * Resets a value of a flag without modifying any other flags.
         */
        function resetFlag(value, flag) {
            debug.assert(!!flag, "flag must be specified and nonzero.");
            return value &= ~flag;
        }
        EnumExtensions.resetFlag = resetFlag;
        /**
         * According to the TypeScript Handbook, this is safe to do.
         */
        function toString(enumType, value) {
            return enumType[value];
        }
        EnumExtensions.toString = toString;
    })(EnumExtensions = jsCommon.EnumExtensions || (jsCommon.EnumExtensions = {}));
    /**
     * Extensions to String class.
     */
    var StringExtensions;
    (function (StringExtensions) {
        /**
         * Checks if a string ends with a sub-string.
         */
        function endsWith(str, suffix) {
            debug.assertValue(str, 'str');
            debug.assertValue(suffix, 'suffix');
            return str.indexOf(suffix, str.length - suffix.length) !== -1;
        }
        StringExtensions.endsWith = endsWith;
    })(StringExtensions = jsCommon.StringExtensions || (jsCommon.StringExtensions = {}));
    var LogicExtensions;
    (function (LogicExtensions) {
        function XOR(a, b) {
            return (a || b) && !(a && b);
        }
        LogicExtensions.XOR = XOR;
    })(LogicExtensions = jsCommon.LogicExtensions || (jsCommon.LogicExtensions = {}));
    var JsonComparer;
    (function (JsonComparer) {
        /**
         * Performs JSON-style comparison of two objects.
         */
        function equals(x, y) {
            if (x === y)
                return true;
            return JSON.stringify(x) === JSON.stringify(y);
        }
        JsonComparer.equals = equals;
    })(JsonComparer = jsCommon.JsonComparer || (jsCommon.JsonComparer = {}));
    /**
     * Values are in terms of 'pt'
     * Convert to pixels using PixelConverter.fromPoint
     */
    var TextSizeDefaults;
    (function (TextSizeDefaults) {
        /**
         * Stored in terms of 'pt'
         * Convert to pixels using PixelConverter.fromPoint
         */
        TextSizeDefaults.TextSizeMin = 8;
        /**
         * Stored in terms of 'pt'
         * Convert to pixels using PixelConverter.fromPoint
         */
        TextSizeDefaults.TextSizeMax = 40;
        var TextSizeRange = TextSizeDefaults.TextSizeMax - TextSizeDefaults.TextSizeMin;
        /**
         * Returns the percentage of this value relative to the TextSizeMax
         * @param textSize - should be given in terms of 'pt'
         */
        function getScale(textSize) {
            return (textSize - TextSizeDefaults.TextSizeMin) / TextSizeRange;
        }
        TextSizeDefaults.getScale = getScale;
    })(TextSizeDefaults = jsCommon.TextSizeDefaults || (jsCommon.TextSizeDefaults = {}));
    var PixelConverter;
    (function (PixelConverter) {
        var PxPtRatio = 4 / 3;
        var PixelString = 'px';
        /**
         * Appends 'px' to the end of number value for use as pixel string in styles
         */
        function toString(px) {
            return px + PixelString;
        }
        PixelConverter.toString = toString;
        /**
         * Converts point value (pt) to pixels
         * Returns a string for font-size property
         * e.g. fromPoint(8) => '24px'
         */
        function fromPoint(pt) {
            return toString(fromPointToPixel(pt));
        }
        PixelConverter.fromPoint = fromPoint;
        /**
         * Converts point value (pt) to pixels
         * Returns a number for font-size property
         * e.g. fromPoint(8) => 24px
         */
        function fromPointToPixel(pt) {
            return (PxPtRatio * pt);
        }
        PixelConverter.fromPointToPixel = fromPointToPixel;
        /**
         * Converts pixel value (px) to pt
         * e.g. toPoint(24) => 8
         */
        function toPoint(px) {
            return px / PxPtRatio;
        }
        PixelConverter.toPoint = toPoint;
    })(PixelConverter = jsCommon.PixelConverter || (jsCommon.PixelConverter = {}));
    var RegExpExtensions;
    (function (RegExpExtensions) {
        /**
         * Runs exec on regex starting from 0 index
         * This is the expected behavior but RegExp actually remember
         * the last index they stopped at (found match at) and will
         * return unexpected results when run in sequence.
         * @param regex - regular expression object
         * @param value - string to search wiht regex
         * @param start - index within value to start regex
         */
        function run(regex, value, start) {
            debug.assertValue(regex, 'regex');
            regex.lastIndex = start || 0;
            return regex.exec(value);
        }
        RegExpExtensions.run = run;
    })(RegExpExtensions = jsCommon.RegExpExtensions || (jsCommon.RegExpExtensions = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    var ConsoleTracer = (function () {
        function ConsoleTracer() {
        }
        ConsoleTracer.prototype.logTrace = function (trace) {
            if (DEBUG) {
                switch (trace.type) {
                    case jsCommon.TraceType.Information:
                        console.info(trace.toString());
                        break;
                    case jsCommon.TraceType.UnexpectedError:
                    case jsCommon.TraceType.Error:
                    case jsCommon.TraceType.Fatal:
                        console.error(trace.toString());
                        break;
                    case jsCommon.TraceType.ExpectedError:
                    case jsCommon.TraceType.Warning:
                        console.warn(trace.toString());
                        break;
                    case jsCommon.TraceType.Verbose:
                        console.log(trace.toString());
                        break;
                    default:
                        console.log(trace.toString());
                        break;
                }
            }
        };
        return ConsoleTracer;
    }());
    jsCommon.ConsoleTracer = ConsoleTracer;
    var Trace;
    (function (Trace) {
        var traceMaxCount = 1000;
        var traces = new Array(traceMaxCount);
        var lastTraceIndex = -1;
        var defaultListener = new ConsoleTracer();
        var listeners = new Array(defaultListener);
        /**
         * Trace a warning. Please ensure that no PII is being logged.
         */
        function warning(text, requestId) {
            debug.assertValue(text, 'text');
            logTraceInternal(new jsCommon.TraceItem(text, jsCommon.TraceType.Warning, requestId));
        }
        Trace.warning = warning;
        /**
         * Trace an error. Please ensure that no PII is being logged.
         */
        function error(text, includeStackTrace, requestId) {
            debug.assertValue(text, 'text');
            if (includeStackTrace)
                text = jsCommon.StringExtensions.format("{0}.\nStack:\n{1}", text, jsCommon.getStackTrace());
            logTraceInternal(new jsCommon.TraceItem(text, jsCommon.TraceType.Error, requestId));
        }
        Trace.error = error;
        /**
         * Trace an information. Please ensure that no PII is being logged.
         */
        function verbose(text, requestId) {
            debug.assertValue(text, 'text');
            logTraceInternal(new jsCommon.TraceItem(text, jsCommon.TraceType.Verbose, requestId));
        }
        Trace.verbose = verbose;
        function addListener(listener) {
            debug.assertValue(listener, 'listener');
            listeners.push(listener);
        }
        Trace.addListener = addListener;
        function removeListener(listener) {
            debug.assertValue(listener, 'listener');
            var index = listeners.indexOf(listener);
            if (index >= 0)
                listeners.splice(index, 1);
        }
        Trace.removeListener = removeListener;
        function resetListeners() {
            listeners = new Array(defaultListener);
        }
        Trace.resetListeners = resetListeners;
        function reset() {
            lastTraceIndex = -1;
        }
        Trace.reset = reset;
        function getTraces() {
            if (lastTraceIndex < 0)
                return;
            var result = new Array(lastTraceIndex + 1);
            for (var i = 0; i <= lastTraceIndex; i++)
                result[i] = traces[i];
            return result;
        }
        Trace.getTraces = getTraces;
        /**
         * Note: Used for unit-test only.
         */
        function disableDefaultListener() {
            removeListener(defaultListener);
        }
        Trace.disableDefaultListener = disableDefaultListener;
        function enableDefaultListener() {
            addListener(defaultListener);
        }
        Trace.enableDefaultListener = enableDefaultListener;
        function logTraceInternal(trace) {
            if ((lastTraceIndex + 1) >= traceMaxCount)
                reset();
            traces[++lastTraceIndex] = trace;
            for (var i = 0, len = listeners.length; i < len; i++)
                listeners[i].logTrace(trace);
        }
    })(Trace = jsCommon.Trace || (jsCommon.Trace = {}));
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * The types of possible traces within the system, this aligns to the traces available in Cloud Platform.
     */
    (function (TraceType) {
        TraceType[TraceType["Information"] = 0] = "Information";
        TraceType[TraceType["Verbose"] = 1] = "Verbose";
        TraceType[TraceType["Warning"] = 2] = "Warning";
        TraceType[TraceType["Error"] = 3] = "Error";
        TraceType[TraceType["ExpectedError"] = 4] = "ExpectedError";
        TraceType[TraceType["UnexpectedError"] = 5] = "UnexpectedError";
        TraceType[TraceType["Fatal"] = 6] = "Fatal";
    })(jsCommon.TraceType || (jsCommon.TraceType = {}));
    var TraceType = jsCommon.TraceType;
})(jsCommon || (jsCommon = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var jsCommon;
(function (jsCommon) {
    /**
     * JavaScript files.
     */
    var MSMapcontrol = 'https://ecn.dev.virtualearth.net/mapcontrol/mapcontrol.ashx?v=7.0&s=1&onscriptload=globalMapControlLoaded';
    /**
     * Map loading logic.
     */
    var MSMapcontrolLoaded = false;
    var WaitForMSMapLoad = null;
    var PowerViewPackage = {
        javaScriptFiles: [
            powerbi.build + '/externals/pv/webclient.js'
        ],
        cssFiles: [
            powerbi.build + '/externals/pv/Styles/_all.css'
        ],
        javaScriptFilesWithCallback: [
            { javascriptFile: MSMapcontrol, onLoadCallback: waitForMapControlLoaded }
        ]
    };
    function ensurePowerView(action) {
        if (action === void 0) { action = _.noop; }
        jsCommon.requires(PowerViewPackage, action);
    }
    jsCommon.ensurePowerView = ensurePowerView;
    var MapPackage = {
        javaScriptFilesWithCallback: [
            { javascriptFile: MSMapcontrol, onLoadCallback: waitForMapControlLoaded }
        ]
    };
    function ensureMap(locale, action) {
        var mapPackageWithLocale = powerbi.Prototype.inherit(MapPackage);
        if (!_.isEmpty(locale)) {
            mapPackageWithLocale.javaScriptFilesWithCallback[0].javascriptFile = MSMapcontrol.concat('&mkt=' + locale);
        }
        jsCommon.requires(mapPackageWithLocale, action);
    }
    jsCommon.ensureMap = ensureMap;
    function mapControlLoaded() {
        MSMapcontrolLoaded = true;
        if (WaitForMSMapLoad) {
            WaitForMSMapLoad.resolve();
            WaitForMSMapLoad = undefined;
        }
    }
    jsCommon.mapControlLoaded = mapControlLoaded;
    function waitForMapControlLoaded() {
        var task;
        if (!MSMapcontrolLoaded) {
            task = WaitForMSMapLoad = $.Deferred();
        }
        else {
            task = $.Deferred();
            task.resolve();
        }
        return task.promise();
    }
    jsCommon.waitForMapControlLoaded = waitForMapControlLoaded;
})(jsCommon || (jsCommon = {}));
/* tslint:disable:no-unused-variable */
var globalMapControlLoaded = function () {
    // Map requires a function in the global namespace to callback once loaded
    jsCommon.mapControlLoaded();
};
/* tslint:enable:no-unused-variable */ 
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var InJs;
(function (InJs) {
    /**
     * The types of possible traces within the system, this aligns to the traces available in Cloud Platform.
     */
    (function (TraceType) {
        TraceType[TraceType["information"] = 0] = "information";
        TraceType[TraceType["verbose"] = 1] = "verbose";
        TraceType[TraceType["warning"] = 2] = "warning";
        TraceType[TraceType["error"] = 3] = "error";
        TraceType[TraceType["expectedError"] = 4] = "expectedError";
        TraceType[TraceType["unexpectedError"] = 5] = "unexpectedError";
        TraceType[TraceType["fatal"] = 6] = "fatal";
    })(InJs.TraceType || (InJs.TraceType = {}));
    var TraceType = InJs.TraceType;
})(InJs || (InJs = {}));


;var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../Typedefs/jquery/jquery.d.ts"/>
///<reference path="../../Typedefs/globalize/globalize.d.ts"/>
///<reference path="../../Typedefs/lodash/lodash.d.ts"/>
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Default IQueryExprVisitorWithArg implementation that others may derive from. */
        var DefaultSQExprVisitorWithArg = (function () {
            function DefaultSQExprVisitorWithArg() {
            }
            DefaultSQExprVisitorWithArg.prototype.visitEntity = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitColumnRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitMeasureRef = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitAggr = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitHierarchy = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitHierarchyLevel = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitPropertyVariationSource = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitBetween = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitIn = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitAnd = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitOr = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitCompare = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitContains = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitExists = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitNot = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitStartsWith = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitConstant = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDateSpan = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDateAdd = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitNow = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDefaultValue = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitAnyValue = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitArithmetic = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitFillRule = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitResourcePackageItem = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitScopedEval = function (expr, arg) {
                return this.visitDefault(expr, arg);
            };
            DefaultSQExprVisitorWithArg.prototype.visitDefault = function (expr, arg) {
                return;
            };
            return DefaultSQExprVisitorWithArg;
        }());
        data.DefaultSQExprVisitorWithArg = DefaultSQExprVisitorWithArg;
        /** Default ISQExprVisitor implementation that others may derive from. */
        var DefaultSQExprVisitor = (function (_super) {
            __extends(DefaultSQExprVisitor, _super);
            function DefaultSQExprVisitor() {
                _super.apply(this, arguments);
            }
            return DefaultSQExprVisitor;
        }(DefaultSQExprVisitorWithArg));
        data.DefaultSQExprVisitor = DefaultSQExprVisitor;
        /** Default ISQExprVisitor implementation that implements default traversal and that others may derive from. */
        var DefaultSQExprVisitorWithTraversal = (function () {
            function DefaultSQExprVisitorWithTraversal() {
            }
            DefaultSQExprVisitorWithTraversal.prototype.visitEntity = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitColumnRef = function (expr) {
                expr.source.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitMeasureRef = function (expr) {
                expr.source.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitAggr = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchy = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitHierarchyLevel = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitPropertyVariationSource = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitBetween = function (expr) {
                expr.arg.accept(this);
                expr.lower.accept(this);
                expr.upper.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitIn = function (expr) {
                var args = expr.args;
                for (var i = 0, len = args.length; i < len; i++)
                    args[i].accept(this);
                var values = expr.values;
                for (var i = 0, len = values.length; i < len; i++) {
                    var valueTuple = values[i];
                    for (var j = 0, jlen = valueTuple.length; j < jlen; j++)
                        valueTuple[j].accept(this);
                }
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitAnd = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitOr = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitCompare = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitContains = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitExists = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitNot = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitStartsWith = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitConstant = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDateSpan = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDateAdd = function (expr) {
                expr.arg.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitNow = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDefaultValue = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitAnyValue = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitArithmetic = function (expr) {
                expr.left.accept(this);
                expr.right.accept(this);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitFillRule = function (expr) {
                expr.input.accept(this);
                var rule = expr.rule, gradient2 = rule.linearGradient2, gradient3 = rule.linearGradient3;
                if (gradient2) {
                    this.visitLinearGradient2(gradient2);
                }
                if (gradient3) {
                    this.visitLinearGradient3(gradient3);
                }
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient2 = function (gradient2) {
                debug.assertValue(gradient2, 'gradient2');
                this.visitFillRuleStop(gradient2.min);
                this.visitFillRuleStop(gradient2.max);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitLinearGradient3 = function (gradient3) {
                debug.assertValue(gradient3, 'gradient3');
                this.visitFillRuleStop(gradient3.min);
                this.visitFillRuleStop(gradient3.mid);
                this.visitFillRuleStop(gradient3.max);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitResourcePackageItem = function (expr) {
                this.visitDefault(expr);
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitScopedEval = function (expr) {
                expr.expression.accept(this);
                for (var _i = 0, _a = expr.scope; _i < _a.length; _i++) {
                    var scopeExpr = _a[_i];
                    scopeExpr.accept(this);
                }
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitDefault = function (expr) {
                return;
            };
            DefaultSQExprVisitorWithTraversal.prototype.visitFillRuleStop = function (stop) {
                debug.assertValue(stop, 'stop');
                stop.color.accept(this);
                var value = stop.value;
                if (value)
                    value.accept(this);
            };
            return DefaultSQExprVisitorWithTraversal;
        }());
        data.DefaultSQExprVisitorWithTraversal = DefaultSQExprVisitorWithTraversal;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    function createEnumType(members) {
        return new EnumType(members);
    }
    powerbi.createEnumType = createEnumType;
    var EnumType = (function () {
        function EnumType(allMembers) {
            debug.assertValue(allMembers, 'allMembers');
            this.allMembers = allMembers;
        }
        EnumType.prototype.members = function (validMembers) {
            var allMembers = this.allMembers;
            if (!validMembers)
                return allMembers;
            var membersToReturn = [];
            for (var _i = 0, allMembers_1 = allMembers; _i < allMembers_1.length; _i++) {
                var member = allMembers_1[_i];
                if (_.contains(validMembers, member.value))
                    membersToReturn.push(member);
            }
            return membersToReturn;
        };
        return EnumType;
    }());
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var FillSolidColorTypeDescriptor;
    (function (FillSolidColorTypeDescriptor) {
        /** Gets a value indicating whether the descriptor is nullable or not. */
        function nullable(descriptor) {
            debug.assertValue(descriptor, 'descriptor');
            if (descriptor === true)
                return false;
            var advancedDescriptor = descriptor;
            return !!advancedDescriptor.nullable;
        }
        FillSolidColorTypeDescriptor.nullable = nullable;
    })(FillSolidColorTypeDescriptor = powerbi.FillSolidColorTypeDescriptor || (powerbi.FillSolidColorTypeDescriptor = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var ImageDefinition;
    (function (ImageDefinition) {
        ImageDefinition.urlType = { misc: { imageUrl: true } };
    })(ImageDefinition = powerbi.ImageDefinition || (powerbi.ImageDefinition = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var StructuralTypeDescriptor;
    (function (StructuralTypeDescriptor) {
        function isValid(type) {
            debug.assertValue(type, 'type');
            if (type.fill ||
                type.fillRule ||
                type.filter ||
                type.expression ||
                type.image ||
                type.paragraphs) {
                return true;
            }
            return false;
        }
        StructuralTypeDescriptor.isValid = isValid;
    })(StructuralTypeDescriptor = powerbi.StructuralTypeDescriptor || (powerbi.StructuralTypeDescriptor = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var EnumExtensions = jsCommon.EnumExtensions;
    /** Describes a data value type, including a primitive type and extended type if any (derived from data category). */
    var ValueType = (function () {
        /** Do not call the ValueType constructor directly. Use the ValueType.fromXXX methods. */
        function ValueType(type, category, enumType) {
            debug.assert((!!type && ExtendedType[type] != null) || type === ExtendedType.Null, 'type');
            debug.assert(!!category || category === null, 'category');
            debug.assert(type !== ExtendedType.Enumeration || !!enumType, 'enumType');
            this.underlyingType = type;
            this.category = category;
            if (EnumExtensions.hasFlag(type, ExtendedType.Temporal)) {
                this.temporalType = new TemporalType(type);
            }
            if (EnumExtensions.hasFlag(type, ExtendedType.Geography)) {
                this.geographyType = new GeographyType(type);
            }
            if (EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous)) {
                this.miscType = new MiscellaneousType(type);
            }
            if (EnumExtensions.hasFlag(type, ExtendedType.Formatting)) {
                this.formattingType = new FormattingType(type);
            }
            if (EnumExtensions.hasFlag(type, ExtendedType.Enumeration)) {
                this.enumType = enumType;
            }
            if (EnumExtensions.hasFlag(type, ExtendedType.Scripting)) {
                this.scriptingType = new ScriptType(type);
            }
        }
        /** Creates or retrieves a ValueType object based on the specified ValueTypeDescriptor. */
        ValueType.fromDescriptor = function (descriptor) {
            descriptor = descriptor || {};
            // Simplified primitive types
            if (descriptor.text)
                return ValueType.fromExtendedType(ExtendedType.Text);
            if (descriptor.integer)
                return ValueType.fromExtendedType(ExtendedType.Integer);
            if (descriptor.numeric)
                return ValueType.fromExtendedType(ExtendedType.Double);
            if (descriptor.bool)
                return ValueType.fromExtendedType(ExtendedType.Boolean);
            if (descriptor.dateTime)
                return ValueType.fromExtendedType(ExtendedType.DateTime);
            if (descriptor.duration)
                return ValueType.fromExtendedType(ExtendedType.Duration);
            if (descriptor.binary)
                return ValueType.fromExtendedType(ExtendedType.Binary);
            if (descriptor.none)
                return ValueType.fromExtendedType(ExtendedType.None);
            // Extended types
            if (descriptor.scripting) {
                if (descriptor.scripting.source)
                    return ValueType.fromExtendedType(ExtendedType.ScriptSource);
            }
            if (descriptor.enumeration)
                return ValueType.fromEnum(descriptor.enumeration);
            if (descriptor.temporal) {
                if (descriptor.temporal.year)
                    return ValueType.fromExtendedType(ExtendedType.Year_Integer);
                if (descriptor.temporal.month)
                    return ValueType.fromExtendedType(ExtendedType.Month_Integer);
            }
            if (descriptor.geography) {
                if (descriptor.geography.address)
                    return ValueType.fromExtendedType(ExtendedType.Address);
                if (descriptor.geography.city)
                    return ValueType.fromExtendedType(ExtendedType.City);
                if (descriptor.geography.continent)
                    return ValueType.fromExtendedType(ExtendedType.Continent);
                if (descriptor.geography.country)
                    return ValueType.fromExtendedType(ExtendedType.Country);
                if (descriptor.geography.county)
                    return ValueType.fromExtendedType(ExtendedType.County);
                if (descriptor.geography.region)
                    return ValueType.fromExtendedType(ExtendedType.Region);
                if (descriptor.geography.postalCode)
                    return ValueType.fromExtendedType(ExtendedType.PostalCode_Text);
                if (descriptor.geography.stateOrProvince)
                    return ValueType.fromExtendedType(ExtendedType.StateOrProvince);
                if (descriptor.geography.place)
                    return ValueType.fromExtendedType(ExtendedType.Place);
                if (descriptor.geography.latitude)
                    return ValueType.fromExtendedType(ExtendedType.Latitude_Double);
                if (descriptor.geography.longitude)
                    return ValueType.fromExtendedType(ExtendedType.Longitude_Double);
            }
            if (descriptor.misc) {
                if (descriptor.misc.image)
                    return ValueType.fromExtendedType(ExtendedType.Image);
                if (descriptor.misc.imageUrl)
                    return ValueType.fromExtendedType(ExtendedType.ImageUrl);
                if (descriptor.misc.webUrl)
                    return ValueType.fromExtendedType(ExtendedType.WebUrl);
            }
            if (descriptor.formatting) {
                if (descriptor.formatting.color)
                    return ValueType.fromExtendedType(ExtendedType.Color);
                if (descriptor.formatting.formatString)
                    return ValueType.fromExtendedType(ExtendedType.FormatString);
                if (descriptor.formatting.alignment)
                    return ValueType.fromExtendedType(ExtendedType.Alignment);
                if (descriptor.formatting.labelDisplayUnits)
                    return ValueType.fromExtendedType(ExtendedType.LabelDisplayUnits);
                if (descriptor.formatting.fontSize)
                    return ValueType.fromExtendedType(ExtendedType.FontSize);
                if (descriptor.formatting.labelDensity)
                    return ValueType.fromExtendedType(ExtendedType.LabelDensity);
            }
            if (descriptor.extendedType) {
                return ValueType.fromExtendedType(descriptor.extendedType);
            }
            return ValueType.fromExtendedType(ExtendedType.Null);
        };
        /** Advanced: Generally use fromDescriptor instead. Creates or retrieves a ValueType object for the specified ExtendedType. */
        ValueType.fromExtendedType = function (extendedType) {
            extendedType = extendedType || ExtendedType.Null;
            var primitiveType = getPrimitiveType(extendedType), category = getCategoryFromExtendedType(extendedType);
            debug.assert(primitiveType !== PrimitiveType.Null || extendedType === ExtendedType.Null, 'Cannot create ValueType for abstract extended type. Consider using fromDescriptor instead.');
            return ValueType.fromPrimitiveTypeAndCategory(primitiveType, category);
        };
        /** Creates or retrieves a ValueType object for the specified PrimitiveType and data category. */
        ValueType.fromPrimitiveTypeAndCategory = function (primitiveType, category) {
            primitiveType = primitiveType || PrimitiveType.Null;
            category = category || null;
            var id = primitiveType.toString();
            if (category)
                id += '|' + category;
            return ValueType.typeCache[id] || (ValueType.typeCache[id] = new ValueType(toExtendedType(primitiveType, category), category));
        };
        /** Creates a ValueType to describe the given IEnumType. */
        ValueType.fromEnum = function (enumType) {
            debug.assertValue(enumType, 'enumType');
            return new ValueType(ExtendedType.Enumeration, null, enumType);
        };
        /** Determines if the specified type is compatible from at least one of the otherTypes. */
        ValueType.isCompatibleTo = function (type, otherTypes) {
            debug.assertValue(type, 'type');
            debug.assertValue(otherTypes, 'otherTypes');
            var valueType = ValueType.fromDescriptor(type);
            for (var _i = 0, otherTypes_1 = otherTypes; _i < otherTypes_1.length; _i++) {
                var otherType = otherTypes_1[_i];
                var otherValueType = ValueType.fromDescriptor(otherType);
                if (otherValueType.isCompatibleFrom(valueType))
                    return true;
            }
            return false;
        };
        /** Determines if the instance ValueType is convertable from the 'other' ValueType. */
        ValueType.prototype.isCompatibleFrom = function (other) {
            debug.assertValue(other, 'other');
            var otherPrimitiveType = other.primitiveType;
            if (this === other ||
                this.primitiveType === otherPrimitiveType ||
                otherPrimitiveType === PrimitiveType.Null)
                return true;
            return false;
        };
        Object.defineProperty(ValueType.prototype, "primitiveType", {
            /** Gets the exact primitive type of this ValueType. */
            get: function () {
                return getPrimitiveType(this.underlyingType);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "extendedType", {
            /** Gets the exact extended type of this ValueType. */
            get: function () {
                return this.underlyingType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "categoryString", {
            /** Gets the data category string (if any) for this ValueType. */
            get: function () {
                return this.category;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "text", {
            // Simplified primitive types
            /** Indicates whether the type represents text values. */
            get: function () {
                return this.primitiveType === PrimitiveType.Text;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "numeric", {
            /** Indicates whether the type represents any numeric value. */
            get: function () {
                return EnumExtensions.hasFlag(this.underlyingType, ExtendedType.Numeric);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "integer", {
            /** Indicates whether the type represents integer numeric values. */
            get: function () {
                return this.primitiveType === PrimitiveType.Integer;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "bool", {
            /** Indicates whether the type represents Boolean values. */
            get: function () {
                return this.primitiveType === PrimitiveType.Boolean;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "dateTime", {
            /** Indicates whether the type represents any date/time values. */
            get: function () {
                return this.primitiveType === PrimitiveType.DateTime ||
                    this.primitiveType === PrimitiveType.Date ||
                    this.primitiveType === PrimitiveType.Time;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "duration", {
            /** Indicates whether the type represents duration values. */
            get: function () {
                return this.primitiveType === PrimitiveType.Duration;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "binary", {
            /** Indicates whether the type represents binary values. */
            get: function () {
                return this.primitiveType === PrimitiveType.Binary;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "none", {
            /** Indicates whether the type represents none values. */
            get: function () {
                return this.primitiveType === PrimitiveType.None;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "temporal", {
            // Extended types
            /** Returns an object describing temporal values represented by the type, if it represents a temporal type. */
            get: function () {
                return this.temporalType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "geography", {
            /** Returns an object describing geographic values represented by the type, if it represents a geographic type. */
            get: function () {
                return this.geographyType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "misc", {
            /** Returns an object describing the specific values represented by the type, if it represents a miscellaneous extended type. */
            get: function () {
                return this.miscType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "formatting", {
            /** Returns an object describing the formatting values represented by the type, if it represents a formatting type. */
            get: function () {
                return this.formattingType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "enum", {
            /** Returns an object describing the enum values represented by the type, if it represents an enumeration type. */
            get: function () {
                return this.enumType;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ValueType.prototype, "scripting", {
            get: function () {
                return this.scriptingType;
            },
            enumerable: true,
            configurable: true
        });
        ValueType.typeCache = {};
        return ValueType;
    }());
    powerbi.ValueType = ValueType;
    var ScriptType = (function () {
        function ScriptType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Scripting), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(ScriptType.prototype, "source", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ScriptSource);
            },
            enumerable: true,
            configurable: true
        });
        return ScriptType;
    }());
    powerbi.ScriptType = ScriptType;
    var TemporalType = (function () {
        function TemporalType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Temporal), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(TemporalType.prototype, "year", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Year);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(TemporalType.prototype, "month", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Month);
            },
            enumerable: true,
            configurable: true
        });
        return TemporalType;
    }());
    powerbi.TemporalType = TemporalType;
    var GeographyType = (function () {
        function GeographyType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Geography), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(GeographyType.prototype, "address", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Address);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "city", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.City);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "continent", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Continent);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "country", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Country);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "county", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.County);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "region", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Region);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "postalCode", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.PostalCode);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "stateOrProvince", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.StateOrProvince);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "place", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Place);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "latitude", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Latitude);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GeographyType.prototype, "longitude", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Longitude);
            },
            enumerable: true,
            configurable: true
        });
        return GeographyType;
    }());
    powerbi.GeographyType = GeographyType;
    var MiscellaneousType = (function () {
        function MiscellaneousType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Miscellaneous), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(MiscellaneousType.prototype, "image", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Image);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiscellaneousType.prototype, "imageUrl", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.ImageUrl);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MiscellaneousType.prototype, "webUrl", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.WebUrl);
            },
            enumerable: true,
            configurable: true
        });
        return MiscellaneousType;
    }());
    powerbi.MiscellaneousType = MiscellaneousType;
    var FormattingType = (function () {
        function FormattingType(type) {
            debug.assert(!!type && EnumExtensions.hasFlag(type, ExtendedType.Formatting), 'type');
            this.underlyingType = type;
        }
        Object.defineProperty(FormattingType.prototype, "color", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Color);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "formatString", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FormatString);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "alignment", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.Alignment);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "labelDisplayUnits", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDisplayUnits);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "fontSize", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.FontSize);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(FormattingType.prototype, "labelDensity", {
            get: function () {
                return matchesExtendedTypeWithAnyPrimitive(this.underlyingType, ExtendedType.LabelDensity);
            },
            enumerable: true,
            configurable: true
        });
        return FormattingType;
    }());
    powerbi.FormattingType = FormattingType;
    /** Defines primitive value types. Must be consistent with types defined by server conceptual schema. */
    (function (PrimitiveType) {
        PrimitiveType[PrimitiveType["Null"] = 0] = "Null";
        PrimitiveType[PrimitiveType["Text"] = 1] = "Text";
        PrimitiveType[PrimitiveType["Decimal"] = 2] = "Decimal";
        PrimitiveType[PrimitiveType["Double"] = 3] = "Double";
        PrimitiveType[PrimitiveType["Integer"] = 4] = "Integer";
        PrimitiveType[PrimitiveType["Boolean"] = 5] = "Boolean";
        PrimitiveType[PrimitiveType["Date"] = 6] = "Date";
        PrimitiveType[PrimitiveType["DateTime"] = 7] = "DateTime";
        PrimitiveType[PrimitiveType["DateTimeZone"] = 8] = "DateTimeZone";
        PrimitiveType[PrimitiveType["Time"] = 9] = "Time";
        PrimitiveType[PrimitiveType["Duration"] = 10] = "Duration";
        PrimitiveType[PrimitiveType["Binary"] = 11] = "Binary";
        PrimitiveType[PrimitiveType["None"] = 12] = "None";
    })(powerbi.PrimitiveType || (powerbi.PrimitiveType = {}));
    var PrimitiveType = powerbi.PrimitiveType;
    /** Defines extended value types, which include primitive types and known data categories constrained to expected primitive types. */
    (function (ExtendedType) {
        // Flags (1 << 8-15 range [0xFF00])
        // Important: Enum members must be declared before they are used in TypeScript.
        ExtendedType[ExtendedType["Numeric"] = 256] = "Numeric";
        ExtendedType[ExtendedType["Temporal"] = 512] = "Temporal";
        ExtendedType[ExtendedType["Geography"] = 1024] = "Geography";
        ExtendedType[ExtendedType["Miscellaneous"] = 2048] = "Miscellaneous";
        ExtendedType[ExtendedType["Formatting"] = 4096] = "Formatting";
        ExtendedType[ExtendedType["Scripting"] = 8192] = "Scripting";
        // Primitive types (0-255 range [0xFF] | flags)
        // The member names and base values must match those in PrimitiveType.
        ExtendedType[ExtendedType["Null"] = 0] = "Null";
        ExtendedType[ExtendedType["Text"] = 1] = "Text";
        ExtendedType[ExtendedType["Decimal"] = 258] = "Decimal";
        ExtendedType[ExtendedType["Double"] = 259] = "Double";
        ExtendedType[ExtendedType["Integer"] = 260] = "Integer";
        ExtendedType[ExtendedType["Boolean"] = 5] = "Boolean";
        ExtendedType[ExtendedType["Date"] = 518] = "Date";
        ExtendedType[ExtendedType["DateTime"] = 519] = "DateTime";
        ExtendedType[ExtendedType["DateTimeZone"] = 520] = "DateTimeZone";
        ExtendedType[ExtendedType["Time"] = 521] = "Time";
        ExtendedType[ExtendedType["Duration"] = 10] = "Duration";
        ExtendedType[ExtendedType["Binary"] = 11] = "Binary";
        ExtendedType[ExtendedType["None"] = 12] = "None";
        // Extended types (0-32767 << 16 range [0xFFFF0000] | corresponding primitive type | flags)
        // Temporal
        ExtendedType[ExtendedType["Year"] = 66048] = "Year";
        ExtendedType[ExtendedType["Year_Text"] = 66049] = "Year_Text";
        ExtendedType[ExtendedType["Year_Integer"] = 66308] = "Year_Integer";
        ExtendedType[ExtendedType["Year_Date"] = 66054] = "Year_Date";
        ExtendedType[ExtendedType["Year_DateTime"] = 66055] = "Year_DateTime";
        ExtendedType[ExtendedType["Month"] = 131584] = "Month";
        ExtendedType[ExtendedType["Month_Text"] = 131585] = "Month_Text";
        ExtendedType[ExtendedType["Month_Integer"] = 131844] = "Month_Integer";
        ExtendedType[ExtendedType["Month_Date"] = 131590] = "Month_Date";
        ExtendedType[ExtendedType["Month_DateTime"] = 131591] = "Month_DateTime";
        // Geography
        ExtendedType[ExtendedType["Address"] = 6554625] = "Address";
        ExtendedType[ExtendedType["City"] = 6620161] = "City";
        ExtendedType[ExtendedType["Continent"] = 6685697] = "Continent";
        ExtendedType[ExtendedType["Country"] = 6751233] = "Country";
        ExtendedType[ExtendedType["County"] = 6816769] = "County";
        ExtendedType[ExtendedType["Region"] = 6882305] = "Region";
        ExtendedType[ExtendedType["PostalCode"] = 6947840] = "PostalCode";
        ExtendedType[ExtendedType["PostalCode_Text"] = 6947841] = "PostalCode_Text";
        ExtendedType[ExtendedType["PostalCode_Integer"] = 6948100] = "PostalCode_Integer";
        ExtendedType[ExtendedType["StateOrProvince"] = 7013377] = "StateOrProvince";
        ExtendedType[ExtendedType["Place"] = 7078913] = "Place";
        ExtendedType[ExtendedType["Latitude"] = 7144448] = "Latitude";
        ExtendedType[ExtendedType["Latitude_Decimal"] = 7144706] = "Latitude_Decimal";
        ExtendedType[ExtendedType["Latitude_Double"] = 7144707] = "Latitude_Double";
        ExtendedType[ExtendedType["Longitude"] = 7209984] = "Longitude";
        ExtendedType[ExtendedType["Longitude_Decimal"] = 7210242] = "Longitude_Decimal";
        ExtendedType[ExtendedType["Longitude_Double"] = 7210243] = "Longitude_Double";
        // Miscellaneous
        ExtendedType[ExtendedType["Image"] = 13109259] = "Image";
        ExtendedType[ExtendedType["ImageUrl"] = 13174785] = "ImageUrl";
        ExtendedType[ExtendedType["WebUrl"] = 13240321] = "WebUrl";
        // Formatting
        ExtendedType[ExtendedType["Color"] = 19664897] = "Color";
        ExtendedType[ExtendedType["FormatString"] = 19730433] = "FormatString";
        ExtendedType[ExtendedType["Alignment"] = 20058113] = "Alignment";
        ExtendedType[ExtendedType["LabelDisplayUnits"] = 20123649] = "LabelDisplayUnits";
        ExtendedType[ExtendedType["FontSize"] = 20189443] = "FontSize";
        ExtendedType[ExtendedType["LabelDensity"] = 20254979] = "LabelDensity";
        // Enumeration
        ExtendedType[ExtendedType["Enumeration"] = 26214401] = "Enumeration";
        // Scripting
        ExtendedType[ExtendedType["ScriptSource"] = 32776193] = "ScriptSource";
    })(powerbi.ExtendedType || (powerbi.ExtendedType = {}));
    var ExtendedType = powerbi.ExtendedType;
    var PrimitiveTypeMask = 0xFF;
    var PrimitiveTypeWithFlagsMask = 0xFFFF;
    var PrimitiveTypeFlagsExcludedMask = 0xFFFF0000;
    function getPrimitiveType(extendedType) {
        return extendedType & PrimitiveTypeMask;
    }
    function isPrimitiveType(extendedType) {
        return (extendedType & PrimitiveTypeWithFlagsMask) === extendedType;
    }
    function getCategoryFromExtendedType(extendedType) {
        if (isPrimitiveType(extendedType))
            return null;
        var category = ExtendedType[extendedType];
        if (category) {
            // Check for ExtendedType declaration without a primitive type.
            // If exists, use it as category (e.g. Longitude rather than Longitude_Double)
            // Otherwise use the ExtendedType declaration with a primitive type (e.g. Address)
            var delimIdx = category.lastIndexOf('_');
            if (delimIdx > 0) {
                var baseCategory = category.slice(0, delimIdx);
                if (ExtendedType[baseCategory]) {
                    debug.assert((ExtendedType[baseCategory] & PrimitiveTypeFlagsExcludedMask) === (extendedType & PrimitiveTypeFlagsExcludedMask), 'Unexpected value for ExtendedType base member of ' + extendedType);
                    category = baseCategory;
                }
            }
        }
        return category || null;
    }
    function toExtendedType(primitiveType, category) {
        var primitiveString = PrimitiveType[primitiveType];
        var t = ExtendedType[primitiveString];
        if (t == null) {
            debug.assertFail('Unexpected primitiveType ' + primitiveType);
            t = ExtendedType.Null;
        }
        if (primitiveType && category) {
            var categoryType = ExtendedType[category];
            if (categoryType) {
                var categoryPrimitiveType = getPrimitiveType(categoryType);
                if (categoryPrimitiveType === PrimitiveType.Null) {
                    // Category supports multiple primitive types, check if requested primitive type is supported
                    // (note: important to use t here rather than primitiveType as it may include primitive type flags)
                    categoryType = t | categoryType;
                    if (ExtendedType[categoryType]) {
                        debug.assert(ExtendedType[categoryType] === (category + '_' + primitiveString), 'Unexpected name for ExtendedType member ' + categoryType);
                        t = categoryType;
                    }
                }
                else if (categoryPrimitiveType === primitiveType) {
                    // Primitive type matches the single supported type for the category
                    t = categoryType;
                }
            }
        }
        return t;
    }
    function matchesExtendedTypeWithAnyPrimitive(a, b) {
        return (a & PrimitiveTypeFlagsExcludedMask) === (b & PrimitiveTypeFlagsExcludedMask);
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        (function (DataShapeBindingLimitType) {
            DataShapeBindingLimitType[DataShapeBindingLimitType["Top"] = 0] = "Top";
            DataShapeBindingLimitType[DataShapeBindingLimitType["First"] = 1] = "First";
            DataShapeBindingLimitType[DataShapeBindingLimitType["Last"] = 2] = "Last";
            DataShapeBindingLimitType[DataShapeBindingLimitType["Sample"] = 3] = "Sample";
            DataShapeBindingLimitType[DataShapeBindingLimitType["Bottom"] = 4] = "Bottom";
        })(data.DataShapeBindingLimitType || (data.DataShapeBindingLimitType = {}));
        var DataShapeBindingLimitType = data.DataShapeBindingLimitType;
        (function (SubtotalType) {
            SubtotalType[SubtotalType["None"] = 0] = "None";
            SubtotalType[SubtotalType["Before"] = 1] = "Before";
            SubtotalType[SubtotalType["After"] = 2] = "After";
        })(data.SubtotalType || (data.SubtotalType = {}));
        var SubtotalType = data.SubtotalType;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataShapeBindingDataReduction;
        (function (DataShapeBindingDataReduction) {
            function createFrom(reduction) {
                if (!reduction)
                    return;
                var result;
                if (reduction.top) {
                    result = {
                        Top: {}
                    };
                    if (reduction.top.count)
                        result.Top.Count = reduction.top.count;
                }
                if (reduction.bottom) {
                    result = {
                        Bottom: {}
                    };
                    if (reduction.bottom.count)
                        result.Bottom.Count = reduction.bottom.count;
                }
                if (reduction.sample) {
                    result = {
                        Sample: {}
                    };
                    if (reduction.sample.count)
                        result.Sample.Count = reduction.sample.count;
                }
                if (reduction.window) {
                    result = {
                        Window: {}
                    };
                    if (reduction.window.count)
                        result.Window.Count = reduction.window.count;
                }
                return result;
            }
            DataShapeBindingDataReduction.createFrom = createFrom;
        })(DataShapeBindingDataReduction = data.DataShapeBindingDataReduction || (data.DataShapeBindingDataReduction = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Represents a federated conceptual schema. */
        var FederatedConceptualSchema = (function () {
            function FederatedConceptualSchema(options) {
                debug.assertValue(options, 'options');
                this.schemas = options.schemas;
                if (options.links)
                    this.links = options.links;
            }
            FederatedConceptualSchema.prototype.schema = function (name) {
                return this.schemas[name];
            };
            return FederatedConceptualSchema;
        }());
        data.FederatedConceptualSchema = FederatedConceptualSchema;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data_1) {
        var Selector;
        (function (Selector) {
            function filterFromSelector(selectors, isNot) {
                if (_.isEmpty(selectors))
                    return;
                var exprs = [];
                for (var i = 0, ilen = selectors.length; i < ilen; i++) {
                    var identity = selectors[i];
                    var data_2 = identity.data;
                    var exprToAdd = undefined;
                    if (data_2 && data_2.length) {
                        for (var j = 0, jlen = data_2.length; j < jlen; j++) {
                            exprToAdd = data_1.SQExprBuilder.and(exprToAdd, identity.data[j].expr);
                        }
                    }
                    if (exprToAdd)
                        exprs.push(exprToAdd);
                }
                if (!_.isEmpty(exprs))
                    return powerbi.DataViewScopeIdentity.filterFromExprs(exprs, isNot);
            }
            Selector.filterFromSelector = filterFromSelector;
            function matchesData(selector, identities) {
                debug.assertValue(selector, 'selector');
                debug.assertValue(selector.data, 'selector.data');
                debug.assertValue(identities, 'identities');
                var selectorData = selector.data;
                if (selectorData.length !== identities.length)
                    return false;
                for (var i = 0, len = selectorData.length; i < len; i++) {
                    var dataItem = selector.data[i];
                    var selectorDataItem = dataItem;
                    if (selectorDataItem.expr) {
                        if (!powerbi.DataViewScopeIdentity.equals(selectorDataItem, identities[i]))
                            return false;
                    }
                    else {
                        if (!data_1.DataViewScopeWildcard.matches(dataItem, identities[i]))
                            return false;
                    }
                }
                return true;
            }
            Selector.matchesData = matchesData;
            function matchesKeys(selector, keysList) {
                debug.assertValue(selector, 'selector');
                debug.assertValue(selector.data, 'selector.data');
                debug.assertValue(keysList, 'keysList');
                var selectorData = selector.data, selectorDataLength = selectorData.length;
                if (selectorDataLength !== keysList.length)
                    return false;
                for (var i = 0; i < selectorDataLength; i++) {
                    var selectorDataItem = selector.data[i], selectorDataExprs = void 0;
                    if (selectorDataItem.expr) {
                        selectorDataExprs = data_1.ScopeIdentityExtractor.getKeys(selectorDataItem.expr);
                    }
                    else if (selectorDataItem.exprs) {
                        selectorDataExprs = selectorDataItem.exprs;
                    }
                    else {
                        // In case DataViewRoleWildcard
                        return false;
                    }
                    if (!selectorDataExprs)
                        continue;
                    if (!data_1.SQExprUtils.sequenceEqual(keysList[i], selectorDataExprs))
                        return false;
                }
                return true;
            }
            Selector.matchesKeys = matchesKeys;
            /** Determines whether two selectors are equal. */
            function equals(x, y) {
                // Normalize falsy to null
                x = x || null;
                y = y || null;
                if (x === y)
                    return true;
                if (!x !== !y)
                    return false;
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                if (x.id !== y.id)
                    return false;
                if (x.metadata !== y.metadata)
                    return false;
                if (!equalsDataArray(x.data, y.data))
                    return false;
                return true;
            }
            Selector.equals = equals;
            function equalsDataArray(x, y) {
                // Normalize falsy to null
                x = x || null;
                y = y || null;
                if (x === y)
                    return true;
                if (!x !== !y)
                    return false;
                if (x.length !== y.length)
                    return false;
                for (var i = 0, len = x.length; i < len; i++) {
                    if (!equalsData(x[i], y[i]))
                        return false;
                }
                return true;
            }
            function equalsData(x, y) {
                if (!x.expr && y.expr) {
                    // TODO: We need to also check wildcard selectors too (once that's supported/figured out).
                    return false;
                }
                return powerbi.DataViewScopeIdentity.equals(x, y);
            }
            function getKey(selector) {
                var toStringify = {};
                if (selector.data) {
                    var data_3 = [];
                    for (var i = 0, ilen = selector.data.length; i < ilen; i++) {
                        data_3.push(selector.data[i].key);
                    }
                    toStringify.data = data_3;
                }
                if (selector.metadata)
                    toStringify.metadata = selector.metadata;
                if (selector.id)
                    toStringify.id = selector.id;
                return JSON.stringify(toStringify);
            }
            Selector.getKey = getKey;
            function containsWildcard(selector) {
                debug.assertValue(selector, 'selector');
                var dataItems = selector.data;
                if (!dataItems)
                    return false;
                for (var _i = 0, dataItems_1 = dataItems; _i < dataItems_1.length; _i++) {
                    var dataItem = dataItems_1[_i];
                    var wildCard = dataItem;
                    if (wildCard.exprs || wildCard.roles)
                        return true;
                }
                return false;
            }
            Selector.containsWildcard = containsWildcard;
            function hasRoleWildcard(selector) {
                debug.assertValue(selector, 'selector');
                var dataItems = selector.data;
                if (_.isEmpty(dataItems))
                    return false;
                for (var _i = 0, dataItems_2 = dataItems; _i < dataItems_2.length; _i++) {
                    var dataItem = dataItems_2[_i];
                    if (isRoleWildcard(dataItem))
                        return true;
                }
                return false;
            }
            Selector.hasRoleWildcard = hasRoleWildcard;
            function isRoleWildcard(dataItem) {
                return !_.isEmpty(dataItem.roles);
            }
            Selector.isRoleWildcard = isRoleWildcard;
        })(Selector = data_1.Selector || (data_1.Selector = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        (function (EntitySourceType) {
            EntitySourceType[EntitySourceType["Table"] = 0] = "Table";
            EntitySourceType[EntitySourceType["Pod"] = 1] = "Pod";
        })(data.EntitySourceType || (data.EntitySourceType = {}));
        var EntitySourceType = data.EntitySourceType;
        function getArithmeticOperatorName(arithmeticOperatorKind) {
            switch (arithmeticOperatorKind) {
                case 0 /* Add */:
                    return "Add";
                case 1 /* Subtract */:
                    return "Subtract";
                case 2 /* Multiply */:
                    return "Multiply";
                case 3 /* Divide */:
                    return "Divide";
            }
            throw new Error('Unexpected ArithmeticOperatorKind: ' + arithmeticOperatorKind);
        }
        data.getArithmeticOperatorName = getArithmeticOperatorName;
        (function (TimeUnit) {
            TimeUnit[TimeUnit["Day"] = 0] = "Day";
            TimeUnit[TimeUnit["Week"] = 1] = "Week";
            TimeUnit[TimeUnit["Month"] = 2] = "Month";
            TimeUnit[TimeUnit["Year"] = 3] = "Year";
            TimeUnit[TimeUnit["Decade"] = 4] = "Decade";
            TimeUnit[TimeUnit["Second"] = 5] = "Second";
            TimeUnit[TimeUnit["Minute"] = 6] = "Minute";
            TimeUnit[TimeUnit["Hour"] = 7] = "Hour";
        })(data.TimeUnit || (data.TimeUnit = {}));
        var TimeUnit = data.TimeUnit;
        (function (QueryAggregateFunction) {
            QueryAggregateFunction[QueryAggregateFunction["Sum"] = 0] = "Sum";
            QueryAggregateFunction[QueryAggregateFunction["Avg"] = 1] = "Avg";
            QueryAggregateFunction[QueryAggregateFunction["Count"] = 2] = "Count";
            QueryAggregateFunction[QueryAggregateFunction["Min"] = 3] = "Min";
            QueryAggregateFunction[QueryAggregateFunction["Max"] = 4] = "Max";
            QueryAggregateFunction[QueryAggregateFunction["CountNonNull"] = 5] = "CountNonNull";
            QueryAggregateFunction[QueryAggregateFunction["Median"] = 6] = "Median";
            QueryAggregateFunction[QueryAggregateFunction["StandardDeviation"] = 7] = "StandardDeviation";
            QueryAggregateFunction[QueryAggregateFunction["Variance"] = 8] = "Variance";
        })(data.QueryAggregateFunction || (data.QueryAggregateFunction = {}));
        var QueryAggregateFunction = data.QueryAggregateFunction;
        (function (QueryComparisonKind) {
            QueryComparisonKind[QueryComparisonKind["Equal"] = 0] = "Equal";
            QueryComparisonKind[QueryComparisonKind["GreaterThan"] = 1] = "GreaterThan";
            QueryComparisonKind[QueryComparisonKind["GreaterThanOrEqual"] = 2] = "GreaterThanOrEqual";
            QueryComparisonKind[QueryComparisonKind["LessThan"] = 3] = "LessThan";
            QueryComparisonKind[QueryComparisonKind["LessThanOrEqual"] = 4] = "LessThanOrEqual";
        })(data.QueryComparisonKind || (data.QueryComparisonKind = {}));
        var QueryComparisonKind = data.QueryComparisonKind;
        /** Defines semantic data types. */
        (function (SemanticType) {
            SemanticType[SemanticType["None"] = 0] = "None";
            SemanticType[SemanticType["Number"] = 1] = "Number";
            SemanticType[SemanticType["Integer"] = 3] = "Integer";
            SemanticType[SemanticType["DateTime"] = 4] = "DateTime";
            SemanticType[SemanticType["Time"] = 8] = "Time";
            SemanticType[SemanticType["Date"] = 20] = "Date";
            SemanticType[SemanticType["Month"] = 35] = "Month";
            SemanticType[SemanticType["Year"] = 67] = "Year";
            SemanticType[SemanticType["YearAndMonth"] = 128] = "YearAndMonth";
            SemanticType[SemanticType["MonthAndDay"] = 256] = "MonthAndDay";
            SemanticType[SemanticType["Decade"] = 515] = "Decade";
            SemanticType[SemanticType["YearAndWeek"] = 1024] = "YearAndWeek";
            SemanticType[SemanticType["String"] = 2048] = "String";
            SemanticType[SemanticType["Boolean"] = 4096] = "Boolean";
            SemanticType[SemanticType["Table"] = 8192] = "Table";
            SemanticType[SemanticType["Range"] = 16384] = "Range";
        })(data.SemanticType || (data.SemanticType = {}));
        var SemanticType = data.SemanticType;
        (function (FilterKind) {
            FilterKind[FilterKind["Default"] = 0] = "Default";
            FilterKind[FilterKind["Period"] = 1] = "Period";
        })(data.FilterKind || (data.FilterKind = {}));
        var FilterKind = data.FilterKind;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var QueryProjectionCollection = (function () {
            function QueryProjectionCollection(items, activeProjectionRefs, showAll) {
                debug.assertValue(items, 'items');
                this.items = items;
                this._activeProjectionRefs = activeProjectionRefs;
                this._showAll = showAll;
            }
            /** Returns all projections in a mutable array. */
            QueryProjectionCollection.prototype.all = function () {
                return this.items;
            };
            Object.defineProperty(QueryProjectionCollection.prototype, "activeProjectionRefs", {
                get: function () {
                    return this._activeProjectionRefs;
                },
                set: function (queryReferences) {
                    if (!_.isEmpty(queryReferences)) {
                        var queryRefs = this.items.map(function (val) { return val.queryRef; });
                        for (var _i = 0, queryReferences_1 = queryReferences; _i < queryReferences_1.length; _i++) {
                            var queryReference = queryReferences_1[_i];
                            if (!_.contains(queryRefs, queryReference))
                                return;
                        }
                        this._activeProjectionRefs = queryReferences;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(QueryProjectionCollection.prototype, "showAll", {
                get: function () {
                    return this._showAll;
                },
                set: function (value) {
                    this._showAll = value;
                },
                enumerable: true,
                configurable: true
            });
            QueryProjectionCollection.prototype.addActiveQueryReference = function (queryRef) {
                if (!this._activeProjectionRefs)
                    this._activeProjectionRefs = [queryRef];
                else
                    this._activeProjectionRefs.push(queryRef);
            };
            QueryProjectionCollection.prototype.getLastActiveQueryReference = function () {
                if (!_.isEmpty(this._activeProjectionRefs)) {
                    return this._activeProjectionRefs[this._activeProjectionRefs.length - 1];
                }
            };
            QueryProjectionCollection.prototype.clone = function () {
                return new QueryProjectionCollection(_.clone(this.items), _.clone(this._activeProjectionRefs), this._showAll);
            };
            return QueryProjectionCollection;
        }());
        data.QueryProjectionCollection = QueryProjectionCollection;
        var QueryProjectionsByRole;
        (function (QueryProjectionsByRole) {
            /** Clones the QueryProjectionsByRole. */
            function clone(roles) {
                if (!roles)
                    return roles;
                var clonedRoles = {};
                for (var roleName in roles)
                    clonedRoles[roleName] = roles[roleName].clone();
                return clonedRoles;
            }
            QueryProjectionsByRole.clone = clone;
            /** Returns the QueryProjectionCollection for that role.  Even returns empty collections so that 'drillable' and 'activeProjection' fields are preserved. */
            function getRole(roles, name) {
                debug.assertAnyValue(roles, 'roles');
                debug.assertValue(name, 'name');
                if (!roles)
                    return;
                return roles[name];
            }
            QueryProjectionsByRole.getRole = getRole;
        })(QueryProjectionsByRole = data.QueryProjectionsByRole || (data.QueryProjectionsByRole = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /** The system used to determine display units used during formatting */
    (function (DisplayUnitSystemType) {
        /** Default display unit system, which saves space by using units such as K, M, bn with PowerView rules for when to pick a unit. Suitable for chart axes. */
        DisplayUnitSystemType[DisplayUnitSystemType["Default"] = 0] = "Default";
        /** A verbose display unit system that will only respect the formatting defined in the model. Suitable for explore mode single-value cards. */
        DisplayUnitSystemType[DisplayUnitSystemType["Verbose"] = 1] = "Verbose";
        /**
         * A display unit system that uses units such as K, M, bn if we have at least one of those units (e.g. 0.9M is not valid as it's less than 1 million).
         * Suitable for dashboard tile cards
         */
        DisplayUnitSystemType[DisplayUnitSystemType["WholeUnits"] = 2] = "WholeUnits";
        /**A display unit system that also contains Auto and None units for data labels*/
        DisplayUnitSystemType[DisplayUnitSystemType["DataLabels"] = 3] = "DataLabels";
    })(powerbi.DisplayUnitSystemType || (powerbi.DisplayUnitSystemType = {}));
    var DisplayUnitSystemType = powerbi.DisplayUnitSystemType;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /** Repreasents the sequence of the dates/times */
    var DateTimeSequence = (function () {
        // Constructors
        /** Creates new instance of the DateTimeSequence */
        function DateTimeSequence(unit) {
            this.unit = unit;
            this.sequence = [];
            this.min = new Date("9999-12-31T23:59:59.999");
            this.max = new Date("0001-01-01T00:00:00.000");
        }
        // Methods
        /**
         * Add a new Date to a sequence.
         * @param date - date to add
         */
        DateTimeSequence.prototype.add = function (date) {
            if (date < this.min) {
                this.min = date;
            }
            if (date > this.max) {
                this.max = date;
            }
            this.sequence.push(date);
        };
        // Methods
        /**
         * Extends the sequence to cover new date range
         * @param min - new min to be covered by sequence
         * @param max - new max to be covered by sequence
         */
        DateTimeSequence.prototype.extendToCover = function (min, max) {
            var x = this.min;
            while (min < x) {
                x = DateTimeSequence.addInterval(x, -this.interval, this.unit);
                this.sequence.splice(0, 0, x);
            }
            this.min = x;
            x = this.max;
            while (x < max) {
                x = DateTimeSequence.addInterval(x, this.interval, this.unit);
                this.sequence.push(x);
            }
            this.max = x;
        };
        /**
         * Move the sequence to cover new date range
         * @param min - new min to be covered by sequence
         * @param max - new max to be covered by sequence
         */
        DateTimeSequence.prototype.moveToCover = function (min, max) {
            var delta = DateTimeSequence.getDelta(min, max, this.unit);
            var count = Math.floor(delta / this.interval);
            this.min = DateTimeSequence.addInterval(this.min, count * this.interval, this.unit);
            this.sequence = [];
            this.sequence.push(this.min);
            this.max = this.min;
            while (this.max < max) {
                this.max = DateTimeSequence.addInterval(this.max, this.interval, this.unit);
                this.sequence.push(this.max);
            }
        };
        // Static
        /**
         * Calculate a new DateTimeSequence
         * @param dataMin - Date representing min of the data range
         * @param dataMax - Date representing max of the data range
         * @param expectedCount - expected number of intervals in the sequence
         * @param unit - of the intervals in the sequence
         */
        DateTimeSequence.calculate = function (dataMin, dataMax, expectedCount, unit) {
            if (!unit) {
                unit = DateTimeSequence.getIntervalUnit(dataMin, dataMax, expectedCount);
            }
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    return DateTimeSequence.calculateYears(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Month:
                    return DateTimeSequence.calculateMonths(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Week:
                    return DateTimeSequence.calculateWeeks(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Day:
                    return DateTimeSequence.calculateDays(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Hour:
                    return DateTimeSequence.calculateHours(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Minute:
                    return DateTimeSequence.calculateMinutes(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Second:
                    return DateTimeSequence.calculateSeconds(dataMin, dataMax, expectedCount);
                case powerbi.DateTimeUnit.Millisecond:
                    return DateTimeSequence.calculateMilliseconds(dataMin, dataMax, expectedCount);
                default:
                    debug.assertFail("Unsupported DateTimeUnit");
            }
        };
        DateTimeSequence.calculateYears = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(!expectedCount || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "Expected count is out of range");
            // Calculate range and sequence
            var yearsRange = powerbi.NumericSequenceRange.calculateDataRange(dataMin.getFullYear(), dataMax.getFullYear(), false);
            // Calculate year sequence
            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(0, yearsRange.max - yearsRange.min), expectedCount, 0, null, null, [1, 2, 5]);
            var newMinYear = Math.floor(yearsRange.min / sequence.interval) * sequence.interval;
            var date = new Date(newMinYear, 0, 1);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Year);
            return result;
        };
        DateTimeSequence.calculateMonths = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var minYear = dataMin.getFullYear();
            var maxYear = dataMax.getFullYear();
            var minMonth = dataMin.getMonth();
            var maxMonth = (maxYear - minYear) * 12 + dataMax.getMonth();
            var date = new Date(minYear, 0, 1);
            // Calculate month sequence
            var sequence = powerbi.NumericSequence.calculateUnits(minMonth, maxMonth, expectedCount, [1, 2, 3, 6, 12]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Month);
            return result;
        };
        DateTimeSequence.calculateWeeks = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            var firstDayOfWeek = 0;
            var minDayOfWeek = dataMin.getDay();
            var dayOffset = (minDayOfWeek - firstDayOfWeek + 7) % 7;
            var minDay = dataMin.getDate() - dayOffset;
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), minDay);
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Week));
            // Calculate week sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 4, 8]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Week);
            return result;
        };
        DateTimeSequence.calculateDays = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = 0;
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(dataMin, dataMax, powerbi.DateTimeUnit.Day));
            // Calculate day sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 7, 14]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Day);
            return result;
        };
        DateTimeSequence.calculateHours = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Hour));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Hour));
            // Calculate hour sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 3, 6, 12, 24]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Hour);
            return result;
        };
        DateTimeSequence.calculateMinutes = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Minute));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Minute));
            // Calculate minutes numeric sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 3, 60 * 6, 60 * 12, 60 * 24]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Minute);
            return result;
        };
        DateTimeSequence.calculateSeconds = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes());
            var min = powerbi.Double.floorWithPrecision(DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Second));
            var max = powerbi.Double.ceilWithPrecision(DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Second));
            // Calculate minutes numeric sequence
            var sequence = powerbi.NumericSequence.calculateUnits(min, max, expectedCount, [1, 2, 5, 10, 15, 30, 60, 60 * 2, 60 * 5, 60 * 10, 60 * 15, 60 * 30, 60 * 60]);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Second);
            return result;
        };
        DateTimeSequence.calculateMilliseconds = function (dataMin, dataMax, expectedCount) {
            debug.assertValue(dataMin, "dataMin");
            debug.assertValue(dataMax, "dataMax");
            debug.assert(expectedCount === undefined || (expectedCount >= DateTimeSequence.MIN_COUNT && expectedCount <= DateTimeSequence.MAX_COUNT), "expected count is out of range");
            // Calculate range
            var date = new Date(dataMin.getFullYear(), dataMin.getMonth(), dataMin.getDate(), dataMin.getHours(), dataMin.getMinutes(), dataMin.getSeconds());
            var min = DateTimeSequence.getDelta(date, dataMin, powerbi.DateTimeUnit.Millisecond);
            var max = DateTimeSequence.getDelta(date, dataMax, powerbi.DateTimeUnit.Millisecond);
            // Calculate milliseconds numeric sequence
            var sequence = powerbi.NumericSequence.calculate(powerbi.NumericSequenceRange.calculate(min, max), expectedCount, 0);
            // Convert to date sequence
            var result = DateTimeSequence.fromNumericSequence(date, sequence, powerbi.DateTimeUnit.Millisecond);
            return result;
        };
        DateTimeSequence.fromNumericSequence = function (date, sequence, unit) {
            var result = new DateTimeSequence(unit);
            for (var i = 0; i < sequence.sequence.length; i++) {
                var x = sequence.sequence[i];
                var d = DateTimeSequence.addInterval(date, x, unit);
                result.add(d);
            }
            result.interval = sequence.interval;
            result.intervalOffset = sequence.intervalOffset;
            return result;
        };
        DateTimeSequence.addInterval = function (value, interval, unit) {
            interval = Math.round(interval);
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    return DateUtils.addYears(value, interval);
                case powerbi.DateTimeUnit.Month:
                    return DateUtils.addMonths(value, interval);
                case powerbi.DateTimeUnit.Week:
                    return DateUtils.addWeeks(value, interval);
                case powerbi.DateTimeUnit.Day:
                    return DateUtils.addDays(value, interval);
                case powerbi.DateTimeUnit.Hour:
                    return DateUtils.addHours(value, interval);
                case powerbi.DateTimeUnit.Minute:
                    return DateUtils.addMinutes(value, interval);
                case powerbi.DateTimeUnit.Second:
                    return DateUtils.addSeconds(value, interval);
                case powerbi.DateTimeUnit.Millisecond:
                    return DateUtils.addMilliseconds(value, interval);
            }
        };
        DateTimeSequence.getDelta = function (min, max, unit) {
            var delta = 0;
            switch (unit) {
                case powerbi.DateTimeUnit.Year:
                    delta = max.getFullYear() - min.getFullYear();
                    break;
                case powerbi.DateTimeUnit.Month:
                    delta = (max.getFullYear() - min.getFullYear()) * 12 + max.getMonth() - min.getMonth();
                    break;
                case powerbi.DateTimeUnit.Week:
                    delta = (max.getTime() - min.getTime()) / (7 * 24 * 3600000);
                    break;
                case powerbi.DateTimeUnit.Day:
                    delta = (max.getTime() - min.getTime()) / (24 * 3600000);
                    break;
                case powerbi.DateTimeUnit.Hour:
                    delta = (max.getTime() - min.getTime()) / 3600000;
                    break;
                case powerbi.DateTimeUnit.Minute:
                    delta = (max.getTime() - min.getTime()) / 60000;
                    break;
                case powerbi.DateTimeUnit.Second:
                    delta = (max.getTime() - min.getTime()) / 1000;
                    break;
                case powerbi.DateTimeUnit.Millisecond:
                    delta = max.getTime() - min.getTime();
                    break;
            }
            return delta;
        };
        DateTimeSequence.getIntervalUnit = function (min, max, maxCount) {
            maxCount = Math.max(maxCount, 2);
            var totalDays = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Day);
            if (totalDays > 356 && totalDays >= 30 * 6 * maxCount)
                return powerbi.DateTimeUnit.Year;
            if (totalDays > 60 && totalDays > 7 * maxCount)
                return powerbi.DateTimeUnit.Month;
            if (totalDays > 14 && totalDays > 2 * maxCount)
                return powerbi.DateTimeUnit.Week;
            var totalHours = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Hour);
            if (totalDays > 2 && totalHours > 12 * maxCount)
                return powerbi.DateTimeUnit.Day;
            if (totalHours >= 24 && totalHours >= maxCount)
                return powerbi.DateTimeUnit.Hour;
            var totalMinutes = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Minute);
            if (totalMinutes > 2 && totalMinutes >= maxCount)
                return powerbi.DateTimeUnit.Minute;
            var totalSeconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Second);
            if (totalSeconds > 2 && totalSeconds >= 0.8 * maxCount)
                return powerbi.DateTimeUnit.Second;
            var totalMilliseconds = DateTimeSequence.getDelta(min, max, powerbi.DateTimeUnit.Millisecond);
            if (totalMilliseconds > 0)
                return powerbi.DateTimeUnit.Millisecond;
            // If the size of the range is 0 we need to guess the unit based on the date's non-zero values starting with milliseconds
            var date = min;
            if (date.getMilliseconds() !== 0)
                return powerbi.DateTimeUnit.Millisecond;
            if (date.getSeconds() !== 0)
                return powerbi.DateTimeUnit.Second;
            if (date.getMinutes() !== 0)
                return powerbi.DateTimeUnit.Minute;
            if (date.getHours() !== 0)
                return powerbi.DateTimeUnit.Hour;
            if (date.getDate() !== 1)
                return powerbi.DateTimeUnit.Day;
            if (date.getMonth() !== 0)
                return powerbi.DateTimeUnit.Month;
            return powerbi.DateTimeUnit.Year;
        };
        // Constants
        DateTimeSequence.MIN_COUNT = 1;
        DateTimeSequence.MAX_COUNT = 1000;
        return DateTimeSequence;
    }());
    powerbi.DateTimeSequence = DateTimeSequence;
    /** DateUtils module provides DateTimeSequence with set of additional date manipulation routines */
    var DateUtils;
    (function (DateUtils) {
        var MonthDays = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        var MonthDaysLeap = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
        /**
         * Returns bool indicating weither the provided year is a leap year.
         * @param year - year value
         */
        function isLeap(year) {
            return ((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0);
        }
        /**
         * Returns number of days in the provided year/month.
         * @param year - year value
         * @param month - month value
         */
        function getMonthDays(year, month) {
            return isLeap(year) ? MonthDaysLeap[month] : MonthDays[month];
        }
        /**
         * Adds a specified number of years to the provided date.
         * @param date - date value
         * @param yearDelta - number of years to add
         */
        function addYears(date, yearDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var isLeapDay = month === 2 && day === 29;
            var result = new Date(date.getTime());
            year = year + yearDelta;
            if (isLeapDay && !isLeap(year)) {
                day = 28;
            }
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addYears = addYears;
        /**
         * Adds a specified number of months to the provided date.
         * @param date - date value
         * @param monthDelta - number of months to add
         */
        function addMonths(date, monthDelta) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            year += (monthDelta - (monthDelta % 12)) / 12;
            month += monthDelta % 12;
            // VSTS 1325771: Certain column charts don't display any data
            // Wrap arround the month if is after december (value 11)
            if (month > 11) {
                month = month % 12;
                year++;
            }
            day = Math.min(day, getMonthDays(year, month));
            result.setFullYear(year, month, day);
            return result;
        }
        DateUtils.addMonths = addMonths;
        /**
         * Adds a specified number of weeks to the provided date.
         * @param date - date value
         * @param weeks - number of weeks to add
         */
        function addWeeks(date, weeks) {
            return addDays(date, weeks * 7);
        }
        DateUtils.addWeeks = addWeeks;
        /**
         * Adds a specified number of days to the provided date.
         * @param date - date value
         * @param days - number of days to add
         */
        function addDays(date, days) {
            var year = date.getFullYear();
            var month = date.getMonth();
            var day = date.getDate();
            var result = new Date(date.getTime());
            result.setFullYear(year, month, day + days);
            return result;
        }
        DateUtils.addDays = addDays;
        /**
         * Adds a specified number of hours to the provided date.
         * @param date - date value
         * @param hours - number of hours to add
         */
        function addHours(date, hours) {
            return new Date(date.getTime() + hours * 3600000);
        }
        DateUtils.addHours = addHours;
        /**
         * Adds a specified number of minutes to the provided date.
         * @param date - date value
         * @param minutes - number of minutes to add
         */
        function addMinutes(date, minutes) {
            return new Date(date.getTime() + minutes * 60000);
        }
        DateUtils.addMinutes = addMinutes;
        /**
         * Adds a specified number of seconds to the provided date.
         * @param date - date value
         * @param seconds - number of seconds to add
         */
        function addSeconds(date, seconds) {
            return new Date(date.getTime() + seconds * 1000);
        }
        DateUtils.addSeconds = addSeconds;
        /**
         * Adds a specified number of milliseconds to the provided date.
         * @param date - date value
         * @param milliseconds - number of milliseconds to add
         */
        function addMilliseconds(date, milliseconds) {
            return new Date(date.getTime() + milliseconds);
        }
        DateUtils.addMilliseconds = addMilliseconds;
    })(DateUtils = powerbi.DateUtils || (powerbi.DateUtils = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    // Constants
    var maxExponent = 24;
    var defaultScientificBigNumbersBoundary = 1E15;
    var scientificSmallNumbersBoundary = 1E-4;
    var PERCENTAGE_FORMAT = '%';
    var SCIENTIFIC_FORMAT = 'E+0';
    var DEFAULT_SCIENTIFIC_FORMAT = '0.##' + SCIENTIFIC_FORMAT;
    // Regular expressions
    /**
     * This regex looks for strings that match one of the following conditions:
     *   - Optionally contain "0", "#", followed by a period, followed by at least one "0" or "#" (Ex. ###,000.###)
     *   - Contains at least one of "0", "#", or "," (Ex. ###,000)
     *   - Contain a "g" (indicates to use the general .NET numeric format string)
     * The entire string (start to end) must match, and the match is not case-sensitive.
     */
    var SUPPORTED_SCIENTIFIC_FORMATS = /^([0\#,]*\.[0\#]+|[0\#,]+|g)$/i;
    var DisplayUnit = (function () {
        function DisplayUnit() {
        }
        // Methods
        DisplayUnit.prototype.project = function (value) {
            if (this.value) {
                return powerbi.Double.removeDecimalNoise(value / this.value);
            }
            else {
                return value;
            }
        };
        DisplayUnit.prototype.reverseProject = function (value) {
            if (this.value) {
                return value * this.value;
            }
            else {
                return value;
            }
        };
        DisplayUnit.prototype.isApplicableTo = function (value) {
            value = Math.abs(value);
            var precision = powerbi.Double.getPrecision(value, 3);
            return powerbi.Double.greaterOrEqualWithPrecision(value, this.applicableRangeMin, precision) && powerbi.Double.lessWithPrecision(value, this.applicableRangeMax, precision);
        };
        DisplayUnit.prototype.isScaling = function () {
            return this.value > 1;
        };
        return DisplayUnit;
    }());
    powerbi.DisplayUnit = DisplayUnit;
    var DisplayUnitSystem = (function () {
        // Constructor
        function DisplayUnitSystem(units) {
            this.units = units ? units : [];
        }
        Object.defineProperty(DisplayUnitSystem.prototype, "title", {
            // Properties
            get: function () {
                return this.displayUnit ? this.displayUnit.title : undefined;
            },
            enumerable: true,
            configurable: true
        });
        // Methods
        DisplayUnitSystem.prototype.update = function (value) {
            if (value === undefined)
                return;
            this.unitBaseValue = value;
            this.displayUnit = this.findApplicableDisplayUnit(value);
        };
        DisplayUnitSystem.prototype.findApplicableDisplayUnit = function (value) {
            for (var _i = 0, _a = this.units; _i < _a.length; _i++) {
                var unit = _a[_i];
                if (unit.isApplicableTo(value))
                    return unit;
            }
            return undefined;
        };
        DisplayUnitSystem.prototype.format = function (value, format, decimals, trailingZeros) {
            debug.assert(typeof (value) === "number", "value must be a number");
            if (this.isFormatSupported(format)) {
                decimals = this.getNumberOfDecimalsForFormatting(format, decimals);
                if (this.hasScientitifcFormat(format)) {
                    return this.formatHelper(value, '', format, decimals, trailingZeros);
                }
                if (this.isScalingUnit() && this.shouldRespectScalingUnit(format)) {
                    return this.formatHelper(this.displayUnit.project(value), this.displayUnit.labelFormat, format, decimals, trailingZeros);
                }
                if (decimals != null) {
                    return this.formatHelper(value, '', format, decimals, trailingZeros);
                }
            }
            return powerbi.formattingService.formatValue(value, format);
        };
        DisplayUnitSystem.prototype.isFormatSupported = function (format) {
            return !DisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);
        };
        DisplayUnitSystem.prototype.isPercentageFormat = function (format) {
            return format && format.indexOf(PERCENTAGE_FORMAT) >= 0;
        };
        DisplayUnitSystem.prototype.shouldRespectScalingUnit = function (format) {
            return !this.isPercentageFormat(format);
        };
        DisplayUnitSystem.prototype.getNumberOfDecimalsForFormatting = function (format, decimals) {
            return decimals;
        };
        DisplayUnitSystem.prototype.isScalingUnit = function () {
            return this.displayUnit && this.displayUnit.isScaling();
        };
        DisplayUnitSystem.prototype.formatHelper = function (value, nonScientificFormat, format, decimals, trailingZeros) {
            // If the format is "general" and we want to override the number of decimal places then use the default numeric format string.
            if ((format === 'g' || format === 'G') && decimals != null)
                format = powerbi.visuals.valueFormatter.DefaultNumericFormat;
            format = powerbi.NumberFormat.addDecimalsToFormat(format, decimals, trailingZeros);
            if (format && !powerbi.formattingService.isStandardNumberFormat(format))
                return powerbi.formattingService.formatNumberWithCustomOverride(value, format, nonScientificFormat);
            if (!format)
                format = 'G';
            if (!nonScientificFormat)
                nonScientificFormat = '{0}';
            var text = powerbi.formattingService.formatValue(value, format);
            return powerbi.formattingService.format(nonScientificFormat, [text]);
        };
        /** Formats a single value by choosing an appropriate base for the DisplayUnitSystem before formatting. */
        DisplayUnitSystem.prototype.formatSingleValue = function (value, format, decimals, trailingZeros) {
            // Change unit base to a value appropriate for this value
            this.update(this.shouldUseValuePrecision(value) ? powerbi.Double.getPrecision(value, 8) : value);
            return this.format(value, format, decimals, trailingZeros);
        };
        DisplayUnitSystem.prototype.shouldUseValuePrecision = function (value) {
            if (this.units.length === 0)
                return true;
            // Check if the value is big enough to have a valid unit by checking against the smallest unit (that it's value bigger than 1).
            var applicableRangeMin = 0;
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].isScaling()) {
                    applicableRangeMin = this.units[i].applicableRangeMin;
                    break;
                }
            }
            return Math.abs(value) < applicableRangeMin;
        };
        DisplayUnitSystem.prototype.isScientific = function (value) {
            return value < -defaultScientificBigNumbersBoundary || value > defaultScientificBigNumbersBoundary ||
                (-scientificSmallNumbersBoundary < value && value < scientificSmallNumbersBoundary && value !== 0);
        };
        DisplayUnitSystem.prototype.hasScientitifcFormat = function (format) {
            return format && format.toUpperCase().indexOf("E") !== -1;
        };
        DisplayUnitSystem.prototype.supportsScientificFormat = function (format) {
            if (format)
                return SUPPORTED_SCIENTIFIC_FORMATS.test(format);
            return true;
        };
        DisplayUnitSystem.prototype.shouldFallbackToScientific = function (value, format) {
            return !this.hasScientitifcFormat(format)
                && this.supportsScientificFormat(format)
                && this.isScientific(value);
        };
        DisplayUnitSystem.prototype.getScientificFormat = function (data, format, decimals, trailingZeros) {
            // Use scientific format outside of the range
            if (this.isFormatSupported(format) && this.shouldFallbackToScientific(data, format)) {
                var numericFormat = powerbi.NumberFormat.getNumericFormat(data, format);
                if (decimals)
                    numericFormat = powerbi.NumberFormat.addDecimalsToFormat(numericFormat ? numericFormat : '0', Math.abs(decimals), trailingZeros);
                if (numericFormat)
                    return numericFormat + SCIENTIFIC_FORMAT;
                else
                    return DEFAULT_SCIENTIFIC_FORMAT;
            }
            return format;
        };
        DisplayUnitSystem.UNSUPPORTED_FORMATS = /^(p\d*)|(.*\%)|(e\d*)$/i;
        return DisplayUnitSystem;
    }());
    powerbi.DisplayUnitSystem = DisplayUnitSystem;
    /** Provides a unit system that is defined by formatting in the model, and is suitable for visualizations shown in single number visuals in explore mode. */
    var NoDisplayUnitSystem = (function (_super) {
        __extends(NoDisplayUnitSystem, _super);
        // Constructor
        function NoDisplayUnitSystem() {
            _super.call(this, []);
        }
        return NoDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.NoDisplayUnitSystem = NoDisplayUnitSystem;
    /** Provides a unit system that creates a more concise format for displaying values. This is suitable for most of the cases where
        we are showing values (chart axes) and as such it is the default unit system. */
    var DefaultDisplayUnitSystem = (function (_super) {
        __extends(DefaultDisplayUnitSystem, _super);
        // Constructor
        function DefaultDisplayUnitSystem(unitLookup) {
            _super.call(this, DefaultDisplayUnitSystem.getUnits(unitLookup));
        }
        // Methods
        DefaultDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        DefaultDisplayUnitSystem.reset = function () {
            DefaultDisplayUnitSystem.units = null;
        };
        DefaultDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!DefaultDisplayUnitSystem.units) {
                DefaultDisplayUnitSystem.units = createDisplayUnits(unitLookup, function (value, previousUnitValue, min) {
                    // When dealing with millions/billions/trillions we need to switch to millions earlier: for example instead of showing 100K 200K 300K we should show 0.1M 0.2M 0.3M etc
                    if (value - previousUnitValue >= 1000) {
                        return value / 10;
                    }
                    return min;
                });
                // Ensure last unit has max of infinity
                DefaultDisplayUnitSystem.units[DefaultDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return DefaultDisplayUnitSystem.units;
        };
        return DefaultDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.DefaultDisplayUnitSystem = DefaultDisplayUnitSystem;
    /** Provides a unit system that creates a more concise format for displaying values, but only allows showing a unit if we have at least
        one of those units (e.g. 0.9M is not allowed since it's less than 1 million). This is suitable for cases such as dashboard tiles
        where we have restricted space but do not want to show partial units. */
    var WholeUnitsDisplayUnitSystem = (function (_super) {
        __extends(WholeUnitsDisplayUnitSystem, _super);
        // Constructor
        function WholeUnitsDisplayUnitSystem(unitLookup) {
            _super.call(this, WholeUnitsDisplayUnitSystem.getUnits(unitLookup));
        }
        WholeUnitsDisplayUnitSystem.reset = function () {
            WholeUnitsDisplayUnitSystem.units = null;
        };
        WholeUnitsDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!WholeUnitsDisplayUnitSystem.units) {
                WholeUnitsDisplayUnitSystem.units = createDisplayUnits(unitLookup);
                // Ensure last unit has max of infinity
                WholeUnitsDisplayUnitSystem.units[WholeUnitsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return WholeUnitsDisplayUnitSystem.units;
        };
        WholeUnitsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        return WholeUnitsDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.WholeUnitsDisplayUnitSystem = WholeUnitsDisplayUnitSystem;
    var DataLabelsDisplayUnitSystem = (function (_super) {
        __extends(DataLabelsDisplayUnitSystem, _super);
        function DataLabelsDisplayUnitSystem(unitLookup) {
            _super.call(this, DataLabelsDisplayUnitSystem.getUnits(unitLookup));
        }
        DataLabelsDisplayUnitSystem.prototype.isFormatSupported = function (format) {
            return !DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS.test(format);
        };
        DataLabelsDisplayUnitSystem.getUnits = function (unitLookup) {
            if (!DataLabelsDisplayUnitSystem.units) {
                var units = [];
                var adjustMinBasedOnPreviousUnit = function (value, previousUnitValue, min) {
                    // Never returns true, we are always ignoring
                    // We do not early switch (e.g. 100K instead of 0.1M)
                    // Intended? If so, remove this function, otherwise, remove if statement
                    if (value === -1)
                        if (value - previousUnitValue >= 1000) {
                            return value / 10;
                        }
                    return min;
                };
                // Add Auto & None
                var names = unitLookup(-1);
                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);
                names = unitLookup(0);
                addUnitIfNonEmpty(units, DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE, names.title, names.format, adjustMinBasedOnPreviousUnit);
                // Add normal units
                DataLabelsDisplayUnitSystem.units = units.concat(createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit));
                // Ensure last unit has max of infinity
                DataLabelsDisplayUnitSystem.units[DataLabelsDisplayUnitSystem.units.length - 1].applicableRangeMax = Infinity;
            }
            return DataLabelsDisplayUnitSystem.units;
        };
        DataLabelsDisplayUnitSystem.prototype.format = function (data, format, decimals, trailingZeros) {
            format = this.getScientificFormat(data, format, decimals, trailingZeros);
            return _super.prototype.format.call(this, data, format, decimals, trailingZeros);
        };
        // Constants
        DataLabelsDisplayUnitSystem.AUTO_DISPLAYUNIT_VALUE = 0;
        DataLabelsDisplayUnitSystem.NONE_DISPLAYUNIT_VALUE = 1;
        DataLabelsDisplayUnitSystem.UNSUPPORTED_FORMATS = /^(e\d*)$/i;
        return DataLabelsDisplayUnitSystem;
    }(DisplayUnitSystem));
    powerbi.DataLabelsDisplayUnitSystem = DataLabelsDisplayUnitSystem;
    function createDisplayUnits(unitLookup, adjustMinBasedOnPreviousUnit) {
        var units = [];
        for (var i = 3; i < maxExponent; i++) {
            var names = unitLookup(i);
            if (names)
                addUnitIfNonEmpty(units, powerbi.Double.pow10(i), names.title, names.format, adjustMinBasedOnPreviousUnit);
        }
        return units;
    }
    function addUnitIfNonEmpty(units, value, title, labelFormat, adjustMinBasedOnPreviousUnit) {
        if (title || labelFormat) {
            var min = value;
            if (units.length > 0) {
                var previousUnit = units[units.length - 1];
                if (adjustMinBasedOnPreviousUnit)
                    min = adjustMinBasedOnPreviousUnit(value, previousUnit.value, min);
                previousUnit.applicableRangeMax = min;
            }
            var unit = new DisplayUnit();
            unit.value = value;
            unit.applicableRangeMin = min;
            unit.applicableRangeMax = min * 1000;
            unit.title = title;
            unit.labelFormat = labelFormat;
            units.push(unit);
        }
    }
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NumericSequence = (function () {
        function NumericSequence() {
        }
        NumericSequence.calculate = function (range, expectedCount, maxAllowedMargin, minPower, useZeroRefPoint, steps) {
            debug.assertValue(range, "range");
            debug.assert(expectedCount === undefined || (expectedCount >= NumericSequence.MIN_COUNT && expectedCount <= NumericSequence.MAX_COUNT), "expectedCount");
            debug.assert(minPower === undefined || (minPower >= powerbi.Double.MIN_EXP && minPower <= powerbi.Double.MAX_EXP), "minPower");
            debug.assert(maxAllowedMargin === undefined || (maxAllowedMargin >= 0), "maxAllowedMargin");
            var result = new NumericSequence();
            if (expectedCount === undefined)
                expectedCount = 10;
            else
                expectedCount = powerbi.Double.ensureInRange(expectedCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (minPower === undefined)
                minPower = powerbi.Double.MIN_EXP;
            if (useZeroRefPoint === undefined)
                useZeroRefPoint = false;
            if (maxAllowedMargin === undefined)
                maxAllowedMargin = 1;
            if (steps === undefined)
                steps = [1, 2, 5];
            // Handle single stop case
            if (range.forcedSingleStop) {
                result.interval = range.getSize();
                result.intervalOffset = result.interval - (range.forcedSingleStop - range.min);
                result.min = range.min;
                result.max = range.max;
                result.sequence = [range.forcedSingleStop];
                return result;
            }
            var interval = 0;
            var min = 0;
            var max = 9;
            var canExtendMin = maxAllowedMargin > 0 && !range.hasFixedMin;
            var canExtendMax = maxAllowedMargin > 0 && !range.hasFixedMax;
            var size = range.getSize();
            var exp = powerbi.Double.log10(size);
            // Account for Exp of steps
            var stepExp = powerbi.Double.log10(steps[0]);
            exp = exp - stepExp;
            // Account for MaxCount
            var expectedCountExp = powerbi.Double.log10(expectedCount);
            exp = exp - expectedCountExp;
            // Account for MinPower
            exp = Math.max(exp, minPower - stepExp + 1);
            var count = undefined;
            // Create array of "good looking" numbers
            if (interval !== 0) {
                // If explicit interval is defined - use it instead of the steps array.
                var power = powerbi.Double.pow10(exp);
                var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax);
                roundRange.shrinkByStep(range, interval);
                min = roundRange.min;
                max = roundRange.max;
                count = Math.floor(roundRange.getSize() / interval);
            }
            else {
                // No interval defined -> find optimal interval
                var dexp = void 0;
                for (dexp = 0; dexp < 3; dexp++) {
                    var e = exp + dexp;
                    var power = powerbi.Double.pow10(e);
                    var roundMin = powerbi.Double.floorToPrecision(range.min, power);
                    var roundMax = powerbi.Double.ceilToPrecision(range.max, power);
                    // Go throught the steps array looking for the smallest step that produces the right interval count.
                    var stepsCount = steps.length;
                    var stepPower = powerbi.Double.pow10(e - 1);
                    for (var i = 0; i < stepsCount; i++) {
                        var step = steps[i] * stepPower;
                        var roundRange = powerbi.NumericSequenceRange.calculateFixedRange(roundMin, roundMax, useZeroRefPoint);
                        roundRange.shrinkByStep(range, step);
                        // If the range is based on Data we might need to extend it to provide nice data margins.
                        if (canExtendMin && range.min === roundRange.min && maxAllowedMargin >= 1)
                            roundRange.min -= step;
                        if (canExtendMax && range.max === roundRange.max && maxAllowedMargin >= 1)
                            roundRange.max += step;
                        // Count the intervals
                        count = powerbi.Double.ceilWithPrecision(roundRange.getSize() / step);
                        if (count <= expectedCount || (dexp === 2 && i === stepsCount - 1) || (expectedCount === 1 && count === 2 && (step > range.getSize() || (range.min < 0 && range.max > 0 && step * 2 >= range.getSize())))) {
                            interval = step;
                            min = roundRange.min;
                            max = roundRange.max;
                            break;
                        }
                    }
                    // Increase the scale power until the interval is found
                    if (interval !== 0)
                        break;
                }
            }
            // Avoid extreme count cases (>1000 ticks)
            if (count > expectedCount * 32 || count > NumericSequence.MAX_COUNT) {
                count = Math.min(expectedCount * 32, NumericSequence.MAX_COUNT);
                interval = (max - min) / count;
            }
            result.min = min;
            result.max = max;
            result.interval = interval;
            result.intervalOffset = min - range.min;
            result.maxAllowedMargin = maxAllowedMargin;
            result.canExtendMin = canExtendMin;
            result.canExtendMax = canExtendMax;
            // Fill in the Sequence
            var precision = powerbi.Double.getPrecision(interval, 0);
            result.precision = precision;
            var sequence = [];
            var x = powerbi.Double.roundToPrecision(min, precision);
            sequence.push(x);
            for (var i = 0; i < count; i++) {
                x = powerbi.Double.roundToPrecision(x + interval, precision);
                sequence.push(x);
            }
            result.sequence = sequence;
            result.trimMinMax(range.min, range.max);
            return result;
        };
        /**
         * Calculates the sequence of int numbers which are mapped to the multiples of the units grid.
         * @min - The minimum of the range.
         * @max - The maximum of the range.
         * @maxCount - The max count of intervals.
         * @steps - array of intervals.
         */
        NumericSequence.calculateUnits = function (min, max, maxCount, steps) {
            // Initialization actions
            maxCount = powerbi.Double.ensureInRange(maxCount, NumericSequence.MIN_COUNT, NumericSequence.MAX_COUNT);
            if (min === max) {
                max = min + 1;
            }
            var stepCount = 0;
            var step = 0;
            // Calculate step
            for (var i = 0; i < steps.length; i++) {
                step = steps[i];
                var maxStepCount = powerbi.Double.ceilWithPrecision(max / step);
                var minStepCount = powerbi.Double.floorWithPrecision(min / step);
                stepCount = maxStepCount - minStepCount;
                if (stepCount <= maxCount) {
                    break;
                }
            }
            // Calculate the offset
            var offset = -min;
            offset = offset % step;
            // Create sequence
            var result = new NumericSequence();
            result.sequence = [];
            for (var x = min + offset;; x += step) {
                result.sequence.push(x);
                if (x >= max)
                    break;
            }
            result.interval = step;
            result.intervalOffset = offset;
            result.min = result.sequence[0];
            result.max = result.sequence[result.sequence.length - 1];
            return result;
        };
        NumericSequence.prototype.trimMinMax = function (min, max) {
            var minMargin = (min - this.min) / this.interval;
            var maxMargin = (this.max - max) / this.interval;
            var marginPrecision = 0.001;
            if (!this.canExtendMin || (minMargin > this.maxAllowedMargin && minMargin > marginPrecision)) {
                this.min = min;
            }
            if (!this.canExtendMax || (maxMargin > this.maxAllowedMargin && maxMargin > marginPrecision)) {
                this.max = max;
            }
        };
        NumericSequence.MIN_COUNT = 1;
        NumericSequence.MAX_COUNT = 1000;
        return NumericSequence;
    }());
    powerbi.NumericSequence = NumericSequence;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NumericSequenceRange = (function () {
        function NumericSequenceRange() {
        }
        NumericSequenceRange.prototype._ensureIncludeZero = function () {
            if (this.includeZero) {
                // fixed min and max has higher priority than includeZero
                if (this.min > 0 && !this.hasFixedMin) {
                    this.min = 0;
                }
                if (this.max < 0 && !this.hasFixedMax) {
                    this.max = 0;
                }
            }
        };
        NumericSequenceRange.prototype._ensureNotEmpty = function () {
            if (this.min === this.max) {
                if (!this.min) {
                    this.min = 0;
                    this.max = NumericSequenceRange.DEFAULT_MAX;
                    this.hasFixedMin = true;
                    this.hasFixedMax = true;
                }
                else {
                    // We are dealing with a single data value (includeZero is not set)
                    // In order to fix the range we need to extend it in both directions by half of the interval.
                    // Interval is calculated based on the number:
                    // 1. Integers below 10,000 are extended by 0.5: so the [2006-2006] empty range is extended to [2005.5-2006.5] range and the ForsedSingleStop=2006
                    // 2. Other numbers are extended by half of their power: [700,001-700,001] => [650,001-750,001] and the ForsedSingleStop=null as we want the intervals to be calculated to cover the range.
                    var value = this.min;
                    var exp = powerbi.Double.log10(Math.abs(value));
                    var step = void 0;
                    if (exp >= 0 && exp < 4) {
                        step = 0.5;
                        this.forcedSingleStop = value;
                    }
                    else {
                        step = powerbi.Double.pow10(exp) / 2;
                        this.forcedSingleStop = null;
                    }
                    this.min = value - step;
                    this.max = value + step;
                }
            }
        };
        NumericSequenceRange.prototype._ensureDirection = function () {
            if (this.min > this.max) {
                var temp = this.min;
                this.min = this.max;
                this.max = temp;
            }
        };
        NumericSequenceRange.prototype.getSize = function () {
            return this.max - this.min;
        };
        NumericSequenceRange.prototype.shrinkByStep = function (range, step) {
            debug.assertValue(range, "range");
            debug.assert(step > 0, "step");
            var oldCount = this.min / step;
            var newCount = range.min / step;
            var deltaCount = Math.floor(newCount - oldCount);
            this.min += deltaCount * step;
            oldCount = this.max / step;
            newCount = range.max / step;
            deltaCount = Math.ceil(newCount - oldCount);
            this.max += deltaCount * step;
        };
        NumericSequenceRange.calculate = function (dataMin, dataMax, fixedMin, fixedMax, includeZero) {
            debug.assert(dataMin <= dataMax, "dataMin should be less or equal to dataMax.");
            debug.assert(!fixedMin || !fixedMax || fixedMin <= fixedMax, "fixedMin should be less or equal to fixedMax.");
            var result = new NumericSequenceRange();
            result.includeZero = includeZero ? true : false;
            result.hasDataRange = ValueUtil.hasValue(dataMin) && ValueUtil.hasValue(dataMax);
            result.hasFixedMin = ValueUtil.hasValue(fixedMin);
            result.hasFixedMax = ValueUtil.hasValue(fixedMax);
            dataMin = powerbi.Double.ensureInRange(dataMin, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            dataMax = powerbi.Double.ensureInRange(dataMax, NumericSequenceRange.MIN_SUPPORTED_DOUBLE, NumericSequenceRange.MAX_SUPPORTED_DOUBLE);
            // Calculate the range using the min, max, dataRange
            if (result.hasFixedMin && result.hasFixedMax) {
                result.min = fixedMin;
                result.max = fixedMax;
            }
            else if (result.hasFixedMin) {
                result.min = fixedMin;
                result.max = dataMax > fixedMin ? dataMax : fixedMin;
            }
            else if (result.hasFixedMax) {
                result.min = dataMin < fixedMax ? dataMin : fixedMax;
                result.max = fixedMax;
            }
            else if (result.hasDataRange) {
                result.min = dataMin;
                result.max = dataMax;
            }
            else {
                result.min = 0;
                result.max = 0;
            }
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            if (result.min === 0) {
                result.hasFixedMin = true; // If the range starts from zero we should prevent extending the intervals into the negative range
            }
            else if (result.max === 0) {
                result.hasFixedMax = true; // If the range ends at zero we should prevent extending the intervals into the positive range
            }
            return result;
        };
        NumericSequenceRange.calculateDataRange = function (dataMin, dataMax, includeZero) {
            if (!ValueUtil.hasValue(dataMin) || !ValueUtil.hasValue(dataMax)) {
                return NumericSequenceRange.calculateFixedRange(0, NumericSequenceRange.DEFAULT_MAX);
            }
            else {
                return NumericSequenceRange.calculate(dataMin, dataMax, null, null, includeZero);
            }
        };
        NumericSequenceRange.calculateFixedRange = function (fixedMin, fixedMax, includeZero) {
            debug.assertValue(fixedMin, "fixedMin");
            debug.assertValue(fixedMax, "fixedMax");
            var result = new NumericSequenceRange();
            result.hasDataRange = false;
            result.includeZero = includeZero;
            result.min = fixedMin;
            result.max = fixedMax;
            result._ensureIncludeZero();
            result._ensureNotEmpty();
            result._ensureDirection();
            result.hasFixedMin = true;
            result.hasFixedMax = true;
            return result;
        };
        NumericSequenceRange.DEFAULT_MAX = 10;
        NumericSequenceRange.MIN_SUPPORTED_DOUBLE = -1E307;
        NumericSequenceRange.MAX_SUPPORTED_DOUBLE = 1E307;
        return NumericSequenceRange;
    }());
    powerbi.NumericSequenceRange = NumericSequenceRange;
    /** Note: Exported for testability */
    var ValueUtil;
    (function (ValueUtil) {
        function hasValue(value) {
            return value !== undefined && value !== null;
        }
        ValueUtil.hasValue = hasValue;
    })(ValueUtil = powerbi.ValueUtil || (powerbi.ValueUtil = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var valueFormatter;
        (function (valueFormatter) {
            var StringExtensions = jsCommon.StringExtensions;
            var BeautifiedFormat = {
                '0.00 %;-0.00 %;0.00 %': 'Percentage',
                '0.0 %;-0.0 %;0.0 %': 'Percentage1',
            };
            valueFormatter.DefaultIntegerFormat = 'g';
            valueFormatter.DefaultNumericFormat = '#,0.00';
            valueFormatter.DefaultDateFormat = 'd';
            var defaultLocalizedStrings = {
                'NullValue': '(Blank)',
                'BooleanTrue': 'True',
                'BooleanFalse': 'False',
                'NaNValue': 'NaN',
                'InfinityValue': '+Infinity',
                'NegativeInfinityValue': '-Infinity',
                'RestatementComma': '{0}, {1}',
                'RestatementCompoundAnd': '{0} and {1}',
                'RestatementCompoundOr': '{0} or {1}',
                'DisplayUnitSystem_EAuto_Title': 'Auto',
                'DisplayUnitSystem_E0_Title': 'None',
                'DisplayUnitSystem_E3_LabelFormat': '{0}K',
                'DisplayUnitSystem_E3_Title': 'Thousands',
                'DisplayUnitSystem_E6_LabelFormat': '{0}M',
                'DisplayUnitSystem_E6_Title': 'Millions',
                'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
                'DisplayUnitSystem_E9_Title': 'Billions',
                'DisplayUnitSystem_E12_LabelFormat': '{0}T',
                'DisplayUnitSystem_E12_Title': 'Trillions',
                'Percentage': '#,0.##%',
                'Percentage1': '#,0.#%',
                'TableTotalLabel': 'Total',
                'Tooltip_HighlightedValueDisplayName': 'Highlighted',
                'Funnel_PercentOfFirst': 'Percent of first',
                'Funnel_PercentOfPrevious': 'Percent of previous',
                'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlight)',
                'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlight)',
                // Geotagging strings
                'GeotaggingString_Continent': 'continent',
                'GeotaggingString_Continents': 'continents',
                'GeotaggingString_Country': 'country',
                'GeotaggingString_Countries': 'countries',
                'GeotaggingString_State': 'state',
                'GeotaggingString_States': 'states',
                'GeotaggingString_City': 'city',
                'GeotaggingString_Cities': 'cities',
                'GeotaggingString_Town': 'town',
                'GeotaggingString_Towns': 'towns',
                'GeotaggingString_Province': 'province',
                'GeotaggingString_Provinces': 'provinces',
                'GeotaggingString_County': 'county',
                'GeotaggingString_Counties': 'counties',
                'GeotaggingString_Village': 'village',
                'GeotaggingString_Villages': 'villages',
                'GeotaggingString_Post': 'post',
                'GeotaggingString_Zip': 'zip',
                'GeotaggingString_Code': 'code',
                'GeotaggingString_Place': 'place',
                'GeotaggingString_Places': 'places',
                'GeotaggingString_Address': 'address',
                'GeotaggingString_Addresses': 'addresses',
                'GeotaggingString_Street': 'street',
                'GeotaggingString_Streets': 'streets',
                'GeotaggingString_Longitude': 'longitude',
                'GeotaggingString_Longitude_Short': 'lon',
                'GeotaggingString_Latitude': 'latitude',
                'GeotaggingString_Latitude_Short': 'lat',
                'GeotaggingString_PostalCode': 'postal code',
                'GeotaggingString_PostalCodes': 'postal codes',
                'GeotaggingString_ZipCode': 'zip code',
                'GeotaggingString_ZipCodes': 'zip codes',
                'GeotaggingString_Territory': 'territory',
                'GeotaggingString_Territories': 'territories',
            };
            function beautify(format) {
                var key = BeautifiedFormat[format];
                if (key)
                    return defaultLocalizedStrings[key] || format;
                return format;
            }
            function describeUnit(exponent) {
                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"];
                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                if (title || format)
                    return { title: title, format: format };
            }
            function getLocalizedString(stringId) {
                return defaultLocalizedStrings[stringId];
            }
            valueFormatter.getLocalizedString = getLocalizedString;
            // NOTE: Define default locale options, but these can be overriden by setLocaleOptions.
            var locale = {
                null: defaultLocalizedStrings['NullValue'],
                true: defaultLocalizedStrings['BooleanTrue'],
                false: defaultLocalizedStrings['BooleanFalse'],
                NaN: defaultLocalizedStrings['NaNValue'],
                infinity: defaultLocalizedStrings['InfinityValue'],
                negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
                beautify: function (format) { return beautify(format); },
                describe: function (exponent) { return describeUnit(exponent); },
                restatementComma: defaultLocalizedStrings['RestatementComma'],
                restatementCompoundAnd: defaultLocalizedStrings['RestatementCompoundAnd'],
                restatementCompoundOr: defaultLocalizedStrings['RestatementCompoundOr'],
            };
            var MaxScaledDecimalPlaces = 2;
            var MaxValueForDisplayUnitRounding = 1000;
            var MinIntegerValueForDisplayUnits = 10000;
            var MinPrecisionForDisplayUnits = 2;
            var DateTimeMetadataColumn = {
                displayName: '',
                type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.DateTime),
            };
            function getFormatMetadata(format) {
                return powerbi.NumberFormat.getCustomFormatMetadata(format);
            }
            valueFormatter.getFormatMetadata = getFormatMetadata;
            function setLocaleOptions(options) {
                debug.assertValue(options, 'options');
                locale = options;
                powerbi.DefaultDisplayUnitSystem.reset();
                powerbi.WholeUnitsDisplayUnitSystem.reset();
            }
            valueFormatter.setLocaleOptions = setLocaleOptions;
            function createDefaultFormatter(formatString, allowFormatBeautification) {
                if (allowFormatBeautification === void 0) { allowFormatBeautification = false; }
                var formatBeaut = allowFormatBeautification ? locale.beautify(formatString) : formatString;
                return {
                    format: function (value) {
                        if (value == null)
                            return locale.null;
                        return formatCore(value, formatBeaut);
                    }
                };
            }
            valueFormatter.createDefaultFormatter = createDefaultFormatter;
            /** Creates an IValueFormatter to be used for a range of values. */
            function create(options) {
                debug.assertValue(options, 'options');
                var format = !!options.allowFormatBeautification ? locale.beautify(options.format) : options.format;
                if (shouldUseNumericDisplayUnits(options)) {
                    var displayUnitSystem_1 = createDisplayUnitSystem(options.displayUnitSystemType);
                    var singleValueFormattingMode_1 = !!options.formatSingleValues;
                    displayUnitSystem_1.update(Math.max(Math.abs(options.value || 0), Math.abs(options.value2 || 0)));
                    var forcePrecision_1 = options.precision != null;
                    var decimals_1;
                    if (forcePrecision_1)
                        decimals_1 = -options.precision;
                    else if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 1)
                        decimals_1 = -MaxScaledDecimalPlaces;
                    // Detect axis precision
                    if (options.detectAxisPrecision) {
                        // Trailing zeroes
                        forcePrecision_1 = true;
                        var axisValue = options.value;
                        if (displayUnitSystem_1.displayUnit && displayUnitSystem_1.displayUnit.value > 0)
                            axisValue = axisValue / displayUnitSystem_1.displayUnit.value;
                        if (powerbi.Double.isInteger(axisValue))
                            decimals_1 = 0;
                        else
                            decimals_1 = powerbi.Double.log10(axisValue);
                    }
                    return {
                        format: function (value) {
                            var formattedValue = getStringFormat(value, true /*nullsAreBlank*/);
                            if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))
                                return formattedValue;
                            // Round to Double.DEFAULT_PRECISION
                            if (value && !displayUnitSystem_1.isScalingUnit() && Math.abs(value) < MaxValueForDisplayUnitRounding && !forcePrecision_1)
                                value = powerbi.Double.roundToPrecision(value);
                            return singleValueFormattingMode_1 ?
                                displayUnitSystem_1.formatSingleValue(value, format, decimals_1, forcePrecision_1) :
                                displayUnitSystem_1.format(value, format, decimals_1, forcePrecision_1);
                        },
                        displayUnit: displayUnitSystem_1.displayUnit,
                        options: options
                    };
                }
                if (shouldUseDateUnits(options.value, options.value2, options.tickCount)) {
                    var unit_1 = powerbi.DateTimeSequence.getIntervalUnit(options.value /* minDate */, options.value2 /* maxDate */, options.tickCount);
                    return {
                        format: function (value) {
                            if (value == null)
                                return locale.null;
                            var formatString = powerbi.formattingService.dateFormatString(unit_1);
                            return formatCore(value, formatString);
                        },
                        options: options
                    };
                }
                return createDefaultFormatter(format);
            }
            valueFormatter.create = create;
            function format(value, format, allowFormatBeautification) {
                if (value == null)
                    return locale.null;
                return formatCore(value, !!allowFormatBeautification ? locale.beautify(format) : format);
            }
            valueFormatter.format = format;
            function getValueFormat(value, columnType) {
                // If column type not defined or is not datetime
                // ...and the value is of time datetime,
                // then use the default date format string
                if ((!columnType || !columnType.dateTime) && value instanceof Date)
                    return getFormatString(DateTimeMetadataColumn, null, false);
            }
            function formatValueColumn(value, column, formatStringProp) {
                var valueFormat = getValueFormat(value, column.type);
                if (valueFormat)
                    return formatCore(value, valueFormat);
                else
                    return formatCore(value, getFormatString(column, formatStringProp));
            }
            valueFormatter.formatValueColumn = formatValueColumn;
            function createDisplayUnitSystem(displayUnitSystemType) {
                if (displayUnitSystemType == null)
                    return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                switch (displayUnitSystemType) {
                    case powerbi.DisplayUnitSystemType.Default:
                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                    case powerbi.DisplayUnitSystemType.WholeUnits:
                        return new powerbi.WholeUnitsDisplayUnitSystem(locale.describe);
                    case powerbi.DisplayUnitSystemType.Verbose:
                        return new powerbi.NoDisplayUnitSystem();
                    case powerbi.DisplayUnitSystemType.DataLabels:
                        return new powerbi.DataLabelsDisplayUnitSystem(locale.describe);
                    default:
                        debug.assertFail('Unknown display unit system type');
                        return new powerbi.DefaultDisplayUnitSystem(locale.describe);
                }
            }
            function shouldUseNumericDisplayUnits(options) {
                var value = options.value;
                var value2 = options.value2;
                var format = options.format;
                // For singleValue visuals like card, gauge we don't want to roundoff data to the nearest thousands so format the whole number / integers below 10K to not use display units
                if (options.formatSingleValues && format) {
                    if (Math.abs(value) < MinIntegerValueForDisplayUnits) {
                        var isCustomFormat = !powerbi.NumberFormat.isStandardFormat(format);
                        if (isCustomFormat) {
                            var precision = powerbi.NumberFormat.getCustomFormatMetadata(format, true /*calculatePrecision*/).precision;
                            if (precision < MinPrecisionForDisplayUnits)
                                return false;
                        }
                        else if (powerbi.Double.isInteger(value))
                            return false;
                    }
                }
                if ((typeof value === 'number') || (typeof value2 === 'number')) {
                    return true;
                }
            }
            function shouldUseDateUnits(value, value2, tickCount) {
                // must check both value and value2 because we'll need to get an interval for date units
                return (value instanceof Date) && (value2 instanceof Date) && (tickCount !== undefined && tickCount !== null);
            }
            /*
             * Get the column format. Order of precendence is:
             *  1. Column format
             *  2. Default PowerView policy for column type
             */
            function getFormatString(column, formatStringProperty, suppressTypeFallback) {
                if (column) {
                    if (formatStringProperty) {
                        var propertyValue = powerbi.DataViewObjects.getValue(column.objects, formatStringProperty);
                        if (propertyValue)
                            return propertyValue;
                    }
                    if (!suppressTypeFallback) {
                        var columnType = column.type;
                        if (columnType) {
                            if (columnType.dateTime)
                                return valueFormatter.DefaultDateFormat;
                            if (columnType.integer)
                                return valueFormatter.DefaultIntegerFormat;
                            if (columnType.numeric)
                                return valueFormatter.DefaultNumericFormat;
                        }
                    }
                }
            }
            valueFormatter.getFormatString = getFormatString;
            function formatListCompound(strings, conjunction) {
                var result;
                if (!strings) {
                    return null;
                }
                var length = strings.length;
                if (length > 0) {
                    result = strings[0];
                    var lastIndex = length - 1;
                    for (var i = 1, len = lastIndex; i < len; i++) {
                        var value = strings[i];
                        result = StringExtensions.format(locale.restatementComma, result, value);
                    }
                    if (length > 1) {
                        var value = strings[lastIndex];
                        result = StringExtensions.format(conjunction, result, value);
                    }
                }
                else {
                    result = null;
                }
                return result;
            }
            /** The returned string will look like 'A, B, ..., and C'  */
            function formatListAnd(strings) {
                return formatListCompound(strings, locale.restatementCompoundAnd);
            }
            valueFormatter.formatListAnd = formatListAnd;
            /** The returned string will look like 'A, B, ..., or C' */
            function formatListOr(strings) {
                return formatListCompound(strings, locale.restatementCompoundOr);
            }
            valueFormatter.formatListOr = formatListOr;
            function formatCore(value, format) {
                var formattedValue = getStringFormat(value, false /*nullsAreBlank*/);
                if (!StringExtensions.isNullOrUndefinedOrWhiteSpaceString(formattedValue))
                    return formattedValue;
                return powerbi.formattingService.formatValue(value, format);
            }
            function getStringFormat(value, nullsAreBlank) {
                if (value == null && nullsAreBlank)
                    return locale.null;
                if (value === true)
                    return locale.true;
                if (value === false)
                    return locale.false;
                if (typeof value === 'number' && isNaN(value))
                    return locale.NaN;
                if (value === Number.NEGATIVE_INFINITY)
                    return locale.negativeInfinity;
                if (value === Number.POSITIVE_INFINITY)
                    return locale.infinity;
                return '';
            }
            function getDisplayUnits(displayUnitSystemType) {
                var displayUnitSystem = createDisplayUnitSystem(displayUnitSystemType);
                return displayUnitSystem.units;
            }
            valueFormatter.getDisplayUnits = getDisplayUnits;
        })(valueFormatter = visuals.valueFormatter || (visuals.valueFormatter = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataRoleHelper;
        (function (DataRoleHelper) {
            function getMeasureIndexOfRole(grouped, roleName) {
                if (!_.isEmpty(grouped)) {
                    var firstGroup = grouped[0];
                    if (firstGroup.values && firstGroup.values.length > 0) {
                        for (var i = 0, len = firstGroup.values.length; i < len; ++i) {
                            var value = firstGroup.values[i];
                            if (value && value.source) {
                                if (hasRole(value.source, roleName))
                                    return i;
                            }
                        }
                    }
                }
                return -1;
            }
            DataRoleHelper.getMeasureIndexOfRole = getMeasureIndexOfRole;
            function getCategoryIndexOfRole(categories, roleName) {
                if (!_.isEmpty(categories)) {
                    for (var i = 0, ilen = categories.length; i < ilen; i++) {
                        if (hasRole(categories[i].source, roleName))
                            return i;
                    }
                }
                return -1;
            }
            DataRoleHelper.getCategoryIndexOfRole = getCategoryIndexOfRole;
            function hasRole(column, name) {
                var roles = column.roles;
                return roles && roles[name];
            }
            DataRoleHelper.hasRole = hasRole;
            function hasRoleInDataView(dataView, name) {
                return dataView != null
                    && dataView.metadata != null
                    && dataView.metadata.columns
                    && _.any(dataView.metadata.columns, function (c) { return c.roles && c.roles[name] !== undefined; });
            }
            DataRoleHelper.hasRoleInDataView = hasRoleInDataView;
            function hasRoleInValueColumn(valueColumn, name) {
                return valueColumn && valueColumn.source && valueColumn.source.roles && (valueColumn.source.roles[name] === true);
            }
            DataRoleHelper.hasRoleInValueColumn = hasRoleInValueColumn;
        })(DataRoleHelper = data.DataRoleHelper || (data.DataRoleHelper = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        function createIDataViewCategoricalReader(dataView) {
            return new DataViewCategoricalReader(dataView);
        }
        data.createIDataViewCategoricalReader = createIDataViewCategoricalReader;
        var DataViewCategoricalReader = (function () {
            function DataViewCategoricalReader(dataView) {
                debug.assertValue(dataView, 'dataView');
                this.dataView = dataView;
                // Validate categories
                var categorical;
                if (dataView)
                    categorical = dataView.categorical;
                var categories;
                if (categorical)
                    categories = this.categories = categorical.categories;
                this.hasValidCategories = !_.isEmpty(categories);
                // Validate values
                var values;
                if (categorical)
                    values = categorical.values;
                // We need to access grouped as long as values is non-null; if it's an empty array (meaning there is a category + series), we'll use grouped for non-value stuff
                // TODO: think a bit more about how to represent this internally; Maybe split this up between hasGroup and hasValidValues or something
                this.hasAnyValidValues = false;
                if (values != null) {
                    var grouped = dataView.categorical.values.grouped();
                    if (grouped.length > 0) {
                        this.hasAnyValidValues = true;
                        this.grouped = grouped;
                        // Iterate through the first group's values to populate the valueRoleIndexMapping
                        var valueRoleIndexMapping = {};
                        var firstGroupValues = grouped[0].values;
                        for (var valueIndex = 0, valueCount = firstGroupValues.length; valueIndex < valueCount; valueIndex++) {
                            var valueRoles = firstGroupValues[valueIndex].source.roles;
                            for (var role in valueRoles) {
                                if (valueRoles[role]) {
                                    if (!valueRoleIndexMapping[role])
                                        valueRoleIndexMapping[role] = [];
                                    valueRoleIndexMapping[role].push(valueIndex);
                                }
                            }
                        }
                        this.valueRoleIndexMapping = valueRoleIndexMapping;
                    }
                }
                if (this.hasAnyValidValues)
                    this.dataHasDynamicSeries = !!this.dataView.categorical.values.source;
            }
            // Category methods
            DataViewCategoricalReader.prototype.hasCategories = function () {
                return this.hasValidCategories;
            };
            DataViewCategoricalReader.prototype.getCategoryCount = function () {
                if (this.hasValidCategories)
                    return this.categories[0].values.length;
                else
                    return 0;
            };
            DataViewCategoricalReader.prototype.getCategoryValues = function (roleName) {
                if (this.hasValidCategories) {
                    var categories = this.getCategoryFromRole(roleName);
                    return categories ? categories.values : undefined;
                }
            };
            DataViewCategoricalReader.prototype.getCategoryValue = function (roleName, categoryIndex) {
                if (this.hasValidCategories) {
                    var categories = this.getCategoryFromRole(roleName);
                    return categories ? categories.values[categoryIndex] : undefined;
                }
            };
            DataViewCategoricalReader.prototype.getCategoryColumn = function (roleName) {
                if (this.hasValidCategories)
                    return this.getCategoryFromRole(roleName);
            };
            DataViewCategoricalReader.prototype.getCategoryMetadataColumn = function (roleName) {
                if (this.hasValidCategories) {
                    var categories = this.getCategoryFromRole(roleName);
                    return categories ? categories.source : undefined;
                }
            };
            DataViewCategoricalReader.prototype.getCategoryColumnIdentityFields = function (roleName) {
                if (this.hasValidCategories) {
                    var categories = this.getCategoryFromRole(roleName);
                    return categories ? categories.identityFields : undefined;
                }
            };
            DataViewCategoricalReader.prototype.getCategoryDisplayName = function (roleName) {
                if (this.hasValidCategories) {
                    var targetColumn = this.getCategoryColumn(roleName);
                    if (targetColumn && targetColumn.source) {
                        return targetColumn.source.displayName;
                    }
                }
            };
            DataViewCategoricalReader.prototype.hasCompositeCategories = function () {
                if (this.hasValidCategories)
                    return this.categories.length > 1;
            };
            DataViewCategoricalReader.prototype.hasCategoryWithRole = function (roleName) {
                return DataRoleHelper.getCategoryIndexOfRole(this.categories, roleName) !== -1;
            };
            DataViewCategoricalReader.prototype.getCategoryObjects = function (roleName, categoryIndex) {
                if (this.hasValidCategories) {
                    var category = this.getCategoryFromRole(roleName);
                    if (category && category.objects) {
                        return category.objects[categoryIndex];
                    }
                }
            };
            DataViewCategoricalReader.prototype.getCategoryFromRole = function (roleName) {
                var categories = this.categories;
                return categories[DataRoleHelper.getCategoryIndexOfRole(categories, roleName)];
            };
            // Value and measure methods
            DataViewCategoricalReader.prototype.hasValues = function (roleName) {
                return this.valueRoleIndexMapping && !_.isEmpty(this.valueRoleIndexMapping[roleName]);
            };
            DataViewCategoricalReader.prototype.getValue = function (roleName, categoryIndex, seriesIndex) {
                if (seriesIndex === void 0) { seriesIndex = 0; }
                if (this.hasValues(roleName)) {
                    if (this.dataHasDynamicSeries) {
                        // For dynamic series, we only ever obtain the first value column from a role
                        return this.getValueInternal(roleName, categoryIndex, seriesIndex, 0);
                    }
                    else {
                        // For static series or single series, we obtain value columns from the first series
                        //    and use the seriesIndex to index into the value columns within the role
                        return this.getValueInternal(roleName, categoryIndex, 0, seriesIndex);
                    }
                }
            };
            DataViewCategoricalReader.prototype.getAllValuesForRole = function (roleName, categoryIndex, seriesIndex) {
                if (seriesIndex === void 0) { seriesIndex = 0; }
                if (this.hasValues(roleName)) {
                    var valuesInRole = [];
                    for (var roleValueIndex = void 0, roleValueCount = this.valueRoleIndexMapping[roleName].length; roleValueIndex < roleValueCount; roleValueIndex++) {
                        valuesInRole.push(this.getValueInternal(roleName, categoryIndex, seriesIndex, roleValueIndex));
                    }
                    return valuesInRole;
                }
            };
            /**
             * Obtains the value from grouped.
             *
             * Grouped:             [0] [1] [2] [3] (seriesIndex)
             *                         /   \
             * .values:       [T0] [V0] [V1] [T1] [V2] (valueColumnIndex)
             *                    /    \ \  \
             * v.values:  [0, 1, 2, 3, 4] [5, 6, 7, 8, 9] (categoryIndex)
             *
             *--------------------------------|
             *                      |Category |
             * Series|Value Columns |A B C D E|
             *--------------------------------|
             *      0|col0 (tooltip)|         |
             *       |col1 (value)  |         |
             *       |col2 (value)  |         |
             *       |col3 (tooltip)|         |
             *       |col4 (value)  |         |
             *--------------------------------|
             *      1|col0 (tooltip)|         |
             *       |col1 (value)  |0 1 2 3 4|
             *       |col2 (value)  |5 6 7 8 9|
             *       |col3 (tooltip)|         |
             *       |col4 (value)  |         |
             *--------------------------------|
             *      2|col0 (tooltip)|...      |
             *
             * valueColumnIndexInRole is for indexing into the values for a single role
             * valueColumnIndex is for indexing into the entire value array including
             * all roles
             *
             * The valueRoleIndexMapping converts roleValueIndex and role (value role
             * with an index of 1) into groupedValueIndex (2)
             *
             * Example: getValueInternal(V, 3, 1, 1) returns 8: The second group,
             * the second value column with role "value" (which is converted to a
             * groupedValueIndex of 2) and the fourth value within that value column.
             */
            DataViewCategoricalReader.prototype.getValueInternal = function (roleName, categoryIndex, groupIndex, valueColumnIndexInRole) {
                if (this.hasValues(roleName)) {
                    var valueColumnIndex = this.valueRoleIndexMapping[roleName][valueColumnIndexInRole];
                    return this.grouped[groupIndex].values[valueColumnIndex].values[categoryIndex];
                }
            };
            DataViewCategoricalReader.prototype.getFirstNonNullValueForCategory = function (roleName, categoryIndex) {
                if (this.hasValues(roleName)) {
                    if (!this.dataHasDynamicSeries) {
                        debug.assert(this.grouped.length === 1, "getFirstNonNullValueForCategory shouldn't be called if you have a static series");
                        return this.getValue(roleName, categoryIndex);
                    }
                    for (var seriesIndex = 0, seriesCount = this.grouped.length; seriesIndex < seriesCount; seriesIndex++) {
                        var value = this.getValue(roleName, categoryIndex, seriesIndex);
                        if (value != null) {
                            return value;
                        }
                    }
                }
            };
            DataViewCategoricalReader.prototype.getMeasureQueryName = function (roleName) {
                if (this.hasValues(roleName))
                    return this.grouped[0].values[this.valueRoleIndexMapping[roleName][0]].source.queryName;
            };
            DataViewCategoricalReader.prototype.getValueColumn = function (roleName, seriesIndex) {
                if (seriesIndex === void 0) { seriesIndex = 0; }
                if (this.hasValues(roleName))
                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]];
            };
            DataViewCategoricalReader.prototype.getValueMetadataColumn = function (roleName, seriesIndex) {
                if (seriesIndex === void 0) { seriesIndex = 0; }
                if (this.hasValues(roleName))
                    return this.grouped[seriesIndex].values[this.valueRoleIndexMapping[roleName][0]].source;
            };
            DataViewCategoricalReader.prototype.getValueDisplayName = function (roleName, seriesIndex) {
                if (this.hasValues(roleName)) {
                    var targetColumn = this.getValueColumn(roleName, seriesIndex);
                    if (targetColumn && targetColumn.source) {
                        return targetColumn.source.displayName;
                    }
                }
            };
            // Series methods
            DataViewCategoricalReader.prototype.hasDynamicSeries = function () {
                return this.dataHasDynamicSeries;
            };
            DataViewCategoricalReader.prototype.getSeriesCount = function () {
                if (this.hasAnyValidValues)
                    return this.grouped.length;
            };
            DataViewCategoricalReader.prototype.getSeriesObjects = function (seriesIndex) {
                if (this.hasAnyValidValues)
                    return this.grouped[seriesIndex].objects;
            };
            DataViewCategoricalReader.prototype.getSeriesValueColumns = function () {
                if (this.hasAnyValidValues)
                    return this.dataView.categorical.values;
            };
            DataViewCategoricalReader.prototype.getSeriesValueColumnGroup = function (seriesIndex) {
                if (this.hasAnyValidValues)
                    return this.grouped[seriesIndex];
            };
            DataViewCategoricalReader.prototype.getSeriesMetadataColumn = function () {
                if (this.hasAnyValidValues)
                    return this.dataView.categorical.values.source;
            };
            DataViewCategoricalReader.prototype.getSeriesColumnIdentityFields = function () {
                if (this.hasAnyValidValues)
                    return this.dataView.categorical.values.identityFields;
            };
            DataViewCategoricalReader.prototype.getSeriesName = function (seriesIndex) {
                if (this.hasAnyValidValues)
                    return this.grouped[seriesIndex].name;
            };
            DataViewCategoricalReader.prototype.getSeriesDisplayName = function () {
                if (this.hasAnyValidValues && this.dataHasDynamicSeries)
                    return this.dataView.categorical.values.source.displayName;
            };
            return DataViewCategoricalReader;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inherit = powerbi.Prototype.inherit;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var valueFormatter = powerbi.visuals.valueFormatter;
        var DataViewConcatenateCategoricalColumns;
        (function (DataViewConcatenateCategoricalColumns) {
            function detectAndApply(dataView, objectDescriptors, roleMappings, projectionOrdering, selects, projectionActiveItems) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(roleMappings, 'roleMappings');
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                var result = dataView;
                var dataViewCategorical = dataView.categorical;
                if (dataViewCategorical) {
                    var concatenationSource = detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, dataView.metadata, roleMappings, selects, projectionActiveItems);
                    if (concatenationSource) {
                        // Consider: Perhaps the re-ordering of categorical columns should happen in the function transformSelects(...) of dataViewTransform?
                        var columnsSortedByProjectionOrdering = sortColumnsByProjectionOrdering(projectionOrdering, concatenationSource.roleName, concatenationSource.categories);
                        if (columnsSortedByProjectionOrdering.length >= 2) {
                            var activeItemsToIgnoreInConcatenation = _.chain(projectionActiveItems[concatenationSource.roleName])
                                .filter(function (activeItemInfo) { return activeItemInfo.suppressConcat; })
                                .map(function (activeItemInfo) { return activeItemInfo.queryRef; })
                                .value();
                            result = applyConcatenation(dataView, objectDescriptors, concatenationSource.roleName, columnsSortedByProjectionOrdering, activeItemsToIgnoreInConcatenation);
                        }
                    }
                }
                return result;
            }
            DataViewConcatenateCategoricalColumns.detectAndApply = detectAndApply;
            /** For applying concatenation to the DataViewCategorical that is the data for one of the frames in a play chart. */
            function applyToPlayChartCategorical(metadata, objectDescriptors, categoryRoleName, categorical) {
                debug.assertValue(metadata, 'metadata');
                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(categorical, 'categorical');
                var result;
                if (!_.isEmpty(categorical.categories) && categorical.categories.length >= 2) {
                    // In PlayChart, the code converts the Visual DataView with a matrix into multiple Visual DataViews, each with a categorical.
                    // metadata and metadata.columns could already be inherited objects as they come from the Visual DataView with a matrix.
                    // To guarantee that this method does not have any side effect on prototypeMetadata (which might already be an inherited obj),
                    // use inherit() rather than inheritSingle() here.
                    var transformingColumns_1 = inherit(metadata.columns);
                    var transformingMetadata = inherit(metadata, function (m) { m.columns = transformingColumns_1; });
                    var transformingDataView = { metadata: transformingMetadata, categorical: categorical };
                    result = applyConcatenation(transformingDataView, objectDescriptors, categoryRoleName, categorical.categories, []);
                }
                else {
                    result = { metadata: metadata, categorical: categorical };
                }
                return result;
            }
            DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical = applyToPlayChartCategorical;
            /**
             * Returns the role and its assocated category columns (from dataViewCategorical.categories)
             * that should be concatenated for the case of hierarchical group.
             *
             * Note: In the future if we support sibling hierarchical groups in categorical,
             * change the return type to CategoryColumnsByRole[] and update detection logic.
             */
            function detectCategoricalRoleForHierarchicalGroup(dataViewCategorical, metadata, dataViewMappings, selects, projectionActiveItems) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertAnyValue(dataViewMappings, 'dataViewMappings');
                var result;
                // For now, just handle the case where roleMappings.length === 1.
                // In the future, if there is more than 1, we might want to proceed if, 
                // for example, all role mappings map category to the same role name and they all have { max: 1 } conditions.
                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, metadata);
                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);
                var roleMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;
                var roleMappingForCategorical = (roleMappings && roleMappings.length === 1 && !!roleMappings[0].categorical) ? roleMappings[0] : undefined;
                if (roleMappingForCategorical) {
                    var roleNamesForCategory = getAllRolesInCategories(roleMappingForCategorical.categorical);
                    // With "list" in role mapping, is it possible to have multiple role names for category.
                    // For now, proceed to concatenate category columns only when categories are bound to 1 Role.
                    // We can change this if we want to support independent (sibling) group hierarchies in categorical.
                    if (roleNamesForCategory && roleNamesForCategory.length === 1) {
                        var targetRoleName_1 = roleNamesForCategory[0];
                        var isVisualExpectingMaxOneCategoryColumn = !_.isEmpty(roleMappingForCategorical.conditions) &&
                            _.every(roleMappingForCategorical.conditions, function (condition) { return condition[targetRoleName_1] && condition[targetRoleName_1].max === 1; });
                        if (isVisualExpectingMaxOneCategoryColumn) {
                            var categoriesForTargetRole_1 = _.filter(dataViewCategorical.categories, function (categoryColumn) { return categoryColumn.source.roles && !!categoryColumn.source.roles[targetRoleName_1]; });
                            // At least for now, we expect all category columns for the same role to have the same number of value entries.
                            // If that's not the case, we won't run the concatenate logic for that role at all...
                            var areValuesCountsEqual = _.every(categoriesForTargetRole_1, function (categoryColumn) { return categoryColumn.values.length === categoriesForTargetRole_1[0].values.length; });
                            // Also, there is no need to concatenate columns unless there is actually more than one column
                            if (areValuesCountsEqual &&
                                categoriesForTargetRole_1.length >= 2) {
                                result = {
                                    roleName: targetRoleName_1,
                                    categories: categoriesForTargetRole_1
                                };
                            }
                        }
                    }
                }
                return result;
            }
            /**
             * Returns the array of role names that are mapped to categorical categories.
             * Returns an empty array if none exists.
             */
            function getAllRolesInCategories(categoricalRoleMapping) {
                debug.assertValue(categoricalRoleMapping, 'categoricalRoleMapping');
                var roleNames = [];
                powerbi.DataViewMapping.visitCategoricalCategories(categoricalRoleMapping.categories, {
                    visitRole: function (roleName) {
                        roleNames.push(roleName);
                    }
                });
                return roleNames;
            }
            function applyConcatenation(dataView, objectDescriptors, roleName, columnsSortedByProjectionOrdering, queryRefsToIgnore) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(roleName, 'roleName');
                debug.assert(columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2, 'columnsSortedByProjectionOrdering && columnsSortedByProjectionOrdering.length >= 2');
                var formatStringPropId = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);
                var concatenatedValues = concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId);
                var columnsSourceSortedByProjectionOrdering = _.map(columnsSortedByProjectionOrdering, function (categoryColumn) { return categoryColumn.source; });
                var concatenatedColumnMetadata = createConcatenatedColumnMetadata(roleName, columnsSourceSortedByProjectionOrdering, queryRefsToIgnore);
                var transformedDataView = inheritSingle(dataView);
                addToMetadata(transformedDataView, concatenatedColumnMetadata);
                var concatenatedCategoryColumn = createConcatenatedCategoryColumn(columnsSortedByProjectionOrdering, concatenatedColumnMetadata, concatenatedValues);
                var dataViewCategorical = dataView.categorical;
                var transformedCategoricalCategories = _.difference(dataViewCategorical.categories, columnsSortedByProjectionOrdering);
                transformedCategoricalCategories.push(concatenatedCategoryColumn);
                var transformedCategorical = inheritSingle(dataViewCategorical);
                transformedCategorical.categories = transformedCategoricalCategories;
                transformedDataView.categorical = transformedCategorical;
                return transformedDataView;
            }
            function concatenateValues(columnsSortedByProjectionOrdering, queryRefsToIgnore, formatStringPropId) {
                debug.assertValue(columnsSortedByProjectionOrdering, 'columnsSortedByProjectionOrdering');
                debug.assertAnyValue(queryRefsToIgnore, 'queryRefsToIgnore');
                debug.assertAnyValue(formatStringPropId, 'formatStringPropId');
                var concatenatedValues = [];
                // concatenate the values in dataViewCategorical.categories[0..length-1].values[j], and store it in combinedValues[j]
                for (var _i = 0, columnsSortedByProjectionOrdering_1 = columnsSortedByProjectionOrdering; _i < columnsSortedByProjectionOrdering_1.length; _i++) {
                    var categoryColumn = columnsSortedByProjectionOrdering_1[_i];
                    var formatString = valueFormatter.getFormatString(categoryColumn.source, formatStringPropId);
                    for (var i = 0, len = categoryColumn.values.length; i < len; i++) {
                        if (!_.contains(queryRefsToIgnore, categoryColumn.source.queryName)) {
                            var value = categoryColumn.values && categoryColumn.values[i];
                            var formattedValue = valueFormatter.format(value, formatString);
                            concatenatedValues[i] = (concatenatedValues[i] === undefined) ? formattedValue : (formattedValue + ' ' + concatenatedValues[i]);
                        }
                    }
                }
                return concatenatedValues;
            }
            /**
            * Returns a new array of elements from columns as they are ordered for the specified roleName in the specified projectionOrdering.
            */
            function sortColumnsByProjectionOrdering(projectionOrdering, roleName, columns) {
                debug.assertAnyValue(projectionOrdering, 'projectionOrdering');
                debug.assertValue(roleName, 'roleName');
                debug.assertValue(columns, 'columns');
                var columnsInProjectionOrdering;
                if (projectionOrdering) {
                    // the numeric values in projectionOrdering correspond to the index property of DataViewMetadataColumn
                    var columnsByIndex_1 = {};
                    for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                        var column = columns_1[_i];
                        if (column.source.roles[roleName]) {
                            debug.assert(!columnsByIndex_1[column.source.index], 'The specified columns should not contain multiple columns with same index: ' + column.source.index);
                            columnsByIndex_1[column.source.index] = column;
                        }
                    }
                    var columnIndicesInProjectionOrdering = projectionOrdering[roleName];
                    columnsInProjectionOrdering = _.chain(columnIndicesInProjectionOrdering)
                        .map(function (columnIndex) { return columnsByIndex_1[columnIndex]; })
                        .filter(function (column) { return !!column; })
                        .value();
                }
                else {
                    // If projectionOrder is unspecified, just return the columns for the specified role in their current order
                    columnsInProjectionOrdering = _.filter(columns, function (column) { return column.source.roles[roleName]; });
                }
                return columnsInProjectionOrdering;
            }
            /**
             * Creates the column metadata that will back the column with the concatenated values.
             */
            function createConcatenatedColumnMetadata(roleName, sourceColumnsSortedByProjectionOrdering, queryRefsToIgnore) {
                debug.assertValue(roleName, 'roleName');
                debug.assertNonEmpty(sourceColumnsSortedByProjectionOrdering, 'sourceColumnsSortedByProjectionOrdering');
                debug.assert(_.chain(sourceColumnsSortedByProjectionOrdering).map(function (c) { return c.isMeasure; }).uniq().value().length === 1, 'pre-condition: caller code should not attempt to combine a mix of measure columns and non-measure columns');
                var concatenatedDisplayName;
                for (var _i = 0, sourceColumnsSortedByProjectionOrdering_1 = sourceColumnsSortedByProjectionOrdering; _i < sourceColumnsSortedByProjectionOrdering_1.length; _i++) {
                    var columnSource = sourceColumnsSortedByProjectionOrdering_1[_i];
                    if (!_.contains(queryRefsToIgnore, columnSource.queryName)) {
                        concatenatedDisplayName = (concatenatedDisplayName == null) ? columnSource.displayName : (columnSource.displayName + ' ' + concatenatedDisplayName);
                    }
                }
                var newRoles = {};
                newRoles[roleName] = true;
                var newColumnMetadata = {
                    displayName: concatenatedDisplayName,
                    roles: newRoles,
                    type: powerbi.ValueType.fromPrimitiveTypeAndCategory(powerbi.PrimitiveType.Text)
                };
                var columnSourceForCurrentDrillLevel = _.last(sourceColumnsSortedByProjectionOrdering);
                if (columnSourceForCurrentDrillLevel.isMeasure !== undefined) {
                    newColumnMetadata.isMeasure = columnSourceForCurrentDrillLevel.isMeasure;
                }
                // TODO VSTS 6842046: Investigate whether we should change that property to mandatory or change the Chart visual code.
                // If queryName is not set at all, the column chart visual will only render column for the first group instance.
                // If queryName is set to any string other than columnForCurrentDrillLevel.source.queryName, then drilldown by group instance is broken (VSTS 6847879).
                newColumnMetadata.queryName = columnSourceForCurrentDrillLevel.queryName;
                return newColumnMetadata;
            }
            function addToMetadata(transformedDataView, newColumn) {
                debug.assertValue(transformedDataView, 'transformedDataView');
                debug.assertValue(newColumn, 'newColumn');
                var transformedColumns = inheritSingle(transformedDataView.metadata.columns);
                transformedColumns.push(newColumn);
                var transformedMetadata = inheritSingle(transformedDataView.metadata);
                transformedMetadata.columns = transformedColumns;
                transformedDataView.metadata = transformedMetadata;
            }
            function createConcatenatedCategoryColumn(sourceColumnsSortedByProjectionOrdering, columnMetadata, concatenatedValues) {
                debug.assert(sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2, 'sourceColumnsSortedByProjectionOrdering && sourceColumnsSortedByProjectionOrdering.length >= 2');
                var newCategoryColumn = {
                    source: columnMetadata,
                    values: concatenatedValues
                };
                // We expect every DataViewCategoryColumn in concatenationSourceColumns to have the same set of identities, always.
                // So, we'll just take the identities and identityFields from the first column
                var firstColumn = sourceColumnsSortedByProjectionOrdering[0];
                if (firstColumn.identity) {
                    newCategoryColumn.identity = firstColumn.identity;
                }
                if (firstColumn.identityFields) {
                    newCategoryColumn.identityFields = firstColumn.identityFields;
                }
                // It is safe to look at the first column as it is the one that is being set by findSelectedCategoricalColumn
                if (firstColumn.objects) {
                    newCategoryColumn.objects = firstColumn.objects;
                }
                return newCategoryColumn;
            }
        })(DataViewConcatenateCategoricalColumns = data.DataViewConcatenateCategoricalColumns || (data.DataViewConcatenateCategoricalColumns = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewMapping;
    (function (DataViewMapping) {
        function visitMapping(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var categorical = mapping.categorical;
            if (categorical)
                visitCategorical(categorical, visitor);
            var table = mapping.table;
            if (table)
                visitTable(table, visitor);
            var matrix = mapping.matrix;
            if (matrix)
                visitMatrix(matrix, visitor);
            var tree = mapping.tree;
            if (tree)
                visitTree(tree, visitor);
            var single = mapping.single;
            if (single)
                visitSingle(single, visitor);
        }
        DataViewMapping.visitMapping = visitMapping;
        function visitCategorical(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            visitCategoricalCategories(mapping.categories, visitor);
            visitCategoricalValues(mapping.values, visitor);
        }
        DataViewMapping.visitCategorical = visitCategorical;
        function visitCategoricalCategories(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitBind(mapping, visitor);
                visitFor(mapping, visitor);
                visitList(mapping, visitor);
                visitReduction(mapping, visitor);
            }
        }
        DataViewMapping.visitCategoricalCategories = visitCategoricalCategories;
        function visitCategoricalValues(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitBind(mapping, visitor, 0 /* CategoricalValue */);
                visitFor(mapping, visitor, 0 /* CategoricalValue */);
                visitList(mapping, visitor, 0 /* CategoricalValue */);
                var groupedRoleMapping = mapping;
                visitGrouped(groupedRoleMapping, visitor);
                var group = groupedRoleMapping.group;
                if (group) {
                    for (var _i = 0, _a = group.select; _i < _a.length; _i++) {
                        var item = _a[_i];
                        visitBind(item, visitor, 1 /* CategoricalValueGroup */);
                        visitFor(item, visitor, 1 /* CategoricalValueGroup */);
                    }
                }
            }
        }
        DataViewMapping.visitCategoricalValues = visitCategoricalValues;
        function visitTable(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var rows = mapping.rows;
            visitBind(rows, visitor);
            visitFor(rows, visitor);
            visitList(rows, visitor);
            visitReduction(rows, visitor);
        }
        DataViewMapping.visitTable = visitTable;
        function visitMatrix(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            visitMatrixItems(mapping.rows, visitor);
            visitMatrixItems(mapping.columns, visitor);
            visitMatrixItems(mapping.values, visitor);
        }
        /**
         * For visiting DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.
         *
         * @param mapping Can be one of DataViewMatrixMapping.rows, DataViewMatrixMapping.columns, or DataViewMatrixMapping.values.
         * @param visitor The visitor.
         */
        function visitMatrixItems(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitFor(mapping, visitor);
                visitList(mapping, visitor);
                visitReduction(mapping, visitor);
            }
        }
        DataViewMapping.visitMatrixItems = visitMatrixItems;
        function visitTree(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            visitTreeNodes(mapping.nodes, visitor);
            visitTreeValues(mapping.values, visitor);
        }
        function visitTreeNodes(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitFor(mapping, visitor);
                visitReduction(mapping, visitor);
            }
        }
        DataViewMapping.visitTreeNodes = visitTreeNodes;
        function visitTreeValues(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (mapping) {
                visitFor(mapping, visitor);
            }
        }
        DataViewMapping.visitTreeValues = visitTreeValues;
        function visitBind(mapping, visitor, context) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var bind = mapping.bind;
            if (bind) {
                if (context != null)
                    visitor.visitRole(bind.to, context);
                else
                    visitor.visitRole(bind.to);
            }
        }
        function visitFor(mapping, visitor, context) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var forValue = mapping.for;
            if (forValue) {
                if (context != null)
                    visitor.visitRole(forValue.in, context);
                else
                    visitor.visitRole(forValue.in);
            }
        }
        function visitList(mapping, visitor, context) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            var select = mapping.select;
            if (select) {
                for (var _i = 0, select_1 = select; _i < select_1.length; _i++) {
                    var item = select_1[_i];
                    visitBind(item, visitor, context);
                    visitFor(item, visitor, context);
                }
            }
        }
        function visitGrouped(mapping, visitor) {
            debug.assertAnyValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (!mapping)
                return;
            var group = mapping.group;
            if (group) {
                visitor.visitRole(group.by);
                visitReduction(group, visitor);
            }
        }
        DataViewMapping.visitGrouped = visitGrouped;
        function visitReduction(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            if (visitor.visitReduction) {
                var reductionAlgorithm = mapping.dataReductionAlgorithm;
                if (reductionAlgorithm) {
                    visitor.visitReduction(reductionAlgorithm);
                }
            }
        }
        function visitSingle(mapping, visitor) {
            debug.assertValue(mapping, 'mapping');
            debug.assertValue(visitor, 'visitor');
            visitor.visitRole(mapping.role);
        }
    })(DataViewMapping = powerbi.DataViewMapping || (powerbi.DataViewMapping = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var DataViewNormalizeValues;
        (function (DataViewNormalizeValues) {
            function apply(options) {
                debug.assertValue(options, 'options');
                var rolesToNormalize = _.filter(options.dataRoles, function (role) { return !_.isEmpty(role.requiredTypes); });
                filterVariantMeasures(options.dataview, options.dataViewMappings, rolesToNormalize);
            }
            DataViewNormalizeValues.apply = apply;
            function filterVariantMeasures(dataview, dataViewMappings, rolesToNormalize) {
                debug.assertValue(dataview, 'dataview');
                // Don't perform this unless we actually have dataViewMappings and variant measures to suppress
                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.
                if (_.isEmpty(dataViewMappings) || _.isEmpty(rolesToNormalize))
                    return;
                var columnFilter = generateMetadataColumnFilter(dataview.metadata.columns, rolesToNormalize);
                var valueFilter = generateValueFilter(dataview.metadata.columns, rolesToNormalize);
                var usedMappings = {};
                for (var _i = 0, dataViewMappings_1 = dataViewMappings; _i < dataViewMappings_1.length; _i++) {
                    var dataViewMapping = dataViewMappings_1[_i];
                    // Get dataview specified in mappings which are also in dataview
                    for (var dataViewMappingProp in dataViewMapping) {
                        if (dataview[dataViewMappingProp] != null)
                            usedMappings[dataViewMappingProp] = true;
                    }
                }
                if (usedMappings['categorical'])
                    filterVariantMeasuresCategorical(dataview.categorical, columnFilter, valueFilter);
                if (usedMappings['table'])
                    filterVariantMeasuresTable(dataview.table, columnFilter, valueFilter);
                if (usedMappings['tree'])
                    filterVariantMeasuresTreeNode(dataview.tree.root, columnFilter, valueFilter);
                if (usedMappings['matrix'])
                    filterVariantMeasuresMatrix(dataview.matrix, columnFilter, valueFilter);
                if (usedMappings['single'])
                    filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter);
            }
            DataViewNormalizeValues.filterVariantMeasures = filterVariantMeasures;
            function generateMetadataColumnFilter(columns, rolesToNormalize) {
                if (!columns || !rolesToNormalize)
                    return function () { return false; };
                var columnsToNormalize = {};
                for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {
                    var column = columns_2[_i];
                    var roles = column.roles;
                    if (!roles)
                        continue;
                    for (var _a = 0, rolesToNormalize_1 = rolesToNormalize; _a < rolesToNormalize_1.length; _a++) {
                        var role = rolesToNormalize_1[_a];
                        if (!roles[role.name])
                            continue;
                        columnsToNormalize[column.index] = true;
                        break;
                    }
                }
                return function (columnIndex) {
                    if (isNaN(columnIndex))
                        return false;
                    return !!columnsToNormalize[columnIndex];
                };
            }
            DataViewNormalizeValues.generateMetadataColumnFilter = generateMetadataColumnFilter;
            function generateValueFilter(columns, rolesToNormalize) {
                if (!columns || !rolesToNormalize)
                    return function () { return true; };
                var columnValueFilters = [];
                // Build columnValueFilters based on role requiredTypes
                for (var _i = 0, columns_3 = columns; _i < columns_3.length; _i++) {
                    var column = columns_3[_i];
                    var columnValueFilter = generateColumnValueFilter(column, rolesToNormalize);
                    if (columnValueFilter)
                        columnValueFilters[column.index] = columnValueFilter;
                }
                return function (columnIndex, value) {
                    if (columnValueFilters[columnIndex])
                        return columnValueFilters[columnIndex](value);
                    return true;
                };
            }
            DataViewNormalizeValues.generateValueFilter = generateValueFilter;
            function generateColumnValueFilter(column, rolesToNormalize) {
                var requiredTypes = getColumnRequiredTypes(column, rolesToNormalize);
                if (_.isEmpty(requiredTypes))
                    return;
                return function (value) {
                    return doesValueMatchTypes(value, requiredTypes);
                };
            }
            function getColumnRequiredTypes(column, rolesToNormalize) {
                var requiredTypes = [];
                var columnRoles = column && column.roles;
                if (!columnRoles)
                    return requiredTypes;
                for (var _i = 0, rolesToNormalize_2 = rolesToNormalize; _i < rolesToNormalize_2.length; _i++) {
                    var role = rolesToNormalize_2[_i];
                    if (!columnRoles[role.name])
                        continue;
                    for (var _a = 0, _b = role.requiredTypes; _a < _b.length; _a++) {
                        var typeDescriptor = _b[_a];
                        var type = powerbi.ValueType.fromDescriptor(typeDescriptor);
                        requiredTypes.push(type);
                    }
                }
                return requiredTypes;
            }
            DataViewNormalizeValues.getColumnRequiredTypes = getColumnRequiredTypes;
            function filterVariantMeasuresCategorical(dataview, columnFilter, valueFilter) {
                var values = dataview && dataview.values;
                if (!values)
                    return;
                var valuesGrouped = values.grouped();
                if (!valuesGrouped)
                    return;
                for (var _i = 0, valuesGrouped_1 = valuesGrouped; _i < valuesGrouped_1.length; _i++) {
                    var valueGroup = valuesGrouped_1[_i];
                    var valuesInGroup = valueGroup.values;
                    for (var _a = 0, valuesInGroup_1 = valuesInGroup; _a < valuesInGroup_1.length; _a++) {
                        var valueColumn = valuesInGroup_1[_a];
                        var columnIndex = valueColumn.source.index;
                        if (!columnFilter(columnIndex))
                            continue;
                        for (var i = 0, ilen = valueColumn.values.length; i < ilen; i++) {
                            valueColumn.values = normalizeVariant(valueColumn.values, i, columnIndex, valueFilter);
                        }
                    }
                }
            }
            function filterVariantMeasuresTable(dataview, columnFilter, valueFilter) {
                var columns = dataview && dataview.columns;
                if (!columns)
                    return;
                var filteredColumns = [];
                for (var _i = 0, columns_4 = columns; _i < columns_4.length; _i++) {
                    var column = columns_4[_i];
                    if (columnFilter(column.index))
                        filteredColumns.push(column.index);
                }
                var rows = dataview.rows;
                for (var i = 0, ilen = rows.length; i < ilen; i++) {
                    for (var _a = 0, filteredColumns_1 = filteredColumns; _a < filteredColumns_1.length; _a++) {
                        var index = filteredColumns_1[_a];
                        rows[i] = normalizeVariant(rows[i], index, index, valueFilter);
                    }
                }
            }
            function filterVariantMeasuresTreeNode(node, columnFilter, valueFilter) {
                if (node.values) {
                    for (var columnIndex in node.values) {
                        // In dataView.tree, the keys in node.values correspond to columnIndex of the node value
                        if (columnFilter(columnIndex)) {
                            // According to nojorgen, it is possible to have primitive values as values in the node.values dictionary.
                            if (typeof (node.values[columnIndex]) === 'object' && ('value' in node.values[columnIndex]))
                                node.values[columnIndex] = normalizeVariant(node.values[columnIndex], 'value', columnIndex, valueFilter);
                            else
                                node.values = normalizeVariant(node.values, columnIndex, columnIndex, valueFilter);
                        }
                    }
                }
                else if (node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var child = _a[_i];
                        filterVariantMeasuresTreeNode(child, columnFilter, valueFilter);
                    }
                }
            }
            function filterVariantMeasuresMatrix(dataview, columnFilter, valueFilter) {
                var root = dataview && dataview.rows && dataview.rows.root;
                if (!root)
                    return;
                // Recurse into rows.children
                // e.g. rows.children -> .children -> .children.values
                filterVariantMeasuresMatrixRecursive(dataview, root, columnFilter, valueFilter);
            }
            function filterVariantMeasuresMatrixRecursive(dataviewMatrix, node, columnFilter, valueFilter) {
                if (node.values) {
                    for (var id in node.values) {
                        // Note related to VSTS 6547124: In dataView.matrix, the keys in node.values are NOT equivalent to value.valueSourceIndex.
                        var nodeValue = node.values[id];
                        // the property DataViewMatrixNodeValue.valueSourceIndex will not exist if valueSourceIndex is 0 for that value
                        var valueSourceIndex = nodeValue.valueSourceIndex || 0;
                        // index is an optional property on DataViewMetadataColumn, but I am not sure when it will ever be undefined in a matrix' column metadata
                        var columnIndex = dataviewMatrix.valueSources[valueSourceIndex].index;
                        if (_.isNumber(columnIndex) && columnFilter(columnIndex)) {
                            node.values[id] = normalizeVariant(nodeValue, 'value', columnIndex, valueFilter);
                        }
                    }
                }
                else if (node.children) {
                    for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                        var child = _a[_i];
                        filterVariantMeasuresMatrixRecursive(dataviewMatrix, child, columnFilter, valueFilter);
                    }
                }
            }
            function filterVariantMeasuresSingle(dataview, dataViewMappings, rolesToNormalize, valueFilter) {
                if (!dataview.single)
                    return;
                var roleNames = [];
                for (var _i = 0, rolesToNormalize_3 = rolesToNormalize; _i < rolesToNormalize_3.length; _i++) {
                    var role = rolesToNormalize_3[_i];
                    if (role.name)
                        roleNames.push(role.name);
                }
                var columns = dataview.metadata.columns;
                for (var _a = 0, dataViewMappings_2 = dataViewMappings; _a < dataViewMappings_2.length; _a++) {
                    var dataViewMapping = dataViewMappings_2[_a];
                    var roleName = dataViewMapping.single.role;
                    if (roleNames.indexOf(roleName) !== -1) {
                        var column = firstColumnByRoleName(columns, roleName);
                        if (column)
                            dataview.single = normalizeVariant(dataview.single, 'value', column.index, valueFilter);
                        return;
                    }
                }
            }
            function normalizeVariant(object, key, columnIndex, valueFilter) {
                if (!object)
                    return;
                var value = object[key];
                if (value !== null && !valueFilter(columnIndex, value)) {
                    object = inheritSingle(object);
                    object[key] = null;
                }
                return object;
            }
            DataViewNormalizeValues.normalizeVariant = normalizeVariant;
            function doesValueMatchTypes(value, types) {
                for (var _i = 0, types_1 = types; _i < types_1.length; _i++) {
                    var type = types_1[_i];
                    if (type.numeric || type.integer)
                        return typeof (value) === 'number';
                }
                return false;
            }
            function firstColumnByRoleName(columns, roleName) {
                for (var _i = 0, columns_5 = columns; _i < columns_5.length; _i++) {
                    var column = columns_5[_i];
                    var columnRoles = column && column.roles;
                    if (columnRoles && columnRoles[roleName])
                        return column;
                }
            }
        })(DataViewNormalizeValues = data.DataViewNormalizeValues || (data.DataViewNormalizeValues = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewObjects;
    (function (DataViewObjects) {
        /** Gets the value of the given object/property pair. */
        function getValue(objects, propertyId, defaultValue) {
            debug.assertAnyValue(objects, 'objects');
            debug.assertValue(propertyId, 'propertyId');
            if (!objects)
                return defaultValue;
            var objectOrMap = objects[propertyId.objectName];
            debug.assert(!isUserDefined(objectOrMap), 'expected DataViewObject');
            var object = objectOrMap;
            return DataViewObject.getValue(object, propertyId.propertyName, defaultValue);
        }
        DataViewObjects.getValue = getValue;
        /** Gets an object from objects. */
        function getObject(objects, objectName, defaultValue) {
            if (objects && objects[objectName]) {
                var object = objects[objectName];
                debug.assert(!isUserDefined(object), 'expected DataViewObject');
                return object;
            }
            else {
                return defaultValue;
            }
        }
        DataViewObjects.getObject = getObject;
        /** Gets a map of user-defined objects. */
        function getUserDefinedObjects(objects, objectName) {
            if (objects && objects[objectName]) {
                var map = objects[objectName];
                debug.assert(isUserDefined(map), 'expected DataViewObjectMap');
                return map;
            }
        }
        DataViewObjects.getUserDefinedObjects = getUserDefinedObjects;
        /** Gets the solid color from a fill property. */
        function getFillColor(objects, propertyId, defaultColor) {
            var value = getValue(objects, propertyId);
            if (!value || !value.solid)
                return defaultColor;
            return value.solid.color;
        }
        DataViewObjects.getFillColor = getFillColor;
        /** Returns true if the given object represents a collection of user-defined objects */
        function isUserDefined(objectOrMap) {
            return _.isArray(objectOrMap);
        }
        DataViewObjects.isUserDefined = isUserDefined;
    })(DataViewObjects = powerbi.DataViewObjects || (powerbi.DataViewObjects = {}));
    var DataViewObject;
    (function (DataViewObject) {
        function getValue(object, propertyName, defaultValue) {
            debug.assertAnyValue(object, 'object');
            debug.assertValue(propertyName, 'propertyName');
            if (!object)
                return defaultValue;
            var propertyValue = object[propertyName];
            if (propertyValue === undefined)
                return defaultValue;
            return propertyValue;
        }
        DataViewObject.getValue = getValue;
        /** Gets the solid color from a fill property using only a propertyName */
        function getFillColorByPropertyName(objects, propertyName, defaultColor) {
            var value = DataViewObject.getValue(objects, propertyName);
            if (!value || !value.solid)
                return defaultColor;
            return value.solid.color;
        }
        DataViewObject.getFillColorByPropertyName = getFillColorByPropertyName;
    })(DataViewObject = powerbi.DataViewObject || (powerbi.DataViewObject = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var JsonComparer = jsCommon.JsonComparer;
        var DataViewObjectDefinitions;
        (function (DataViewObjectDefinitions) {
            /** Creates or reuses a DataViewObjectDefinition for matching the given objectName and selector within the defns. */
            function ensure(defns, objectName, selector) {
                debug.assertValue(defns, 'defns');
                var defnsForObject = defns[objectName];
                if (!defnsForObject)
                    defns[objectName] = defnsForObject = [];
                for (var i = 0, len = defnsForObject.length; i < len; i++) {
                    var defn = defnsForObject[i];
                    if (data.Selector.equals(defn.selector, selector))
                        return defn;
                }
                var newDefn = {
                    selector: selector,
                    properties: {},
                };
                defnsForObject.push(newDefn);
                return newDefn;
            }
            DataViewObjectDefinitions.ensure = ensure;
            function deleteProperty(defns, objectName, selector, propertyName) {
                debug.assertValue(defns, 'defns');
                var defn = getObjectDefinition(defns, objectName, selector);
                if (!defn)
                    return;
                DataViewObjectDefinition.deleteSingleProperty(defn, propertyName);
            }
            DataViewObjectDefinitions.deleteProperty = deleteProperty;
            function setValue(defns, propertyId, selector, value) {
                debug.assertValue(defns, 'defns');
                debug.assertValue(propertyId, 'propertyId');
                ensure(defns, propertyId.objectName, selector).properties[propertyId.propertyName] = value;
            }
            DataViewObjectDefinitions.setValue = setValue;
            function getValue(defns, propertyId, selector) {
                var properties = getPropertyContainer(defns, propertyId, selector);
                if (!properties)
                    return;
                return properties[propertyId.propertyName];
            }
            DataViewObjectDefinitions.getValue = getValue;
            function getPropertyContainer(defns, propertyId, selector) {
                var defn = getObjectDefinition(defns, propertyId.objectName, selector);
                if (!defn)
                    return;
                return defn.properties;
            }
            DataViewObjectDefinitions.getPropertyContainer = getPropertyContainer;
            function getObjectDefinition(defns, objectName, selector) {
                debug.assertAnyValue(defns, 'defns');
                debug.assertValue(objectName, 'objectName');
                debug.assertAnyValue(selector, 'selector');
                if (!defns)
                    return;
                var defnsForObject = defns[objectName];
                if (!defnsForObject)
                    return;
                for (var i = 0, len = defnsForObject.length; i < len; i++) {
                    var defn = defnsForObject[i];
                    if (data.Selector.equals(defn.selector, selector))
                        return defn;
                }
            }
            DataViewObjectDefinitions.getObjectDefinition = getObjectDefinition;
            function propertiesAreEqual(a, b) {
                if (a instanceof data.SemanticFilter && b instanceof data.SemanticFilter) {
                    return data.SemanticFilter.isSameFilter(a, b);
                }
                return JsonComparer.equals(a, b);
            }
            DataViewObjectDefinitions.propertiesAreEqual = propertiesAreEqual;
            function allPropertiesAreEqual(a, b) {
                debug.assertValue(a, 'a');
                debug.assertValue(b, 'b');
                if (Object.keys(a).length !== Object.keys(b).length)
                    return false;
                for (var property in a) {
                    if (!propertiesAreEqual(a[property], b[property]))
                        return false;
                }
                return true;
            }
            DataViewObjectDefinitions.allPropertiesAreEqual = allPropertiesAreEqual;
            function encodePropertyValue(value, valueTypeDescriptor) {
                debug.assertAnyValue(value, 'value');
                debug.assertValue(valueTypeDescriptor, 'valueTypeDescriptor');
                if (valueTypeDescriptor.bool) {
                    if (typeof (value) !== 'boolean')
                        value = false; // This is fallback, which doesn't really belong here.
                    return data.SQExprBuilder.boolean(value);
                }
                else if (valueTypeDescriptor.text || (valueTypeDescriptor.scripting && valueTypeDescriptor.scripting.source)) {
                    return data.SQExprBuilder.text(value);
                }
                else if (valueTypeDescriptor.numeric) {
                    if ($.isNumeric(value))
                        return data.SQExprBuilder.double(+value);
                }
                else if (valueTypeDescriptor.fill) {
                    if (value) {
                        return {
                            solid: { color: data.SQExprBuilder.text(value) }
                        };
                    }
                }
                else if (valueTypeDescriptor.formatting) {
                    if (valueTypeDescriptor.formatting.labelDisplayUnits) {
                        return data.SQExprBuilder.double(+value);
                    }
                    else {
                        return data.SQExprBuilder.text(value);
                    }
                }
                else if (valueTypeDescriptor.enumeration) {
                    if ($.isNumeric(value))
                        return data.SQExprBuilder.double(+value);
                    else
                        return data.SQExprBuilder.text(value);
                }
                else if (valueTypeDescriptor.misc) {
                    if (value) {
                        value = data.SQExprBuilder.text(value);
                    }
                    else {
                        value = null;
                    }
                }
                else if (valueTypeDescriptor.image) {
                    if (value) {
                        var imageValue = value;
                        var imageDefinition = {
                            name: data.SQExprBuilder.text(imageValue.name),
                            url: data.SQExprBuilder.text(imageValue.url),
                        };
                        if (imageValue.scaling)
                            imageDefinition.scaling = data.SQExprBuilder.text(imageValue.scaling);
                        return imageDefinition;
                    }
                }
                return value;
            }
            DataViewObjectDefinitions.encodePropertyValue = encodePropertyValue;
            function clone(original) {
                debug.assertValue(original, 'original');
                var cloned = {};
                for (var objectName in original) {
                    var originalDefns = original[objectName];
                    if (_.isEmpty(originalDefns))
                        continue;
                    var clonedDefns = [];
                    for (var _i = 0, originalDefns_1 = originalDefns; _i < originalDefns_1.length; _i++) {
                        var originalDefn = originalDefns_1[_i];
                        clonedDefns.push({
                            properties: cloneProperties(originalDefn.properties),
                            selector: originalDefn.selector,
                        });
                    }
                    cloned[objectName] = clonedDefns;
                }
                return cloned;
            }
            DataViewObjectDefinitions.clone = clone;
            function cloneProperties(original) {
                debug.assertValue(original, 'original');
                // NOTE: properties are considered atomic, so a shallow clone is appropriate here.
                return _.clone(original);
            }
        })(DataViewObjectDefinitions = data.DataViewObjectDefinitions || (data.DataViewObjectDefinitions = {}));
        var DataViewObjectDefinition;
        (function (DataViewObjectDefinition) {
            function deleteSingleProperty(defn, propertyName) {
                //note: We decided that delete is acceptable here and that we don't need optimization here
                delete defn.properties[propertyName];
            }
            DataViewObjectDefinition.deleteSingleProperty = deleteSingleProperty;
        })(DataViewObjectDefinition = data.DataViewObjectDefinition || (data.DataViewObjectDefinition = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewObjectDescriptors;
        (function (DataViewObjectDescriptors) {
            /** Attempts to find the format string property.  This can be useful for upgrade and conversion. */
            function findFormatString(descriptors) {
                return findProperty(descriptors, function (propDesc) {
                    var formattingTypeDesc = powerbi.ValueType.fromDescriptor(propDesc.type).formatting;
                    return formattingTypeDesc && formattingTypeDesc.formatString;
                });
            }
            DataViewObjectDescriptors.findFormatString = findFormatString;
            /** Attempts to find the filter property.  This can be useful for propagating filters from one visual to others. */
            function findFilterOutput(descriptors) {
                return findProperty(descriptors, function (propDesc) {
                    var propType = propDesc.type;
                    return propType && !!propType.filter;
                });
            }
            DataViewObjectDescriptors.findFilterOutput = findFilterOutput;
            /** Attempts to find the default value property.  This can be useful for propagating schema default value. */
            function findDefaultValue(descriptors) {
                return findProperty(descriptors, function (propDesc) {
                    var propType = propDesc.type;
                    return propType && !!propType.expression && propType.expression.defaultValue;
                });
            }
            DataViewObjectDescriptors.findDefaultValue = findDefaultValue;
            function findProperty(descriptors, propPredicate) {
                debug.assertAnyValue(descriptors, 'descriptors');
                debug.assertAnyValue(propPredicate, 'propPredicate');
                if (!descriptors)
                    return;
                for (var objectName in descriptors) {
                    var objPropDescs = descriptors[objectName].properties;
                    for (var propertyName in objPropDescs) {
                        if (propPredicate(objPropDescs[propertyName])) {
                            return {
                                objectName: objectName,
                                propertyName: propertyName,
                            };
                        }
                    }
                }
            }
        })(DataViewObjectDescriptors = data.DataViewObjectDescriptors || (data.DataViewObjectDescriptors = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
 *  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
*
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewObjectEvaluationUtils;
        (function (DataViewObjectEvaluationUtils) {
            function evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefns, 'objectDefns');
                var objects;
                for (var j = 0, jlen = objectDefns.length; j < jlen; j++) {
                    var objectDefinition = objectDefns[j], objectName = objectDefinition.name;
                    var evaluatedObject = data.DataViewObjectEvaluator.run(evalContext, objectDescriptors[objectName], objectDefinition.properties);
                    if (!evaluatedObject)
                        continue;
                    if (!objects)
                        objects = {};
                    // NOTE: this currently has last-object-wins semantics.
                    objects[objectName] = evaluatedObject;
                }
                return objects;
            }
            DataViewObjectEvaluationUtils.evaluateDataViewObjects = evaluateDataViewObjects;
            function groupObjectsBySelector(objectDefinitions) {
                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');
                var grouped = {
                    data: [],
                };
                if (objectDefinitions) {
                    for (var objectName in objectDefinitions) {
                        var objectDefnList = objectDefinitions[objectName];
                        for (var i = 0, len = objectDefnList.length; i < len; i++) {
                            var objectDefn = objectDefnList[i];
                            ensureDefinitionListForSelector(grouped, objectDefn.selector).objects.push({
                                name: objectName,
                                properties: objectDefn.properties,
                            });
                        }
                    }
                }
                return grouped;
            }
            DataViewObjectEvaluationUtils.groupObjectsBySelector = groupObjectsBySelector;
            function ensureDefinitionListForSelector(grouped, selector) {
                debug.assertValue(grouped, 'grouped');
                debug.assertAnyValue(selector, 'selector');
                if (!selector) {
                    if (!grouped.metadataOnce)
                        grouped.metadataOnce = { objects: [] };
                    return grouped.metadataOnce;
                }
                var groupedObjects;
                if (selector.data) {
                    groupedObjects = grouped.data;
                }
                else if (selector.metadata) {
                    if (!grouped.metadata)
                        grouped.metadata = [];
                    groupedObjects = grouped.metadata;
                }
                else if (selector.id) {
                    if (!grouped.userDefined)
                        grouped.userDefined = [];
                    groupedObjects = grouped.userDefined;
                }
                debug.assert(!!groupedObjects, 'GroupedObjects is not defined.  Indicates malformed selector.');
                for (var _i = 0, groupedObjects_1 = groupedObjects; _i < groupedObjects_1.length; _i++) {
                    var item_1 = groupedObjects_1[_i];
                    if (data.Selector.equals(selector, item_1.selector))
                        return item_1;
                }
                var item = {
                    selector: selector,
                    objects: [],
                };
                groupedObjects.push(item);
                return item;
            }
            function addImplicitObjects(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {
                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(columns, 'columns');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                if (selectTransforms) {
                    addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);
                    addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms);
                }
            }
            DataViewObjectEvaluationUtils.addImplicitObjects = addImplicitObjects;
            function addDefaultFormatString(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {
                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(columns, 'columns');
                debug.assertValue(selectTransforms, 'selectTransforms');
                var formatStringProp = data.DataViewObjectDescriptors.findFormatString(objectDescriptors);
                if (!formatStringProp)
                    return;
                for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {
                    var selectTransform = selectTransforms[selectIdx];
                    if (!selectTransform)
                        continue;
                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');
                    applyFormatString(objectsForAllSelectors, formatStringProp, selectTransform.queryName, selectTransform.format || getColumnFormatForIndex(columns, selectIdx));
                }
            }
            /** Registers properties for default value, if the properties are not explicitly provided. */
            function addDefaultValue(objectsForAllSelectors, objectDescriptors, columns, selectTransforms) {
                debug.assertValue(objectsForAllSelectors, 'objectsForAllSelectors');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(columns, 'columns');
                debug.assertValue(selectTransforms, 'selectTransforms');
                var defaultValueProp = data.DataViewObjectDescriptors.findDefaultValue(objectDescriptors);
                if (!defaultValueProp)
                    return;
                for (var _i = 0, selectTransforms_1 = selectTransforms; _i < selectTransforms_1.length; _i++) {
                    var selectTransform = selectTransforms_1[_i];
                    if (!selectTransform)
                        continue;
                    debug.assertValue(selectTransform.queryName, 'selectTransform.queryName');
                    applyDefaultValue(objectsForAllSelectors, defaultValueProp, selectTransform.queryName, selectTransform.defaultValue);
                }
            }
            function getColumnFormatForIndex(columns, selectIdx) {
                for (var columnIdx = 0, columnLen = columns.length; columnIdx < columnLen; columnIdx++) {
                    var column = columns[columnIdx];
                    if (!column || column.index !== selectIdx)
                        continue;
                    return column.format;
                }
            }
            function applyFormatString(objectsForAllSelectors, formatStringProp, queryName, formatStringValue) {
                if (!formatStringValue)
                    return;
                // There is a format string specified -- apply it as an object property, if there is not already one specified.
                applyMetadataProperty(objectsForAllSelectors, formatStringProp, { metadata: queryName }, data.SQExprBuilder.text(formatStringValue));
            }
            function applyDefaultValue(objectsForAllSelectors, defaultValueProp, queryName, defaultValue) {
                if (!defaultValue)
                    return;
                // There is a default value specified -- apply it as an object property, if there is not already one specified.
                applyMetadataProperty(objectsForAllSelectors, defaultValueProp, { metadata: queryName }, defaultValue);
            }
            function applyMetadataProperty(objectsForAllSelectors, propertyId, selector, value) {
                var objectDefns;
                if (selector) {
                    var metadataObjects = objectsForAllSelectors.metadata;
                    if (!metadataObjects)
                        metadataObjects = objectsForAllSelectors.metadata = [];
                    objectDefns = metadataObjects;
                }
                else {
                    var metadataOnce = objectsForAllSelectors.metadataOnce;
                    if (!metadataOnce)
                        metadataOnce = objectsForAllSelectors.metadataOnce = { selector: selector, objects: [] };
                    objectDefns = [metadataOnce];
                }
                var targetMetadataObject = findWithMatchingSelector(objectDefns, selector);
                var targetObjectDefn;
                if (targetMetadataObject) {
                    var targetObjectDefns = targetMetadataObject.objects;
                    targetObjectDefn = findExistingObject(targetObjectDefns, propertyId.objectName);
                    if (targetObjectDefn) {
                        if (targetObjectDefn.properties[propertyId.propertyName])
                            return;
                    }
                    else {
                        targetObjectDefn = {
                            name: propertyId.objectName,
                            properties: {},
                        };
                        targetObjectDefns.push(targetObjectDefn);
                    }
                }
                else {
                    targetObjectDefn = {
                        name: propertyId.objectName,
                        properties: {}
                    };
                    objectDefns.push({
                        selector: selector,
                        objects: [targetObjectDefn],
                    });
                }
                targetObjectDefn.properties[propertyId.propertyName] = value;
            }
            function findWithMatchingSelector(objects, selector) {
                debug.assertValue(objects, 'objects');
                debug.assertAnyValue(selector, 'selector');
                for (var i = 0, len = objects.length; i < len; i++) {
                    var object = objects[i];
                    if (data.Selector.equals(object.selector, selector))
                        return object;
                }
            }
            function findExistingObject(objectDefns, objectName) {
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(objectName, 'objectName');
                for (var i = 0, len = objectDefns.length; i < len; i++) {
                    var objectDefn = objectDefns[i];
                    if (objectDefn.name === objectName)
                        return objectDefn;
                }
            }
        })(DataViewObjectEvaluationUtils = data.DataViewObjectEvaluationUtils || (data.DataViewObjectEvaluationUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Responsible for evaluating object property expressions to be applied at various scopes in a DataView. */
        var DataViewObjectEvaluator;
        (function (DataViewObjectEvaluator) {
            var colorValueType = powerbi.ValueType.fromDescriptor({ formatting: { color: true } });
            var numericType = powerbi.ValueType.fromDescriptor({ numeric: true });
            var textType = powerbi.ValueType.fromDescriptor({ text: true });
            function run(evalContext, objectDescriptor, propertyDefinitions) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertAnyValue(objectDescriptor, 'objectDescriptor');
                debug.assertValue(propertyDefinitions, 'propertyDefinitions');
                if (!objectDescriptor)
                    return;
                var object, propertyDescriptors = objectDescriptor.properties;
                for (var propertyName in propertyDefinitions) {
                    var propertyDefinition = propertyDefinitions[propertyName], propertyDescriptor = propertyDescriptors[propertyName];
                    if (!propertyDescriptor)
                        continue;
                    var propertyValue = evaluateProperty(evalContext, propertyDescriptor, propertyDefinition);
                    if (propertyValue === undefined)
                        continue;
                    if (!object)
                        object = {};
                    object[propertyName] = propertyValue;
                }
                return object;
            }
            DataViewObjectEvaluator.run = run;
            /** Note: Exported for testability */
            function evaluateProperty(evalContext, propertyDescriptor, propertyDefinition) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(propertyDescriptor, 'propertyDescriptor');
                debug.assertValue(propertyDefinition, 'propertyDefinition');
                var structuralType = propertyDescriptor.type;
                if (structuralType && structuralType.expression)
                    return propertyDefinition;
                var value = evaluateValue(evalContext, propertyDefinition, powerbi.ValueType.fromDescriptor(propertyDescriptor.type));
                if (value !== undefined || (propertyDefinition instanceof data.RuleEvaluation))
                    return value;
                return evaluateFill(evalContext, propertyDefinition, structuralType)
                    || evaluateFillRule(evalContext, propertyDefinition, structuralType)
                    || evaluateImage(evalContext, propertyDefinition, structuralType)
                    || evaluateParagraphs(evalContext, propertyDefinition, structuralType)
                    || propertyDefinition;
            }
            DataViewObjectEvaluator.evaluateProperty = evaluateProperty;
            function evaluateFill(evalContext, fillDefn, type) {
                var fillType = type.fill;
                if (!fillType)
                    return;
                if (fillType && fillType.solid && fillType.solid.color && fillDefn.solid) {
                    return {
                        solid: {
                            color: evaluateValue(evalContext, fillDefn.solid.color, powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Color)),
                        }
                    };
                }
            }
            function evaluateFillRule(evalContext, fillRuleDefn, type) {
                if (!type.fillRule)
                    return;
                if (fillRuleDefn.linearGradient2) {
                    var linearGradient2 = fillRuleDefn.linearGradient2;
                    return {
                        linearGradient2: {
                            min: evaluateColorStop(evalContext, linearGradient2.min),
                            max: evaluateColorStop(evalContext, linearGradient2.max),
                        }
                    };
                }
                if (fillRuleDefn.linearGradient3) {
                    var linearGradient3 = fillRuleDefn.linearGradient3;
                    return {
                        linearGradient3: {
                            min: evaluateColorStop(evalContext, linearGradient3.min),
                            mid: evaluateColorStop(evalContext, linearGradient3.mid),
                            max: evaluateColorStop(evalContext, linearGradient3.max),
                        }
                    };
                }
            }
            function evaluateColorStop(evalContext, colorStop) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(colorStop, 'colorStop');
                var step = {
                    color: evaluateValue(evalContext, colorStop.color, colorValueType),
                };
                var value = evaluateValue(evalContext, colorStop.value, numericType);
                if (value != null)
                    step.value = value;
                return step;
            }
            function evaluateImage(evalContext, definition, type) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertAnyValue(definition, 'definition');
                debug.assertValue(type, 'type');
                if (!type.image || !definition)
                    return;
                var value = {
                    name: evaluateValue(evalContext, definition.name, textType),
                    url: evaluateValue(evalContext, definition.url, powerbi.ValueType.fromDescriptor(powerbi.ImageDefinition.urlType)),
                };
                if (definition.scaling)
                    value.scaling = evaluateValue(evalContext, definition.scaling, textType);
                return value;
            }
            function evaluateParagraphs(evalContext, definition, type) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertAnyValue(definition, 'definition');
                debug.assertValue(type, 'type');
                if (!type.paragraphs || !definition)
                    return;
                return evaluateArrayCopyOnChange(evalContext, definition, evaluateParagraph);
            }
            function evaluateParagraph(evalContext, definition) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(definition, 'definition');
                var evaluated;
                var definitionTextRuns = definition.textRuns;
                var evaluatedTextRuns = evaluateArrayCopyOnChange(evalContext, definitionTextRuns, evaluateTextRun);
                if (definitionTextRuns !== evaluatedTextRuns) {
                    evaluated = _.clone(definition);
                    evaluated.textRuns = evaluatedTextRuns;
                }
                return evaluated || definition;
            }
            function evaluateTextRun(evalContext, definition) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(definition, 'definition');
                var evaluated;
                var definitionValue = definition.value;
                var evaluatedValue = evaluateValue(evalContext, definitionValue, textType);
                if (evaluatedValue !== undefined) {
                    evaluated = _.clone(definition);
                    evaluated.value = evaluatedValue;
                }
                return evaluated || definition;
            }
            /**
             * Evaluates an array, and lazily copies on write whenever the evaluator function returns something
             * other than the input to it.
             */
            function evaluateArrayCopyOnChange(evalContext, definitions, evaluator) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(definitions, 'definitions');
                debug.assertValue(evaluator, 'evaluator');
                var evaluatedValues;
                for (var i = 0, len = definitions.length; i < len; i++) {
                    var definition = definitions[i];
                    var evaluated = evaluator(evalContext, definition);
                    // NOTE: the any casts here are necessary due to the compiler not knowing the relationship
                    // between TEvaluated & TDefinition
                    if (!evaluatedValues && definition !== evaluated) {
                        evaluatedValues = _.take(definitions, i);
                    }
                    if (evaluatedValues) {
                        evaluatedValues.push(evaluated);
                    }
                }
                return evaluatedValues || definitions;
            }
            function evaluateValue(evalContext, definition, valueType) {
                if (definition instanceof data.SQExpr)
                    return ExpressionEvaluator.evaluate(definition, evalContext);
                if (definition instanceof data.RuleEvaluation)
                    return definition.evaluate(evalContext);
            }
            /** Responsible for evaluating SQExprs into values. */
            var ExpressionEvaluator = (function (_super) {
                __extends(ExpressionEvaluator, _super);
                function ExpressionEvaluator() {
                    _super.apply(this, arguments);
                }
                ExpressionEvaluator.evaluate = function (expr, evalContext) {
                    if (expr == null)
                        return;
                    return expr.accept(ExpressionEvaluator.instance, evalContext);
                };
                ExpressionEvaluator.prototype.visitColumnRef = function (expr, evalContext) {
                    return evalContext.getExprValue(expr);
                };
                ExpressionEvaluator.prototype.visitConstant = function (expr, evalContext) {
                    return expr.value;
                };
                ExpressionEvaluator.prototype.visitMeasureRef = function (expr, evalContext) {
                    return evalContext.getExprValue(expr);
                };
                ExpressionEvaluator.prototype.visitAggr = function (expr, evalContext) {
                    return evalContext.getExprValue(expr);
                };
                ExpressionEvaluator.prototype.visitFillRule = function (expr, evalContext) {
                    var inputValue = expr.input.accept(this, evalContext);
                    if (inputValue !== undefined) {
                        var colorAllocator = evalContext.getColorAllocator(expr);
                        if (colorAllocator) {
                            return colorAllocator.color(inputValue);
                        }
                    }
                };
                ExpressionEvaluator.instance = new ExpressionEvaluator();
                return ExpressionEvaluator;
            }(data.DefaultSQExprVisitorWithArg));
        })(DataViewObjectEvaluator = data.DataViewObjectEvaluator || (data.DataViewObjectEvaluator = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inherit = powerbi.Prototype.inherit;
        var DataViewPivotCategorical;
        (function (DataViewPivotCategorical) {
            /**
             * Pivots categories in a categorical DataView into valueGroupings.
             * This is akin to a mathematical matrix transpose.
             */
            function apply(dataView) {
                debug.assertValue(dataView, 'dataView');
                var categorical = dataView.categorical;
                if (!categorical)
                    return null;
                var categories = categorical.categories;
                if (!categories || categories.length !== 1)
                    return null;
                var values = categorical.values;
                if (_.isEmpty(values) || values.source)
                    return null;
                var category = categories[0], categoryIdentities = category.identity, categoryValues = category.values, pivotedColumns = [], pivotedValues = [];
                for (var rowIdx = 0, rowCount = categoryValues.length; rowIdx < rowCount; rowIdx++) {
                    var categoryValue = categoryValues[rowIdx], categoryIdentity = categoryIdentities[rowIdx];
                    for (var colIdx = 0, colCount = values.length; colIdx < colCount; colIdx++) {
                        var value = values[colIdx], pivotedColumn = inherit(value.source);
                        // A value has a series group, which is not implemented for pivoting -- just give up.
                        if (value.identity)
                            return null;
                        pivotedColumn.groupName = categoryValue;
                        var pivotedValue = {
                            source: pivotedColumn,
                            values: [value.values[rowIdx]],
                            identity: categoryIdentity,
                            min: value.min,
                            max: value.max,
                            subtotal: value.subtotal
                        };
                        var highlights = value.highlights;
                        if (highlights) {
                            pivotedValue.highlights = [highlights[rowIdx]];
                        }
                        pivotedColumns.push(pivotedColumn);
                        pivotedValues.push(pivotedValue);
                    }
                }
                var pivotedMetadata = inherit(dataView.metadata);
                pivotedMetadata.columns = pivotedColumns;
                values = data.DataViewTransform.createValueColumns(pivotedValues, category.identityFields, category.source);
                return {
                    metadata: pivotedMetadata,
                    categorical: {
                        values: values,
                    },
                    matrix: dataView.matrix
                };
            }
            DataViewPivotCategorical.apply = apply;
        })(DataViewPivotCategorical = data.DataViewPivotCategorical || (data.DataViewPivotCategorical = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewPivotMatrix;
        (function (DataViewPivotMatrix) {
            /** Pivots row hierarchy members in a matrix DataView into column hierarchy. */
            function apply(dataViewMatrix, context) {
                debug.assertValue(dataViewMatrix, 'dataViewMatrix');
                if (!context.columnHierarchyRewritten)
                    dataViewMatrix.columns = powerbi.Prototype.inherit(dataViewMatrix.columns);
                var columns = dataViewMatrix.columns;
                if (!context.rowHierarchyRewritten)
                    dataViewMatrix.rows = powerbi.Prototype.inherit(dataViewMatrix.rows);
                var rows = dataViewMatrix.rows;
                if (columns.levels.length > 1)
                    return;
                var pivotedRowNode = {
                    level: 0
                };
                var columnLeafNodes = columns.root.children;
                var measureCount = columnLeafNodes.length;
                // Notes related to VSTS 6999369: The level value of Measure Header nodes is not necessarily its parent node's level + 1.
                // In particular, the Measure Header column nodes directly under the Grand Total node at level 0 (i.e. _.last(pivotResultMatrix.columns.root.children))
                // will have level === (pivotResultMatrix.columns.levels.length - 1), which will be greater than the Grand Total node's 'level + 1' 
                // in a matrix with 2+ column fields and 2+ measure fields.
                // In this code, all row levels will get pivoted over to the columns hierarchy, hence the level of any Measure Header nodes in the pivot result
                // is just (1 + the level of the deepest row node's level), which === rows.levels.length.
                var pivotResultMeasureHeaderLevel = rows.levels.length;
                if (measureCount > 0) {
                    var index_1 = 0;
                    var callback = function (node) {
                        // Collect values and remove them from row leaves
                        if (node.values) {
                            if (!pivotedRowNode.values)
                                pivotedRowNode.values = {};
                            for (var i = 0; i < measureCount; i++)
                                pivotedRowNode.values[index_1++] = node.values[i];
                            delete node.values;
                        }
                        // Create measure headers if there are more than one measures
                        if (measureCount > 1) {
                            if (!node.children)
                                node.children = [];
                            for (var j = 0; j < measureCount; j++) {
                                var measureHeaderLeaf = { level: pivotResultMeasureHeaderLevel };
                                // Copy levelSourceIndex from columnLeafNodes (as they might have been reordered)
                                var columnLeafNode = columnLeafNodes[j];
                                measureHeaderLeaf.levelSourceIndex = columnLeafNode.levelSourceIndex;
                                if (node.isSubtotal)
                                    measureHeaderLeaf.isSubtotal = true;
                                node.children.push(measureHeaderLeaf);
                            }
                        }
                    };
                    if (context.hierarchyTreesRewritten) {
                        forEachLeaf(rows.root, callback);
                    }
                    else {
                        dataViewMatrix.columns.root = cloneTreeExecuteOnLeaf(rows.root, callback);
                    }
                }
                else {
                    if (!context.hierarchyTreesRewritten) {
                        dataViewMatrix.columns.root = cloneTree(rows.root);
                    }
                }
                if (measureCount > 1) {
                    // Keep measure headers, but move them to the innermost level
                    var level = { sources: columns.levels[0].sources };
                    rows.levels.push(level);
                    columns.levels.length = 0;
                }
                if (context.hierarchyTreesRewritten) {
                    dataViewMatrix.columns.root = rows.root;
                    dataViewMatrix.rows.root = {
                        children: [pivotedRowNode]
                    };
                }
                else {
                    var updatedRowRoot = powerbi.Prototype.inherit(dataViewMatrix.rows.root);
                    updatedRowRoot.children = [pivotedRowNode];
                    dataViewMatrix.rows.root = updatedRowRoot;
                }
                dataViewMatrix.columns.levels = rows.levels;
                dataViewMatrix.rows.levels = [];
            }
            DataViewPivotMatrix.apply = apply;
            function forEachLeaf(root, callback) {
                var children = root.children;
                if (children && children.length > 0) {
                    for (var i = 0, ilen = children.length; i < ilen; i++)
                        forEachLeaf(children[i], callback);
                    return;
                }
                callback(root);
            }
            function cloneTree(node) {
                return cloneTreeExecuteOnLeaf(node);
            }
            DataViewPivotMatrix.cloneTree = cloneTree;
            function cloneTreeExecuteOnLeaf(node, callback) {
                var updatedNode = powerbi.Prototype.inherit(node);
                var children = node.children;
                if (children && children.length > 0) {
                    var newChildren = [];
                    for (var i = 0, ilen = children.length; i < ilen; i++) {
                        var updatedChild = cloneTreeExecuteOnLeaf(children[i], callback);
                        newChildren.push(updatedChild);
                    }
                    updatedNode.children = newChildren;
                }
                else {
                    if (callback)
                        callback(updatedNode);
                }
                return updatedNode;
            }
            DataViewPivotMatrix.cloneTreeExecuteOnLeaf = cloneTreeExecuteOnLeaf;
        })(DataViewPivotMatrix = data.DataViewPivotMatrix || (data.DataViewPivotMatrix = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewSelfCrossJoin;
        (function (DataViewSelfCrossJoin) {
            /**
             * Returns a new DataView based on the original, with a single DataViewCategorical category that is "cross joined"
             * to itself as a value grouping.
             * This is the mathematical equivalent of taking an array and turning it into an identity matrix.
             */
            function apply(dataView) {
                debug.assertValue(dataView, 'dataView');
                if (!dataView.categorical)
                    return;
                var dataViewCategorical = dataView.categorical;
                if (!dataViewCategorical.categories || dataViewCategorical.categories.length !== 1)
                    return;
                if (dataViewCategorical.values && dataViewCategorical.values.source)
                    return;
                return applyCategorical(dataView.metadata, dataViewCategorical);
            }
            DataViewSelfCrossJoin.apply = apply;
            function applyCategorical(dataViewMetadata, dataViewCategorical) {
                debug.assertValue(dataViewMetadata, 'dataViewMetadata');
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertValue(dataViewCategorical.categories, 'dataViewCategorical.categories');
                var category = dataViewCategorical.categories[0], categoryValues = category.values, categoryLength = categoryValues.length;
                if (categoryLength === 0)
                    return;
                var valuesArray = dataViewCategorical.values
                    ? dataViewCategorical.values.grouped()[0].values
                    : [];
                var transformedDataView = data.createCategoricalDataViewBuilder()
                    .withCategories(dataViewCategorical.categories)
                    .withGroupedValues(createGroupedValues(category, categoryValues, categoryLength, valuesArray))
                    .build();
                dataViewMetadata = powerbi.Prototype.inherit(dataViewMetadata);
                dataViewMetadata.columns = transformedDataView.metadata.columns;
                return {
                    metadata: dataViewMetadata,
                    categorical: transformedDataView.categorical,
                };
            }
            function createGroupedValues(category, categoryValues, categoryLength, valuesArray) {
                debug.assertValue(category, 'category');
                debug.assertValue(categoryValues, 'categoryValues');
                debug.assertValue(categoryLength, 'categoryLength');
                debug.assertValue(valuesArray, 'valuesArray');
                var nullValuesArray = createNullValues(categoryLength), valuesArrayLen = valuesArray.length, seriesData = [];
                for (var i = 0; i < categoryLength; i++) {
                    var seriesDataItem = [];
                    for (var j = 0; j < valuesArrayLen; j++) {
                        var originalValueColumn = valuesArray[j], originalHighlightValues = originalValueColumn.highlights;
                        var seriesDataItemCategory = {
                            values: inheritArrayWithValue(nullValuesArray, originalValueColumn.values, i),
                        };
                        if (originalHighlightValues)
                            seriesDataItemCategory.highlights = inheritArrayWithValue(nullValuesArray, originalHighlightValues, i);
                        seriesDataItem.push(seriesDataItemCategory);
                    }
                    seriesData.push(seriesDataItem);
                }
                return {
                    groupColumn: {
                        source: category.source,
                        identityFrom: { fields: category.identityFields, identities: category.identity },
                        values: category.values,
                    },
                    valueColumns: _.map(valuesArray, function (v) { return { source: v.source }; }),
                    data: seriesData,
                };
            }
        })(DataViewSelfCrossJoin = data.DataViewSelfCrossJoin || (data.DataViewSelfCrossJoin = {}));
        function createNullValues(length) {
            debug.assertValue(length, 'length');
            var array = new Array(length);
            for (var i = 0; i < length; i++)
                array[i] = null;
            return array;
        }
        function inheritArrayWithValue(nullValues, original, index) {
            var inherited = powerbi.Prototype.inherit(nullValues);
            inherited[index] = original[index];
            return inherited;
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataShapeBindingDataReduction = powerbi.data.DataShapeBindingDataReduction;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var DataViewPivotCategoricalToPrimaryGroups;
        (function (DataViewPivotCategoricalToPrimaryGroups) {
            /**
             * If mapping requests cross axis data reduction and the binding has secondary grouping, mutates the binding to
             * pivot the secondary before the primary.
             */
            function pivotBinding(binding, allMappings, finalMapping, defaultDataVolume) {
                // unpivot is inferred from result in DataViewTransform.apply but it does not have the
                // compiled mappings available, let alone the merged mapping, only the original
                // DataViewMappings. to keep that inference easy, only apply pivot when there's
                // only one matching mapping
                if (!allMappings || allMappings.length !== 1)
                    return;
                if (!finalMapping.categorical || !finalMapping.categorical.dataReductionAlgorithm)
                    return;
                if (!binding)
                    return;
                if (!canPivotCategorical(binding, finalMapping))
                    return;
                // pivot secondary onto front of primary
                binding.Primary.Groupings = [binding.Secondary.Groupings[0], binding.Primary.Groupings[0]];
                binding.Secondary = undefined;
                // set primary to pivot reduction
                binding.DataReduction = {
                    Primary: DataShapeBindingDataReduction.createFrom(finalMapping.categorical.dataReductionAlgorithm),
                    DataVolume: finalMapping.categorical.dataVolume || defaultDataVolume,
                };
            }
            DataViewPivotCategoricalToPrimaryGroups.pivotBinding = pivotBinding;
            /** narrowly targets scatter chart scenario for now to keep code simple */
            function isPivotableAxis(axis) {
                return axis
                    && axis.Groupings
                    && axis.Groupings.length === 1
                    && !_.isEmpty(axis.Groupings[0].Projections)
                    && !axis.Groupings[0].Subtotal
                    && _.isEmpty(axis.Groupings[0].SuppressedProjections);
            }
            function canPivotCategorical(binding, mapping) {
                if (!isPivotableAxis(binding.Primary))
                    return false;
                if (!isPivotableAxis(binding.Secondary) || binding.Secondary.Groupings[0].Projections.length !== 1)
                    return false;
                // don't pivot if either axis has a data reduction
                if (binding.DataReduction && (binding.DataReduction.Primary || binding.DataReduction.Secondary))
                    return false;
                return true;
            }
            function unpivotResult(oldDataView, selects, dataViewMappings, projectionActiveItems) {
                if (!inferUnpivotTransform(selects, dataViewMappings, oldDataView, projectionActiveItems))
                    return oldDataView;
                // This returns a subsetted version of the DataView rather than using prototypal inheritance because
                // any dataviews in the old one (including ones invented after this code is written) will correspond
                // to a pivoted query result and therefore will be in the wrong shape for the unpivoted query the
                // querying code made.
                var newDataView = {
                    metadata: {
                        columns: ArrayExtensions.copy(oldDataView.metadata.columns),
                    },
                };
                // preserve view types that aren't affected by pivoting
                if (oldDataView.single)
                    newDataView.single = oldDataView.single;
                if (oldDataView.table)
                    newDataView.table = oldDataView.table;
                // other views are derived from matrix
                if (oldDataView.matrix) {
                    var newDataViewMatrix = unpivotMatrix(oldDataView.matrix);
                    // categorical only if there's data
                    if (!_.isEmpty(newDataViewMatrix.valueSources)) {
                        // Guard against a DataViewMatrix with composite grouping in columns, because composite group in Series is 
                        // not yet expressible in the current version of DataViewValueColumns and DataViewValueColumnGroup interfaces.
                        // this.canPivotCategorical() would have returned false in the first place for this query.
                        var hasCompositeGroupInSeries = data.utils.DataViewMatrixUtils.containsCompositeGroup(newDataViewMatrix.columns);
                        if (!hasCompositeGroupInSeries) {
                            newDataView.categorical = categoricalFromUnpivotedMatrix(newDataViewMatrix, newDataView.metadata.columns);
                        }
                    }
                }
                return newDataView;
            }
            DataViewPivotCategoricalToPrimaryGroups.unpivotResult = unpivotResult;
            /**
             * Infer from the query result and the visual mappings whether the query was pivoted.
             * Narrowly targets scatter chart scenario for now to keep code simple
             */
            function inferUnpivotTransform(selects, dataViewMappings, dataView, projectionActiveItems) {
                if (_.isEmpty(selects) || _.isEmpty(dataViewMappings) || !dataView)
                    return false;
                // select applicable mappings based on select roles
                var roleKinds = data.DataViewSelectTransform.createRoleKindFromMetadata(selects, dataView.metadata);
                var projections = data.DataViewSelectTransform.projectionsFromSelects(selects, projectionActiveItems);
                var supportedDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKinds).supportedMappings;
                // NOTE: limiting to simple situation that handles scatter for now - see the other side in canPivotCategorical
                if (!supportedDataViewMappings || supportedDataViewMappings.length !== 1)
                    return false;
                var categoricalMapping = supportedDataViewMappings[0].categorical;
                if (!categoricalMapping)
                    return false;
                // pivoted query will have produced a matrix
                var matrixDataview = dataView.matrix;
                if (!matrixDataview)
                    return false;
                // matrix must have two levels of grouping
                if (!matrixDataview.rows || !matrixDataview.rows.levels || matrixDataview.rows.levels.length !== 2)
                    return false;
                // get category and value grouping roles
                var categoryGroups = [];
                var valueGroups = [];
                var addGroupingRole = function (roleName, groups) {
                    var roleProjections = projections[roleName];
                    if (!roleProjections)
                        return;
                    for (var _i = 0, _a = roleProjections.all(); _i < _a.length; _i++) {
                        var roleProjection = _a[_i];
                        if (roleKinds[roleProjection.queryRef] === powerbi.VisualDataRoleKind.Grouping)
                            groups.push(roleProjection.queryRef);
                    }
                };
                powerbi.DataViewMapping.visitCategoricalCategories(categoricalMapping.categories, {
                    visitRole: function (roleName) { addGroupingRole(roleName, categoryGroups); }
                });
                powerbi.DataViewMapping.visitCategoricalValues(categoricalMapping.values, {
                    visitRole: function (roleName) { addGroupingRole(roleName, valueGroups); }
                });
                // need both for pivot to have been done
                if (_.isEmpty(categoryGroups) || _.isEmpty(valueGroups))
                    return false;
                // if there was a pivot, there won't be any measures left in the columns
                for (var _i = 0, _a = matrixDataview.columns.levels; _i < _a.length; _i++) {
                    var level = _a[_i];
                    for (var _b = 0, _c = level.sources; _b < _c.length; _b++) {
                        var source = _c[_b];
                        if (!source.isMeasure)
                            return false;
                    }
                }
                return true;
            }
            /**
             * matrix will have two groupings in the rows, outer (series) and inner (categories), and none in the columns.
             * this function changes that so that the categories become the rows and the series the columns.
             */
            function unpivotMatrix(oldMatrix) {
                var oldRows = oldMatrix.rows;
                var oldRoot = oldRows.root;
                var oldChildren = oldRoot.children;
                // series are the outer grouping
                var series = [];
                var seriesIdLevel = oldRows.levels[0];
                var seriesIdFields = oldRoot.childIdentityFields;
                // categories are the inner grouping. 
                var categoryIndex = {};
                var categories = [];
                var categoryIdLevel = oldRows.levels[1];
                var categoryIdFields = _.isEmpty(oldChildren) ? undefined : oldChildren[0].childIdentityFields;
                var measureCount = oldMatrix.valueSources.length;
                // within each series value, the category list may not be complete so cannot simply use the inner loop index
                // to reference it.
                var findCategory = function (identity) {
                    var index = categoryIndex[identity.key];
                    debug.assert(index !== undefined, "findcat() !== undefined");
                    return index;
                };
                // collect series and categories from the row hierarchy
                if (oldChildren) {
                    var addCategory = function (categoryNode) {
                        var key = categoryNode.identity.key;
                        var index = categoryIndex[key];
                        if (index === undefined) {
                            index = categories.length;
                            categoryIndex[key] = index;
                            categories.push(categoryNode);
                        }
                    };
                    for (var _i = 0, oldChildren_1 = oldChildren; _i < oldChildren_1.length; _i++) {
                        var seriesNode = oldChildren_1[_i];
                        series.push(seriesNode);
                        for (var _a = 0, _b = seriesNode.children; _a < _b.length; _a++) {
                            var categoryNode = _b[_a];
                            addCategory(categoryNode);
                        }
                    }
                }
                // extract intersection values from pivoted matrix
                // values will be indexed by categories then series
                var matrixValues = new Array(categories.length);
                for (var j = 0; j < series.length; ++j) {
                    var seriesNode = oldChildren[j];
                    for (var _c = 0, _d = seriesNode.children; _c < _d.length; _c++) {
                        var categoryNode = _d[_c];
                        var i = findCategory(categoryNode.identity); // must lookup actual category index
                        if (!matrixValues[i])
                            matrixValues[i] = new Array(series.length);
                        matrixValues[i][j] = categoryNode.values;
                    }
                }
                // columns of the unpivoted matrix are the series
                var newColumns = {
                    root: {
                        children: _.map(series, function (s) {
                            var inheritedNode = inheritSingle(s);
                            inheritedNode.level = 0; // s.level should already be 0, but just in case...
                            inheritedNode.children = undefined; // if Measure Headers exist in oldMatrix.columns, newColumns.root.children will get populated later in this function
                            inheritedNode.childIdentityFields = undefined;
                            return inheritedNode;
                        }),
                        childIdentityFields: seriesIdFields,
                    },
                    levels: [
                        seriesIdLevel,
                    ],
                };
                // Re-add any Measure Headers from oldMatrix.columns as leaf nodes under newColumns
                if (measureCount > 0) {
                    var newColChildren = _.map(oldMatrix.columns.root.children, function (srcnode) {
                        var dstnode = { level: 1 };
                        if (srcnode.levelSourceIndex)
                            dstnode.levelSourceIndex = srcnode.levelSourceIndex;
                        return dstnode;
                    });
                    for (var i = 0; i < newColumns.root.children.length; ++i)
                        newColumns.root.children[i].children = newColChildren;
                    newColumns.levels.push(oldMatrix.columns.levels[0]);
                }
                // rows of the unpivoted matrix are the categories
                var newRows = {
                    root: {
                        children: _.map(categories, function (c) {
                            var inheritedNode = inheritSingle(c);
                            inheritedNode.level = 0;
                            inheritedNode.children = undefined; // c.children should already be undefined, but just in case...
                            inheritedNode.childIdentityFields = undefined; // c.children should already be undefined, but just in case...
                            return inheritedNode;
                        }),
                        childIdentityFields: categoryIdFields,
                    },
                    levels: [
                        categoryIdLevel,
                    ],
                };
                // put values into rows
                if (measureCount > 0) {
                    for (var i = 0; i < categories.length; ++i) {
                        var row = newRows.root.children[i];
                        var rowValues = {};
                        for (var j = 0; j < series.length; ++j) {
                            var mvalues = matrixValues[i] && matrixValues[i][j];
                            for (var k = 0; k < measureCount; ++k) {
                                var l = j * measureCount + k;
                                rowValues[l] = !mvalues
                                    ? (k === 0 ? { value: null } : { value: null, valueSourceIndex: k })
                                    : mvalues[k];
                            }
                        }
                        row.values = rowValues;
                    }
                }
                var newMatrix = {
                    rows: newRows,
                    columns: newColumns,
                    valueSources: oldMatrix.valueSources,
                };
                return newMatrix;
            }
            /** build a categorical data view from an unpivoted matrix. */
            function categoricalFromUnpivotedMatrix(matrix, columnMetadata) {
                var seriesCount = matrix.columns.root.children.length;
                var measureMetadata = matrix.valueSources;
                var measureCount = measureMetadata.length;
                var categories = createCategoryColumnsFromUnpivotedMatrix(matrix);
                // create grouped values
                var groups = [];
                for (var j = 0; j < seriesCount; ++j) {
                    var seriesColumn = matrix.columns.root.children[j];
                    var group = {
                        values: [],
                        identity: seriesColumn.identity,
                        name: seriesColumn.value || null,
                    };
                    groups.push(group);
                    for (var k = 0; k < measureCount; ++k) {
                        var valueColumnMetadataSrc = measureMetadata[k];
                        var valueColumnMetadataDst = {};
                        for (var key in valueColumnMetadataSrc)
                            valueColumnMetadataDst[key] = valueColumnMetadataSrc[key];
                        valueColumnMetadataDst.groupName = group.name;
                        columnMetadata.push(valueColumnMetadataDst);
                        var valueColumn = {
                            source: valueColumnMetadataDst,
                            values: [],
                            identity: group.identity,
                        };
                        group.values.push(valueColumn);
                        // grab measure values in the group from across rows of matrix
                        var index = k + j * measureCount;
                        for (var _i = 0, _a = matrix.rows.root.children; _i < _a.length; _i++) {
                            var categoryNode = _a[_i];
                            var value = categoryNode.values[index].value;
                            valueColumn.values.push(value);
                        }
                    }
                }
                // and now ungrouped
                var values = [];
                for (var _b = 0, groups_1 = groups; _b < groups_1.length; _b++) {
                    var group = groups_1[_b];
                    for (var k = 0; k < measureCount; ++k) {
                        values.push(group.values[k]);
                    }
                }
                values.grouped = function () { return groups; };
                values.identityFields = matrix.columns.root.childIdentityFields;
                values.source = matrix.columns.levels[0].sources[0];
                // final assembly
                var categorical = {
                    categories: categories,
                    values: values,
                };
                return categorical;
            }
            function createCategoryColumnsFromUnpivotedMatrix(unpivotedMatrix) {
                debug.assertValue(unpivotedMatrix, 'unpivotedMatrix');
                debug.assert(unpivotedMatrix && unpivotedMatrix.rows && unpivotedMatrix.rows.levels && (unpivotedMatrix.rows.levels.length === 1), 'pre-condition: unpivotedMatrix should have exactly one level in row hierarchy');
                // Create categories from rows.  If matrix.rows.levels[0].sources represents a composite group, expand each column in the 
                // composite group into a separate DataViewCategoryColumn.  The identity and childIdentityFields properties will be the 
                // same amongst the resulting DataViewCategoryColumns.
                var categoryIdentity = _.map(unpivotedMatrix.rows.root.children, function (x) { return x.identity; });
                var categoryIdentityFields = unpivotedMatrix.rows.root.childIdentityFields;
                var categorySourceColumns = unpivotedMatrix.rows.levels[0].sources;
                var categories = [];
                for (var i = 0, ilen = categorySourceColumns.length; i < ilen; i++) {
                    var groupLevelValues = _.map(unpivotedMatrix.rows.root.children, function (categoryNode) {
                        var levelValues = categoryNode.levelValues;
                        // Please refer to the interface comments on when this is undefined... But in today's code
                        // I believe we will not see undefined levelValues in the rows of any unpivotedMatrix. 
                        if (levelValues !== undefined) {
                            debug.assert(levelValues[i] && (levelValues[i].levelSourceIndex === i), 'pre-condition: DataViewMatrixNode.levelValues is expected to have one DataViewMatrixGroupValue node per level source column, sorted by levelSourceIndex.');
                            return levelValues[i].value;
                        }
                    });
                    categories.push({
                        source: categorySourceColumns[i],
                        values: groupLevelValues,
                        identity: categoryIdentity,
                        identityFields: categoryIdentityFields,
                    });
                }
                return categories;
            }
        })(DataViewPivotCategoricalToPrimaryGroups = data.DataViewPivotCategoricalToPrimaryGroups || (data.DataViewPivotCategoricalToPrimaryGroups = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var inherit = powerbi.Prototype.inherit;
        var inheritSingle = powerbi.Prototype.inheritSingle;
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var EnumExtensions = jsCommon.EnumExtensions;
        // TODO: refactor & focus DataViewTransform into a service with well-defined dependencies.
        var DataViewTransform;
        (function (DataViewTransform) {
            var fillRulePropertyDescriptor = { type: { fillRule: {} } };
            function apply(options) {
                debug.assertValue(options, 'options');
                // TODO: Flow a context object through to capture errors/warnings about what happens here for better diagnosability.
                var prototype = options.prototype, objectDescriptors = options.objectDescriptors, dataViewMappings = options.dataViewMappings, transforms = options.transforms, projectionActiveItems = transforms && transforms.roles && transforms.roles.activeItems, colorAllocatorFactory = options.colorAllocatorFactory, dataRoles = options.dataRoles;
                if (!prototype)
                    return transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory);
                if (!transforms)
                    return [prototype];
                // Transform Query DataView
                prototype = data.DataViewPivotCategoricalToPrimaryGroups.unpivotResult(prototype, transforms.selects, dataViewMappings, projectionActiveItems);
                var visualDataViews = transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles);
                // Transform and generate derived visual DataViews
                visualDataViews = data.DataViewRegression.run({
                    dataViewMappings: dataViewMappings,
                    visualDataViews: visualDataViews,
                    dataRoles: dataRoles,
                    objectDescriptors: objectDescriptors,
                    objectDefinitions: transforms.objects,
                    colorAllocatorFactory: colorAllocatorFactory,
                    transformSelects: transforms.selects,
                    metadata: prototype.metadata,
                    projectionActiveItems: projectionActiveItems,
                });
                return visualDataViews;
            }
            DataViewTransform.apply = apply;
            function transformQueryToVisualDataView(prototype, transforms, objectDescriptors, dataViewMappings, colorAllocatorFactory, dataRoles) {
                var transformedDataViews = [];
                var splits = transforms.splits;
                if (_.isEmpty(splits)) {
                    transformedDataViews.push(transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles));
                }
                else {
                    for (var _i = 0, splits_1 = splits; _i < splits_1.length; _i++) {
                        var split = splits_1[_i];
                        var transformed = transformDataView(prototype, objectDescriptors, dataViewMappings, transforms, colorAllocatorFactory, dataRoles, split.selects);
                        transformedDataViews.push(transformed);
                    }
                }
                return transformedDataViews;
            }
            function transformEmptyDataView(objectDescriptors, transforms, colorAllocatorFactory) {
                if (transforms && transforms.objects) {
                    var emptyDataView = {
                        metadata: {
                            columns: [],
                        }
                    };
                    transformObjects(emptyDataView, 0 /* None */, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);
                    return [emptyDataView];
                }
                return [];
            }
            function transformDataView(prototype, objectDescriptors, roleMappings, transforms, colorAllocatorFactory, dataRoles, selectsToInclude) {
                debug.assertValue(prototype, 'prototype');
                var targetKinds = getTargetKinds(roleMappings);
                var transformed = inherit(prototype);
                transformed.metadata = inherit(prototype.metadata);
                var projectionOrdering = transforms.roles && transforms.roles.ordering;
                var projectionActiveItems = transforms.roles && transforms.roles.activeItems;
                transformed = transformSelects(transformed, roleMappings, transforms.selects, projectionOrdering, selectsToInclude);
                transformObjects(transformed, targetKinds, objectDescriptors, transforms.objects, transforms.selects, colorAllocatorFactory);
                // Note: Do this step after transformObjects() so that metadata columns in 'transformed' have roles and objects.general.formatString populated
                transformed = data.DataViewConcatenateCategoricalColumns.detectAndApply(transformed, objectDescriptors, roleMappings, projectionOrdering, transforms.selects, projectionActiveItems);
                data.DataViewNormalizeValues.apply({
                    dataview: transformed,
                    dataViewMappings: roleMappings,
                    dataRoles: dataRoles,
                });
                return transformed;
            }
            function getTargetKinds(roleMappings) {
                debug.assertAnyValue(roleMappings, 'roleMappings');
                if (!roleMappings)
                    return 0 /* None */;
                var result = 0 /* None */;
                for (var _i = 0, roleMappings_1 = roleMappings; _i < roleMappings_1.length; _i++) {
                    var roleMapping = roleMappings_1[_i];
                    if (roleMapping.categorical)
                        result |= 1 /* Categorical */;
                    if (roleMapping.matrix)
                        result |= 2 /* Matrix */;
                    if (roleMapping.single)
                        result |= 4 /* Single */;
                    if (roleMapping.table)
                        result |= 8 /* Table */;
                    if (roleMapping.tree)
                        result |= 16 /* Tree */;
                }
                return result;
            }
            function transformSelects(dataView, roleMappings, selectTransforms, projectionOrdering, selectsToInclude) {
                var columnRewrites = [];
                if (selectTransforms) {
                    dataView.metadata.columns = applyTransformsToColumns(dataView.metadata.columns, selectTransforms, columnRewrites);
                }
                // NOTE: no rewrites necessary for Tree (it doesn't reference the columns)
                if (dataView.categorical) {
                    dataView.categorical = applyRewritesToCategorical(dataView.categorical, columnRewrites, selectsToInclude);
                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)
                    // NOTE: This is slightly DSR-specific.
                    dataView = pivotIfNecessary(dataView, roleMappings);
                }
                if (dataView.matrix) {
                    var matrixTransformationContext = {
                        rowHierarchyRewritten: false,
                        columnHierarchyRewritten: false,
                        hierarchyTreesRewritten: false
                    };
                    dataView.matrix = applyRewritesToMatrix(dataView.matrix, columnRewrites, roleMappings, projectionOrdering, matrixTransformationContext);
                    // TODO VSTS 7024199: separate out structural transformations from dataViewTransform.transformSelects(...)
                    if (shouldPivotMatrix(dataView.matrix, roleMappings))
                        data.DataViewPivotMatrix.apply(dataView.matrix, matrixTransformationContext);
                }
                if (dataView.table)
                    dataView.table = applyRewritesToTable(dataView.table, columnRewrites, roleMappings, projectionOrdering);
                return dataView;
            }
            function applyTransformsToColumns(prototypeColumns, selects, rewrites) {
                debug.assertValue(prototypeColumns, 'columns');
                if (!selects)
                    return prototypeColumns;
                //column may contain undefined entries
                var columns = inherit(prototypeColumns);
                for (var i = 0, len = prototypeColumns.length; i < len; i++) {
                    var prototypeColumn = prototypeColumns[i];
                    var select = selects[prototypeColumn.index];
                    if (!select)
                        continue;
                    var column = columns[i] = inherit(prototypeColumn);
                    if (select.roles)
                        column.roles = select.roles;
                    if (select.type)
                        column.type = select.type;
                    column.format = getFormatForColumn(select, column);
                    if (select.displayName)
                        column.displayName = select.displayName;
                    if (select.queryName)
                        column.queryName = select.queryName;
                    if (select.kpi)
                        column.kpi = select.kpi;
                    if (select.sort)
                        column.sort = select.sort;
                    if (select.discourageAggregationAcrossGroups)
                        column.discourageAggregationAcrossGroups = select.discourageAggregationAcrossGroups;
                    rewrites.push({
                        from: prototypeColumn,
                        to: column,
                    });
                }
                return columns;
            }
            /**
             * Get the column format. Order of precendence is:
             *  1. Select format
             *  2. Column format
             */
            function getFormatForColumn(select, column) {
                // TODO: we already copied the select.Format to column.format, we probably don't need this check
                return select.format || column.format;
            }
            function applyRewritesToCategorical(prototype, columnRewrites, selectsToInclude) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(columnRewrites, 'columnRewrites');
                var categorical = inherit(prototype);
                function override(value) {
                    var rewrittenSource = findOverride(value.source, columnRewrites);
                    if (rewrittenSource) {
                        var rewritten = inherit(value);
                        rewritten.source = rewrittenSource;
                        return rewritten;
                    }
                }
                var categories = powerbi.Prototype.overrideArray(prototype.categories, override);
                if (categories)
                    categorical.categories = categories;
                var valuesOverride = powerbi.Prototype.overrideArray(prototype.values, override);
                var values = valuesOverride || prototype.values;
                if (values) {
                    var grouped = inherit(values.grouped());
                    for (var i = 0, ilen = grouped.length; i < ilen; i++) {
                        grouped[i] = inherit(grouped[i]);
                    }
                    if (selectsToInclude) {
                        // Apply selectsToInclude to values by removing value columns not included
                        for (var i = values.length - 1; i >= 0; i--) {
                            if (!selectsToInclude[values[i].source.index]) {
                                values.splice(i, 1);
                            }
                        }
                        // Apply selectsToInclude to grouped()
                        if (values.length > 0 && values[0].identity) {
                            // We have a dynamic series, so we should remove any value columns not included in the split from each
                            //    valueColumnGroup
                            for (var i = 0, ilen = grouped.length; i < ilen; i++) {
                                var currentGroupValues = grouped[i].values;
                                for (var j = currentGroupValues.length - 1; j >= 0; j--) {
                                    if (!selectsToInclude[currentGroupValues[j].source.index])
                                        currentGroupValues.splice(i, 1);
                                }
                            }
                        }
                        else {
                            // We are in a static series, so we should throw away the grouped and recreate it using the static values
                            //   which have already been filtered
                            grouped = [];
                            grouped[0] = {
                                values: values,
                            };
                        }
                    }
                    if (values.source) {
                        if (selectsToInclude && !selectsToInclude[values.source.index]) {
                            values.source = undefined;
                        }
                        else {
                            var rewrittenValuesSource = findOverride(values.source, columnRewrites);
                            if (rewrittenValuesSource)
                                values.source = rewrittenValuesSource;
                        }
                    }
                    var currentGroupIndex = 0;
                    var group = void 0;
                    for (var i = 0, ilen = values.length; i < ilen; i++) {
                        var currentValue = values[i];
                        if (!group || (currentValue.identity !== group.identity)) {
                            group = inherit(grouped[currentGroupIndex]);
                            grouped[currentGroupIndex] = group;
                            group.values = [];
                            currentGroupIndex++;
                        }
                        group.values.push(currentValue);
                    }
                    categorical.values = values;
                    setGrouped(values, grouped);
                }
                return categorical;
            }
            function applyRewritesToTable(prototype, columnRewrites, roleMappings, projectionOrdering) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(columnRewrites, 'columnRewrites');
                // Don't perform this potentially expensive transform unless we actually have a table.
                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.
                if (!roleMappings || roleMappings.length !== 1 || !roleMappings[0].table)
                    return prototype;
                var table = inherit(prototype);
                // Copy the rewritten columns into the table view
                var override = function (metadata) { return findOverride(metadata, columnRewrites); };
                var columns = powerbi.Prototype.overrideArray(prototype.columns, override);
                if (columns)
                    table.columns = columns;
                if (!projectionOrdering)
                    return table;
                var newToOldPositions = createTableColumnPositionMapping(projectionOrdering, columnRewrites);
                if (!newToOldPositions)
                    return table;
                // Reorder the columns
                var columnsClone = columns.slice(0);
                var keys = Object.keys(newToOldPositions);
                for (var i = 0, len = keys.length; i < len; i++) {
                    var sourceColumn = columnsClone[newToOldPositions[keys[i]]];
                    // In the case we've hit the end of our columns array, but still have position reordering keys,
                    // there is a duplicate column so we will need to add a new column for the duplicate data
                    if (i === columns.length)
                        columns.push(sourceColumn);
                    else {
                        debug.assert(i < columns.length, 'The column index is out of range for reordering.');
                        columns[i] = sourceColumn;
                    }
                }
                // Reorder the rows
                var rows = powerbi.Prototype.overrideArray(table.rows, function (row) {
                    var newRow = [];
                    for (var i = 0, len = keys.length; i < len; ++i)
                        newRow[i] = row[newToOldPositions[keys[i]]];
                    return newRow;
                });
                if (rows)
                    table.rows = rows;
                return table;
            }
            /** Creates a mapping of new position to original position. */
            function createTableColumnPositionMapping(projectionOrdering, columnRewrites) {
                var roles = Object.keys(projectionOrdering);
                // If we have more than one role then the ordering of columns between roles is ambiguous, so don't reorder anything.
                if (roles.length !== 1)
                    return;
                var role = roles[0], originalOrder = _.map(columnRewrites, function (rewrite) { return rewrite.from.index; }), newOrder = projectionOrdering[role];
                return createOrderMapping(originalOrder, newOrder);
            }
            function applyRewritesToMatrix(prototype, columnRewrites, roleMappings, projectionOrdering, context) {
                debug.assertValue(prototype, 'prototype');
                debug.assertValue(columnRewrites, 'columnRewrites');
                // Don't perform this potentially expensive transform unless we actually have a matrix.
                // When we switch to lazy per-visual DataView creation, we'll be able to remove this check.
                if (!roleMappings || roleMappings.length < 1 || !(roleMappings[0].matrix || (roleMappings[1] && roleMappings[1].matrix)))
                    return prototype;
                var matrixMapping = roleMappings[0].matrix || roleMappings[1].matrix;
                var matrix = inherit(prototype);
                function override(metadata) {
                    return findOverride(metadata, columnRewrites);
                }
                function overrideHierarchy(hierarchy) {
                    var rewrittenHierarchy = null;
                    var newLevels = powerbi.Prototype.overrideArray(hierarchy.levels, function (level) {
                        var newLevel = null;
                        var levelSources = powerbi.Prototype.overrideArray(level.sources, override);
                        if (levelSources)
                            newLevel = ensureRewritten(newLevel, level, function (h) { return h.sources = levelSources; });
                        return newLevel;
                    });
                    if (newLevels)
                        rewrittenHierarchy = ensureRewritten(rewrittenHierarchy, hierarchy, function (r) { return r.levels = newLevels; });
                    return rewrittenHierarchy;
                }
                var rows = overrideHierarchy(matrix.rows);
                if (rows) {
                    matrix.rows = rows;
                    context.rowHierarchyRewritten = true;
                }
                var columns = overrideHierarchy(matrix.columns);
                if (columns) {
                    matrix.columns = columns;
                    context.columnHierarchyRewritten = true;
                }
                var valueSources = powerbi.Prototype.overrideArray(matrix.valueSources, override);
                if (valueSources) {
                    matrix.valueSources = valueSources;
                    // Only need to reorder if we have more than one value source, and they are all bound to the same role
                    var matrixValues = matrixMapping.values;
                    if (projectionOrdering && valueSources.length > 1 && matrixValues && matrixValues.for) {
                        var columnLevels = columns.levels.length;
                        if (columnLevels > 0) {
                            var newToOldPositions_1 = createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites);
                            if (newToOldPositions_1) {
                                var keys_1 = Object.keys(newToOldPositions_1);
                                var numKeys_1 = keys_1.length;
                                // Reorder the value columns
                                columns.root = data.DataViewPivotMatrix.cloneTree(columns.root);
                                if (columnLevels === 1)
                                    reorderChildNodes(columns.root, newToOldPositions_1);
                                else
                                    forEachNodeAtLevel(columns.root, columnLevels - 2, function (node) { return reorderChildNodes(node, newToOldPositions_1); });
                                // Reorder the value rows
                                matrix.rows.root = data.DataViewPivotMatrix.cloneTreeExecuteOnLeaf(matrix.rows.root, function (node) {
                                    if (!node.values)
                                        return;
                                    var newValues = {};
                                    var iterations = Object.keys(node.values).length / numKeys_1;
                                    for (var i = 0, len = iterations; i < len; i++) {
                                        var offset = i * numKeys_1;
                                        for (var keysIndex = 0; keysIndex < numKeys_1; keysIndex++)
                                            newValues[offset + keysIndex] = node.values[offset + newToOldPositions_1[keys_1[keysIndex]]];
                                    }
                                    node.values = newValues;
                                });
                                context.hierarchyTreesRewritten = true;
                            }
                        }
                    }
                }
                reorderMatrixCompositeGroups(matrix, matrixMapping, projectionOrdering);
                return matrix;
            }
            function reorderChildNodes(node, newToOldPositions) {
                var keys = Object.keys(newToOldPositions);
                var numKeys = keys.length;
                var children = node.children;
                var childrenClone = children.slice(0);
                for (var i = 0, len = numKeys; i < len; i++) {
                    var sourceColumn = childrenClone[newToOldPositions[keys[i]]];
                    // In the case we've hit the end of our columns array, but still have position reordering keys,
                    // there is a duplicate column so we will need to add a new column for the duplicate data
                    if (i === children.length)
                        children.push(sourceColumn);
                    else {
                        debug.assert(i < children.length, 'The column index is out of range for reordering.');
                        children[i] = sourceColumn;
                    }
                }
            }
            /**
             * Returns a inheritSingle() version of the specified prototype DataViewMatrix with any composite group levels
             * and values re-ordered by projection ordering.
             * Returns undefined if no re-ordering under the specified prototype is necessary.
             */
            function reorderMatrixCompositeGroups(prototype, supportedDataViewMapping, projection) {
                var transformedDataView;
                if (prototype && supportedDataViewMapping && projection) {
                    // reorder levelValues in any composite groups in rows hierarchy
                    var transformedRowsHierarchy_1;
                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.rows, {
                        visitRole: function (role, context) {
                            transformedRowsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedRowsHierarchy_1 || prototype.rows, role, projection);
                        }
                    });
                    // reorder levelValues in any composite groups in columns hierarchy
                    var transformedColumnsHierarchy_1;
                    powerbi.DataViewMapping.visitMatrixItems(supportedDataViewMapping.columns, {
                        visitRole: function (role, context) {
                            transformedColumnsHierarchy_1 = reorderMatrixHierarchyCompositeGroups(transformedColumnsHierarchy_1 || prototype.columns, role, projection);
                        }
                    });
                    if (transformedRowsHierarchy_1 || transformedColumnsHierarchy_1) {
                        transformedDataView = inheritSingle(prototype);
                        transformedDataView.rows = transformedRowsHierarchy_1 || transformedDataView.rows;
                        transformedDataView.columns = transformedColumnsHierarchy_1 || transformedDataView.columns;
                    }
                }
                return transformedDataView;
            }
            /**
             * Returns a inheritSingle() version of the specified matrixHierarchy with any composite group levels and
             * values re-ordered by projection ordering.
             * Returns undefined if no re-ordering under the specified matrixHierarchy is necessary.
             */
            function reorderMatrixHierarchyCompositeGroups(matrixHierarchy, hierarchyRole, projection) {
                debug.assertValue(matrixHierarchy, 'matrixHierarchy');
                debug.assertValue(hierarchyRole, 'hierarchyRole');
                debug.assertValue(projection, 'projection');
                var transformedHierarchy;
                var selectIndicesInProjectionOrder = projection[hierarchyRole];
                // reordering needs to happen only if there are multiple columns for the hierarchy's role in the projection
                var hasMultipleColumnsInProjection = selectIndicesInProjectionOrder && selectIndicesInProjectionOrder.length >= 2;
                if (hasMultipleColumnsInProjection && !_.isEmpty(matrixHierarchy.levels)) {
                    for (var i = matrixHierarchy.levels.length - 1; i >= 0; i--) {
                        var hierarchyLevel = matrixHierarchy.levels[i];
                        // compute a mapping for any necessary reordering of columns at this given level, based on projection ordering
                        var newToOldLevelSourceIndicesMapping = createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection);
                        if (newToOldLevelSourceIndicesMapping) {
                            if (_.isUndefined(transformedHierarchy)) {
                                // Because we start inspecting the hierarchy from the deepest level and work backwards to the root,
                                // the current hierarchyLevel is therefore the inner-most level that needs re-ordering of composite group values...
                                transformedHierarchy = inheritSingle(matrixHierarchy);
                                transformedHierarchy.levels = inheritSingle(matrixHierarchy.levels);
                                // Because the current hierarchyLevel is the inner-most level that needs re-ordering of composite group values,
                                // inheriting all nodes from root down to this level will also prepare the nodes for any transform that needs to
                                // happen in other hierarchy levels in the later iterations of this for-loop.
                                transformedHierarchy.root = data.utils.DataViewMatrixUtils.inheritMatrixNodeHierarchy(matrixHierarchy.root, i, true);
                            }
                            // reorder the metadata columns in the sources array at that level
                            var transformingHierarchyLevel = inheritSingle(matrixHierarchy.levels[i]); // inherit at most once during the whole dataViewTransform for this obj...
                            transformedHierarchy.levels[i] = reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping);
                            // reorder the level values in the composite group nodes at the current hierarchy level
                            reorderMatrixHierarchyLevelValues(transformedHierarchy.root, i, newToOldLevelSourceIndicesMapping);
                        }
                    }
                }
                return transformedHierarchy;
            }
            /**
             * If reordering is needed on the level's metadata column sources (i.e. hierarchyLevel.sources),
             * returns the mapping from the target LevelSourceIndex (based on projection order) to original LevelSourceIndex.
             *
             * The returned value maps level source indices from the new target order (calculated from projection order)
             * back to the original order as they appear in the specified hierarchyLevel's sources.
             * Please refer to comments on the createOrderMapping() function for more explanation on the mappings in the return value.
             *
             * Note: The return value is the mapping from new index to old index, for consistency with existing and similar functions in this module.
             *
             * @param hierarchyLevel The hierarchy level that contains the metadata column sources.
             * @param hierarchyRoleName The role name for the hierarchy where the specified hierarchyLevel belongs.
             * @param projection The projection ordering that includes an ordering for the specified hierarchyRoleName.
             */
            function createMatrixHierarchyLevelSourcesPositionMapping(hierarchyLevel, hierarchyRole, projection) {
                debug.assertValue(hierarchyLevel, 'hierarchyLevel');
                debug.assertValue(hierarchyRole, 'hierarchyRole');
                debug.assertValue(projection, 'projection');
                debug.assertValue(projection[hierarchyRole], 'pre-condition: The specified projection must contain an ordering for the specified hierarchyRoleName.');
                var newToOldLevelSourceIndicesMapping;
                var levelSourceColumns = hierarchyLevel.sources;
                if (levelSourceColumns && levelSourceColumns.length >= 2) {
                    // The hierarchy level has multiple columns, so it is possible to have composite group, go on to check other conditions...
                    var columnsForHierarchyRoleOrderedByLevelSourceIndex = data.utils.DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder(levelSourceColumns, projection, hierarchyRole);
                    if (columnsForHierarchyRoleOrderedByLevelSourceIndex && columnsForHierarchyRoleOrderedByLevelSourceIndex.length >= 2) {
                        // The hierarchy level has multiple columns for the hierarchy's role, go on to calculate newToOldLevelSourceIndicesMapping...
                        var columnsForHierarchyRoleOrderedByProjection = _.sortBy(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.projectionOrderIndex; });
                        newToOldLevelSourceIndicesMapping = createOrderMapping(_.map(columnsForHierarchyRoleOrderedByLevelSourceIndex, function (columnInfo) { return columnInfo.sourceIndex; }), _.map(columnsForHierarchyRoleOrderedByProjection, function (columnInfo) { return columnInfo.sourceIndex; }));
                    }
                }
                return newToOldLevelSourceIndicesMapping;
            }
            /**
             * Applies re-ordering on the specified transformingHierarchyLevel's sources.
             * Returns the same object as the specified transformingHierarchyLevel.
             */
            function reorderMatrixHierarchyLevelColumnSources(transformingHierarchyLevel, newToOldLevelSourceIndicesMapping) {
                debug.assertValue(transformingHierarchyLevel, 'transformingHierarchyLevel');
                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');
                var originalLevelSources = transformingHierarchyLevel.sources;
                transformingHierarchyLevel.sources = originalLevelSources.slice(0); // make a clone of the array before modifying it, because the for-loop depends on the origin array.
                var newLevelSourceIndices = Object.keys(newToOldLevelSourceIndicesMapping);
                for (var i = 0, ilen = newLevelSourceIndices.length; i < ilen; i++) {
                    var newLevelSourceIndex = newLevelSourceIndices[i];
                    var oldLevelSourceIndex = newToOldLevelSourceIndicesMapping[newLevelSourceIndex];
                    debug.assert(oldLevelSourceIndex < originalLevelSources.length, 'pre-condition: The value in every mapping in the specified levelSourceIndicesReorderingMap must be a valid index to the specified hierarchyLevel.sources array property');
                    transformingHierarchyLevel.sources[newLevelSourceIndex] = originalLevelSources[oldLevelSourceIndex];
                }
                return transformingHierarchyLevel;
            }
            /**
             * Reorders the elements in levelValues in each node under transformingHierarchyRootNode at the specified hierarchyLevel,
             * and updates their DataViewMatrixGroupValue.levelSourceIndex property.
             *
             * Returns the same object as the specified transformingHierarchyRootNode.
             */
            function reorderMatrixHierarchyLevelValues(transformingHierarchyRootNode, transformingHierarchyLevelIndex, newToOldLevelSourceIndicesMapping) {
                debug.assertValue(transformingHierarchyRootNode, 'transformingHierarchyRootNode');
                debug.assertValue(newToOldLevelSourceIndicesMapping, 'newToOldLevelSourceIndicesMapping');
                var oldToNewLevelSourceIndicesMapping = createReversedMapping(newToOldLevelSourceIndicesMapping);
                forEachNodeAtLevel(transformingHierarchyRootNode, transformingHierarchyLevelIndex, function (transformingMatrixNode) {
                    var originalLevelValues = transformingMatrixNode.levelValues;
                    // Note: Technically this function is incorrect, because the driving source of the new LevelValues is really
                    // the "projection for this composite group", a concept that isn't yet implemented in DataViewProjectionOrdering.
                    // The following code isn't correct in the special case where a column is projected twice in this composite group,
                    // in which case the DSR will not have the duplicate columns; DataViewTransform is supposed to expand the duplicates.
                    // Until we fully implement composite group projection, though, we'll just sort what we have in transformingMatrixNode.levelValues.
                    if (!_.isEmpty(originalLevelValues)) {
                        // First, re-order the elements in transformingMatrixNode.levelValues by the new levelSourceIndex order.
                        // _.sortBy() also creates a new array, which we want to do for all nodes (including when levelValues.length === 1)
                        // because we don't want to accidentally modify the array AND its value references in Query DataView
                        var newlyOrderedLevelValues = _.sortBy(originalLevelValues, function (levelValue) { return oldToNewLevelSourceIndicesMapping[levelValue.levelSourceIndex]; });
                        for (var i = 0, ilen = newlyOrderedLevelValues.length; i < ilen; i++) {
                            var transformingLevelValue = inheritSingle(newlyOrderedLevelValues[i]);
                            transformingLevelValue.levelSourceIndex = oldToNewLevelSourceIndicesMapping[transformingLevelValue.levelSourceIndex];
                            newlyOrderedLevelValues[i] = transformingLevelValue;
                        }
                        transformingMatrixNode.levelValues = newlyOrderedLevelValues;
                        // For consistency with how DataViewTreeNode.value works, and for a bit of backward compatibility,
                        // copy the last value from DataViewMatrixNode.levelValues to DataViewMatrixNode.value.
                        var newlyOrderedLastLevelValue = _.last(newlyOrderedLevelValues);
                        if (transformingMatrixNode.value !== newlyOrderedLastLevelValue.value) {
                            transformingMatrixNode.value = newlyOrderedLastLevelValue.value;
                        }
                        if ((transformingMatrixNode.levelSourceIndex || 0) !== newlyOrderedLastLevelValue.levelSourceIndex) {
                            transformingMatrixNode.levelSourceIndex = newlyOrderedLastLevelValue.levelSourceIndex;
                        }
                    }
                });
                return transformingHierarchyRootNode;
            }
            /**
             * Creates a mapping of new position to original position.
             *
             * The return value is a mapping where each key-value pair represent the order  mapping of a particular column:
             * - the key in the key-value pair is the index of the particular column in the new order (e.g. projection order)
             * - the value in the key-value pair is the index of the particular column in the original order
             */
            function createMatrixValuesPositionMapping(matrixValues, projectionOrdering, valueSources, columnRewrites) {
                var role = matrixValues.for.in;
                var newOrder = projectionOrdering[role];
                var originalOrder = _.chain(columnRewrites)
                    .filter(function (rewrite) { return _.contains(valueSources, rewrite.to); })
                    .map(function (rewrite) { return rewrite.from.index; })
                    .value();
                return createOrderMapping(originalOrder, newOrder);
            }
            /**
             * Creates a mapping of indices, from indices to the specified newOrder array, back to indices to the specified
             * originalOrder array.
             * Each of the number value in originalOrder and newOrder is actually the unique key of a column (unqiue
             * under the context of the caller code), e.g. the Select Index in projection ordering array.
             * Also, the specified originalOrder must contain every value that exists in newOrder.
             *
             * If the specified originalOrder and newOrder are different in sequence order, then this function returns a collection of
             * key-value pair, each of which represents the new and old indices of a particular column:
             * - the key in each key-value pair is the index of the particular column key as it exists in the specified newOrder array
             * - the value in each key-value pair is the index of the particular column key as it exists in the specified originalOrder array
             *
             * For example on how the return value is consumed, see functions such as reorderMatrixHierarchyLevelColumnSources(...).
             *
             * If the specified originalOrder and newOrder are same, then this function returns undefined.
             *
             * @param originalOrder E.g. an array of metadata column "select indices", in the original order as they exist in Query DataView.
             * @param newOrder E.g. an array of metadata column "select indices", in rojection ordering.
             */
            function createOrderMapping(originalOrder, newOrder) {
                // Optimization: avoid rewriting if the current order is correct
                if (ArrayExtensions.sequenceEqual(originalOrder, newOrder, function (x, y) { return x === y; }))
                    return;
                var mapping = {};
                for (var i = 0, len = newOrder.length; i < len; ++i) {
                    var newPosition = newOrder[i];
                    mapping[i] = originalOrder.indexOf(newPosition);
                }
                return mapping;
            }
            function createReversedMapping(mapping) {
                debug.assertValue(mapping, 'mapping');
                var reversed = {};
                for (var key in mapping) {
                    // Note: key is a string after we get it out from mapping, thus we need to parse it
                    // back into a number before putting it as the value in the reversed mapping
                    var value = mapping[key];
                    var keyAsNumber = parseInt(key, 10);
                    reversed[value] = keyAsNumber;
                }
                debug.assertValue(Object.keys(mapping).length === Object.keys(reversed).length, 'pre-condition: The specified mapping must not contain any duplicate value because duplicate values are obmitted from the reversed mapping.');
                return reversed;
            }
            function forEachNodeAtLevel(node, targetLevel, callback) {
                debug.assertValue(node, 'node');
                debug.assert(targetLevel >= 0, 'argetLevel >= 0');
                debug.assertValue(callback, 'callback');
                if (node.level === targetLevel) {
                    callback(node);
                    return;
                }
                var children = node.children;
                if (children && children.length > 0) {
                    for (var i = 0, ilen = children.length; i < ilen; i++)
                        forEachNodeAtLevel(children[i], targetLevel, callback);
                }
            }
            DataViewTransform.forEachNodeAtLevel = forEachNodeAtLevel;
            function findOverride(source, columnRewrites) {
                for (var i = 0, len = columnRewrites.length; i < len; i++) {
                    var columnRewrite = columnRewrites[i];
                    if (columnRewrite.from === source)
                        return columnRewrite.to;
                }
            }
            function ensureRewritten(rewritten, prototype, callback) {
                if (!rewritten)
                    rewritten = inherit(prototype);
                if (callback)
                    callback(rewritten);
                return rewritten;
            }
            function transformObjects(dataView, targetDataViewKinds, objectDescriptors, objectDefinitions, selectTransforms, colorAllocatorFactory) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');
                debug.assertAnyValue(objectDescriptors, 'objectDescriptors');
                debug.assertAnyValue(objectDefinitions, 'objectDefinitions');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                if (!objectDescriptors)
                    return;
                var objectsForAllSelectors = data.DataViewObjectEvaluationUtils.groupObjectsBySelector(objectDefinitions);
                data.DataViewObjectEvaluationUtils.addImplicitObjects(objectsForAllSelectors, objectDescriptors, dataView.metadata.columns, selectTransforms);
                var metadataOnce = objectsForAllSelectors.metadataOnce;
                var dataObjects = objectsForAllSelectors.data;
                if (metadataOnce)
                    evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, metadataOnce.objects, dataObjects, colorAllocatorFactory);
                var metadataObjects = objectsForAllSelectors.metadata;
                if (metadataObjects) {
                    for (var i = 0, len = metadataObjects.length; i < len; i++) {
                        var metadataObject = metadataObjects[i];
                        var objectDefns = metadataObject.objects;
                        var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);
                        evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, metadataObject.selector, objectDefns, colorAllocatorCache);
                    }
                }
                for (var i = 0, len = dataObjects.length; i < len; i++) {
                    var dataObject = dataObjects[i];
                    var objectDefns = dataObject.objects;
                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);
                    evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, dataObject.selector, dataObject.rules, objectDefns, colorAllocatorCache);
                }
                var userDefined = objectsForAllSelectors.userDefined;
                if (userDefined) {
                    // TODO: We only handle user defined objects at the metadata level, but should be able to support them with arbitrary repetition.
                    evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, userDefined, colorAllocatorFactory);
                }
            }
            DataViewTransform.transformObjects = transformObjects;
            function evaluateUserDefinedObjects(dataView, selectTransforms, objectDescriptors, objectDefns, colorAllocatorFactory) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                var dataViewObjects = dataView.metadata.objects;
                if (!dataViewObjects) {
                    dataViewObjects = dataView.metadata.objects = {};
                }
                for (var _i = 0, objectDefns_1 = objectDefns; _i < objectDefns_1.length; _i++) {
                    var objectDefn = objectDefns_1[_i];
                    var id = objectDefn.selector.id;
                    var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefn.objects, colorAllocatorFactory);
                    var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);
                    var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefn.objects);
                    for (var objectName in objects) {
                        var object = objects[objectName];
                        var map = dataViewObjects[objectName];
                        if (!map)
                            map = dataViewObjects[objectName] = [];
                        debug.assert(powerbi.DataViewObjects.isUserDefined(map), 'expected DataViewObjectMap');
                        // NOTE: We do not check for duplicate ids.
                        map.push({ id: id, object: object });
                    }
                }
            }
            /** Evaluates and sets properties on the DataView metadata. */
            function evaluateMetadataObjects(dataView, selectTransforms, objectDescriptors, objectDefns, dataObjects, colorAllocatorFactory) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(dataObjects, 'dataObjects');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                var colorAllocatorCache = populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory);
                var evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);
                var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                if (objects) {
                    dataView.metadata.objects = objects;
                    for (var objectName in objects) {
                        var object = objects[objectName], objectDesc = objectDescriptors[objectName];
                        for (var propertyName in object) {
                            var propertyDesc = objectDesc.properties[propertyName], ruleDesc = propertyDesc.rule;
                            if (!ruleDesc)
                                continue;
                            var definition = createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, object[propertyName], propertyDesc.type);
                            if (!definition)
                                continue;
                            dataObjects.push(definition);
                        }
                    }
                }
            }
            function createRuleEvaluationInstance(dataView, colorAllocatorFactory, ruleDesc, objectName, propertyValue, ruleType) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(ruleDesc, 'ruleDesc');
                debug.assertValue(propertyValue, 'propertyValue');
                debug.assertValue(ruleType, 'ruleType');
                var ruleOutput = ruleDesc.output;
                if (!ruleOutput)
                    return;
                var selectorToCreate = findSelectorForRuleInput(dataView, ruleOutput.selector);
                if (!selectorToCreate)
                    return;
                if (ruleType.fillRule) {
                    return createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue);
                }
            }
            function createRuleEvaluationInstanceFillRule(dataView, colorAllocatorFactory, ruleDesc, selectorToCreate, objectName, propertyValue) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(ruleDesc, 'ruleDesc');
                debug.assertValue(selectorToCreate, 'selectorToCreate');
                debug.assertValue(propertyValue, 'propertyValue');
                var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, ruleDesc.inputRole, 1 /* Role */, propertyValue);
                if (!colorAllocator)
                    return;
                var rule = new data.ColorRuleEvaluation(ruleDesc.inputRole, colorAllocator);
                var fillRuleProperties = {};
                fillRuleProperties[ruleDesc.output.property] = {
                    solid: { color: rule }
                };
                return {
                    selector: selectorToCreate,
                    rules: [rule],
                    objects: [{
                            name: objectName,
                            properties: fillRuleProperties,
                        }]
                };
            }
            function tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(identifier, 'identifier');
                debug.assertValue(identifierKind, 'identifierKind');
                debug.assertValue(propertyValue, 'propertyValue');
                if (propertyValue.linearGradient2)
                    return createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient2);
                if (propertyValue.linearGradient3)
                    return createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValue, propertyValue.linearGradient3);
            }
            function createColorAllocatorLinearGradient2(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient2) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(identifier, 'identifier');
                debug.assertValue(identifierKind, 'identifierKind');
                debug.assertValue(linearGradient2, 'linearGradient2');
                linearGradient2 = propertyValueFillRule.linearGradient2;
                if (linearGradient2.min.value === undefined ||
                    linearGradient2.max.value === undefined) {
                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);
                    if (!inputRange)
                        return;
                    if (linearGradient2.min.value === undefined)
                        linearGradient2.min.value = inputRange.min;
                    if (linearGradient2.max.value === undefined)
                        linearGradient2.max.value = inputRange.max;
                }
                return colorAllocatorFactory.linearGradient2(propertyValueFillRule.linearGradient2);
            }
            function createColorAllocatorLinearGradient3(dataView, colorAllocatorFactory, identifier, identifierKind, propertyValueFillRule, linearGradient3) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertValue(identifier, 'identifier');
                debug.assertValue(identifierKind, 'identifierKind');
                debug.assertValue(linearGradient3, 'linearGradient3');
                var splitScales;
                linearGradient3 = propertyValueFillRule.linearGradient3;
                if (linearGradient3.min.value === undefined ||
                    linearGradient3.mid.value === undefined ||
                    linearGradient3.max.value === undefined) {
                    var inputRange = findRuleInputColumnNumberRange(dataView, identifier, identifierKind);
                    if (!inputRange)
                        return;
                    splitScales =
                        linearGradient3.min.value === undefined &&
                            linearGradient3.max.value === undefined &&
                            linearGradient3.mid.value !== undefined;
                    if (linearGradient3.min.value === undefined) {
                        linearGradient3.min.value = inputRange.min;
                    }
                    if (linearGradient3.max.value === undefined) {
                        linearGradient3.max.value = inputRange.max;
                    }
                    if (linearGradient3.mid.value === undefined) {
                        var midValue = (linearGradient3.max.value + linearGradient3.min.value) / 2;
                        linearGradient3.mid.value = midValue;
                    }
                }
                return colorAllocatorFactory.linearGradient3(propertyValueFillRule.linearGradient3, splitScales);
            }
            function populateColorAllocatorCache(dataView, selectTransforms, objectDefns, colorAllocatorFactory) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                var cache = data.createColorAllocatorCache();
                var staticEvalContext = data.createStaticEvalContext();
                for (var i = 0, len = objectDefns.length; i < len; i++) {
                    var objectDefnProperties = objectDefns[i].properties;
                    for (var propertyName in objectDefnProperties) {
                        var fillProperty = objectDefnProperties[propertyName];
                        if (fillProperty &&
                            fillProperty.solid &&
                            fillProperty.solid.color &&
                            fillProperty.solid.color.kind === 23 /* FillRule */) {
                            var fillRuleExpr = fillProperty.solid.color;
                            var inputExprQueryName = findFirstQueryNameForExpr(selectTransforms, fillRuleExpr.input);
                            if (!inputExprQueryName)
                                continue;
                            var fillRule = data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, fillRulePropertyDescriptor, fillRuleExpr.rule);
                            var colorAllocator = tryCreateColorAllocatorForFillRule(dataView, colorAllocatorFactory, inputExprQueryName, 0 /* QueryName */, fillRule);
                            if (colorAllocator)
                                cache.register(fillRuleExpr, colorAllocator);
                        }
                    }
                }
                return cache;
            }
            function evaluateDataRepetition(dataView, targetDataViewKinds, selectTransforms, objectDescriptors, selector, rules, objectDefns, colorAllocatorCache) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(targetDataViewKinds, 'targetDataViewKinds');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorFactory');
                var containsWildcard = data.Selector.containsWildcard(selector);
                var dataViewCategorical = dataView.categorical;
                if (dataViewCategorical && EnumExtensions.hasFlag(targetDataViewKinds, 1 /* Categorical */)) {
                    // 1) Match against categories
                    evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);
                    // 2) Match against valueGrouping
                    evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);
                }
                var dataViewMatrix = dataView.matrix;
                if (dataViewMatrix && EnumExtensions.hasFlag(targetDataViewKinds, 2 /* Matrix */)) {
                    var rewrittenMatrix = evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache);
                    if (rewrittenMatrix) {
                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                        // revisit this, likely when we do lazy evaluation of DataView.
                        dataView.matrix = rewrittenMatrix;
                    }
                }
                var dataViewTable = dataView.table;
                if (dataViewTable && EnumExtensions.hasFlag(targetDataViewKinds, 8 /* Table */)) {
                    var rewrittenSelector = rewriteTableRoleSelector(dataViewTable, selector);
                    var rewrittenTable = evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, rewrittenSelector, rules, containsWildcard, objectDefns, colorAllocatorCache);
                    if (rewrittenTable) {
                        // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                        // revisit this, likely when we do lazy evaluation of DataView.
                        dataView.table = rewrittenTable;
                    }
                }
            }
            function rewriteTableRoleSelector(dataViewTable, selector) {
                if (data.Selector.hasRoleWildcard(selector)) {
                    selector = findSelectorForRoleWildcard(dataViewTable, selector);
                }
                return selector;
            }
            function findSelectorForRoleWildcard(dataViewTable, selector) {
                var resultingSelector = {
                    data: [],
                    id: selector.id,
                    metadata: selector.metadata
                };
                for (var _i = 0, _a = selector.data; _i < _a.length; _i++) {
                    var dataSelector = _a[_i];
                    if (data.Selector.isRoleWildcard(dataSelector)) {
                        var selectorRoles = dataSelector.roles;
                        var allColumnsBelongToSelectorRole = allColumnsBelongToRole(dataViewTable.columns, selectorRoles);
                        var exprs = dataViewTable.identityFields;
                        if (allColumnsBelongToSelectorRole && exprs) {
                            resultingSelector.data.push(data.DataViewScopeWildcard.fromExprs(exprs));
                            continue;
                        }
                    }
                    if (isUniqueDataSelector(resultingSelector.data, dataSelector)) {
                        resultingSelector.data.push(dataSelector);
                    }
                }
                return resultingSelector;
            }
            function isUniqueDataSelector(dataSelectors, newSelector) {
                if (_.isEmpty(dataSelectors))
                    return true;
                return !_.any(dataSelectors, function (dataSelector) { return dataSelector.key === newSelector.key; });
            }
            function allColumnsBelongToRole(columns, selectorRoles) {
                for (var _i = 0, columns_6 = columns; _i < columns_6.length; _i++) {
                    var column = columns_6[_i];
                    var roles = column.roles;
                    if (!roles || !_.any(selectorRoles, function (selectorRole) { return roles[selectorRole]; }))
                        return false;
                }
                return true;
            }
            function evaluateDataRepetitionCategoricalCategory(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(containsWildcard, 'containsWildcard');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                if (!dataViewCategorical.categories || dataViewCategorical.categories.length === 0)
                    return;
                var targetColumn = findSelectedCategoricalColumn(dataViewCategorical, selector);
                if (!targetColumn)
                    return;
                var identities = targetColumn.identities, foundMatch, evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);
                if (!identities)
                    return;
                debug.assert(targetColumn.column.values.length === identities.length, 'Column length mismatch');
                for (var i = 0, len = identities.length; i < len; i++) {
                    var identity = identities[i];
                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {
                        evalContext.setCurrentRowIndex(i);
                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                        if (objects) {
                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                            // revisit this, likely when we do lazy evaluation of DataView.
                            if (!targetColumn.column.objects) {
                                targetColumn.column.objects = [];
                                targetColumn.column.objects.length = len;
                            }
                            targetColumn.column.objects[i] = objects;
                        }
                        if (!containsWildcard)
                            return true;
                        foundMatch = true;
                    }
                }
                return foundMatch;
            }
            function evaluateDataRepetitionCategoricalValueGrouping(dataViewCategorical, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {
                debug.assertValue(dataViewCategorical, 'dataViewCategorical');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(containsWildcard, 'containsWildcard');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                var dataViewCategoricalValues = dataViewCategorical.values;
                if (!dataViewCategoricalValues || !dataViewCategoricalValues.identityFields)
                    return;
                if (!data.Selector.matchesKeys(selector, [dataViewCategoricalValues.identityFields]))
                    return;
                var valuesGrouped = dataViewCategoricalValues.grouped();
                if (!valuesGrouped)
                    return;
                // NOTE: We do not set the evalContext row index below because iteration is over value groups (i.e., columns, no rows).
                // This should be enhanced in the future.
                var evalContext = data.createCategoricalEvalContext(colorAllocatorCache, dataViewCategorical);
                var foundMatch;
                for (var i = 0, len = valuesGrouped.length; i < len; i++) {
                    var valueGroup = valuesGrouped[i];
                    var selectorMetadata = selector.metadata;
                    var valuesInGroup = valueGroup.values;
                    if (containsWildcard || data.Selector.matchesData(selector, [valueGroup.identity])) {
                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                        if (objects) {
                            // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                            // revisit this, likely when we do lazy evaluation of DataView.
                            if (selectorMetadata) {
                                for (var j = 0, jlen = valuesInGroup.length; j < jlen; j++) {
                                    var valueColumn = valuesInGroup[j], valueSource = valueColumn.source;
                                    if (valueSource.queryName === selectorMetadata) {
                                        var valueSourceOverwrite = powerbi.Prototype.inherit(valueSource);
                                        valueSourceOverwrite.objects = objects;
                                        valueColumn.source = valueSourceOverwrite;
                                        foundMatch = true;
                                        break;
                                    }
                                }
                            }
                            else {
                                valueGroup.objects = objects;
                                setGrouped(dataViewCategoricalValues, valuesGrouped);
                                foundMatch = true;
                            }
                        }
                        if (!containsWildcard)
                            return true;
                    }
                }
                return foundMatch;
            }
            function evaluateDataRepetitionMatrix(dataViewMatrix, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {
                var evalContext = data.createMatrixEvalContext(colorAllocatorCache, dataViewMatrix);
                var rewrittenRows = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.rows, objectDescriptors, selector, rules, containsWildcard, objectDefns);
                var rewrittenCols = evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrix.columns, objectDescriptors, selector, rules, containsWildcard, objectDefns);
                if (rewrittenRows || rewrittenCols) {
                    var rewrittenMatrix = inheritSingle(dataViewMatrix);
                    if (rewrittenRows)
                        rewrittenMatrix.rows = rewrittenRows;
                    if (rewrittenCols)
                        rewrittenMatrix.columns = rewrittenCols;
                    return rewrittenMatrix;
                }
            }
            function evaluateDataRepetitionMatrixHierarchy(evalContext, dataViewMatrixHierarchy, objectDescriptors, selector, rules, containsWildcard, objectDefns) {
                debug.assertAnyValue(dataViewMatrixHierarchy, 'dataViewMatrixHierarchy');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(objectDefns, 'objectDefns');
                if (!dataViewMatrixHierarchy)
                    return;
                var root = dataViewMatrixHierarchy.root;
                if (!root)
                    return;
                var rewrittenRoot = evaluateDataRepetitionMatrixNode(evalContext, root, objectDescriptors, selector, rules, containsWildcard, objectDefns);
                if (rewrittenRoot) {
                    var rewrittenHierarchy = inheritSingle(dataViewMatrixHierarchy);
                    rewrittenHierarchy.root = rewrittenRoot;
                    return rewrittenHierarchy;
                }
            }
            function evaluateDataRepetitionMatrixNode(evalContext, dataViewNode, objectDescriptors, selector, rules, containsWildcard, objectDefns) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(dataViewNode, 'dataViewNode');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(objectDefns, 'objectDefns');
                var childNodes = dataViewNode.children;
                if (!childNodes)
                    return;
                var rewrittenNode;
                var shouldSearchChildren;
                var childIdentityFields = dataViewNode.childIdentityFields;
                if (childIdentityFields) {
                    // NOTE: selector matching in matrix currently only considers the current node, and does not consider parents as part of the match.
                    shouldSearchChildren = data.Selector.matchesKeys(selector, [childIdentityFields]);
                }
                for (var i = 0, len = childNodes.length; i < len; i++) {
                    var childNode = childNodes[i], identity = childNode.identity, rewrittenChildNode = null;
                    if (shouldSearchChildren) {
                        if (containsWildcard || data.Selector.matchesData(selector, [identity])) {
                            // TODO: Need to initialize context for rule-based properties.  Rule-based properties
                            // (such as fillRule/gradients) are not currently implemented.
                            var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                            if (objects) {
                                rewrittenChildNode = inheritSingle(childNode);
                                rewrittenChildNode.objects = objects;
                            }
                        }
                    }
                    else {
                        rewrittenChildNode = evaluateDataRepetitionMatrixNode(evalContext, childNode, objectDescriptors, selector, rules, containsWildcard, objectDefns);
                    }
                    if (rewrittenChildNode) {
                        if (!rewrittenNode)
                            rewrittenNode = inheritNodeAndChildren(dataViewNode);
                        rewrittenNode.children[i] = rewrittenChildNode;
                        if (!containsWildcard) {
                            // NOTE: once we find a match for a non-wildcard selector, stop looking.
                            break;
                        }
                    }
                }
                return rewrittenNode;
            }
            function inheritNodeAndChildren(node) {
                if (Object.getPrototypeOf(node) !== Object.prototype) {
                    return node;
                }
                var inherited = inheritSingle(node);
                inherited.children = inherit(node.children);
                return inherited;
            }
            function evaluateDataRepetitionTable(dataViewTable, selectTransforms, objectDescriptors, selector, rules, containsWildcard, objectDefns, colorAllocatorCache) {
                debug.assertValue(dataViewTable, 'dataViewTable');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                var evalContext = data.createTableEvalContext(colorAllocatorCache, dataViewTable, selectTransforms);
                var rewrittenRows = evaluateDataRepetitionTableRows(evalContext, dataViewTable.columns, dataViewTable.rows, dataViewTable.identity, dataViewTable.identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns);
                if (rewrittenRows) {
                    var rewrittenTable = inheritSingle(dataViewTable);
                    rewrittenTable.rows = rewrittenRows;
                    return rewrittenTable;
                }
            }
            function evaluateDataRepetitionTableRows(evalContext, columns, rows, identities, identityFields, objectDescriptors, selector, rules, containsWildcard, objectDefns) {
                debug.assertValue(evalContext, 'evalContext');
                debug.assertValue(columns, 'columns');
                debug.assertValue(rows, 'rows');
                debug.assertAnyValue(identities, 'identities');
                debug.assertAnyValue(identityFields, 'identityFields');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertAnyValue(rules, 'rules');
                debug.assertValue(objectDefns, 'objectDefns');
                if (_.isEmpty(identities) || _.isEmpty(identityFields))
                    return;
                if (!selector.metadata ||
                    !data.Selector.matchesKeys(selector, [identityFields]))
                    return;
                var colIdx = _.findIndex(columns, function (col) { return col.queryName === selector.metadata; });
                if (colIdx < 0)
                    return;
                debug.assert(rows.length === identities.length, 'row length mismatch');
                var colLen = columns.length;
                var inheritedRows;
                for (var rowIdx = 0, rowLen = identities.length; rowIdx < rowLen; rowIdx++) {
                    var identity = identities[rowIdx];
                    if (containsWildcard || data.Selector.matchesData(selector, [identity])) {
                        evalContext.setCurrentRowIndex(rowIdx);
                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                        if (objects) {
                            if (!inheritedRows)
                                inheritedRows = inheritSingle(rows);
                            var inheritedRow = inheritedRows[rowIdx] = inheritSingle(inheritedRows[rowIdx]);
                            var objectsForColumns = inheritedRow.objects;
                            if (!objectsForColumns)
                                inheritedRow.objects = objectsForColumns = new Array(colLen);
                            objectsForColumns[colIdx] = objects;
                        }
                        if (!containsWildcard)
                            break;
                    }
                }
                return inheritedRows;
            }
            function evaluateMetadataRepetition(dataView, selectTransforms, objectDescriptors, selector, objectDefns, colorAllocatorCache) {
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(selector, 'selector');
                debug.assertValue(objectDefns, 'objectDefns');
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                // TODO: This mutates the DataView -- the assumption is that prototypal inheritance has already occurred.  We should
                // revisit this, likely when we do lazy evaluation of DataView.
                var columns = dataView.metadata.columns, metadataId = selector.metadata, evalContext = data.createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms);
                for (var i = 0, len = columns.length; i < len; i++) {
                    var column = columns[i];
                    if (column.queryName === metadataId) {
                        var objects = data.DataViewObjectEvaluationUtils.evaluateDataViewObjects(evalContext, objectDescriptors, objectDefns);
                        if (objects)
                            column.objects = objects;
                    }
                }
            }
            /** Attempts to find a column that can possibly match the selector. */
            function findSelectedCategoricalColumn(dataViewCategorical, selector) {
                debug.assertValue(dataViewCategorical.categories[0], 'dataViewCategorical.categories[0]');
                var categoricalColumn = dataViewCategorical.categories[0];
                if (!categoricalColumn.identityFields)
                    return;
                if (!data.Selector.matchesKeys(selector, [categoricalColumn.identityFields]))
                    return;
                var identities = categoricalColumn.identity, targetColumn = categoricalColumn;
                var selectedMetadataId = selector.metadata;
                if (selectedMetadataId) {
                    var valueColumns = dataViewCategorical.values;
                    if (valueColumns) {
                        for (var i = 0, len = valueColumns.length; i < len; i++) {
                            var valueColumn = valueColumns[i];
                            if (valueColumn.source.queryName === selectedMetadataId) {
                                targetColumn = valueColumn;
                                break;
                            }
                        }
                    }
                }
                return {
                    column: targetColumn,
                    identities: identities,
                };
            }
            function findSelectorForRuleInput(dataView, selectorRoles) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(selectorRoles, 'selectorRoles');
                if (selectorRoles.length !== 1)
                    return;
                var dataViewCategorical = dataView.categorical;
                if (!dataViewCategorical)
                    return;
                var categories = dataViewCategorical.categories;
                if (!categories || categories.length !== 1)
                    return;
                var categoryColumn = categories[0], categoryRoles = categoryColumn.source.roles, categoryIdentityFields = categoryColumn.identityFields;
                if (!categoryRoles || !categoryIdentityFields || !categoryRoles[selectorRoles[0]])
                    return;
                return { data: [data.DataViewScopeWildcard.fromExprs(categoryIdentityFields)] };
            }
            function findFirstQueryNameForExpr(selectTransforms, expr) {
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                debug.assertValue(expr, 'expr');
                if (!selectTransforms)
                    return;
                for (var i = 0, len = selectTransforms.length; i < len; i++) {
                    var select = selectTransforms[i], columnExpr = select.expr;
                    if (!columnExpr || !data.SQExpr.equals(expr, select.expr))
                        continue;
                    return select.queryName;
                }
            }
            /** Attempts to find the value range for the single column with the given identifier/identifierKind. */
            function findRuleInputColumnNumberRange(dataView, identifier, identifierKind) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(identifier, 'identifier');
                debug.assertValue(identifierKind, 'identifierKind');
                // NOTE: This implementation currently only supports categorical DataView, becuase that's the
                // only scenario that has custom colors, as of this writing.  This would be rewritten to be more generic
                // as required, when needed.
                var dataViewCategorical = dataView.categorical;
                if (!dataViewCategorical)
                    return;
                var values = dataViewCategorical.values;
                if (!values)
                    return;
                for (var i = 0, len = values.length; i < len; i++) {
                    var valueCol = values[i];
                    if (identifierKind === 1 /* Role */) {
                        var valueColRoles = valueCol.source.roles;
                        if (!valueColRoles || !valueColRoles[identifier])
                            continue;
                    }
                    else {
                        debug.assert(identifierKind === 0 /* QueryName */, 'identifierKind === ColumnIdentifierKind.QueryName');
                        if (valueCol.source.queryName !== identifier)
                            continue;
                    }
                    var min = valueCol.min;
                    if (min === undefined)
                        min = valueCol.minLocal;
                    if (min === undefined)
                        continue;
                    var max = valueCol.max;
                    if (max === undefined)
                        max = valueCol.maxLocal;
                    if (max === undefined)
                        continue;
                    return { min: min, max: max };
                }
            }
            // TODO: refactor this, setGrouped, and groupValues to a test helper to stop using it in the product
            function createValueColumns(values, valueIdentityFields, source) {
                if (values === void 0) { values = []; }
                var result = values;
                setGrouped(values);
                if (valueIdentityFields)
                    result.identityFields = valueIdentityFields;
                if (source)
                    result.source = source;
                return result;
            }
            DataViewTransform.createValueColumns = createValueColumns;
            function setGrouped(values, groupedResult) {
                values.grouped = groupedResult
                    ? function () { return groupedResult; }
                    : function () { return groupValues(values); };
            }
            DataViewTransform.setGrouped = setGrouped;
            /** Group together the values with a common identity. */
            function groupValues(values) {
                debug.assertValue(values, 'values');
                var groups = [], currentGroup;
                for (var i = 0, len = values.length; i < len; i++) {
                    var value = values[i];
                    if (!currentGroup || currentGroup.identity !== value.identity) {
                        currentGroup = {
                            values: []
                        };
                        if (value.identity) {
                            currentGroup.identity = value.identity;
                            var source = value.source;
                            // allow null, which will be formatted as (Blank).
                            if (source.groupName !== undefined)
                                currentGroup.name = source.groupName;
                            else if (source.displayName)
                                currentGroup.name = source.displayName;
                        }
                        groups.push(currentGroup);
                    }
                    currentGroup.values.push(value);
                }
                return groups;
            }
            function pivotIfNecessary(dataView, dataViewMappings) {
                debug.assertValue(dataView, 'dataView');
                var transformedDataView;
                switch (determineCategoricalTransformation(dataView.categorical, dataViewMappings)) {
                    case 1 /* Pivot */:
                        transformedDataView = data.DataViewPivotCategorical.apply(dataView);
                        break;
                    case 2 /* SelfCrossJoin */:
                        transformedDataView = data.DataViewSelfCrossJoin.apply(dataView);
                        break;
                }
                return transformedDataView || dataView;
            }
            function determineCategoricalTransformation(categorical, dataViewMappings) {
                if (!categorical || _.isEmpty(dataViewMappings))
                    return;
                var categories = categorical.categories;
                if (!categories || categories.length !== 1)
                    return;
                var values = categorical.values;
                if (_.isEmpty(values))
                    return;
                if (values.grouped().some(function (vg) { return !!vg.identity; }))
                    return;
                // If we made it here, the DataView has a single category and no valueGrouping.
                var categoryRoles = categories[0].source.roles;
                for (var i = 0, len = dataViewMappings.length; i < len; i++) {
                    var roleMappingCategorical = dataViewMappings[i].categorical;
                    if (!roleMappingCategorical)
                        continue;
                    if (!hasRolesGrouped(categoryRoles, roleMappingCategorical.values))
                        continue;
                    // If we made it here, the DataView's single category has the value grouping role.
                    var categoriesMapping = roleMappingCategorical.categories;
                    var hasCategoryRole = hasRolesBind(categoryRoles, categoriesMapping) ||
                        hasRolesFor(categoryRoles, categoriesMapping);
                    if (hasCategoryRole)
                        return 2 /* SelfCrossJoin */;
                    return 1 /* Pivot */;
                }
            }
            function shouldPivotMatrix(matrix, dataViewMappings) {
                if (!matrix || _.isEmpty(dataViewMappings))
                    return;
                var rowLevels = matrix.rows.levels;
                if (rowLevels.length < 1)
                    return;
                var rows = matrix.rows.root.children;
                if (!rows || rows.length === 0)
                    return;
                var rowRoles = rowLevels[0].sources[0].roles;
                for (var i = 0, len = dataViewMappings.length; i < len; i++) {
                    var roleMappingMatrix = dataViewMappings[i].matrix;
                    if (!roleMappingMatrix)
                        continue;
                    if (!hasRolesFor(rowRoles, roleMappingMatrix.rows) &&
                        hasRolesFor(rowRoles, roleMappingMatrix.columns)) {
                        return true;
                    }
                }
            }
            function hasRolesBind(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.bind)
                    return roles[roleMapping.bind.to];
            }
            function hasRolesFor(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.for)
                    return roles[roleMapping.for.in];
            }
            function hasRolesGrouped(roles, roleMapping) {
                if (roles && roleMapping && roleMapping.group)
                    return roles[roleMapping.group.by];
            }
        })(DataViewTransform = data.DataViewTransform || (data.DataViewTransform = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createDisplayNameGetter(displayNameKey) {
            return function (resourceProvider) { return resourceProvider.get(displayNameKey); };
        }
        data.createDisplayNameGetter = createDisplayNameGetter;
        function getDisplayName(displayNameGetter, resourceProvider) {
            if (typeof displayNameGetter === 'function')
                return displayNameGetter(resourceProvider);
            if (typeof displayNameGetter === 'string')
                return displayNameGetter;
        }
        data.getDisplayName = getDisplayName;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    /** Enumeration of DateTimeUnits */
    (function (DateTimeUnit) {
        DateTimeUnit[DateTimeUnit["Year"] = 0] = "Year";
        DateTimeUnit[DateTimeUnit["Month"] = 1] = "Month";
        DateTimeUnit[DateTimeUnit["Week"] = 2] = "Week";
        DateTimeUnit[DateTimeUnit["Day"] = 3] = "Day";
        DateTimeUnit[DateTimeUnit["Hour"] = 4] = "Hour";
        DateTimeUnit[DateTimeUnit["Minute"] = 5] = "Minute";
        DateTimeUnit[DateTimeUnit["Second"] = 6] = "Second";
        DateTimeUnit[DateTimeUnit["Millisecond"] = 7] = "Millisecond";
    })(powerbi.DateTimeUnit || (powerbi.DateTimeUnit = {}));
    var DateTimeUnit = powerbi.DateTimeUnit;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQExprBuilder;
        (function (SQExprBuilder) {
            function fieldExpr(fieldExpr) {
                var sqExpr = FieldExprPattern.visit(fieldExpr, FieldExprToSQExprVisitor.instance);
                debug.assertValue(sqExpr, 'Failed to convert FieldExprPattern into SQExpr');
                return sqExpr;
            }
            SQExprBuilder.fieldExpr = fieldExpr;
            function fromColumnAggr(columnAggr) {
                return SQExprBuilder.aggregate(fromColumn(columnAggr), columnAggr.aggregate);
            }
            SQExprBuilder.fromColumnAggr = fromColumnAggr;
            function fromColumn(column) {
                return SQExprBuilder.columnRef(fromEntity(column), column.name);
            }
            SQExprBuilder.fromColumn = fromColumn;
            function fromEntity(entityPattern) {
                return SQExprBuilder.entity(entityPattern.schema, entityPattern.entity, entityPattern.entityVar);
            }
            SQExprBuilder.fromEntity = fromEntity;
            function fromEntityAggr(entityAggr) {
                return SQExprBuilder.aggregate(fromEntity(entityAggr), entityAggr.aggregate);
            }
            SQExprBuilder.fromEntityAggr = fromEntityAggr;
            function fromHierarchyLevelAggr(hierarchyLevelAggr) {
                return SQExprBuilder.aggregate(fromHierarchyLevel(hierarchyLevelAggr), hierarchyLevelAggr.aggregate);
            }
            SQExprBuilder.fromHierarchyLevelAggr = fromHierarchyLevelAggr;
            function fromHierarchyLevel(hierarchyLevelPattern) {
                return SQExprBuilder.hierarchyLevel(fromHierarchy(hierarchyLevelPattern), hierarchyLevelPattern.level);
            }
            SQExprBuilder.fromHierarchyLevel = fromHierarchyLevel;
            function fromHierarchy(hierarchyPattern) {
                return SQExprBuilder.hierarchy(fromEntity(hierarchyPattern), hierarchyPattern.name);
            }
            SQExprBuilder.fromHierarchy = fromHierarchy;
            var FieldExprToSQExprVisitor = (function () {
                function FieldExprToSQExprVisitor() {
                }
                FieldExprToSQExprVisitor.prototype.visitColumn = function (column) {
                    return fromColumn(column);
                };
                FieldExprToSQExprVisitor.prototype.visitColumnAggr = function (columnAggr) {
                    return fromColumnAggr(columnAggr);
                };
                FieldExprToSQExprVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariationPattern) {
                    return SQExprBuilder.propertyVariationSource(this.visitEntity(columnHierarchyLevelVariationPattern.source), columnHierarchyLevelVariationPattern.source.name, columnHierarchyLevelVariationPattern.level.name);
                };
                FieldExprToSQExprVisitor.prototype.visitEntity = function (entityPattern) {
                    return fromEntity(entityPattern);
                };
                FieldExprToSQExprVisitor.prototype.visitEntityAggr = function (entityAggr) {
                    return fromEntityAggr(entityAggr);
                };
                FieldExprToSQExprVisitor.prototype.visitHierarchy = function (hierarchyPattern) {
                    return fromHierarchy(hierarchyPattern);
                };
                FieldExprToSQExprVisitor.prototype.visitHierarchyLevel = function (level) {
                    return fromHierarchyLevel(level);
                };
                FieldExprToSQExprVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                    return fromHierarchyLevelAggr(hierarchyLevelAggr);
                };
                FieldExprToSQExprVisitor.prototype.visitMeasure = function (measure) {
                    return SQExprBuilder.measureRef(this.visitEntity(measure), measure.name);
                };
                FieldExprToSQExprVisitor.instance = new FieldExprToSQExprVisitor();
                return FieldExprToSQExprVisitor;
            }());
        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));
        var SQExprConverter;
        (function (SQExprConverter) {
            function asFieldPattern(sqExpr) {
                return sqExpr.accept(FieldExprPatternBuilder.instance);
            }
            SQExprConverter.asFieldPattern = asFieldPattern;
        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));
        var FieldExprPatternBuilder = (function (_super) {
            __extends(FieldExprPatternBuilder, _super);
            function FieldExprPatternBuilder() {
                _super.apply(this, arguments);
            }
            FieldExprPatternBuilder.prototype.visitColumnRef = function (expr) {
                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);
                if (!sourceRef)
                    return;
                if (sourceRef.entity) {
                    var columnRef = sourceRef.entity;
                    columnRef.name = expr.ref;
                    return { column: columnRef };
                }
            };
            FieldExprPatternBuilder.prototype.visitMeasureRef = function (expr) {
                var sourceRef = expr.source.accept(SourceExprPatternBuilder.instance);
                if (!sourceRef)
                    return;
                if (sourceRef.entity) {
                    var measureRef = sourceRef.entity;
                    measureRef.name = expr.ref;
                    return { measure: measureRef };
                }
            };
            FieldExprPatternBuilder.prototype.visitEntity = function (expr) {
                var entityRef = {
                    schema: expr.schema,
                    entity: expr.entity
                };
                if (expr.variable)
                    entityRef.entityVar = expr.variable;
                return { entity: entityRef };
            };
            FieldExprPatternBuilder.prototype.visitAggr = function (expr) {
                var fieldPattern = expr.arg.accept(this);
                if (fieldPattern && fieldPattern.column) {
                    var argAggr = fieldPattern.column;
                    argAggr.aggregate = expr.func;
                    return { columnAggr: argAggr };
                }
                else if (fieldPattern && fieldPattern.columnAggr) {
                    var argAggr = fieldPattern.columnAggr;
                    argAggr.aggregate = expr.func;
                    return { columnAggr: argAggr };
                }
                else if (fieldPattern && fieldPattern.hierarchyLevel) {
                    var argAggr = fieldPattern.hierarchyLevel;
                    argAggr.aggregate = expr.func;
                    return { hierarchyLevelAggr: argAggr };
                }
                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);
                if (sourcePattern && sourcePattern.entity) {
                    var argAggr = sourcePattern.entity;
                    argAggr.aggregate = expr.func;
                    return { entityAggr: argAggr };
                }
            };
            FieldExprPatternBuilder.prototype.visitHierarchy = function (expr) {
                var sourcePattern = expr.arg.accept(SourceExprPatternBuilder.instance);
                if (sourcePattern && sourcePattern.entity) {
                    var hierarchyRef = (sourcePattern.entity);
                    hierarchyRef.name = expr.hierarchy;
                    return { hierarchy: hierarchyRef };
                }
            };
            FieldExprPatternBuilder.prototype.visitHierarchyLevel = function (expr) {
                var hierarchySourceExprPattern = expr.arg.accept(HierarchyExprPatternBuiler.instance);
                if (!hierarchySourceExprPattern)
                    return;
                var hierarchyLevel;
                if (hierarchySourceExprPattern.hierarchy) {
                    hierarchyLevel = {
                        entity: hierarchySourceExprPattern.hierarchy.entity,
                        schema: hierarchySourceExprPattern.hierarchy.schema,
                        name: hierarchySourceExprPattern.hierarchy.name,
                        level: expr.level,
                    };
                }
                if (hierarchySourceExprPattern.variation) {
                    return {
                        columnHierarchyLevelVariation: {
                            source: {
                                entity: hierarchySourceExprPattern.variation.column.entity,
                                schema: hierarchySourceExprPattern.variation.column.schema,
                                name: hierarchySourceExprPattern.variation.column.name,
                            },
                            level: hierarchyLevel,
                            variationName: hierarchySourceExprPattern.variation.variationName,
                        }
                    };
                }
                return { hierarchyLevel: hierarchyLevel };
            };
            FieldExprPatternBuilder.instance = new FieldExprPatternBuilder();
            return FieldExprPatternBuilder;
        }(data.DefaultSQExprVisitor));
        var SourceExprPatternBuilder = (function (_super) {
            __extends(SourceExprPatternBuilder, _super);
            function SourceExprPatternBuilder() {
                _super.apply(this, arguments);
            }
            SourceExprPatternBuilder.prototype.visitEntity = function (expr) {
                var entityRef = {
                    schema: expr.schema,
                    entity: expr.entity
                };
                if (expr.variable)
                    entityRef.entityVar = expr.variable;
                return { entity: entityRef };
            };
            SourceExprPatternBuilder.prototype.visitPropertyVariationSource = function (expr) {
                var entityExpr = expr.arg;
                if (entityExpr instanceof data.SQEntityExpr) {
                    var propertyVariationSource = {
                        schema: entityExpr.schema,
                        entity: entityExpr.entity,
                        name: expr.property,
                    };
                    if (entityExpr.variable)
                        propertyVariationSource.entityVar = entityExpr.variable;
                    return {
                        variation: {
                            column: propertyVariationSource,
                            variationName: expr.name,
                        }
                    };
                }
            };
            SourceExprPatternBuilder.instance = new SourceExprPatternBuilder();
            return SourceExprPatternBuilder;
        }(data.DefaultSQExprVisitor));
        var HierarchyExprPatternBuiler = (function (_super) {
            __extends(HierarchyExprPatternBuiler, _super);
            function HierarchyExprPatternBuiler() {
                _super.apply(this, arguments);
            }
            HierarchyExprPatternBuiler.prototype.visitHierarchy = function (expr) {
                var exprPattern = expr.arg.accept(SourceExprPatternBuilder.instance);
                var hierarchyRef;
                var variationRef;
                if (exprPattern.variation) {
                    hierarchyRef = {
                        name: expr.hierarchy,
                        schema: exprPattern.variation.column.schema,
                        entity: exprPattern.variation.column.entity,
                    };
                    variationRef = exprPattern.variation;
                }
                else
                    hierarchyRef = {
                        name: expr.hierarchy,
                        schema: exprPattern.entity.schema,
                        entity: exprPattern.entity.entity,
                    };
                return {
                    hierarchy: hierarchyRef,
                    variation: variationRef
                };
            };
            HierarchyExprPatternBuiler.instance = new HierarchyExprPatternBuiler();
            return HierarchyExprPatternBuiler;
        }(data.DefaultSQExprVisitor));
        var FieldExprPattern;
        (function (FieldExprPattern) {
            function visit(expr, visitor) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(visitor, 'visitor');
                var fieldExprPattern = expr instanceof data.SQExpr ? SQExprConverter.asFieldPattern(expr) : expr;
                debug.assertValue(fieldExprPattern, 'expected sqExpr to conform to a fieldExprPattern');
                if (fieldExprPattern.column)
                    return visitColumn(fieldExprPattern.column, visitor);
                if (fieldExprPattern.columnAggr)
                    return visitColumnAggr(fieldExprPattern.columnAggr, visitor);
                if (fieldExprPattern.columnHierarchyLevelVariation)
                    return visitColumnHierarchyLevelVariation(fieldExprPattern.columnHierarchyLevelVariation, visitor);
                if (fieldExprPattern.entity)
                    return visitEntity(fieldExprPattern.entity, visitor);
                if (fieldExprPattern.entityAggr)
                    return visitEntityAggr(fieldExprPattern.entityAggr, visitor);
                if (fieldExprPattern.hierarchy)
                    return visitHierarchy(fieldExprPattern.hierarchy, visitor);
                if (fieldExprPattern.hierarchyLevel)
                    return visitHierarchyLevel(fieldExprPattern.hierarchyLevel, visitor);
                if (fieldExprPattern.hierarchyLevelAggr)
                    return visitHierarchyLevelAggr(fieldExprPattern.hierarchyLevelAggr, visitor);
                if (fieldExprPattern.measure)
                    return visitMeasure(fieldExprPattern.measure, visitor);
                debug.assertFail('failed to visit a fieldExprPattern.');
                return;
            }
            FieldExprPattern.visit = visit;
            function visitColumn(column, visitor) {
                debug.assertValue(column, 'column');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitColumn(column);
            }
            function visitColumnAggr(columnAggr, visitor) {
                debug.assertValue(columnAggr, 'columnAggr');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitColumnAggr(columnAggr);
            }
            function visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation, visitor) {
                debug.assertValue(columnHierarchyLevelVariation, 'columnHierarchyLevelVariation');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitColumnHierarchyLevelVariation(columnHierarchyLevelVariation);
            }
            function visitEntity(entity, visitor) {
                debug.assertValue(entity, 'entity');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitEntity(entity);
            }
            function visitEntityAggr(entityAggr, visitor) {
                debug.assertValue(entityAggr, 'entityAggr');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitEntityAggr(entityAggr);
            }
            function visitHierarchy(hierarchy, visitor) {
                debug.assertValue(hierarchy, 'hierarchy');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitHierarchy(hierarchy);
            }
            function visitHierarchyLevel(hierarchyLevel, visitor) {
                debug.assertValue(hierarchyLevel, 'hierarchyLevel');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitHierarchyLevel(hierarchyLevel);
            }
            function visitHierarchyLevelAggr(hierarchyLevelAggr, visitor) {
                debug.assertValue(hierarchyLevelAggr, 'hierarchyLevelAggr');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitHierarchyLevelAggr(hierarchyLevelAggr);
            }
            function visitMeasure(measure, visitor) {
                debug.assertValue(measure, 'measure');
                debug.assertValue(visitor, 'visitor');
                return visitor.visitMeasure(measure);
            }
            function toColumnRefSQExpr(columnPattern) {
                return SQExprBuilder.columnRef(SQExprBuilder.entity(columnPattern.schema, columnPattern.entity, columnPattern.entityVar), columnPattern.name);
            }
            FieldExprPattern.toColumnRefSQExpr = toColumnRefSQExpr;
            function getAggregate(fieldExpr) {
                debug.assertValue(fieldExpr, 'fieldExpr');
                return visit(fieldExpr, FieldExprPatternAggregateVisitor.instance);
            }
            FieldExprPattern.getAggregate = getAggregate;
            function hasFieldExprName(fieldExpr) {
                return (fieldExpr.column ||
                    fieldExpr.columnAggr ||
                    fieldExpr.measure) !== undefined;
            }
            FieldExprPattern.hasFieldExprName = hasFieldExprName;
            function getPropertyName(fieldExpr) {
                var column = (fieldExpr.column ||
                    fieldExpr.columnAggr ||
                    fieldExpr.measure);
                if (column)
                    return column.name;
            }
            FieldExprPattern.getPropertyName = getPropertyName;
            function getHierarchyName(fieldExpr) {
                var hierarchy = fieldExpr.hierarchy;
                if (hierarchy)
                    return hierarchy.name;
            }
            FieldExprPattern.getHierarchyName = getHierarchyName;
            function getColumnRef(fieldExpr) {
                if (fieldExpr.columnHierarchyLevelVariation)
                    return fieldExpr.columnHierarchyLevelVariation.source;
                return fieldExpr.column || fieldExpr.measure || fieldExpr.columnAggr;
            }
            FieldExprPattern.getColumnRef = getColumnRef;
            function getFieldExprName(fieldExpr) {
                var name = getPropertyName(fieldExpr);
                if (name)
                    return name;
                // In case it is an entity
                return toFieldExprEntityPattern(fieldExpr).entity;
            }
            FieldExprPattern.getFieldExprName = getFieldExprName;
            function toFieldExprEntityPattern(fieldExpr) {
                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);
            }
            FieldExprPattern.toFieldExprEntityPattern = toFieldExprEntityPattern;
            function toFieldExprEntityItemPattern(fieldExpr) {
                return FieldExprPattern.visit(fieldExpr, FieldExprToEntityExprPatternBuilder.instance);
            }
            FieldExprPattern.toFieldExprEntityItemPattern = toFieldExprEntityItemPattern;
            var FieldExprPatternAggregateVisitor = (function () {
                function FieldExprPatternAggregateVisitor() {
                }
                FieldExprPatternAggregateVisitor.prototype.visitColumn = function (column) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitColumnAggr = function (columnAggr) {
                    return columnAggr.aggregate;
                };
                FieldExprPatternAggregateVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitEntity = function (entity) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitEntityAggr = function (entityAggr) {
                    return entityAggr.aggregate;
                };
                FieldExprPatternAggregateVisitor.prototype.visitHierarchy = function (hierarchy) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                    return;
                };
                FieldExprPatternAggregateVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                    return hierarchyLevelAggr.aggregate;
                };
                FieldExprPatternAggregateVisitor.prototype.visitMeasure = function (measure) {
                    return;
                };
                FieldExprPatternAggregateVisitor.instance = new FieldExprPatternAggregateVisitor();
                return FieldExprPatternAggregateVisitor;
            }());
            var FieldExprToEntityExprPatternBuilder = (function () {
                function FieldExprToEntityExprPatternBuilder() {
                }
                FieldExprToEntityExprPatternBuilder.prototype.visitColumn = function (column) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(column);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitColumnAggr = function (columnAggr) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnAggr);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(columnHierarchyLevelVariation.source);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitEntity = function (entity) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entity);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitEntityAggr = function (entityAggr) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(entityAggr);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchy = function (hierarchy) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchy);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevel);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(hierarchyLevelAggr);
                };
                FieldExprToEntityExprPatternBuilder.prototype.visitMeasure = function (measure) {
                    return FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern(measure);
                };
                FieldExprToEntityExprPatternBuilder.toEntityItemExprPattern = function (exprPattern) {
                    debug.assertValue(exprPattern, 'exprPattern');
                    var pattern = { schema: exprPattern.schema, entity: exprPattern.entity };
                    if (exprPattern.entityVar) {
                        pattern.entityVar = exprPattern.entityVar;
                    }
                    return pattern;
                };
                FieldExprToEntityExprPatternBuilder.instance = new FieldExprToEntityExprPatternBuilder();
                return FieldExprToEntityExprPatternBuilder;
            }());
        })(FieldExprPattern = data.FieldExprPattern || (data.FieldExprPattern = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewAnalysis;
    (function (DataViewAnalysis) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;
        (function (DataViewMappingMatchErrorCode) {
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionRangeTooLarge"] = 0] = "conditionRangeTooLarge";
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionRangeTooSmall"] = 1] = "conditionRangeTooSmall";
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionKindExpectedMeasure"] = 2] = "conditionKindExpectedMeasure";
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionKindExpectedGrouping"] = 3] = "conditionKindExpectedGrouping";
            DataViewMappingMatchErrorCode[DataViewMappingMatchErrorCode["conditionKindExpectedGroupingOrMeasure"] = 4] = "conditionKindExpectedGroupingOrMeasure";
        })(DataViewAnalysis.DataViewMappingMatchErrorCode || (DataViewAnalysis.DataViewMappingMatchErrorCode = {}));
        var DataViewMappingMatchErrorCode = DataViewAnalysis.DataViewMappingMatchErrorCode;
        /** Reshapes the data view to match the provided schema if possible. If not, returns null */
        function validateAndReshape(dataView, dataViewMappings) {
            if (!dataViewMappings || dataViewMappings.length === 0)
                return { dataView: dataView, isValid: true };
            if (dataView) {
                for (var _i = 0, dataViewMappings_3 = dataViewMappings; _i < dataViewMappings_3.length; _i++) {
                    var dataViewMapping = dataViewMappings_3[_i];
                    // Keep the original when possible.
                    if (supports(dataView, dataViewMapping))
                        return { dataView: dataView, isValid: true };
                    if (dataViewMapping.categorical && dataView.categorical)
                        return reshapeCategorical(dataView, dataViewMapping);
                    if (dataViewMapping.tree && dataView.tree)
                        return reshapeTree(dataView, dataViewMapping.tree);
                    if (dataViewMapping.single && dataView.single)
                        return reshapeSingle(dataView, dataViewMapping.single);
                    if (dataViewMapping.table && dataView.table)
                        return reshapeTable(dataView, dataViewMapping.table);
                }
            }
            else if (powerbi.ScriptResultUtil.findScriptResult(dataViewMappings)) {
                // Currently, PBI Service treats R Script Visuals as static images.
                // This causes validation to fail, since in PBI service no DataView is generated, but there are DataViewMappings,
                // to support the PBI Desktop scenario.
                // This code will be removed once PBI Service fully supports R Script Visuals.
                // VSTS: 6217994 - [R Viz] Remove temporary DataViewAnalysis validation workaround of static R Script Visual mappings
                return { dataView: dataView, isValid: true };
            }
            return { isValid: false };
        }
        DataViewAnalysis.validateAndReshape = validateAndReshape;
        function reshapeCategorical(dataView, dataViewMapping) {
            debug.assertValue(dataViewMapping, 'dataViewMapping');
            //The functionality that used to compare categorical.values.length to schema.values doesn't apply any more, we don't want to use the same logic for re-shaping.
            var categoryRoleMapping = dataViewMapping.categorical;
            var categorical = dataView.categorical;
            if (!categorical)
                return { isValid: false };
            var rowCount;
            if (categoryRoleMapping.rowCount) {
                rowCount = categoryRoleMapping.rowCount.supported;
                if (rowCount && rowCount.max) {
                    var updated = void 0;
                    var categories = categorical.categories;
                    var maxRowCount = rowCount.max;
                    var originalLength = undefined;
                    if (categories) {
                        for (var i = 0, len = categories.length; i < len; i++) {
                            var category = categories[i];
                            originalLength = category.values.length;
                            if (maxRowCount !== undefined && originalLength > maxRowCount) {
                                // Row count too large: Trim it to fit.
                                var updatedCategories = ArrayExtensions.range(category.values, 0, maxRowCount - 1);
                                updated = updated || { categories: [] };
                                updated.categories.push({
                                    source: category.source,
                                    values: updatedCategories
                                });
                            }
                        }
                    }
                    if (categorical.values && categorical.values.length > 0 && maxRowCount) {
                        if (!originalLength)
                            originalLength = categorical.values[0].values.length;
                        if (maxRowCount !== undefined && originalLength > maxRowCount) {
                            updated = updated || {};
                            updated.values = powerbi.data.DataViewTransform.createValueColumns();
                            for (var i = 0, len = categorical.values.length; i < len; i++) {
                                var column = categorical.values[i], updatedColumn = {
                                    source: column.source,
                                    values: ArrayExtensions.range(column.values, 0, maxRowCount - 1)
                                };
                                if (column.min !== undefined)
                                    updatedColumn.min = column.min;
                                if (column.max !== undefined)
                                    updatedColumn.max = column.max;
                                if (column.subtotal !== undefined)
                                    updatedColumn.subtotal = column.subtotal;
                                updated.values.push(updatedColumn);
                            }
                        }
                    }
                    if (updated) {
                        dataView = {
                            metadata: dataView.metadata,
                            categorical: updated,
                        };
                    }
                }
            }
            if (supportsCategorical(dataView, dataViewMapping))
                return { dataView: dataView, isValid: true };
            return null;
        }
        function reshapeSingle(dataView, singleRoleMapping) {
            debug.assertValue(dataView, 'dataView');
            debug.assertValue(singleRoleMapping, 'singleRoleMapping');
            if (dataView.single)
                return { dataView: dataView, isValid: true };
            return { isValid: false };
        }
        function reshapeTree(dataView, treeRoleMapping) {
            debug.assertValue(dataView, 'dataView');
            debug.assertValue(treeRoleMapping, 'treeRoleMapping');
            // TODO: Need to implement the reshaping of Tree
            var metadata = dataView.metadata;
            if (validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null /*&& conforms(countMeasures(metadata.columns), treeRoleMapping.aggregates)*/)
                return { dataView: dataView, isValid: true };
            return { isValid: false };
        }
        function reshapeTable(dataView, tableRoleMapping) {
            debug.assertValue(dataView, 'dataView');
            debug.assertValue(tableRoleMapping, 'tableRoleMapping');
            if (dataView.table)
                return { dataView: dataView, isValid: true };
            return { isValid: false };
        }
        function countGroups(columns) {
            var count = 0;
            for (var i = 0, len = columns.length; i < len; i++) {
                if (!columns[i].isMeasure)
                    ++count;
            }
            return count;
        }
        DataViewAnalysis.countGroups = countGroups;
        function countMeasures(columns) {
            var count = 0;
            for (var i = 0, len = columns.length; i < len; i++) {
                if (columns[i].isMeasure)
                    ++count;
            }
            return count;
        }
        DataViewAnalysis.countMeasures = countMeasures;
        /** Indicates whether the dataView conforms to the specified schema. */
        function supports(dataView, roleMapping, usePreferredDataViewSchema) {
            if (!roleMapping || !dataView)
                return false;
            if (roleMapping.scriptResult && !supportsScriptResult(dataView.scriptResult, roleMapping.scriptResult))
                return false;
            if (roleMapping.categorical && !supportsCategorical(dataView, roleMapping.categorical, usePreferredDataViewSchema))
                return false;
            if (roleMapping.tree && !supportsTree(dataView, roleMapping.tree))
                return false;
            if (roleMapping.single && !supportsSingle(dataView.single, roleMapping.single))
                return false;
            if (roleMapping.table && !supportsTable(dataView.table, roleMapping.table, usePreferredDataViewSchema))
                return false;
            return true;
        }
        DataViewAnalysis.supports = supports;
        function supportsCategorical(dataView, categoryRoleMapping, usePreferredDataViewSchema) {
            debug.assertValue(categoryRoleMapping, 'categoryRoleMapping');
            var dataViewCategorical = dataView.categorical;
            if (!dataViewCategorical)
                return false;
            // TODO: Disabling this implementation isn't right.
            //if (!conforms(countMeasures(dataView.metadata.columns), categoryRoleMapping.values.roles.length))
            //    return false;
            if (categoryRoleMapping.rowCount) {
                var rowCount = categoryRoleMapping.rowCount.supported;
                if (usePreferredDataViewSchema && categoryRoleMapping.rowCount.preferred)
                    rowCount = categoryRoleMapping.rowCount.preferred;
                if (rowCount) {
                    var len = 0;
                    if (dataViewCategorical.values && dataViewCategorical.values.length)
                        len = dataViewCategorical.values[0].values.length;
                    else if (dataViewCategorical.categories && dataViewCategorical.categories.length)
                        len = dataViewCategorical.categories[0].values.length;
                    if (validateRange(len, rowCount) != null)
                        return false;
                }
            }
            return true;
        }
        function supportsSingle(dataViewSingle, singleRoleMapping) {
            debug.assertValue(singleRoleMapping, 'singleRoleMapping');
            if (!dataViewSingle)
                return false;
            return true;
        }
        function supportsTree(dataView, treeRoleMapping) {
            debug.assertValue(treeRoleMapping, 'treeRoleMapping');
            var metadata = dataView.metadata;
            return validateRange(countGroups(metadata.columns), treeRoleMapping.depth) == null;
        }
        function supportsTable(dataViewTable, tableRoleMapping, usePreferredDataViewSchema) {
            debug.assertValue(tableRoleMapping, 'tableRoleMapping');
            if (!dataViewTable)
                return false;
            if (tableRoleMapping.rowCount) {
                var rowCount = tableRoleMapping.rowCount.supported;
                if (usePreferredDataViewSchema && tableRoleMapping.rowCount.preferred)
                    rowCount = tableRoleMapping.rowCount.preferred;
                if (rowCount) {
                    var len = 0;
                    if (dataViewTable.rows && dataViewTable.rows.length)
                        len = dataViewTable.rows.length;
                    if (validateRange(len, rowCount) != null)
                        return false;
                }
            }
            return true;
        }
        function supportsScriptResult(dataView, scriptResultRoleMapping) {
            debug.assertValue(scriptResultRoleMapping, 'scriptResultRoleMapping');
            if (!dataView)
                return false;
            if (!dataView.imageBase64)
                return false;
            return true;
        }
        /**
         * Determines whether the value conforms to the range in the role condition, returning undefined
         * if so or an appropriate error code if not.
         */
        function validateRange(value, roleCondition, ignoreMin) {
            debug.assertValue(value, 'value');
            if (!roleCondition)
                return;
            if (!ignoreMin && roleCondition.min !== undefined && roleCondition.min > value)
                return DataViewMappingMatchErrorCode.conditionRangeTooSmall;
            if (roleCondition.max !== undefined && roleCondition.max < value)
                return DataViewMappingMatchErrorCode.conditionRangeTooLarge;
        }
        DataViewAnalysis.validateRange = validateRange;
        /**
         * Determines whether the value conforms to the kind in the role condition, returning undefined
         * if so or an appropriate error code if not.
         */
        function validateKind(roleCondition, roleName, projections, roleKindByQueryRef) {
            if (!roleCondition || roleCondition.kind === undefined) {
                return;
            }
            var expectedKind = roleCondition.kind;
            var roleCollection = projections[roleName];
            if (roleCollection) {
                var roleProjections = roleCollection.all();
                for (var _i = 0, roleProjections_1 = roleProjections; _i < roleProjections_1.length; _i++) {
                    var roleProjection = roleProjections_1[_i];
                    if (roleKindByQueryRef[roleProjection.queryRef] !== expectedKind) {
                        switch (expectedKind) {
                            case powerbi.VisualDataRoleKind.Measure:
                                return DataViewMappingMatchErrorCode.conditionKindExpectedMeasure;
                            case powerbi.VisualDataRoleKind.Grouping:
                                return DataViewMappingMatchErrorCode.conditionKindExpectedGrouping;
                            case powerbi.VisualDataRoleKind.GroupingOrMeasure:
                                return DataViewMappingMatchErrorCode.conditionKindExpectedGroupingOrMeasure;
                        }
                    }
                }
            }
        }
        /** Determines the appropriate DataViewMappings for the projections. */
        function chooseDataViewMappings(projections, mappings, roleKindByQueryRef, objectDescriptors, objectDefinitions) {
            debug.assertValue(projections, 'projections');
            debug.assertAnyValue(mappings, 'mappings');
            var supportedMappings = [];
            var errors = [];
            if (!_.isEmpty(mappings)) {
                for (var mappingIndex = 0, mappingCount = mappings.length; mappingIndex < mappingCount; mappingIndex++) {
                    var mapping = mappings[mappingIndex], mappingConditions = mapping.conditions, requiredProperties = mapping.requiredProperties;
                    var allPropertiesValid = areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions);
                    var conditionsMet = [];
                    if (!_.isEmpty(mappingConditions)) {
                        for (var conditionIndex = 0, conditionCount = mappingConditions.length; conditionIndex < conditionCount; conditionIndex++) {
                            var condition = mappingConditions[conditionIndex];
                            var currentConditionErrors = checkForConditionErrors(projections, condition, roleKindByQueryRef);
                            if (!_.isEmpty(currentConditionErrors)) {
                                for (var _i = 0, currentConditionErrors_1 = currentConditionErrors; _i < currentConditionErrors_1.length; _i++) {
                                    var error = currentConditionErrors_1[_i];
                                    error.mappingIndex = mappingIndex;
                                    error.conditionIndex = conditionIndex;
                                    errors.push(error);
                                }
                            }
                            else
                                conditionsMet.push(condition);
                        }
                    }
                    else {
                        conditionsMet.push({});
                    }
                    if (!_.isEmpty(conditionsMet) && allPropertiesValid) {
                        var supportedMapping = _.cloneDeep(mapping);
                        var updatedConditions = _.filter(conditionsMet, function (condition) { return Object.keys(condition).length > 0; });
                        if (!_.isEmpty(updatedConditions))
                            supportedMapping.conditions = updatedConditions;
                        supportedMappings.push(supportedMapping);
                    }
                }
            }
            return {
                supportedMappings: ArrayExtensions.emptyToNull(supportedMappings),
                mappingErrors: ArrayExtensions.emptyToNull(errors),
            };
        }
        DataViewAnalysis.chooseDataViewMappings = chooseDataViewMappings;
        function checkForConditionErrors(projections, condition, roleKindByQueryRef) {
            debug.assertValue(projections, 'projections');
            debug.assertValue(condition, 'condition');
            var conditionRoles = Object.keys(condition);
            var errors = [];
            for (var i = 0, len = conditionRoles.length; i < len; i++) {
                var roleName = conditionRoles[i], isDrillable = projections[roleName] && !_.isEmpty(projections[roleName].activeProjectionRefs), roleCondition = condition[roleName];
                var roleCount = getPropertyCount(roleName, projections, isDrillable);
                var rangeError = validateRange(roleCount, roleCondition);
                if (rangeError != null) {
                    errors.push({
                        code: rangeError,
                        roleName: roleName,
                    });
                }
                var kindError = validateKind(roleCondition, roleName, projections, roleKindByQueryRef);
                if (kindError != null) {
                    errors.push({
                        code: kindError,
                        roleName: roleName,
                    });
                }
            }
            return errors;
        }
        function areAllPropertiesValid(requiredProperties, objectDescriptors, objectDefinitions) {
            if (_.isEmpty(requiredProperties))
                return true;
            if (!objectDescriptors || !objectDefinitions)
                return false;
            var staticEvalContext = powerbi.data.createStaticEvalContext();
            return _.every(requiredProperties, function (requiredProperty) {
                var objectDescriptorValue = null;
                var objectDescriptorProperty = objectDescriptors[requiredProperty.objectName];
                if (objectDescriptorProperty)
                    objectDescriptorValue = objectDescriptorProperty.properties[requiredProperty.propertyName];
                var objectDefinitionValue = DataViewObjectDefinitions.getValue(objectDefinitions, requiredProperty, null);
                if (!objectDescriptorValue || !objectDefinitionValue)
                    return false;
                return powerbi.data.DataViewObjectEvaluator.evaluateProperty(staticEvalContext, objectDescriptorValue, objectDefinitionValue);
            });
        }
        function getPropertyCount(roleName, projections, useActiveIfAvailable) {
            debug.assertValue(roleName, 'roleName');
            debug.assertValue(projections, 'projections');
            var projectionsForRole = projections[roleName];
            if (projectionsForRole) {
                if (useActiveIfAvailable)
                    return 1;
                return projectionsForRole.all().length;
            }
            return 0;
        }
        DataViewAnalysis.getPropertyCount = getPropertyCount;
        function hasSameCategoryIdentity(dataView1, dataView2) {
            if (dataView1
                && dataView2
                && dataView1.categorical
                && dataView2.categorical) {
                var dv1Categories = dataView1.categorical.categories;
                var dv2Categories = dataView2.categorical.categories;
                if (dv1Categories
                    && dv2Categories
                    && dv1Categories.length === dv2Categories.length) {
                    for (var i = 0, len = dv1Categories.length; i < len; i++) {
                        var dv1Identity = dv1Categories[i].identity;
                        var dv2Identity = dv2Categories[i].identity;
                        var dv1Length = getLengthOptional(dv1Identity);
                        if (dv1Length !== getLengthOptional(dv2Identity))
                            return false;
                        for (var j = 0; j < dv1Length; j++) {
                            if (!powerbi.DataViewScopeIdentity.equals(dv1Identity[j], dv2Identity[j]))
                                return false;
                        }
                    }
                    return true;
                }
            }
            return false;
        }
        DataViewAnalysis.hasSameCategoryIdentity = hasSameCategoryIdentity;
        function getLengthOptional(identity) {
            if (identity)
                return identity.length;
            return 0;
        }
        function areMetadataColumnsEquivalent(column1, column2) {
            if (!column1 && !column2)
                return true;
            if (!column1 || !column2)
                return false;
            if (column1.displayName !== column2.displayName)
                return false;
            if (column1.queryName !== column2.queryName)
                return false;
            if (column1.isMeasure !== column2.isMeasure)
                return false;
            if (column1.type !== column2.type)
                return false;
            if (column1.sort !== column2.sort)
                return false;
            return true;
        }
        DataViewAnalysis.areMetadataColumnsEquivalent = areMetadataColumnsEquivalent;
        /* Returns true if the metadata columns at the same positions in the array are equivalent. */
        function isMetadataEquivalent(metadata1, metadata2) {
            if (!metadata1 && !metadata2)
                return true;
            if (!metadata1 || !metadata2)
                return false;
            var previousColumnsLength = metadata1.columns.length;
            var newColumnsLength = metadata2.columns.length;
            if (previousColumnsLength !== newColumnsLength)
                return false;
            for (var i = 0; i < newColumnsLength; i++) {
                if (!DataViewAnalysis.areMetadataColumnsEquivalent(metadata1.columns[i], metadata2.columns[i]))
                    return false;
            }
            return true;
        }
        DataViewAnalysis.isMetadataEquivalent = isMetadataEquivalent;
    })(DataViewAnalysis = powerbi.DataViewAnalysis || (powerbi.DataViewAnalysis = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var Lazy = jsCommon.Lazy;
        var DataViewRoleWildcard;
        (function (DataViewRoleWildcard) {
            function fromRoles(roles) {
                return new DataViewRoleWildcardImpl(roles);
            }
            DataViewRoleWildcard.fromRoles = fromRoles;
            function equals(firstRoleWildcard, secondRoleWildcard) {
                return firstRoleWildcard.key &&
                    secondRoleWildcard.key &&
                    firstRoleWildcard.key === secondRoleWildcard.key &&
                    ArrayExtensions.sequenceEqual(firstRoleWildcard.roles, secondRoleWildcard.roles, function (role1, role2) { return role1 === role2; });
            }
            DataViewRoleWildcard.equals = equals;
            var DataViewRoleWildcardImpl = (function () {
                function DataViewRoleWildcardImpl(roles) {
                    var _this = this;
                    debug.assertNonEmpty(roles, 'roles');
                    this._roles = roles;
                    this._key = new Lazy(function () { return JSON.stringify(_this.roles); });
                }
                Object.defineProperty(DataViewRoleWildcardImpl.prototype, "roles", {
                    get: function () {
                        return this._roles;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DataViewRoleWildcardImpl.prototype, "key", {
                    get: function () {
                        return this._key.getValue();
                    },
                    enumerable: true,
                    configurable: true
                });
                return DataViewRoleWildcardImpl;
            }());
        })(DataViewRoleWildcard = data.DataViewRoleWildcard || (data.DataViewRoleWildcard = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var DataViewScopeIdentity;
    (function (DataViewScopeIdentity) {
        /** Compares the two DataViewScopeIdentity values for equality. */
        function equals(x, y, ignoreCase) {
            // Normalize falsy to null
            x = x || null;
            y = y || null;
            if (x === y)
                return true;
            if (!x !== !y)
                return false;
            debug.assertValue(x, 'x');
            debug.assertValue(y, 'y');
            return data.SQExpr.equals(x.expr, y.expr, ignoreCase);
        }
        DataViewScopeIdentity.equals = equals;
        function filterFromIdentity(identities, isNot) {
            if (_.isEmpty(identities))
                return;
            var exprs = [];
            for (var _i = 0, identities_1 = identities; _i < identities_1.length; _i++) {
                var identity = identities_1[_i];
                exprs.push(identity.expr);
            }
            return filterFromExprs(exprs, isNot);
        }
        DataViewScopeIdentity.filterFromIdentity = filterFromIdentity;
        function filterFromExprs(orExprs, isNot) {
            if (_.isEmpty(orExprs))
                return;
            var resultExpr;
            for (var _i = 0, orExprs_1 = orExprs; _i < orExprs_1.length; _i++) {
                var orExpr = orExprs_1[_i];
                var inExpr = data.ScopeIdentityExtractor.getInExpr(orExpr);
                if (resultExpr)
                    resultExpr = data.SQExprBuilder.or(resultExpr, inExpr);
                else
                    resultExpr = inExpr || orExpr;
            }
            if (resultExpr) {
                if (isNot)
                    resultExpr = powerbi.data.SQExprBuilder.not(resultExpr);
            }
            return powerbi.data.SemanticFilter.fromSQExpr(resultExpr);
        }
        DataViewScopeIdentity.filterFromExprs = filterFromExprs;
    })(DataViewScopeIdentity = powerbi.DataViewScopeIdentity || (powerbi.DataViewScopeIdentity = {}));
    var data;
    (function (data) {
        var Lazy = jsCommon.Lazy;
        function createDataViewScopeIdentity(expr) {
            return new DataViewScopeIdentityImpl(expr);
        }
        data.createDataViewScopeIdentity = createDataViewScopeIdentity;
        var DataViewScopeIdentityImpl = (function () {
            function DataViewScopeIdentityImpl(expr) {
                debug.assertValue(expr, 'expr');
                this._expr = expr;
                this._key = new Lazy(function () { return data.SQExprShortSerializer.serialize(expr); });
            }
            Object.defineProperty(DataViewScopeIdentityImpl.prototype, "expr", {
                get: function () {
                    return this._expr;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DataViewScopeIdentityImpl.prototype, "key", {
                get: function () {
                    return this._key.getValue();
                },
                enumerable: true,
                configurable: true
            });
            return DataViewScopeIdentityImpl;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var Lazy = jsCommon.Lazy;
        var DataViewScopeWildcard;
        (function (DataViewScopeWildcard) {
            function matches(wildcard, instance) {
                var instanceExprs = data.ScopeIdentityExtractor.getKeys(instance.expr);
                if (!instanceExprs)
                    return false;
                return data.SQExprUtils.sequenceEqual(wildcard.exprs, instanceExprs);
            }
            DataViewScopeWildcard.matches = matches;
            function equals(firstScopeWildcard, secondScopeWildcard) {
                return firstScopeWildcard.key === secondScopeWildcard.key &&
                    data.SQExprUtils.sequenceEqual(firstScopeWildcard.exprs, secondScopeWildcard.exprs);
            }
            DataViewScopeWildcard.equals = equals;
            function fromExprs(exprs) {
                return new DataViewScopeWildcardImpl(exprs);
            }
            DataViewScopeWildcard.fromExprs = fromExprs;
            var DataViewScopeWildcardImpl = (function () {
                function DataViewScopeWildcardImpl(exprs) {
                    debug.assertValue(exprs, 'exprs');
                    this._exprs = exprs;
                    this._key = new Lazy(function () { return data.SQExprShortSerializer.serializeArray(exprs); });
                }
                Object.defineProperty(DataViewScopeWildcardImpl.prototype, "exprs", {
                    get: function () {
                        return this._exprs;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(DataViewScopeWildcardImpl.prototype, "key", {
                    get: function () {
                        return this._key.getValue();
                    },
                    enumerable: true,
                    configurable: true
                });
                return DataViewScopeWildcardImpl;
            }());
        })(DataViewScopeWildcard = data.DataViewScopeWildcard || (data.DataViewScopeWildcard = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createColorAllocatorCache() {
            return new ColorAllocatorProvider();
        }
        data.createColorAllocatorCache = createColorAllocatorCache;
        var ColorAllocatorProvider = (function () {
            function ColorAllocatorProvider() {
                this.cache = [];
            }
            ColorAllocatorProvider.prototype.get = function (key) {
                debug.assertValue(key, 'key');
                for (var _i = 0, _a = this.cache; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    if (entry.key === key)
                        return entry.allocator;
                }
            };
            ColorAllocatorProvider.prototype.register = function (key, colorAllocator) {
                debug.assertValue(key, 'key');
                debug.assertValue(colorAllocator, 'colorAllocator');
                debug.assert(this.get(key) == null, 'Trying to re-register for same key expr.');
                this.cache.push({
                    key: key,
                    allocator: colorAllocator,
                });
                return this;
            };
            return ColorAllocatorProvider;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewRegression;
        (function (DataViewRegression) {
            // TODO VSTS 6842046: Currently we are using a constant queryName since we don't have a way to generate
            // unique ones. There is a bug filed to do this by lawong, so this part will be fixed with that bug.
            var regressionXQueryName = 'RegressionX';
            var regressionSeriesQueryName = 'RegressionSeries';
            DataViewRegression.regressionYQueryName = 'RegressionY';
            function run(options) {
                debug.assertValue(options, 'options');
                var dataViewMappings = options.dataViewMappings;
                var visualDataViews = options.visualDataViews;
                var dataRoles = options.dataRoles;
                var objectDescriptors = options.objectDescriptors;
                var objectDefinitions = options.objectDefinitions;
                var colorAllocatorFactory = options.colorAllocatorFactory;
                var transformSelects = options.transformSelects;
                var projectionActiveItems = options.projectionActiveItems;
                var metadata = options.metadata;
                if (!_.isEmpty(visualDataViews) && transformSelects && metadata) {
                    // compute linear regression line if applicable
                    var roleKindByQueryRef = data.DataViewSelectTransform.createRoleKindFromMetadata(transformSelects, metadata);
                    var projections = data.DataViewSelectTransform.projectionsFromSelects(transformSelects, projectionActiveItems);
                    if (!roleKindByQueryRef || !projections || _.isEmpty(dataViewMappings) || !objectDescriptors || !objectDefinitions)
                        return visualDataViews;
                    var applicableDataViewMappings = powerbi.DataViewAnalysis.chooseDataViewMappings(projections, dataViewMappings, roleKindByQueryRef, objectDescriptors, objectDefinitions).supportedMappings;
                    if (applicableDataViewMappings) {
                        var regressionDataViewMapping = _.find(applicableDataViewMappings, function (dataViewMapping) {
                            return dataViewMapping.usage && dataViewMapping.usage.regression;
                        });
                        if (regressionDataViewMapping) {
                            var regressionDataViews = [];
                            for (var _i = 0, visualDataViews_1 = visualDataViews; _i < visualDataViews_1.length; _i++) {
                                var visualDataView = visualDataViews_1[_i];
                                var regressionDataView = this.linearRegressionTransform(visualDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                                if (regressionDataView)
                                    regressionDataViews.push(regressionDataView);
                            }
                            if (!_.isEmpty(regressionDataViews))
                                visualDataViews.push.apply(visualDataViews, regressionDataViews);
                        }
                    }
                }
                return visualDataViews;
            }
            DataViewRegression.run = run;
            /**
             * This function will compute the linear regression algorithm on the sourceDataView and create a new dataView.
             * It works on scalar axis only.
             * The algorithm is as follows
             *
             * 1. Find the cartesian X and Y roles and the columns that correspond to those roles
             * 2. Get the data points, (X, Y) pairs, for each series, combining if needed.
             * 3. Compute the X and Y points for regression line using Y = Slope * X + Intercept
             * If highlights values are present, repeat steps 2 & 3 using highlight values.
             * 4. Create the new dataView using the points computed above
             */
            function linearRegressionTransform(sourceDataView, dataRoles, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                debug.assertValue(sourceDataView, 'sourceDataView');
                debug.assertValue(sourceDataView.categorical, 'sourceDataView.categorical');
                debug.assertValue(dataRoles, 'dataRoles');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefinitions, 'objectDefinitions');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                if (!sourceDataView.categorical)
                    return;
                // Step 1
                var xColumns = getColumnsForCartesianRoleKind(0 /* X */, sourceDataView.categorical, dataRoles);
                var yColumns = getColumnsForCartesianRoleKind(1 /* Y */, sourceDataView.categorical, dataRoles);
                if (_.isEmpty(xColumns) || _.isEmpty(yColumns))
                    return;
                var xColumnSource = xColumns[0].source;
                var yColumnSource = yColumns[0].source;
                var combineSeries = true;
                if (regressionDataViewMapping.usage && regressionDataViewMapping.usage.regression && sourceDataView.metadata.objects) {
                    var regressionUsage = regressionDataViewMapping.usage.regression;
                    var combineSeriesPropertyId = regressionUsage['combineSeries'];
                    if (combineSeriesPropertyId) {
                        combineSeries = powerbi.DataViewObjects.getValue(sourceDataView.metadata.objects, combineSeriesPropertyId, true);
                    }
                }
                // Step 2
                var dataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ false);
                var lineDefSet = calculateLineDefinitions(dataPointsBySeries);
                var xMin = lineDefSet.xMin;
                var xMax = lineDefSet.xMax;
                var shouldComputeHightlights = hasHighlightValues(yColumns) || hasHighlightValues(xColumns);
                var highlightsLineDefSet;
                if (shouldComputeHightlights) {
                    var highlightDataPointsBySeries = getDataPointsBySeries(xColumns, yColumns, combineSeries, /* preferHighlights */ true);
                    highlightsLineDefSet = calculateLineDefinitions(highlightDataPointsBySeries);
                    if (highlightsLineDefSet) {
                        xMin = _.min([xMin, highlightsLineDefSet.xMin]);
                        xMax = _.max([xMax, highlightsLineDefSet.xMax]);
                    }
                    else {
                        shouldComputeHightlights = false;
                    }
                }
                // Step 3
                var valuesByTrend = [];
                for (var _i = 0, _a = lineDefSet.lineDefs; _i < _a.length; _i++) {
                    var trend = _a[_i];
                    valuesByTrend.push(computeLineYValues(trend, +xMin, +xMax));
                }
                var highlightsByTrend;
                if (shouldComputeHightlights) {
                    highlightsByTrend = [];
                    for (var _b = 0, _c = highlightsLineDefSet.lineDefs; _b < _c.length; _b++) {
                        var trend = _c[_b];
                        highlightsByTrend.push(computeLineYValues(trend, +xMin, +xMax));
                    }
                }
                // Step 4
                var groupValues;
                if (combineSeries) {
                    groupValues = ['combinedRegressionSeries'];
                }
                else {
                    // If we are producing a trend line per series we need to maintain the group identities so that we can map between the 
                    // trend line and the original series (to match the color for example).
                    if (sourceDataView.categorical.values.source) {
                        // Source data view has dynamic series.
                        var groups = sourceDataView.categorical.values.grouped();
                        groupValues = _.map(groups, function (group) { return group.name; });
                    }
                    else {
                        // Source data view has static or no series.
                        groupValues = _.map(yColumns, function (column) { return column.source.queryName; });
                    }
                }
                // Step 5
                var regressionDataView = createRegressionDataView(xColumnSource, yColumnSource, groupValues, [xMin, xMax], valuesByTrend, highlightsByTrend, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory);
                return regressionDataView;
            }
            DataViewRegression.linearRegressionTransform = linearRegressionTransform;
            function calculateLineDefinitions(dataPointsBySeries) {
                var xMin;
                var xMax;
                var lineDefs = [];
                for (var _i = 0, dataPointsBySeries_1 = dataPointsBySeries; _i < dataPointsBySeries_1.length; _i++) {
                    var dataPointSet = dataPointsBySeries_1[_i];
                    var unsortedXValues = dataPointSet.xValues;
                    var unsortedYValues = dataPointSet.yValues;
                    if (_.isEmpty(unsortedXValues) || _.isEmpty(unsortedYValues))
                        return;
                    // get the data type for each column; we will have null type when dataPoints have different type or if a value is null
                    var xDataType = getDataType(unsortedXValues);
                    if (!xDataType)
                        return;
                    var yDataType = getDataType(unsortedYValues);
                    if (!yDataType)
                        return;
                    var sortedDataPointSet = sortValues(unsortedXValues, unsortedYValues);
                    var minCategoryValue = sortedDataPointSet.xValues[0];
                    var maxCategoryValue = sortedDataPointSet.xValues[sortedDataPointSet.xValues.length - 1];
                    var lineDef = computeRegressionLine(sortedDataPointSet.xValues, sortedDataPointSet.yValues);
                    xMin = _.min([xMin, minCategoryValue]);
                    xMax = _.max([xMax, maxCategoryValue]);
                    lineDefs.push(lineDef);
                }
                return {
                    lineDefs: lineDefs,
                    xMin: xMin,
                    xMax: xMax,
                };
            }
            function getColumnsForCartesianRoleKind(roleKind, categorical, roles) {
                debug.assertValue(roleKind, 'roleKind');
                debug.assertValue(categorical, 'categorical');
                var columns = getColumnsWithRoleKind(roleKind, categorical.values, roles);
                if (!_.isEmpty(columns))
                    return columns;
                var categories = categorical.categories;
                if (_.isEmpty(categories))
                    return;
                debug.assert(categories.length === 1, 'composite category columns not supported');
                var categoryColumn = categories[0];
                columns = getColumnsWithRoleKind(roleKind, [categoryColumn], roles);
                if (!_.isEmpty(columns))
                    return columns;
            }
            function getColumnsWithRoleKind(roleKind, columns, roles) {
                if (_.isEmpty(columns))
                    return;
                return _.filter(columns, function (column) {
                    var _loop_1 = function(roleName) {
                        if (!column.source.roles[roleName])
                            return "continue";
                        var role = _.find(roles, function (role) { return role.name === roleName; });
                        if (role && role.cartesianKind === roleKind)
                            return { value: true };
                    };
                    for (var roleName in column.source.roles) {
                        var state_1 = _loop_1(roleName);
                        if (typeof state_1 === "object") return state_1.value;
                        if (state_1 === "continue") continue;
                    }
                    return false;
                });
            }
            function getDataType(values) {
                var firstNonNull = _.find(values, function (value) { return value != null; });
                if (firstNonNull == null)
                    return;
                var dataType = typeof firstNonNull;
                if (_.some(values, function (value) { return value != null && typeof value !== dataType; }))
                    return;
                return dataType;
            }
            function sortValues(unsortedXValues, unsortedYValues) {
                debug.assertValue(unsortedXValues, 'unsortedXValues');
                debug.assertValue(unsortedYValues, 'unsortedYValues');
                var zippedValues = _.zip(unsortedXValues, unsortedYValues);
                var _a = _.chain(zippedValues)
                    .filter(function (valuePair) { return valuePair[0] != null && valuePair[1] != null; })
                    .sortBy(function (valuePair) { return valuePair[0]; })
                    .unzip()
                    .value(), xValues = _a[0], yValues = _a[1];
                return {
                    xValues: xValues,
                    yValues: yValues
                };
            }
            /**
             * Computes a line definition using linear regression.
             *   xBar: average of X values, yBar: average of Y values
             *   ssXX: sum of squares of X values = Sum(xi - xBar)^2
             *   ssXY: sum of squares of X and Y values  = Sum((xi - xBar)(yi - yBar)
             *   Slope: ssXY / ssXX
             *   Intercept: yBar - xBar * slope
             */
            function computeRegressionLine(xValues, yValues) {
                debug.assertValue(xValues, 'xValues');
                debug.assertValue(yValues, 'yValues');
                var xBar = _.sum(xValues) / xValues.length;
                var yBar = _.sum(yValues) / yValues.length;
                var ssXX = _.chain(xValues)
                    .map(function (x) {
                    return Math.pow((x - xBar), 2);
                })
                    .sum();
                var ssXY = _.chain(xValues)
                    .map(function (x, i) {
                    return (x - xBar) * (yValues[i] - yBar);
                })
                    .sum();
                var slope = ssXY / ssXX;
                var intercept = yBar - (xBar * slope);
                return {
                    slope: slope,
                    intercept: intercept
                };
            }
            function computeLineYValues(lineDef, x1, x2) {
                return [x1 * lineDef.slope + lineDef.intercept, x2 * lineDef.slope + lineDef.intercept];
            }
            function getValuesFromColumn(column, preferHighlights) {
                if (preferHighlights) {
                    // Attempt to use highlight values. When X is categorical, we may not have highlight values so we should fall back to the non-highlight values.
                    var valueColumn = column;
                    if (valueColumn.highlights) {
                        return valueColumn.highlights;
                    }
                }
                return column.values;
            }
            function getDataPointsBySeries(xColumns, yColumns, combineSeries, preferHighlights) {
                var dataPointsBySeries = [];
                var xValueArray = _.map(xColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });
                var seriesYValues = _.map(yColumns, function (column) { return getValuesFromColumn(column, preferHighlights); });
                var multipleXValueColumns = xColumns.length > 1;
                for (var i = 0; i < seriesYValues.length; i++) {
                    var xValues = multipleXValueColumns ? xValueArray[i] : xValueArray[0];
                    var yValues = seriesYValues[i];
                    if (combineSeries && dataPointsBySeries.length > 0) {
                        dataPointsBySeries[0].xValues = dataPointsBySeries[0].xValues.concat(xValues);
                        dataPointsBySeries[0].yValues = dataPointsBySeries[0].yValues.concat(yValues);
                    }
                    else {
                        dataPointsBySeries.push({
                            xValues: xValues,
                            yValues: yValues,
                        });
                    }
                }
                return dataPointsBySeries;
            }
            function createRegressionDataView(xColumnSource, yColumnSource, groupValues, categories, values, highlights, sourceDataView, regressionDataViewMapping, objectDescriptors, objectDefinitions, colorAllocatorFactory) {
                debug.assertValue(xColumnSource, 'xColumnSource');
                debug.assertValue(yColumnSource, 'yColumnSource');
                debug.assertValue(categories, 'categories');
                debug.assertValue(values, 'values');
                debug.assertValue(sourceDataView, 'sourceDataView');
                debug.assertValue(objectDescriptors, 'objectDescriptors');
                debug.assertValue(objectDefinitions, 'objectDefinitions');
                debug.assertValue(colorAllocatorFactory, 'colorAllocatorFactory');
                debug.assertAnyValue(highlights, 'highlights');
                debug.assert(!highlights || highlights.length === values.length, 'highlights should have the same length as values');
                var xRole = regressionDataViewMapping.categorical.categories.for.in;
                var grouped = regressionDataViewMapping.categorical.values.group;
                var yRole;
                var seriesRole;
                if (grouped && !_.isEmpty(grouped.select)) {
                    yRole = grouped.select[0].for ?
                        grouped.select[0].for.in :
                        grouped.select[0].bind.to;
                    seriesRole = grouped.by;
                }
                if (!yRole || !seriesRole)
                    return;
                var categoricalRoles = (_a = {}, _a[xRole] = true, _a);
                var valueRoles = (_b = {}, _b[yRole] = true, _b);
                var seriesRoles = (_c = {}, _c[seriesRole] = true, _c);
                var valuesBySeries = [];
                for (var index in values) {
                    var seriesData = {
                        values: values[index],
                    };
                    if (highlights)
                        seriesData.highlights = highlights[index];
                    valuesBySeries.push([seriesData]);
                }
                var regressionDataView = data.createCategoricalDataViewBuilder()
                    .withCategory({
                    source: {
                        displayName: xColumnSource.displayName,
                        queryName: regressionXQueryName,
                        type: xColumnSource.type,
                        isMeasure: false,
                        roles: categoricalRoles
                    },
                    values: categories,
                    identityFrom: {
                        fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionCategories')],
                    },
                })
                    .withGroupedValues({
                    groupColumn: {
                        source: {
                            displayName: yColumnSource.displayName + 'Regression',
                            queryName: regressionSeriesQueryName,
                            type: yColumnSource.type,
                            isMeasure: yColumnSource.isMeasure,
                            roles: seriesRoles
                        },
                        values: groupValues,
                        identityFrom: {
                            fields: [data.SQExprBuilder.columnRef(data.SQExprBuilder.entity('s', 'RegressionEntity'), 'RegressionSeries')],
                        }
                    },
                    valueColumns: [{
                            source: {
                                displayName: yColumnSource.displayName,
                                queryName: DataViewRegression.regressionYQueryName,
                                type: yColumnSource.type,
                                isMeasure: yColumnSource.isMeasure,
                                roles: valueRoles
                            },
                        }],
                    data: valuesBySeries
                })
                    .build();
                data.DataViewTransform.transformObjects(regressionDataView, 1 /* Categorical */, objectDescriptors, objectDefinitions, [], colorAllocatorFactory);
                return regressionDataView;
                var _a, _b, _c;
            }
            function hasHighlightValues(columns) {
                return _.any(columns, function (column) {
                    var valueColumn = column;
                    return valueColumn.highlights != null;
                });
            }
        })(DataViewRegression = data.DataViewRegression || (data.DataViewRegression = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var DataViewSelectTransform;
        (function (DataViewSelectTransform) {
            /** Convert selection info to projections */
            function projectionsFromSelects(selects, projectionActiveItems) {
                debug.assertAnyValue(selects, "selects");
                debug.assertAnyValue(projectionActiveItems, "projectionActiveItems");
                var projections = {};
                for (var _i = 0, selects_1 = selects; _i < selects_1.length; _i++) {
                    var select = selects_1[_i];
                    var roles = select.roles;
                    if (!roles)
                        continue;
                    for (var roleName in roles) {
                        if (roles[roleName]) {
                            var qp = projections[roleName];
                            if (!qp)
                                qp = projections[roleName] = new data.QueryProjectionCollection([]);
                            qp.all().push({ queryRef: select.queryName });
                            if (projectionActiveItems && projectionActiveItems[roleName])
                                qp.activeProjectionRefs = _.map(projectionActiveItems[roleName], function (activeItem) { return activeItem.queryRef; });
                        }
                    }
                }
                return projections;
            }
            DataViewSelectTransform.projectionsFromSelects = projectionsFromSelects;
            /** Use selections and metadata to fashion query role kinds */
            function createRoleKindFromMetadata(selects, metadata) {
                var roleKindByQueryRef = {};
                for (var _i = 0, _a = metadata.columns; _i < _a.length; _i++) {
                    var column = _a[_i];
                    if ((!column.index && column.index !== 0) || column.index < 0 || column.index >= selects.length)
                        continue;
                    var select = selects[column.index];
                    if (select) {
                        var queryRef = select.queryName;
                        if (queryRef && roleKindByQueryRef[queryRef] === undefined) {
                            roleKindByQueryRef[queryRef] = column.isMeasure ? powerbi.VisualDataRoleKind.Measure : powerbi.VisualDataRoleKind.Grouping;
                        }
                    }
                }
                return roleKindByQueryRef;
            }
            DataViewSelectTransform.createRoleKindFromMetadata = createRoleKindFromMetadata;
        })(DataViewSelectTransform = data.DataViewSelectTransform || (data.DataViewSelectTransform = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createCategoricalEvalContext(colorAllocatorProvider, dataViewCategorical) {
            return new CategoricalEvalContext(colorAllocatorProvider, dataViewCategorical);
        }
        data.createCategoricalEvalContext = createCategoricalEvalContext;
        var CategoricalEvalContext = (function () {
            function CategoricalEvalContext(colorAllocatorProvider, dataView) {
                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');
                debug.assertValue(dataView, 'dataView');
                this.colorAllocatorProvider = colorAllocatorProvider;
                this.dataView = dataView;
                this.columnsByRole = {};
            }
            CategoricalEvalContext.prototype.getColorAllocator = function (expr) {
                return this.colorAllocatorProvider.get(expr);
            };
            CategoricalEvalContext.prototype.getExprValue = function (expr) {
                return;
            };
            CategoricalEvalContext.prototype.getRoleValue = function (roleName) {
                var columnsByRole = this.columnsByRole;
                var column = columnsByRole[roleName];
                if (!column)
                    column = columnsByRole[roleName] = findRuleInputColumn(this.dataView, roleName);
                if (!column)
                    return;
                var index = this.index;
                if (index != null)
                    return column.values[this.index];
            };
            CategoricalEvalContext.prototype.setCurrentRowIndex = function (index) {
                debug.assertValue(index, 'index');
                this.index = index;
            };
            return CategoricalEvalContext;
        }());
        function findRuleInputColumn(dataViewCategorical, inputRole) {
            debug.assertValue(dataViewCategorical, 'dataViewCategorical');
            return findRuleInputInColumns(dataViewCategorical.values, inputRole) ||
                findRuleInputInColumns(dataViewCategorical.categories, inputRole);
        }
        function findRuleInputInColumns(columns, inputRole) {
            debug.assertAnyValue(columns, 'columns');
            if (!columns)
                return;
            for (var _i = 0, columns_7 = columns; _i < columns_7.length; _i++) {
                var column = columns_7[_i];
                var roles = column.source.roles;
                if (!roles || !roles[inputRole])
                    continue;
                return column;
            }
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createTableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms) {
            return new TableEvalContext(colorAllocatorProvider, dataViewTable, selectTransforms);
        }
        data.createTableEvalContext = createTableEvalContext;
        var TableEvalContext = (function () {
            function TableEvalContext(colorAllocatorProvider, dataView, selectTransforms) {
                debug.assertValue(colorAllocatorProvider, 'colorAllocatorProvider');
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(selectTransforms, 'selectTransforms');
                this.colorAllocatorProvider = colorAllocatorProvider;
                this.dataView = dataView;
                this.selectTransforms = selectTransforms;
            }
            TableEvalContext.prototype.getColorAllocator = function (expr) {
                return this.colorAllocatorProvider.get(expr);
            };
            TableEvalContext.prototype.getExprValue = function (expr) {
                debug.assertValue(expr, 'expr');
                var rowIdx = this.rowIdx;
                if (rowIdx == null)
                    return;
                return data.getExprValueFromTable(expr, this.selectTransforms, this.dataView, rowIdx);
            };
            TableEvalContext.prototype.getRoleValue = function (roleName) {
                return;
            };
            TableEvalContext.prototype.setCurrentRowIndex = function (index) {
                debug.assertValue(index, 'index');
                this.rowIdx = index;
            };
            return TableEvalContext;
        }());
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var RuleEvaluation = (function () {
            function RuleEvaluation() {
            }
            // NOTE: even though this class has no behaviour, we still use a class to facilitate instanceof checks.
            RuleEvaluation.prototype.evaluate = function (evalContext) {
                debug.assertFail('Abstract method RuleEvaluation.evaluate not implemented.');
            };
            return RuleEvaluation;
        }());
        data.RuleEvaluation = RuleEvaluation;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ColorRuleEvaluation = (function (_super) {
            __extends(ColorRuleEvaluation, _super);
            function ColorRuleEvaluation(inputRole, allocator) {
                debug.assertValue(inputRole, 'inputRole');
                debug.assertValue(allocator, 'allocator');
                _super.call(this);
                this.inputRole = inputRole;
                this.allocator = allocator;
            }
            ColorRuleEvaluation.prototype.evaluate = function (evalContext) {
                debug.assertValue(evalContext, 'evalContext');
                var value = evalContext.getRoleValue(this.inputRole);
                if (value !== undefined)
                    return this.allocator.color(value);
            };
            return ColorRuleEvaluation;
        }(data.RuleEvaluation));
        data.ColorRuleEvaluation = ColorRuleEvaluation;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var utils;
        (function (utils) {
            var inherit = powerbi.Prototype.inherit;
            var inheritSingle = powerbi.Prototype.inheritSingle;
            var ArrayExtensions = jsCommon.ArrayExtensions;
            var DataViewMatrixUtils;
            (function (DataViewMatrixUtils) {
                /**
                 * Invokes the specified callback once per leaf nodes (including root-level leaves and descendent leaves) of the
                 * specified rootNodes, with an optional index parameter in the callback that is the 0-based index of the
                 * particular leaf node in the context of this forEachLeafNode(...) invocation.
                 *
                 * If rootNodes is null or undefined or empty, the specified callback will not get invoked.
                 *
                 * The treePath parameter in the callback is an ordered set of nodes that form the path from the specified
                 * rootNodes down to the leafNode argument itself.  If callback leafNode is one of the specified rootNodes,
                 * then treePath will be an array of length 1 containing that very node.
                 *
                 * IMPORTANT: The treePath array passed to the callback will be modified after the callback function returns!
                 * If your callback needs to retain a copy of the treePath, please clone the array before returning.
                 */
                function forEachLeafNode(rootNodes, callback) {
                    debug.assertAnyValue(rootNodes, 'rootNodes');
                    debug.assertValue(callback, 'callback');
                    // Note: Don't do "if (!_.isEmpty(rootNodes))" for checking whether rootNodes is an empty array DataViewMatrixNode[],
                    // because rootNodes can also be an non-array DataViewMatrixNode, and an empty object can be a valid root node DataViewMatrixNode, 
                    // for the fact that all the properties on DataViewMatrixNode are optional...
                    if (rootNodes) {
                        if (isNodeArray(rootNodes)) {
                            var index = 0;
                            for (var _i = 0, rootNodes_1 = rootNodes; _i < rootNodes_1.length; _i++) {
                                var rootNode = rootNodes_1[_i];
                                if (rootNode) {
                                    index = forEachLeafNodeRecursive(rootNode, index, [], callback);
                                }
                            }
                        }
                        else {
                            forEachLeafNodeRecursive(rootNodes, 0, [], callback);
                        }
                    }
                }
                DataViewMatrixUtils.forEachLeafNode = forEachLeafNode;
                function isNodeArray(nodeOrNodeArray) {
                    return ArrayExtensions.isArrayOrInheritedArray(nodeOrNodeArray);
                }
                /**
                 * Recursively traverses to each leaf node of the specified matrixNode and invokes callback with each of them.
                 * Returns the index for the next node after the last node that this function invokes callback with.
                 *
                 * @treePath an array that contains the path from the specified rootNodes in forEachLeafNode() down to the parent of the argument matrixNode (i.e. treePath does not contain the matrixNode argument yet).
                 */
                function forEachLeafNodeRecursive(matrixNode, nextIndex, treePath, callback) {
                    debug.assertValue(matrixNode, 'matrixNode');
                    debug.assertValue(treePath, 'treePath');
                    debug.assertValue(callback, 'callback');
                    // If treePath already contains matrixNode, then either one of the following errors has happened:
                    // 1. the caller code mistakenly added matrixNode to treePath, or
                    // 2. the callback modified treePath by adding a node to it, or
                    // 3. the matrix hierarchy contains a cyclical node reference.');
                    debug.assert(!_.contains(treePath, matrixNode), 'pre-condition: treePath must not already contain matrixNode');
                    treePath.push(matrixNode);
                    if (_.isEmpty(matrixNode.children)) {
                        callback(matrixNode, nextIndex, treePath);
                        nextIndex++;
                    }
                    else {
                        var children = matrixNode.children;
                        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                            var nextChild = children_1[_i];
                            if (nextChild) {
                                nextIndex = forEachLeafNodeRecursive(nextChild, nextIndex, treePath, callback);
                            }
                        }
                    }
                    debug.assert(_.last(treePath) === matrixNode, 'pre-condition: the callback given to forEachLeafNode() is not supposed to modify the treePath argument array.');
                    treePath.pop();
                    return nextIndex;
                }
                /**
                 * Returned an object tree where each node and its children property are inherited from the specified node
                 * hierarchy, from the root down to the nodes at the specified deepestLevelToInherit, inclusively.
                 *
                 * The inherited nodes at level === deepestLevelToInherit will NOT get an inherited version of children array
                 * property, i.e. its children property is the same array object referenced in the input node's object tree.
                 *
                 * @param node The input node with the hierarchy object tree.
                 * @param deepestLevelToInherit The highest level for a node to get inherited. See DataViewMatrixNode.level property.
                 * @param useInheritSingle If true, then a node will get inherited in the returned object tree only if it is
                 * not already an inherited object. Same goes for the node's children property.  This is useful for creating
                 * "visual DataView" objects from "query DataView" objects, as object inheritance is the mechanism for
                 * "visual DataView" to override properties in "query DataView", and that "query DataView" never contains
                 * inherited objects.
                 */
                function inheritMatrixNodeHierarchy(node, deepestLevelToInherit, useInheritSingle) {
                    debug.assertValue(node, 'node');
                    debug.assert(deepestLevelToInherit >= 0, 'deepestLevelToInherit >= 0');
                    debug.assertValue(useInheritSingle, 'useInheritSingle');
                    var returnNode = node;
                    // Note: The level property of DataViewMatrix.rows.root and DataViewMatrix.columns.root are always undefined.
                    // Also, in a matrix with multiple column grouping fields and multiple value fields, the DataViewMatrixNode
                    // for the Grand Total column in the column hierarchy will have children nodes where level > (parent.level + 1):
                    //  {
                    //    "level": 0,
                    //    "isSubtotal": true,
                    //    "children": [
                    //      { "level": 2, "isSubtotal": true },
                    //      { "level": 2, "levelSourceIndex": 1, "isSubtotal": true }
                    //    ]
                    //  }
                    var isRootNode = _.isUndefined(node.level);
                    var shouldInheritCurrentNode = isRootNode || (node.level <= deepestLevelToInherit);
                    if (shouldInheritCurrentNode) {
                        var inheritFunc = useInheritSingle ? inheritSingle : inherit;
                        var inheritedNode = inheritFunc(node);
                        var shouldInheritChildNodes = isRootNode || (node.level < deepestLevelToInherit);
                        if (shouldInheritChildNodes && !_.isEmpty(node.children)) {
                            inheritedNode.children = inheritFunc(node.children); // first, make an inherited array
                            for (var i = 0, ilen = inheritedNode.children.length; i < ilen; i++) {
                                inheritedNode.children[i] =
                                    inheritMatrixNodeHierarchy(inheritedNode.children[i], deepestLevelToInherit, useInheritSingle);
                            }
                        }
                        returnNode = inheritedNode;
                    }
                    return returnNode;
                }
                DataViewMatrixUtils.inheritMatrixNodeHierarchy = inheritMatrixNodeHierarchy;
                /**
                 * Returns true if the specified matrixOrHierarchy contains any composite grouping, i.e. a grouping on multiple columns.
                 * An example of composite grouping is one on [Year, Quarter, Month], where a particular group instance can have
                 * Year === 2016, Quarter === 'Qtr 1', Month === 1.
                 *
                 * Returns false if the specified matrixOrHierarchy does not contain any composite group,
                 * or if matrixOrHierarchy is null or undefined.
                 */
                function containsCompositeGroup(matrixOrHierarchy) {
                    debug.assertAnyValue(matrixOrHierarchy, 'matrixOrHierarchy');
                    var hasCompositeGroup = false;
                    if (matrixOrHierarchy) {
                        if (isMatrix(matrixOrHierarchy)) {
                            hasCompositeGroup = containsCompositeGroup(matrixOrHierarchy.rows) ||
                                containsCompositeGroup(matrixOrHierarchy.columns);
                        }
                        else {
                            var hierarchyLevels = matrixOrHierarchy.levels;
                            if (!_.isEmpty(hierarchyLevels)) {
                                for (var _i = 0, hierarchyLevels_1 = hierarchyLevels; _i < hierarchyLevels_1.length; _i++) {
                                    var level = hierarchyLevels_1[_i];
                                    // it takes at least 2 columns at the same hierarchy level to form a composite group...
                                    if (level.sources && (level.sources.length >= 2)) {
                                        debug.assert(_.all(level.sources, function (sourceColumn) { return sourceColumn.isMeasure === level.sources[0].isMeasure; }), 'pre-condition: in a valid DataViewMatrix, the source columns in each of its hierarchy levels must either be all non-measure columns (i.e. a grouping level) or all measure columns (i.e. a measure headers level)');
                                        // Measure headers are not group
                                        var isMeasureHeadersLevel = level.sources[0].isMeasure;
                                        if (!isMeasureHeadersLevel) {
                                            hasCompositeGroup = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return hasCompositeGroup;
                }
                DataViewMatrixUtils.containsCompositeGroup = containsCompositeGroup;
                function isMatrix(matrixOrHierarchy) {
                    return 'rows' in matrixOrHierarchy &&
                        'columns' in matrixOrHierarchy &&
                        'valueSources' in matrixOrHierarchy;
                }
            })(DataViewMatrixUtils = utils.DataViewMatrixUtils || (utils.DataViewMatrixUtils = {}));
        })(utils = data.utils || (data.utils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var utils;
        (function (utils) {
            var DataViewMetadataColumnUtils;
            (function (DataViewMetadataColumnUtils) {
                /**
                 * Returns true iff the specified metadataColumn is assigned to the specified targetRole.
                 */
                function isForRole(metadataColumn, targetRole) {
                    debug.assertValue(metadataColumn, 'metadataColumn');
                    debug.assertValue(targetRole, 'targetRole');
                    var roles = metadataColumn.roles;
                    return roles && roles[targetRole];
                }
                DataViewMetadataColumnUtils.isForRole = isForRole;
                /**
                 * Joins each column in the specified columnSources with projection ordering index into a wrapper object.
                 *
                 * Note: In order for this function to reliably calculate the "source index" of a particular column, the
                 * specified columnSources must be a non-filtered array of column sources from the DataView, such as
                 * the DataViewHierarchyLevel.sources and DataViewMatrix.valueSources array properties.
                 *
                 * @param columnSources E.g. DataViewHierarchyLevel.sources, DataViewMatrix.valueSources...
                 * @param projection The projection ordering.  It must contain an ordering for the specified role.
                 * @param role The role for getting the relevant projection ordering, as well as for filtering out the irrevalent columns in columnSources.
                 */
                function joinMetadataColumnsAndProjectionOrder(columnSources, projection, role) {
                    debug.assertAnyValue(columnSources, 'columnSources');
                    debug.assert(_.all(columnSources, function (column) { return _.isNumber(column.index); }), 'pre-condition: Every value in columnSources must already have its Select Index property initialized.');
                    debug.assertNonEmpty(projection[role], 'projection[role]');
                    debug.assert(_.all(columnSources, function (column) { return !isForRole(column, role) || _.contains(projection[role], column.index); }), 'pre-condition: The projection order for the specified role must contain the Select Index of every column with matching role in the specified columnSources.');
                    var jointResult = [];
                    if (!_.isEmpty(columnSources)) {
                        var projectionOrderSelectIndices = projection[role];
                        var selectIndexToProjectionIndexMap = {};
                        for (var i = 0, ilen = projectionOrderSelectIndices.length; i < ilen; i++) {
                            var selectIndex = projectionOrderSelectIndices[i];
                            selectIndexToProjectionIndexMap[selectIndex] = i;
                        }
                        for (var j = 0, jlen = columnSources.length; j < jlen; j++) {
                            var column = columnSources[j];
                            if (isForRole(column, role)) {
                                var jointColumnInfo = {
                                    metadataColumn: column,
                                    sourceIndex: j,
                                    projectionOrderIndex: selectIndexToProjectionIndexMap[column.index]
                                };
                                jointResult.push(jointColumnInfo);
                            }
                        }
                    }
                    return jointResult;
                }
                DataViewMetadataColumnUtils.joinMetadataColumnsAndProjectionOrder = joinMetadataColumnsAndProjectionOrder;
            })(DataViewMetadataColumnUtils = utils.DataViewMetadataColumnUtils || (utils.DataViewMetadataColumnUtils = {}));
        })(utils = data.utils || (data.utils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ConceptualSchema = (function () {
            function ConceptualSchema() {
            }
            ConceptualSchema.prototype.findProperty = function (entityName, propertyName) {
                var entity = this.entities.withName(entityName);
                if (!entity || _.isEmpty(entity.properties))
                    return;
                return entity.properties.withName(propertyName);
            };
            ConceptualSchema.prototype.findHierarchy = function (entityName, name) {
                var entity = this.entities.withName(entityName);
                if (!entity || _.isEmpty(entity.hierarchies))
                    return;
                return entity.hierarchies.withName(name);
            };
            ConceptualSchema.prototype.findHierarchyByVariation = function (variationEntityName, variationColumnName, variationName, hierarchyName) {
                var variationEntity = this.entities.withName(variationEntityName);
                if (!variationEntity || _.isEmpty(variationEntity.properties))
                    return;
                var variationProperty = variationEntity.properties.withName(variationColumnName);
                if (!variationProperty)
                    return;
                var variationColumn = variationProperty.column;
                if (!variationColumn || _.isEmpty(variationColumn.variations))
                    return;
                var variation = variationColumn.variations.withName(variationName);
                if (variation) {
                    var targetEntity = variation.navigationProperty ? variation.navigationProperty.targetEntity : variationEntity;
                    if (!targetEntity || _.isEmpty(targetEntity.hierarchies))
                        return;
                    return targetEntity.hierarchies.withName(hierarchyName);
                }
            };
            /**
            * Returns the first property of the entity whose kpi is tied to kpiProperty
            */
            ConceptualSchema.prototype.findPropertyWithKpi = function (entityName, kpiProperty) {
                debug.assertValue(kpiProperty, 'kpiProperty');
                var entity = this.entities.withName(entityName);
                if (!entity || _.isEmpty(entity.properties))
                    return;
                for (var _i = 0, _a = entity.properties; _i < _a.length; _i++) {
                    var prop = _a[_i];
                    if (prop &&
                        prop.measure &&
                        prop.measure.kpi &&
                        (prop.measure.kpi.status === kpiProperty || prop.measure.kpi.goal === kpiProperty))
                        return prop;
                }
                return;
            };
            return ConceptualSchema;
        }());
        data.ConceptualSchema = ConceptualSchema;
        // TODO: Remove this (replaced by ValueType)
        (function (ConceptualDataCategory) {
            ConceptualDataCategory[ConceptualDataCategory["None"] = 0] = "None";
            ConceptualDataCategory[ConceptualDataCategory["Address"] = 1] = "Address";
            ConceptualDataCategory[ConceptualDataCategory["City"] = 2] = "City";
            ConceptualDataCategory[ConceptualDataCategory["Company"] = 3] = "Company";
            ConceptualDataCategory[ConceptualDataCategory["Continent"] = 4] = "Continent";
            ConceptualDataCategory[ConceptualDataCategory["Country"] = 5] = "Country";
            ConceptualDataCategory[ConceptualDataCategory["County"] = 6] = "County";
            ConceptualDataCategory[ConceptualDataCategory["Date"] = 7] = "Date";
            ConceptualDataCategory[ConceptualDataCategory["Image"] = 8] = "Image";
            ConceptualDataCategory[ConceptualDataCategory["ImageUrl"] = 9] = "ImageUrl";
            ConceptualDataCategory[ConceptualDataCategory["Latitude"] = 10] = "Latitude";
            ConceptualDataCategory[ConceptualDataCategory["Longitude"] = 11] = "Longitude";
            ConceptualDataCategory[ConceptualDataCategory["Organization"] = 12] = "Organization";
            ConceptualDataCategory[ConceptualDataCategory["Place"] = 13] = "Place";
            ConceptualDataCategory[ConceptualDataCategory["PostalCode"] = 14] = "PostalCode";
            ConceptualDataCategory[ConceptualDataCategory["Product"] = 15] = "Product";
            ConceptualDataCategory[ConceptualDataCategory["StateOrProvince"] = 16] = "StateOrProvince";
            ConceptualDataCategory[ConceptualDataCategory["WebUrl"] = 17] = "WebUrl";
        })(data.ConceptualDataCategory || (data.ConceptualDataCategory = {}));
        var ConceptualDataCategory = data.ConceptualDataCategory;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var StringExtensions = jsCommon.StringExtensions;
    var FieldExprPattern = powerbi.data.FieldExprPattern;
    var ScriptResultUtil;
    (function (ScriptResultUtil) {
        function findScriptResult(dataViewMappings) {
            if (dataViewMappings && dataViewMappings.length === 1) {
                return dataViewMappings[0].scriptResult;
            }
            return undefined;
        }
        ScriptResultUtil.findScriptResult = findScriptResult;
        function extractScriptResult(dataViewMappings) {
            var scriptResult = findScriptResult(dataViewMappings);
            if (scriptResult) {
                var objects = dataViewMappings[0].metadata.objects;
                var source = powerbi.DataViewObjects.getValue(objects, scriptResult.script.source);
                var provider = powerbi.DataViewObjects.getValue(objects, scriptResult.script.provider);
                return {
                    source: source,
                    provider: provider
                };
            }
            return undefined;
        }
        ScriptResultUtil.extractScriptResult = extractScriptResult;
        function extractScriptResultFromVisualConfig(dataViewMappings, objects) {
            var scriptResult = findScriptResult(dataViewMappings);
            if (scriptResult && objects) {
                var scriptSource = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.source, null);
                var provider = powerbi.data.DataViewObjectDefinitions.getValue(objects, scriptResult.script.provider, null);
                return {
                    source: scriptSource ? scriptSource.value : null,
                    provider: provider ? provider.value : null
                };
            }
            return undefined;
        }
        ScriptResultUtil.extractScriptResultFromVisualConfig = extractScriptResultFromVisualConfig;
        function getScriptInput(projections, selects, schema) {
            var scriptInput = {
                VariableName: "dataset",
                Columns: []
            };
            // Go over all the projections, and create an input column according to the order
            // of the projections (including duplicate expressions)
            if (projections && selects && !_.isEmpty(selects)) {
                var scriptInputColumnNames = [];
                var scriptInputColumns = [];
                for (var role in projections) {
                    for (var _i = 0, _a = projections[role].all(); _i < _a.length; _i++) {
                        var projection = _a[_i];
                        var select = selects.withName(projection.queryRef);
                        if (select) {
                            var scriptInputColumn = {
                                QueryName: select.name,
                                Name: FieldExprPattern.visit(select.expr, new ScriptInputColumnNameVisitor(schema))
                            };
                            scriptInputColumns.push(scriptInputColumn);
                            scriptInputColumnNames.push(scriptInputColumn.Name);
                        }
                    }
                }
                // Make sure the names of the columns are unique
                scriptInputColumnNames = StringExtensions.ensureUniqueNames(scriptInputColumnNames);
                // Update the names of the columns
                for (var i = 0; i < scriptInputColumnNames.length; i++) {
                    var scriptInputColumn = scriptInputColumns[i];
                    scriptInputColumn.Name = scriptInputColumnNames[i];
                }
                scriptInput.Columns = scriptInputColumns;
            }
            return scriptInput;
        }
        ScriptResultUtil.getScriptInput = getScriptInput;
        var ScriptInputColumnNameVisitor = (function () {
            function ScriptInputColumnNameVisitor(federatedSchema) {
                this.federatedSchema = federatedSchema;
            }
            ScriptInputColumnNameVisitor.prototype.visitColumn = function (column) {
                return ScriptInputColumnNameVisitor.getNameForProperty(column, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitColumnAggr = function (columnAggr) {
                return ScriptInputColumnNameVisitor.getNameForProperty(columnAggr, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitColumnHierarchyLevelVariation = function (columnHierarchyLevelVariation) {
                return ScriptInputColumnNameVisitor.getVariationLevelName(columnHierarchyLevelVariation, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitEntity = function (entity) {
                return entity.entity;
            };
            ScriptInputColumnNameVisitor.prototype.visitEntityAggr = function (entityAggr) {
                return entityAggr.entity;
            };
            ScriptInputColumnNameVisitor.prototype.visitHierarchy = function (hierarchy) {
                return ScriptInputColumnNameVisitor.getNameForHierarchy(hierarchy, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevel = function (hierarchyLevel) {
                /*Hierarchy levels are not supported yet*/
                return;
            };
            ScriptInputColumnNameVisitor.prototype.visitHierarchyLevelAggr = function (hierarchyLevelAggr) {
                return ScriptInputColumnNameVisitor.getNameForProperty(hierarchyLevelAggr, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.prototype.visitMeasure = function (measure) {
                return ScriptInputColumnNameVisitor.getNameForProperty(measure, this.federatedSchema);
            };
            ScriptInputColumnNameVisitor.getNameForHierarchy = function (pattern, federatedScheam) {
                debug.assertValue(pattern, 'pattern');
                var schema = federatedScheam.schema(pattern.schema), hierarchy = schema.findHierarchy(pattern.entity, pattern.name);
                if (hierarchy)
                    return hierarchy.name;
            };
            ScriptInputColumnNameVisitor.getNameForProperty = function (pattern, federatedSchema) {
                debug.assertValue(pattern, 'pattern');
                var schema = federatedSchema.schema(pattern.schema), property = schema.findProperty(pattern.entity, pattern.name);
                if (property)
                    return property.name;
            };
            ScriptInputColumnNameVisitor.getVariationLevelName = function (pattern, federatedSchema) {
                debug.assertValue(pattern, 'pattern');
                var source = pattern.source;
                var prop = federatedSchema.schema(source.schema).findProperty(source.entity, source.name);
                if (!prop)
                    return;
                var variations = prop.column.variations;
                for (var _i = 0, variations_1 = variations; _i < variations_1.length; _i++) {
                    var variation = variations_1[_i];
                    if (variation.name === pattern.variationName)
                        for (var _a = 0, _b = variation.defaultHierarchy.levels; _a < _b.length; _a++) {
                            var level = _b[_a];
                            if (level.name === pattern.level.level)
                                return level.column.name;
                        }
                }
            };
            return ScriptInputColumnNameVisitor;
        }());
    })(ScriptResultUtil = powerbi.ScriptResultUtil || (powerbi.ScriptResultUtil = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var segmentation;
        (function (segmentation) {
            var DataViewMerger;
            (function (DataViewMerger) {
                function mergeDataViews(source, segment) {
                    if (!powerbi.DataViewAnalysis.isMetadataEquivalent(source.metadata, segment.metadata)) {
                        debug.assertFail("Cannot merge data views with different metadata columns");
                    }
                    // The last segment is complete. We mark the source as complete.
                    if (!segment.metadata.segment)
                        delete source.metadata.segment;
                    if (source.table && segment.table)
                        mergeTables(source.table, segment.table);
                    if (source.categorical && segment.categorical)
                        mergeCategorical(source.categorical, segment.categorical);
                    // Tree cannot support subtotals hence we can get into situations
                    // where a node has no children in one segment and more than 1 child
                    // in another segment.
                    if (source.tree && segment.tree)
                        mergeTreeNodes(source.tree.root, segment.tree.root, true /*allowDifferentStructure*/);
                    if (source.matrix && segment.matrix)
                        mergeTreeNodes(source.matrix.rows.root, segment.matrix.rows.root, false /*allowDifferentStructure*/);
                }
                DataViewMerger.mergeDataViews = mergeDataViews;
                /** Note: Public for testability */
                function mergeTables(source, segment) {
                    debug.assertValue(source, 'source');
                    debug.assertValue(segment, 'segment');
                    if (segment.rows.length === 0)
                        return;
                    merge(source.rows, segment.rows, segment.lastMergeIndex + 1);
                }
                DataViewMerger.mergeTables = mergeTables;
                /**
                 * Merge categories values and identities
                 *
                 * Note: Public for testability
                 */
                function mergeCategorical(source, segment) {
                    debug.assertValue(source, 'source');
                    debug.assertValue(segment, 'segment');
                    // Merge categories values and identities
                    if (source.categories && segment.categories) {
                        var segmentCategoriesLength = segment.categories.length;
                        debug.assert(source.categories.length === segmentCategoriesLength, "Source and segment categories have different lengths.");
                        for (var categoryIndex = 0; categoryIndex < segmentCategoriesLength; categoryIndex++) {
                            var segmentCategory = segment.categories[categoryIndex];
                            var sourceCategory = source.categories[categoryIndex];
                            debug.assert(powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(sourceCategory.source, segmentCategory.source), "Source and segment category have different sources.");
                            if (!sourceCategory.values && segmentCategory.values) {
                                sourceCategory.values = [];
                                debug.assert(!sourceCategory.identity, "Source category is missing values but has identities.");
                            }
                            if (segmentCategory.values) {
                                merge(sourceCategory.values, segmentCategory.values, segment.lastMergeIndex + 1);
                            }
                            if (!sourceCategory.identity && segmentCategory.identity) {
                                sourceCategory.identity = [];
                            }
                            if (segmentCategory.identity) {
                                merge(sourceCategory.identity, segmentCategory.identity, segment.lastMergeIndex + 1);
                            }
                        }
                    }
                    // Merge values for each value column
                    if (source.values && segment.values) {
                        var segmentValuesLength = segment.values.length;
                        debug.assert(source.values.length === segmentValuesLength, "Source and segment values have different lengths.");
                        for (var valueIndex = 0; valueIndex < segmentValuesLength; valueIndex++) {
                            var segmentValue = segment.values[valueIndex];
                            var sourceValue = source.values[valueIndex];
                            debug.assert(jsCommon.JsonComparer.equals(sourceValue.source, segmentValue.source), "Source and segment value have different sources.");
                            if (!sourceValue.values && segmentValue.values) {
                                sourceValue.values = [];
                            }
                            if (segmentValue.values) {
                                merge(sourceValue.values, segmentValue.values, segment.lastMergeIndex + 1);
                            }
                            if (segmentValue.highlights) {
                                merge(sourceValue.highlights, segmentValue.highlights, segment.lastMergeIndex + 1);
                            }
                        }
                    }
                }
                DataViewMerger.mergeCategorical = mergeCategorical;
                /**
                 * Merges the segment array starting at the specified index into the source array
                 * and returns the segment slice that wasn't merged.
                 * The segment array is spliced up to specified index in the process.
                 */
                function merge(source, segment, index) {
                    if (index >= segment.length)
                        return segment;
                    var result = [];
                    if (index !== undefined)
                        result = segment.splice(0, index);
                    Array.prototype.push.apply(source, segment);
                    return result;
                }
                /** Note: Public for testability */
                function mergeTreeNodes(sourceRoot, segmentRoot, allowDifferentStructure) {
                    debug.assertValue(sourceRoot, 'sourceRoot');
                    debug.assertValue(segmentRoot, 'segmentRoot');
                    if (!segmentRoot.children || segmentRoot.children.length === 0)
                        return;
                    if (allowDifferentStructure && (!sourceRoot.children || sourceRoot.children.length === 0)) {
                        sourceRoot.children = segmentRoot.children;
                        return;
                    }
                    debug.assert(sourceRoot.children && sourceRoot.children.length >= 0, "Source tree has different structure than segment.");
                    var firstAppendIndex = findFirstAppendIndex(segmentRoot.children);
                    var lastSourceChild = sourceRoot.children[sourceRoot.children.length - 1];
                    var mergedChildren = merge(sourceRoot.children, segmentRoot.children, firstAppendIndex);
                    if (mergedChildren.length > 0)
                        mergeTreeNodes(lastSourceChild, mergedChildren[mergedChildren.length - 1], allowDifferentStructure);
                }
                DataViewMerger.mergeTreeNodes = mergeTreeNodes;
                function findFirstAppendIndex(children) {
                    if (children.length === 0)
                        return 0;
                    var i = 0;
                    for (; i < children.length; i++) {
                        var childSegment = children[i];
                        if (!childSegment.isMerge)
                            break;
                    }
                    return i;
                }
            })(DataViewMerger = segmentation.DataViewMerger || (segmentation.DataViewMerger = {}));
        })(segmentation = data.segmentation || (data.segmentation = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /** Rewrites an expression tree, including all descendant nodes. */
        var SQExprRewriter = (function () {
            function SQExprRewriter() {
            }
            SQExprRewriter.prototype.visitColumnRef = function (expr) {
                var origArg = expr.source, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQColumnRefExpr(rewrittenArg, expr.ref);
            };
            SQExprRewriter.prototype.visitMeasureRef = function (expr) {
                var origArg = expr.source, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQMeasureRefExpr(rewrittenArg, expr.ref);
            };
            SQExprRewriter.prototype.visitAggr = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQAggregationExpr(rewrittenArg, expr.func);
            };
            SQExprRewriter.prototype.visitHierarchy = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQHierarchyExpr(rewrittenArg, expr.hierarchy);
            };
            SQExprRewriter.prototype.visitHierarchyLevel = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQHierarchyLevelExpr(rewrittenArg, expr.level);
            };
            SQExprRewriter.prototype.visitPropertyVariationSource = function (expr) {
                var origArg = expr.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return expr;
                return new data.SQPropertyVariationSourceExpr(rewrittenArg, expr.name, expr.property);
            };
            SQExprRewriter.prototype.visitEntity = function (expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitAnd = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQAndExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitBetween = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this), origLower = orig.lower, rewrittenLower = origLower.accept(this), origUpper = orig.upper, rewrittenUpper = origUpper.accept(this);
                if (origArg === rewrittenArg && origLower === rewrittenLower && origUpper === rewrittenUpper)
                    return orig;
                return new data.SQBetweenExpr(rewrittenArg, rewrittenLower, rewrittenUpper);
            };
            SQExprRewriter.prototype.visitIn = function (orig) {
                var origArgs = orig.args, rewrittenArgs = this.rewriteAll(origArgs), origValues = orig.values, rewrittenValues;
                for (var i = 0, len = origValues.length; i < len; i++) {
                    var origValueTuple = origValues[i], rewrittenValueTuple = this.rewriteAll(origValueTuple);
                    if (origValueTuple !== rewrittenValueTuple && !rewrittenValues)
                        rewrittenValues = ArrayExtensions.take(origValues, i);
                    if (rewrittenValues)
                        rewrittenValues.push(rewrittenValueTuple);
                }
                if (origArgs === rewrittenArgs && !rewrittenValues)
                    return orig;
                return new data.SQInExpr(rewrittenArgs, rewrittenValues || origValues);
            };
            SQExprRewriter.prototype.rewriteAll = function (origExprs) {
                debug.assertValue(origExprs, 'origExprs');
                var rewrittenResult;
                for (var i = 0, len = origExprs.length; i < len; i++) {
                    var origExpr = origExprs[i], rewrittenExpr = origExpr.accept(this);
                    if (origExpr !== rewrittenExpr && !rewrittenResult)
                        rewrittenResult = ArrayExtensions.take(origExprs, i);
                    if (rewrittenResult)
                        rewrittenResult.push(rewrittenExpr);
                }
                return rewrittenResult || origExprs;
            };
            SQExprRewriter.prototype.visitOr = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQOrExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitCompare = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQCompareExpr(orig.comparison, rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitContains = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQContainsExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitExists = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQExistsExpr(rewrittenArg);
            };
            SQExprRewriter.prototype.visitNot = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQNotExpr(rewrittenArg);
            };
            SQExprRewriter.prototype.visitStartsWith = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQStartsWithExpr(rewrittenLeft, rewrittenRight);
            };
            SQExprRewriter.prototype.visitConstant = function (expr) {
                return expr;
            };
            SQExprRewriter.prototype.visitDateSpan = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQDateSpanExpr(orig.unit, rewrittenArg);
            };
            SQExprRewriter.prototype.visitDateAdd = function (orig) {
                var origArg = orig.arg, rewrittenArg = origArg.accept(this);
                if (origArg === rewrittenArg)
                    return orig;
                return new data.SQDateAddExpr(orig.unit, orig.amount, rewrittenArg);
            };
            SQExprRewriter.prototype.visitNow = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitDefaultValue = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitAnyValue = function (orig) {
                return orig;
            };
            SQExprRewriter.prototype.visitArithmetic = function (orig) {
                var origLeft = orig.left, rewrittenLeft = origLeft.accept(this), origRight = orig.right, rewrittenRight = origRight.accept(this);
                if (origLeft === rewrittenLeft && origRight === rewrittenRight)
                    return orig;
                return new data.SQArithmeticExpr(rewrittenLeft, rewrittenRight, orig.operator);
            };
            SQExprRewriter.prototype.visitScopedEval = function (orig) {
                var origExpression = orig.expression, rewrittenExpression = origExpression.accept(this), origScope = orig.scope, rewrittenScope = this.rewriteAll(origScope);
                if (origExpression === rewrittenExpression && origScope === rewrittenScope)
                    return orig;
                return new data.SQScopedEvalExpr(rewrittenExpression, rewrittenScope);
            };
            SQExprRewriter.prototype.visitFillRule = function (orig) {
                var origInput = orig.input, rewrittenInput = origInput.accept(this);
                var origRule = orig.rule;
                var origGradient2 = origRule.linearGradient2, rewrittenGradient2 = origGradient2;
                if (origGradient2) {
                    rewrittenGradient2 = this.visitLinearGradient2(origGradient2);
                }
                var origGradient3 = origRule.linearGradient3, rewrittenGradient3 = origGradient3;
                if (origGradient3) {
                    rewrittenGradient3 = this.visitLinearGradient3(origGradient3);
                }
                if (origInput !== rewrittenInput ||
                    origGradient2 !== rewrittenGradient2 ||
                    origGradient3 !== rewrittenGradient3) {
                    var rewrittenRule = {};
                    if (rewrittenGradient2)
                        rewrittenRule.linearGradient2 = rewrittenGradient2;
                    if (rewrittenGradient3)
                        rewrittenRule.linearGradient3 = rewrittenGradient3;
                    return new data.SQFillRuleExpr(rewrittenInput, rewrittenRule);
                }
                return orig;
            };
            SQExprRewriter.prototype.visitLinearGradient2 = function (origGradient2) {
                debug.assertValue(origGradient2, 'origGradient2');
                var origMin = origGradient2.min, rewrittenMin = this.visitFillRuleStop(origMin), origMax = origGradient2.max, rewrittenMax = this.visitFillRuleStop(origMax);
                if (origMin !== rewrittenMin || origMax !== rewrittenMax) {
                    return {
                        min: rewrittenMin,
                        max: rewrittenMax,
                    };
                }
                return origGradient2;
            };
            SQExprRewriter.prototype.visitLinearGradient3 = function (origGradient3) {
                debug.assertValue(origGradient3, 'origGradient3');
                var origMin = origGradient3.min, rewrittenMin = this.visitFillRuleStop(origMin), origMid = origGradient3.mid, rewrittenMid = this.visitFillRuleStop(origMid), origMax = origGradient3.max, rewrittenMax = this.visitFillRuleStop(origMax);
                if (origMin !== rewrittenMin || origMid !== rewrittenMid || origMax !== rewrittenMax) {
                    return {
                        min: rewrittenMin,
                        mid: rewrittenMid,
                        max: rewrittenMax,
                    };
                }
                return origGradient3;
            };
            SQExprRewriter.prototype.visitFillRuleStop = function (stop) {
                debug.assertValue(stop, 'stop');
                var origColor = stop.color, rewrittenColor = stop.color.accept(this);
                var origValue = stop.value, rewrittenValue = origValue;
                if (origValue)
                    rewrittenValue = origValue.accept(this);
                if (origColor !== rewrittenColor || origValue !== rewrittenValue) {
                    var rewrittenStop = {
                        color: rewrittenColor
                    };
                    if (rewrittenValue)
                        rewrittenStop.value = rewrittenValue;
                    return rewrittenStop;
                }
                return stop;
            };
            SQExprRewriter.prototype.visitResourcePackageItem = function (orig) {
                return orig;
            };
            return SQExprRewriter;
        }());
        data.SQExprRewriter = SQExprRewriter;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Responsible for writing equality comparisons against a field to an SQInExpr. */
        var EqualsToInRewriter;
        (function (EqualsToInRewriter) {
            function run(expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(new Rewriter());
            }
            EqualsToInRewriter.run = run;
            var Rewriter = (function (_super) {
                __extends(Rewriter, _super);
                function Rewriter() {
                    _super.call(this);
                }
                Rewriter.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== data.QueryComparisonKind.Equal)
                        return this.visitUnsupported(expr);
                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))
                        return this.visitUnsupported(expr);
                    var leftIsComparand = this.isComparand(expr.left);
                    var rightIsComparand = this.isComparand(expr.right);
                    if (leftIsComparand === rightIsComparand)
                        return this.visitUnsupported(expr);
                    var operand = leftIsComparand
                        ? expr.left
                        : expr.right;
                    var value = leftIsComparand
                        ? expr.right
                        : expr.left;
                    var current = this.current;
                    if (!current) {
                        return data.SQExprBuilder.inExpr([operand], [[value]]);
                    }
                    current.add(operand, value);
                    return expr;
                };
                Rewriter.prototype.visitOr = function (expr) {
                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))
                        return this.visitUnsupported(expr);
                    var current;
                    if (!this.current) {
                        current = this.current = new InBuilder();
                    }
                    expr.left.accept(this);
                    expr.right.accept(this);
                    if (current) {
                        this.current = null;
                        return current.complete() || expr;
                    }
                    return expr;
                };
                Rewriter.prototype.visitAnd = function (expr) {
                    if (!this.isSupported(expr.left) || !this.isSupported(expr.right))
                        return this.visitUnsupported(expr);
                    var current = this.current;
                    if (current) {
                        // NOTE: Composite keys are not supported by this algorithm.
                        current.cancel();
                        return expr;
                    }
                    return _super.prototype.visitAnd.call(this, expr);
                };
                Rewriter.prototype.visitUnsupported = function (expr) {
                    var current = this.current;
                    if (current)
                        current.cancel();
                    return expr;
                };
                Rewriter.prototype.isSupported = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return expr instanceof data.SQCompareExpr
                        || expr instanceof data.SQColumnRefExpr
                        || expr instanceof data.SQConstantExpr
                        || expr instanceof data.SQHierarchyLevelExpr
                        || expr instanceof data.SQOrExpr
                        || expr instanceof data.SQAndExpr;
                };
                Rewriter.prototype.isComparand = function (expr) {
                    return expr instanceof data.SQColumnRefExpr
                        || expr instanceof data.SQHierarchyLevelExpr;
                };
                return Rewriter;
            }(data.SQExprRewriter));
            var InBuilder = (function () {
                function InBuilder() {
                }
                InBuilder.prototype.add = function (operand, value) {
                    debug.assertValue(operand, 'operand');
                    debug.assertValue(value, 'value');
                    if (this.cancelled)
                        return;
                    if (this.operand && !data.SQExpr.equals(operand, this.operand)) {
                        this.cancel();
                        return;
                    }
                    this.operand = operand;
                    var values = this.values;
                    if (!values)
                        values = this.values = [];
                    values.push(value);
                };
                InBuilder.prototype.cancel = function () {
                    this.cancelled = true;
                };
                InBuilder.prototype.complete = function () {
                    if (this.cancelled || !this.operand)
                        return;
                    return data.SQExprBuilder.inExpr([this.operand], _.map(this.values, function (v) { return [v]; }));
                };
                return InBuilder;
            }());
        })(EqualsToInRewriter = data.EqualsToInRewriter || (data.EqualsToInRewriter = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQExprConverter;
        (function (SQExprConverter) {
            function asScopeIdsContainer(filter, fieldSQExprs) {
                debug.assertValue(filter, 'filter');
                debug.assertValue(fieldSQExprs, 'fieldSQExprs');
                debug.assert(fieldSQExprs.length > 0, 'There should be at least 1 field expression.');
                var filterItems = filter.conditions();
                debug.assert(filterItems.length === 1, 'There should be exactly 1 filter expression.');
                var filterItem = filterItems[0];
                if (filterItem) {
                    var visitor = new FilterScopeIdsCollectorVisitor(fieldSQExprs);
                    if (filterItem.accept(visitor))
                        return visitor.getResult();
                }
            }
            SQExprConverter.asScopeIdsContainer = asScopeIdsContainer;
            /** Gets a comparand value from the given DataViewScopeIdentity. */
            function getFirstComparandValue(identity) {
                debug.assertValue(identity, 'identity');
                var comparandExpr = identity.expr.accept(new FindComparandVisitor());
                if (comparandExpr)
                    return comparandExpr.value;
            }
            SQExprConverter.getFirstComparandValue = getFirstComparandValue;
        })(SQExprConverter = data.SQExprConverter || (data.SQExprConverter = {}));
        /** Collect filter values from simple semantic filter that is similar to 'is any of' or 'is not any of', getResult() returns a collection of scopeIds.**/
        var FilterScopeIdsCollectorVisitor = (function (_super) {
            __extends(FilterScopeIdsCollectorVisitor, _super);
            function FilterScopeIdsCollectorVisitor(fieldSQExprs) {
                _super.call(this);
                this.isRoot = true;
                this.isNot = false;
                this.keyExprsCount = null;
                this.valueExprs = [];
                // Need to drop the entitylet before create the scopeIdentity. The ScopeIdentity created on the client is used to
                // compare the ScopeIdentity came from the server. But server doesn't have the entity variable concept, so we will
                // need to drop it in order to use JsonComparer.
                this.fieldExprs = [];
                for (var _i = 0, fieldSQExprs_1 = fieldSQExprs; _i < fieldSQExprs_1.length; _i++) {
                    var field = fieldSQExprs_1[_i];
                    this.fieldExprs.push(data.SQExprBuilder.removeEntityVariables(field));
                }
            }
            FilterScopeIdsCollectorVisitor.prototype.getResult = function () {
                debug.assert(this.fieldExprs.length > 0, 'fieldExprs has at least one fieldExpr');
                var valueExprs = this.valueExprs, scopeIds = [];
                var valueCount = this.keyExprsCount || 1;
                for (var startIndex = 0, endIndex = valueCount, len = valueExprs.length; startIndex < len && endIndex <= len;) {
                    var values = valueExprs.slice(startIndex, endIndex);
                    var scopeId = FilterScopeIdsCollectorVisitor.getScopeIdentity(this.fieldExprs, values);
                    if (!jsCommon.ArrayExtensions.isInArray(scopeIds, scopeId, powerbi.DataViewScopeIdentity.equals))
                        scopeIds.push(scopeId);
                    startIndex += valueCount;
                    endIndex += valueCount;
                }
                return {
                    isNot: this.isNot,
                    scopeIds: scopeIds,
                };
            };
            FilterScopeIdsCollectorVisitor.getScopeIdentity = function (fieldExprs, valueExprs) {
                debug.assert(valueExprs.length > 0, 'valueExprs has at least one valueExpr');
                debug.assert(valueExprs.length === fieldExprs.length, 'fieldExpr and valueExpr count should match');
                var compoundSQExpr;
                for (var i = 0, len = fieldExprs.length; i < len; i++) {
                    var equalsExpr = data.SQExprBuilder.equal(fieldExprs[i], valueExprs[i]);
                    if (!compoundSQExpr)
                        compoundSQExpr = equalsExpr;
                    else
                        compoundSQExpr = data.SQExprBuilder.and(compoundSQExpr, equalsExpr);
                }
                return data.createDataViewScopeIdentity(compoundSQExpr);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitOr = function (expr) {
                if (this.keyExprsCount !== null)
                    return this.unsupportedSQExpr();
                this.isRoot = false;
                return expr.left.accept(this) && expr.right.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitNot = function (expr) {
                if (!this.isRoot)
                    return this.unsupportedSQExpr();
                this.isNot = true;
                return expr.arg.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitConstant = function (expr) {
                if (this.isRoot && expr.type.primitiveType === powerbi.PrimitiveType.Null)
                    return this.unsupportedSQExpr();
                this.valueExprs.push(expr);
                return true;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitCompare = function (expr) {
                if (this.keyExprsCount !== null)
                    return this.unsupportedSQExpr();
                this.isRoot = false;
                if (expr.comparison !== data.QueryComparisonKind.Equal)
                    return this.unsupportedSQExpr();
                return expr.left.accept(this) && expr.right.accept(this);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitIn = function (expr) {
                this.keyExprsCount = 0;
                var result;
                this.isRoot = false;
                for (var _i = 0, _a = expr.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    result = arg.accept(this);
                    if (!result)
                        return this.unsupportedSQExpr();
                    this.keyExprsCount++;
                }
                if (this.keyExprsCount !== this.fieldExprs.length)
                    return this.unsupportedSQExpr();
                var values = expr.values;
                for (var _b = 0, values_1 = values; _b < values_1.length; _b++) {
                    var valueTuple = values_1[_b];
                    var jlen = valueTuple.length;
                    debug.assert(jlen === this.keyExprsCount, "keys count and values count should match");
                    for (var _c = 0, valueTuple_1 = valueTuple; _c < valueTuple_1.length; _c++) {
                        var value = valueTuple_1[_c];
                        result = value.accept(this);
                        if (!result)
                            return this.unsupportedSQExpr();
                    }
                }
                return result;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitColumnRef = function (expr) {
                if (this.isRoot)
                    return this.unsupportedSQExpr();
                var fixedExpr = data.SQExprBuilder.removeEntityVariables(expr);
                if (this.keyExprsCount !== null)
                    return data.SQExpr.equals(this.fieldExprs[this.keyExprsCount], fixedExpr);
                return data.SQExpr.equals(this.fieldExprs[0], fixedExpr);
            };
            FilterScopeIdsCollectorVisitor.prototype.visitDefaultValue = function (expr) {
                if (this.isRoot || this.keyExprsCount !== null)
                    return this.unsupportedSQExpr();
                this.valueExprs.push(expr);
                return true;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitAnyValue = function (expr) {
                if (this.isRoot || this.keyExprsCount !== null)
                    return this.unsupportedSQExpr();
                this.valueExprs.push(expr);
                return true;
            };
            FilterScopeIdsCollectorVisitor.prototype.visitDefault = function (expr) {
                return this.unsupportedSQExpr();
            };
            FilterScopeIdsCollectorVisitor.prototype.unsupportedSQExpr = function () {
                return false;
            };
            return FilterScopeIdsCollectorVisitor;
        }(data.DefaultSQExprVisitor));
        var FindComparandVisitor = (function (_super) {
            __extends(FindComparandVisitor, _super);
            function FindComparandVisitor() {
                _super.apply(this, arguments);
            }
            FindComparandVisitor.prototype.visitAnd = function (expr) {
                return expr.left.accept(this) || expr.right.accept(this);
            };
            FindComparandVisitor.prototype.visitCompare = function (expr) {
                if (expr.comparison === data.QueryComparisonKind.Equal) {
                    if (expr.right instanceof data.SQConstantExpr)
                        return expr.right;
                    if (expr.left instanceof data.SQConstantExpr)
                        return expr.left;
                }
            };
            return FindComparandVisitor;
        }(data.DefaultSQExprVisitor));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /** Recognizes DataViewScopeIdentity expression trees to extract comparison keys. */
        var ScopeIdentityExtractor;
        (function (ScopeIdentityExtractor) {
            function getKeys(expr) {
                var extractor = new ScopeIdExtractorImpl();
                expr.accept(extractor);
                if (extractor.malformed)
                    return null;
                return ArrayExtensions.emptyToNull(extractor.keys);
            }
            ScopeIdentityExtractor.getKeys = getKeys;
            function getInExpr(expr) {
                var extractor = new ScopeIdExtractorImpl();
                expr.accept(extractor);
                if (extractor.malformed)
                    return;
                var keys = ArrayExtensions.emptyToNull(extractor.keys);
                var keyValues = ArrayExtensions.emptyToNull(extractor.values);
                if (keys && keyValues)
                    return data.SQExprBuilder.inExpr(keys, [keyValues]);
            }
            ScopeIdentityExtractor.getInExpr = getInExpr;
            /**
             * Recognizes expressions of the form:
             * 1) Equals(ColRef, Constant)
             * 2) And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2))
             * or And(And(Equals(ColRef1, Constant1), Equals(ColRef2, Constant2)), Equals(ColRef3, Constant3)) etc..
             */
            var ScopeIdExtractorImpl = (function (_super) {
                __extends(ScopeIdExtractorImpl, _super);
                function ScopeIdExtractorImpl() {
                    _super.apply(this, arguments);
                    this.keys = [];
                    this.values = [];
                }
                ScopeIdExtractorImpl.prototype.visitAnd = function (expr) {
                    expr.left.accept(this);
                    expr.right.accept(this);
                };
                ScopeIdExtractorImpl.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== data.QueryComparisonKind.Equal) {
                        this.visitDefault(expr);
                        return;
                    }
                    debug.assert(expr.left instanceof data.SQExpr && expr.right instanceof data.SQConstantExpr, 'invalid compare expr operands');
                    expr.left.accept(this);
                    expr.right.accept(this);
                };
                ScopeIdExtractorImpl.prototype.visitColumnRef = function (expr) {
                    this.keys.push(expr);
                };
                ScopeIdExtractorImpl.prototype.visitHierarchyLevel = function (expr) {
                    this.keys.push(expr);
                };
                ScopeIdExtractorImpl.prototype.visitConstant = function (expr) {
                    this.values.push(expr);
                };
                ScopeIdExtractorImpl.prototype.visitArithmetic = function (expr) {
                    this.keys.push(expr);
                };
                ScopeIdExtractorImpl.prototype.visitDefault = function (expr) {
                    this.malformed = true;
                };
                return ScopeIdExtractorImpl;
            }(data.DefaultSQExprVisitor));
        })(ScopeIdentityExtractor = data.ScopeIdentityExtractor || (data.ScopeIdentityExtractor = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var PrimitiveValueEncoding;
        (function (PrimitiveValueEncoding) {
            var SingleQuoteRegex = /'/g;
            function decimal(value) {
                debug.assertValue(value, 'value');
                return value + 'M';
            }
            PrimitiveValueEncoding.decimal = decimal;
            function double(value) {
                debug.assertValue(value, 'value');
                return value + 'D';
            }
            PrimitiveValueEncoding.double = double;
            function integer(value) {
                debug.assertValue(value, 'value');
                return value + 'L';
            }
            PrimitiveValueEncoding.integer = integer;
            function dateTime(value) {
                debug.assertValue(value, 'value');
                // Currently, server doesn't support timezone. All date time data on the server don't have time zone information.
                // So, when we construct a dateTime object on the client, we will need to ignor user's time zone and force it to be UTC time.
                // When we subtract the timeZone offset, the date time object will remain the same value as you entered but dropped the local timeZone.
                var date = new Date(value.getTime() - (value.getTimezoneOffset() * 60000));
                var dateTimeString = date.toISOString();
                // If it ends with Z, we want to get rid of it, because with trailing Z, it will assume the dateTime is UTC, but we don't want any timeZone information, so
                // we will drop it.
                // Also, we need to add Prefix and Suffix to match the dsr value format for dateTime object.
                if (jsCommon.StringExtensions.endsWith(dateTimeString, 'Z'))
                    dateTimeString = dateTimeString.substr(0, dateTimeString.length - 1);
                return "datetime'" + dateTimeString + "'";
            }
            PrimitiveValueEncoding.dateTime = dateTime;
            function text(value) {
                debug.assertValue(value, 'value');
                return "'" + value.replace(SingleQuoteRegex, "''") + "'";
            }
            PrimitiveValueEncoding.text = text;
            function nullEncoding() {
                return 'null';
            }
            PrimitiveValueEncoding.nullEncoding = nullEncoding;
            function boolean(value) {
                return value ? 'true' : 'false';
            }
            PrimitiveValueEncoding.boolean = boolean;
        })(PrimitiveValueEncoding = data.PrimitiveValueEncoding || (data.PrimitiveValueEncoding = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var Agg = powerbi.data.QueryAggregateFunction;
        function createSQAggregationOperations(datetimeMinMaxSupported) {
            return new SQAggregationOperations(datetimeMinMaxSupported);
        }
        data.createSQAggregationOperations = createSQAggregationOperations;
        var SQAggregationOperations = (function () {
            function SQAggregationOperations(datetimeMinMaxSupported) {
                this.datetimeMinMaxSupported = datetimeMinMaxSupported;
            }
            SQAggregationOperations.prototype.getSupportedAggregates = function (expr, schema, targetTypes) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                debug.assertAnyValue(targetTypes, 'targetTypes');
                var metadata = getMetadataForUnderlyingType(expr, schema);
                // don't use expr.validate as validate will be using this function and we end up in a recursive loop
                if (!metadata)
                    return [];
                var valueType = metadata.type, fieldKind = metadata.kind, isPropertyIdentity = metadata.idOnEntityKey;
                if (!valueType)
                    return [];
                // Cannot aggregate on model measures
                if (fieldKind === 1 /* Measure */)
                    return [];
                if (valueType.numeric || valueType.integer) {
                    var aggregates_1 = [Agg.Sum, Agg.Avg, Agg.Min, Agg.Max, Agg.Count, Agg.CountNonNull, Agg.StandardDeviation, Agg.Variance];
                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                    var currentSchema = schema.schema(fieldExprItem.schema);
                    if (currentSchema.capabilities.supportsMedian)
                        aggregates_1.push(Agg.Median);
                    return aggregates_1;
                }
                var aggregates = [];
                // Min/Max of DateTime
                if (this.datetimeMinMaxSupported &&
                    valueType.dateTime &&
                    (_.isEmpty(targetTypes) || powerbi.ValueType.isCompatibleTo(valueType, targetTypes))) {
                    aggregates.push(Agg.Min);
                    aggregates.push(Agg.Max);
                }
                // The supported aggregation types for an identity field are restricted to 'Count Non-Null' (e.g. for the field well aggregation options)
                // but a valid semantic query can return a less-restricted aggregation option which we should honor. (e.g. this results from Q&A)
                var distinctCountAggExists = data.SQExprInfo.getAggregate(expr) === Agg.Count;
                if (!(isPropertyIdentity && !distinctCountAggExists))
                    aggregates.push(Agg.Count);
                aggregates.push(Agg.CountNonNull);
                return aggregates;
            };
            SQAggregationOperations.prototype.isSupportedAggregate = function (expr, schema, aggregate, targetTypes) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                var supportedAggregates = this.getSupportedAggregates(expr, schema, targetTypes);
                return _.contains(supportedAggregates, aggregate);
            };
            SQAggregationOperations.prototype.createExprWithAggregate = function (expr, schema, aggregateNonNumericFields, targetTypes, preferredAggregate) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                var aggregate;
                if (preferredAggregate != null && this.isSupportedAggregate(expr, schema, preferredAggregate, targetTypes)) {
                    aggregate = preferredAggregate;
                }
                else {
                    aggregate = expr.getDefaultAggregate(schema, aggregateNonNumericFields);
                }
                if (aggregate !== undefined)
                    expr = data.SQExprBuilder.aggregate(expr, aggregate);
                return expr;
            };
            return SQAggregationOperations;
        }());
        function getMetadataForUnderlyingType(expr, schema) {
            // Unwrap the aggregate (if the expr has one), and look at the underlying type.
            var metadata = data.SQExprBuilder.removeAggregate(expr).getMetadata(schema);
            if (!metadata)
                metadata = expr.getMetadata(schema);
            return metadata;
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQHierarchyExprUtils;
        (function (SQHierarchyExprUtils) {
            function getConceptualHierarchyLevelFromExpr(conceptualSchema, fieldExpr) {
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                var hierarchyLevel = fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr;
                if (hierarchyLevel)
                    return SQHierarchyExprUtils.getConceptualHierarchyLevel(conceptualSchema, fieldExprItem.schema, fieldExprItem.entity, hierarchyLevel.name, hierarchyLevel.level);
            }
            SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr = getConceptualHierarchyLevelFromExpr;
            function getConceptualHierarchyLevel(conceptualSchema, schemaName, entity, hierarchy, hierarchyLevel) {
                var schema = conceptualSchema.schema(schemaName);
                var conceptualHierarchy = schema.findHierarchy(entity, hierarchy);
                if (conceptualHierarchy) {
                    return conceptualHierarchy.levels.withName(hierarchyLevel);
                }
            }
            SQHierarchyExprUtils.getConceptualHierarchyLevel = getConceptualHierarchyLevel;
            function getConceptualHierarchy(sqExpr, federatedSchema) {
                if (sqExpr instanceof data.SQHierarchyExpr) {
                    var hierarchy = sqExpr;
                    if (sqExpr.arg instanceof data.SQEntityExpr) {
                        var entityExpr = sqExpr.arg;
                        return federatedSchema
                            .schema(entityExpr.schema)
                            .findHierarchy(entityExpr.entity, hierarchy.hierarchy);
                    }
                    else if (sqExpr.arg instanceof data.SQPropertyVariationSourceExpr) {
                        var variationExpr = sqExpr.arg;
                        var sourceEntityExpr = variationExpr.arg;
                        return federatedSchema
                            .schema(sourceEntityExpr.schema)
                            .findHierarchyByVariation(sourceEntityExpr.entity, variationExpr.property, variationExpr.name, hierarchy.hierarchy);
                    }
                }
            }
            SQHierarchyExprUtils.getConceptualHierarchy = getConceptualHierarchy;
            function expandExpr(schema, expr, suppressHierarchyLevelExpansion) {
                return SQExprHierarchyToHierarchyLevelConverter.convert(expr, schema) ||
                    SQExprVariationConverter.expand(expr, schema) ||
                    // If we are calling expandExpr from suppressHierarchyLevelExpansion, we should not expand the hierarchylevels
                    (!suppressHierarchyLevelExpansion && SQExprHierarchyLevelConverter.expand(expr, schema)) ||
                    expr;
            }
            SQHierarchyExprUtils.expandExpr = expandExpr;
            function isHierarchyOrVariation(schema, expr) {
                if (expr instanceof data.SQHierarchyExpr || expr instanceof data.SQHierarchyLevelExpr)
                    return true;
                var conceptualProperty = expr.getConceptualProperty(schema);
                if (conceptualProperty) {
                    var column = conceptualProperty.column;
                    if (column && column.variations && column.variations.length > 0)
                        return true;
                }
                return false;
            }
            SQHierarchyExprUtils.isHierarchyOrVariation = isHierarchyOrVariation;
            // Return column reference expression for hierarchy level expression.
            function getSourceVariationExpr(hierarchyLevelExpr) {
                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);
                if (fieldExprPattern.columnHierarchyLevelVariation) {
                    var entity = data.SQExprBuilder.entity(fieldExprPattern.columnHierarchyLevelVariation.source.schema, fieldExprPattern.columnHierarchyLevelVariation.source.entity);
                    return data.SQExprBuilder.columnRef(entity, fieldExprPattern.columnHierarchyLevelVariation.source.name);
                }
            }
            SQHierarchyExprUtils.getSourceVariationExpr = getSourceVariationExpr;
            // Return hierarchy expression for hierarchy level expression.
            function getSourceHierarchy(hierarchyLevelExpr) {
                var fieldExprPattern = data.SQExprConverter.asFieldPattern(hierarchyLevelExpr);
                var hierarchyLevel = fieldExprPattern.hierarchyLevel;
                if (hierarchyLevel) {
                    var entity = data.SQExprBuilder.entity(hierarchyLevel.schema, hierarchyLevel.entity, hierarchyLevel.entityVar);
                    return data.SQExprBuilder.hierarchy(entity, hierarchyLevel.name);
                }
            }
            SQHierarchyExprUtils.getSourceHierarchy = getSourceHierarchy;
            function getHierarchySourceAsVariationSource(hierarchyLevelExpr) {
                // Make sure the hierarchy level source is a hierarchy
                if (!(hierarchyLevelExpr.arg instanceof data.SQHierarchyExpr))
                    return;
                // Check if the hierarchy source if a variation
                var hierarchyRef = hierarchyLevelExpr.arg;
                if (hierarchyRef.arg instanceof data.SQPropertyVariationSourceExpr)
                    return hierarchyRef.arg;
            }
            SQHierarchyExprUtils.getHierarchySourceAsVariationSource = getHierarchySourceAsVariationSource;
            /**
            * Returns true if firstExpr and secondExpr are levels in the same hierarchy and firstExpr is before secondExpr in allLevels.
            */
            function areHierarchyLevelsOrdered(allLevels, firstExpr, secondExpr) {
                // Validate that both items hierarchy levels
                if (!(firstExpr instanceof data.SQHierarchyLevelExpr) || !(secondExpr instanceof data.SQHierarchyLevelExpr))
                    return false;
                var firstLevel = firstExpr;
                var secondLevel = secondExpr;
                // Validate that both items belong to the same hierarchy
                if (!data.SQExpr.equals(firstLevel.arg, secondLevel.arg))
                    return false;
                // Determine the order
                var firstIndex = data.SQExprUtils.indexOfExpr(allLevels, firstLevel);
                var secondIndex = data.SQExprUtils.indexOfExpr(allLevels, secondLevel);
                return firstIndex !== -1 && secondIndex !== -1 && firstIndex < secondIndex;
            }
            SQHierarchyExprUtils.areHierarchyLevelsOrdered = areHierarchyLevelsOrdered;
            /**
             * Given an ordered set of levels and an ordered subset of those levels, returns the index where
             * expr should be inserted into the subset to maintain the correct order.
             */
            function getInsertionIndex(allLevels, orderedSubsetOfLevels, expr) {
                var insertIndex = 0;
                // Loop through the supplied levels until the insertion would no longer be in the correct order
                while (insertIndex < orderedSubsetOfLevels.length &&
                    areHierarchyLevelsOrdered(allLevels, orderedSubsetOfLevels[insertIndex], expr)) {
                    insertIndex++;
                }
                return insertIndex;
            }
            SQHierarchyExprUtils.getInsertionIndex = getInsertionIndex;
        })(SQHierarchyExprUtils = data.SQHierarchyExprUtils || (data.SQHierarchyExprUtils = {}));
        var SQExprHierarchyToHierarchyLevelConverter;
        (function (SQExprHierarchyToHierarchyLevelConverter) {
            function convert(sqExpr, federatedSchema) {
                debug.assertValue(sqExpr, 'sqExpr');
                debug.assertValue(federatedSchema, 'federatedSchema');
                if (sqExpr instanceof data.SQHierarchyExpr) {
                    var hierarchyExpr = sqExpr;
                    var conceptualHierarchy = SQHierarchyExprUtils.getConceptualHierarchy(hierarchyExpr, federatedSchema);
                    if (conceptualHierarchy)
                        return _.map(conceptualHierarchy.levels, function (hierarchyLevel) { return data.SQExprBuilder.hierarchyLevel(sqExpr, hierarchyLevel.name); });
                }
            }
            SQExprHierarchyToHierarchyLevelConverter.convert = convert;
        })(SQExprHierarchyToHierarchyLevelConverter = data.SQExprHierarchyToHierarchyLevelConverter || (data.SQExprHierarchyToHierarchyLevelConverter = {}));
        var SQExprHierarchyLevelConverter;
        (function (SQExprHierarchyLevelConverter) {
            function expand(expr, schema) {
                debug.assertValue(expr, 'sqExpr');
                debug.assertValue(schema, 'federatedSchema');
                var exprs = [];
                if (expr instanceof data.SQHierarchyLevelExpr) {
                    var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                    if (fieldExpr.hierarchyLevel) {
                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                        var hierarchy = schema
                            .schema(fieldExprItem.schema)
                            .findHierarchy(fieldExprItem.entity, fieldExpr.hierarchyLevel.name);
                        if (hierarchy) {
                            var hierarchyLevels = hierarchy.levels;
                            for (var _i = 0, hierarchyLevels_2 = hierarchyLevels; _i < hierarchyLevels_2.length; _i++) {
                                var hierarchyLevel = hierarchyLevels_2[_i];
                                if (hierarchyLevel.name === fieldExpr.hierarchyLevel.level) {
                                    exprs.push(expr);
                                    break;
                                }
                                else
                                    exprs.push(data.SQExprBuilder.hierarchyLevel(data.SQExprBuilder.hierarchy(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), hierarchy.name), hierarchyLevel.name));
                            }
                        }
                    }
                }
                if (!_.isEmpty(exprs))
                    return exprs;
            }
            SQExprHierarchyLevelConverter.expand = expand;
        })(SQExprHierarchyLevelConverter || (SQExprHierarchyLevelConverter = {}));
        var SQExprVariationConverter;
        (function (SQExprVariationConverter) {
            function expand(expr, schema) {
                debug.assertValue(expr, 'sqExpr');
                debug.assertValue(schema, 'federatedSchema');
                var exprs;
                var conceptualProperty = expr.getConceptualProperty(schema);
                if (conceptualProperty) {
                    var column = conceptualProperty.column;
                    if (column && column.variations && column.variations.length > 0) {
                        var variations = column.variations;
                        // for SU11, we support only one variation
                        debug.assert(variations.length === 1, "variations.length");
                        var variation = variations[0];
                        var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                        exprs = [];
                        if (variation.defaultHierarchy) {
                            var hierarchyExpr = data.SQExprBuilder.hierarchy(data.SQExprBuilder.propertyVariationSource(data.SQExprBuilder.entity(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.entityVar), variation.name, conceptualProperty.name), variation.defaultHierarchy.name);
                            for (var _i = 0, _a = variation.defaultHierarchy.levels; _i < _a.length; _i++) {
                                var level = _a[_i];
                                exprs.push(data.SQExprBuilder.hierarchyLevel(hierarchyExpr, level.name));
                            }
                        }
                    }
                }
                return exprs;
            }
            SQExprVariationConverter.expand = expand;
        })(SQExprVariationConverter || (SQExprVariationConverter = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        ;
        var SQExprGroupUtils;
        (function (SQExprGroupUtils) {
            /** Group all projections. Eacch group can consist of either a single property, or a collection of hierarchy items. */
            function groupExprs(schema, exprs) {
                var groups = [];
                for (var i = 0, len = exprs.length; i < len; i++) {
                    var expr = exprs[i];
                    debug.assertValue(expr, "Expression not found");
                    if (!(expr instanceof data.SQHierarchyLevelExpr)) {
                        groups.push({ expr: expr, children: null, selectQueryIndex: i });
                    }
                    else {
                        addChildToGroup(schema, groups, expr, i);
                    }
                }
                return groups;
            }
            SQExprGroupUtils.groupExprs = groupExprs;
            function addChildToGroup(schema, groups, expr, selectQueryIndex) {
                // shouldAddExpressionToNewGroup is used to control whether we should add the passed expr to 
                // a new Group or to the last Group
                var shouldAddExpressionToNewGroup = true;
                var exprSource = data.SQHierarchyExprUtils.getSourceVariationExpr(expr) || data.SQHierarchyExprUtils.getSourceHierarchy(expr);
                var lastGroup = _.last(groups);
                // The relevant group is always the last added. If it has the same source hierarchy,
                // and is properly ordered within that hierarchy, we will need to add to this group.
                if (lastGroup && lastGroup.children && data.SQExpr.equals(lastGroup.expr, exprSource)) {
                    var expandedExpr = data.SQHierarchyExprUtils.expandExpr(schema, expr.arg);
                    if (expandedExpr instanceof Array) {
                        var allHierarchyLevels = expandedExpr;
                        shouldAddExpressionToNewGroup = !data.SQHierarchyExprUtils.areHierarchyLevelsOrdered(allHierarchyLevels, _.last(lastGroup.children), expr);
                    }
                }
                if (shouldAddExpressionToNewGroup)
                    // Use the Sourcevariation as the expression for the group.
                    groups.push({ expr: exprSource, children: [expr], selectQueryIndex: selectQueryIndex });
                else {
                    debug.assertValue(lastGroup, 'There should be a group to add the variation to');
                    debug.assertValue(lastGroup.children, 'The group should have children to add the variation to');
                    lastGroup.children.push(expr);
                }
            }
        })(SQExprGroupUtils = data.SQExprGroupUtils || (data.SQExprGroupUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var StringExtensions = jsCommon.StringExtensions;
        /** Represents an immutable expression within a SemanticQuery. */
        var SQExpr = (function () {
            function SQExpr(kind) {
                debug.assertValue(kind, 'kind');
                this._kind = kind;
            }
            SQExpr.equals = function (x, y, ignoreCase) {
                return SQExprEqualityVisitor.run(x, y, ignoreCase);
            };
            SQExpr.prototype.validate = function (schema, aggrUtils, errors) {
                var validator = new SQExprValidationVisitor(schema, aggrUtils, errors);
                this.accept(validator);
                return validator.errors;
            };
            SQExpr.prototype.accept = function (visitor, arg) {
                debug.assertFail('abstract method');
                return;
            };
            Object.defineProperty(SQExpr.prototype, "kind", {
                get: function () {
                    return this._kind;
                },
                enumerable: true,
                configurable: true
            });
            SQExpr.isColumn = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 1 /* ColumnRef */;
            };
            SQExpr.isConstant = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 16 /* Constant */;
            };
            SQExpr.isEntity = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 0 /* Entity */;
            };
            SQExpr.isHierarchy = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 5 /* Hierarchy */;
            };
            SQExpr.isHierarchyLevel = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 6 /* HierarchyLevel */;
            };
            SQExpr.isAggregation = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 3 /* Aggregation */;
            };
            SQExpr.isMeasure = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 2 /* MeasureRef */;
            };
            SQExpr.isResourcePackageItem = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.kind === 24 /* ResourcePackageItem */;
            };
            SQExpr.prototype.getMetadata = function (federatedSchema) {
                debug.assertValue(federatedSchema, 'federatedSchema');
                var field = data.SQExprConverter.asFieldPattern(this);
                if (!field)
                    return;
                if (field.column || field.columnAggr || field.measure)
                    return this.getMetadataForProperty(field, federatedSchema);
                if (field.hierarchyLevel || field.hierarchyLevelAggr)
                    return this.getMetadataForHierarchyLevel(field, federatedSchema);
                if (field.columnHierarchyLevelVariation)
                    return this.getMetadataForVariation(field, federatedSchema);
                return SQExpr.getMetadataForEntity(field, federatedSchema);
            };
            SQExpr.prototype.getDefaultAggregate = function (federatedSchema, forceAggregation) {
                if (forceAggregation === void 0) { forceAggregation = false; }
                debug.assertValue(federatedSchema, 'federatedSchema');
                var property = this.getConceptualProperty(federatedSchema) || this.getHierarchyLevelConceptualProperty(federatedSchema);
                if (!property)
                    return;
                var aggregate;
                if (property && property.kind === 0 /* Column */) {
                    var propertyDefaultAggregate = property.column ? property.column.defaultAggregate : null;
                    if ((property.type.integer || property.type.numeric) &&
                        propertyDefaultAggregate !== 1 /* None */) {
                        aggregate = defaultAggregateToQueryAggregateFunction(propertyDefaultAggregate);
                        if (aggregate === undefined)
                            aggregate = defaultAggregateForDataType(property.type);
                    }
                    // If we haven't found an appropriate aggregate, and want to force aggregation anyway, 
                    // aggregate on CountNonNull.
                    if (aggregate === undefined && forceAggregation) {
                        aggregate = data.QueryAggregateFunction.CountNonNull;
                    }
                }
                return aggregate;
            };
            /** Return the SQExpr[] of group on columns if it has group on keys otherwise return the SQExpr of the column.*/
            SQExpr.prototype.getKeyColumns = function (schema) {
                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);
                if (!columnRefExpr)
                    return;
                var keySQExprs = [];
                var keys = this.getPropertyKeys(schema);
                if (keys && keys.length > 0) {
                    for (var i = 0, len = keys.length; i < len; i++) {
                        keySQExprs.push(SQExprBuilder.columnRef(columnRefExpr.source, keys[i].name));
                    }
                }
                else
                    keySQExprs.push(columnRefExpr);
                return keySQExprs;
            };
            /** Returns a value indicating whether the expression would group on keys other than itself.*/
            SQExpr.prototype.hasGroupOnKeys = function (schema) {
                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(schema, this);
                if (!columnRefExpr)
                    return;
                var keys = this.getPropertyKeys(schema);
                if (!keys || keys.length < 1)
                    return false;
                if (keys.length > 1)
                    return true;
                var keySqExpr = SQExprBuilder.columnRef(columnRefExpr.source, keys[0].name);
                return !SQExpr.equals(keySqExpr, this);
            };
            SQExpr.prototype.getPropertyKeys = function (schema) {
                var property = this.getConceptualProperty(schema) || this.getHierarchyLevelConceptualProperty(schema);
                if (!property)
                    return;
                return property.column ? property.column.keys : undefined;
            };
            SQExpr.prototype.getConceptualProperty = function (federatedSchema) {
                var field = data.SQExprConverter.asFieldPattern(this);
                if (!field)
                    return;
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                var propertyName = data.FieldExprPattern.getPropertyName(field);
                if (propertyName)
                    return federatedSchema
                        .schema(fieldExprItem.schema)
                        .findProperty(fieldExprItem.entity, propertyName);
            };
            SQExpr.prototype.getTargetEntityForVariation = function (federatedSchema, variationName) {
                var property = this.getConceptualProperty(federatedSchema);
                if (property && property.column && !_.isEmpty(property.column.variations)) {
                    var variations = property.column.variations;
                    for (var _i = 0, variations_2 = variations; _i < variations_2.length; _i++) {
                        var variation = variations_2[_i];
                        if (variation.name === variationName)
                            return variation.navigationProperty.targetEntity.name;
                    }
                }
            };
            SQExpr.prototype.getTargetEntity = function (federatedSchema) {
                return SQEntityExprInfoVisitor.getEntityExpr(federatedSchema, this);
            };
            SQExpr.prototype.getHierarchyLevelConceptualProperty = function (federatedSchema) {
                var field = data.SQExprConverter.asFieldPattern(this);
                if (!field)
                    return;
                var fieldExprHierachyLevel = field.hierarchyLevel || field.hierarchyLevelAggr;
                if (fieldExprHierachyLevel) {
                    var fieldExprEntity = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                    var hierarchy = federatedSchema
                        .schema(fieldExprEntity.schema)
                        .findHierarchy(fieldExprEntity.entity, fieldExprHierachyLevel.name);
                    if (hierarchy) {
                        var hierarchyLevel = hierarchy.levels.withName(fieldExprHierachyLevel.level);
                        if (hierarchyLevel)
                            return hierarchyLevel.column;
                    }
                }
            };
            SQExpr.prototype.getMetadataForVariation = function (field, federatedSchema) {
                debug.assertValue(field, 'field');
                debug.assertValue(federatedSchema, 'federatedSchema');
                var columnHierarchyLevelVariation = field.columnHierarchyLevelVariation;
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                var sourceProperty = federatedSchema
                    .schema(fieldExprItem.schema)
                    .findProperty(fieldExprItem.entity, columnHierarchyLevelVariation.source.name);
                if (sourceProperty && sourceProperty.column && sourceProperty.column.variations) {
                    for (var _i = 0, _a = sourceProperty.column.variations; _i < _a.length; _i++) {
                        var variation = _a[_i];
                        if (variation.defaultHierarchy && variation.defaultHierarchy.levels) {
                            for (var _b = 0, _c = variation.defaultHierarchy.levels; _b < _c.length; _b++) {
                                var level = _c[_b];
                                if (level.name === columnHierarchyLevelVariation.level.level) {
                                    var property = level.column;
                                    return {
                                        kind: (property.kind === 1 /* Measure */) ? 1 /* Measure */ : 0 /* Column */,
                                        type: property.type,
                                        format: property.format,
                                        idOnEntityKey: property.column ? property.column.idOnEntityKey : false,
                                        defaultAggregate: property.column ? property.column.defaultAggregate : null
                                    };
                                }
                            }
                        }
                    }
                }
            };
            SQExpr.prototype.getMetadataForHierarchyLevel = function (field, federatedSchema) {
                debug.assertValue(field, 'field');
                debug.assertValue(federatedSchema, 'federatedSchema');
                var property = this.getHierarchyLevelConceptualProperty(federatedSchema);
                if (!property)
                    return;
                return this.getPropertyMetadata(field, property);
            };
            SQExpr.prototype.getPropertyMetadata = function (field, property) {
                var format = property.format;
                var type = property.type;
                var columnAggregate = field.columnAggr || field.hierarchyLevelAggr;
                if (columnAggregate) {
                    switch (columnAggregate.aggregate) {
                        case data.QueryAggregateFunction.Count:
                        case data.QueryAggregateFunction.CountNonNull:
                            type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer);
                            format = undefined;
                            break;
                        case data.QueryAggregateFunction.Avg:
                            if (type.integer)
                                type = powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double);
                            break;
                    }
                }
                return {
                    kind: (property.kind === 1 /* Measure */ || (columnAggregate && columnAggregate.aggregate !== undefined)) ? 1 /* Measure */ : 0 /* Column */,
                    type: type,
                    format: format,
                    idOnEntityKey: property.column ? property.column.idOnEntityKey : false,
                    aggregate: columnAggregate ? columnAggregate.aggregate : undefined,
                    defaultAggregate: property.column ? property.column.defaultAggregate : null
                };
            };
            SQExpr.prototype.getMetadataForProperty = function (field, federatedSchema) {
                debug.assertValue(field, 'field');
                debug.assertValue(federatedSchema, 'federatedSchema');
                var property = this.getConceptualProperty(federatedSchema);
                if (!property)
                    return;
                return this.getPropertyMetadata(field, property);
            };
            SQExpr.getMetadataForEntity = function (field, federatedSchema) {
                debug.assertValue(field, 'field');
                debug.assertValue(federatedSchema, 'federatedSchema');
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                var entity = federatedSchema
                    .schema(fieldExprItem.schema)
                    .entities
                    .withName(fieldExprItem.entity);
                if (!entity)
                    return;
                // We only support count and countnonnull for entity.
                if (field.entityAggr) {
                    switch (field.entityAggr.aggregate) {
                        case data.QueryAggregateFunction.Count:
                        case data.QueryAggregateFunction.CountNonNull:
                            return {
                                kind: 1 /* Measure */,
                                type: powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer),
                                format: undefined,
                                idOnEntityKey: false,
                                aggregate: field.entityAggr.aggregate
                            };
                    }
                }
            };
            return SQExpr;
        }());
        data.SQExpr = SQExpr;
        /** Note: Exported for testability */
        function defaultAggregateForDataType(type) {
            if (type.integer || type.numeric)
                return data.QueryAggregateFunction.Sum;
            return data.QueryAggregateFunction.Count;
        }
        data.defaultAggregateForDataType = defaultAggregateForDataType;
        /** Note: Exported for testability */
        function defaultAggregateToQueryAggregateFunction(aggregate) {
            switch (aggregate) {
                case 6 /* Average */:
                    return data.QueryAggregateFunction.Avg;
                case 3 /* Count */:
                    return data.QueryAggregateFunction.CountNonNull;
                case 7 /* DistinctCount */:
                    return data.QueryAggregateFunction.Count;
                case 5 /* Max */:
                    return data.QueryAggregateFunction.Max;
                case 4 /* Min */:
                    return data.QueryAggregateFunction.Min;
                case 2 /* Sum */:
                    return data.QueryAggregateFunction.Sum;
                default:
                    return;
            }
        }
        data.defaultAggregateToQueryAggregateFunction = defaultAggregateToQueryAggregateFunction;
        var SQEntityExpr = (function (_super) {
            __extends(SQEntityExpr, _super);
            function SQEntityExpr(schema, entity, variable) {
                debug.assertValue(entity, 'entity');
                _super.call(this, 0 /* Entity */);
                this.schema = schema;
                this.entity = entity;
                if (variable)
                    this.variable = variable;
            }
            SQEntityExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitEntity(this, arg);
            };
            return SQEntityExpr;
        }(SQExpr));
        data.SQEntityExpr = SQEntityExpr;
        var SQArithmeticExpr = (function (_super) {
            __extends(SQArithmeticExpr, _super);
            function SQArithmeticExpr(left, right, operator) {
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                debug.assertValue(operator, 'operator');
                _super.call(this, 22 /* Arithmetic */);
                this.left = left;
                this.right = right;
                this.operator = operator;
            }
            SQArithmeticExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitArithmetic(this, arg);
            };
            return SQArithmeticExpr;
        }(SQExpr));
        data.SQArithmeticExpr = SQArithmeticExpr;
        var SQScopedEvalExpr = (function (_super) {
            __extends(SQScopedEvalExpr, _super);
            function SQScopedEvalExpr(expression, scope) {
                debug.assertValue(expression, 'expression');
                debug.assertValue(scope, 'scope');
                _super.call(this, 25 /* ScopedEval */);
                this.expression = expression;
                this.scope = scope;
            }
            SQScopedEvalExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitScopedEval(this, arg);
            };
            return SQScopedEvalExpr;
        }(SQExpr));
        data.SQScopedEvalExpr = SQScopedEvalExpr;
        var SQPropRefExpr = (function (_super) {
            __extends(SQPropRefExpr, _super);
            function SQPropRefExpr(kind, source, ref) {
                debug.assertValue(kind, 'kind');
                debug.assertValue(source, 'source');
                debug.assertValue(ref, 'ref');
                _super.call(this, kind);
                this.source = source;
                this.ref = ref;
            }
            return SQPropRefExpr;
        }(SQExpr));
        data.SQPropRefExpr = SQPropRefExpr;
        var SQColumnRefExpr = (function (_super) {
            __extends(SQColumnRefExpr, _super);
            function SQColumnRefExpr(source, ref) {
                _super.call(this, 1 /* ColumnRef */, source, ref);
            }
            SQColumnRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitColumnRef(this, arg);
            };
            return SQColumnRefExpr;
        }(SQPropRefExpr));
        data.SQColumnRefExpr = SQColumnRefExpr;
        var SQMeasureRefExpr = (function (_super) {
            __extends(SQMeasureRefExpr, _super);
            function SQMeasureRefExpr(source, ref) {
                _super.call(this, 2 /* MeasureRef */, source, ref);
            }
            SQMeasureRefExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitMeasureRef(this, arg);
            };
            return SQMeasureRefExpr;
        }(SQPropRefExpr));
        data.SQMeasureRefExpr = SQMeasureRefExpr;
        var SQAggregationExpr = (function (_super) {
            __extends(SQAggregationExpr, _super);
            function SQAggregationExpr(arg, func) {
                debug.assertValue(arg, 'arg');
                debug.assertValue(func, 'func');
                _super.call(this, 3 /* Aggregation */);
                this.arg = arg;
                this.func = func;
            }
            SQAggregationExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitAggr(this, arg);
            };
            return SQAggregationExpr;
        }(SQExpr));
        data.SQAggregationExpr = SQAggregationExpr;
        var SQPropertyVariationSourceExpr = (function (_super) {
            __extends(SQPropertyVariationSourceExpr, _super);
            function SQPropertyVariationSourceExpr(arg, name, property) {
                debug.assertValue(arg, 'arg');
                debug.assertValue(name, 'name');
                debug.assertValue(property, 'property');
                _super.call(this, 4 /* PropertyVariationSource */);
                this.arg = arg;
                this.name = name;
                this.property = property;
            }
            SQPropertyVariationSourceExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitPropertyVariationSource(this, arg);
            };
            return SQPropertyVariationSourceExpr;
        }(SQExpr));
        data.SQPropertyVariationSourceExpr = SQPropertyVariationSourceExpr;
        var SQHierarchyExpr = (function (_super) {
            __extends(SQHierarchyExpr, _super);
            function SQHierarchyExpr(arg, hierarchy) {
                debug.assertValue(arg, 'arg');
                debug.assertValue(hierarchy, 'hierarchy');
                _super.call(this, 5 /* Hierarchy */);
                this.arg = arg;
                this.hierarchy = hierarchy;
            }
            SQHierarchyExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitHierarchy(this, arg);
            };
            return SQHierarchyExpr;
        }(SQExpr));
        data.SQHierarchyExpr = SQHierarchyExpr;
        var SQHierarchyLevelExpr = (function (_super) {
            __extends(SQHierarchyLevelExpr, _super);
            function SQHierarchyLevelExpr(arg, level) {
                debug.assertValue(arg, 'arg');
                debug.assertValue(level, 'level');
                _super.call(this, 6 /* HierarchyLevel */);
                this.arg = arg;
                this.level = level;
            }
            SQHierarchyLevelExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitHierarchyLevel(this, arg);
            };
            return SQHierarchyLevelExpr;
        }(SQExpr));
        data.SQHierarchyLevelExpr = SQHierarchyLevelExpr;
        var SQAndExpr = (function (_super) {
            __extends(SQAndExpr, _super);
            function SQAndExpr(left, right) {
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _super.call(this, 7 /* And */);
                this.left = left;
                this.right = right;
            }
            SQAndExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitAnd(this, arg);
            };
            return SQAndExpr;
        }(SQExpr));
        data.SQAndExpr = SQAndExpr;
        var SQBetweenExpr = (function (_super) {
            __extends(SQBetweenExpr, _super);
            function SQBetweenExpr(arg, lower, upper) {
                debug.assertValue(arg, 'arg');
                debug.assertValue(lower, 'lower');
                debug.assertValue(upper, 'upper');
                _super.call(this, 8 /* Between */);
                this.arg = arg;
                this.lower = lower;
                this.upper = upper;
            }
            SQBetweenExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitBetween(this, arg);
            };
            return SQBetweenExpr;
        }(SQExpr));
        data.SQBetweenExpr = SQBetweenExpr;
        var SQInExpr = (function (_super) {
            __extends(SQInExpr, _super);
            function SQInExpr(args, values) {
                debug.assertValue(args, 'args');
                debug.assertValue(values, 'values');
                _super.call(this, 9 /* In */);
                this.args = args;
                this.values = values;
            }
            SQInExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitIn(this, arg);
            };
            return SQInExpr;
        }(SQExpr));
        data.SQInExpr = SQInExpr;
        var SQOrExpr = (function (_super) {
            __extends(SQOrExpr, _super);
            function SQOrExpr(left, right) {
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _super.call(this, 10 /* Or */);
                this.left = left;
                this.right = right;
            }
            SQOrExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitOr(this, arg);
            };
            return SQOrExpr;
        }(SQExpr));
        data.SQOrExpr = SQOrExpr;
        var SQCompareExpr = (function (_super) {
            __extends(SQCompareExpr, _super);
            function SQCompareExpr(comparison, left, right) {
                debug.assertValue(comparison, 'kind');
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _super.call(this, 12 /* Compare */);
                this.comparison = comparison;
                this.left = left;
                this.right = right;
            }
            SQCompareExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitCompare(this, arg);
            };
            return SQCompareExpr;
        }(SQExpr));
        data.SQCompareExpr = SQCompareExpr;
        var SQContainsExpr = (function (_super) {
            __extends(SQContainsExpr, _super);
            function SQContainsExpr(left, right) {
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _super.call(this, 11 /* Contains */);
                this.left = left;
                this.right = right;
            }
            SQContainsExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitContains(this, arg);
            };
            return SQContainsExpr;
        }(SQExpr));
        data.SQContainsExpr = SQContainsExpr;
        var SQStartsWithExpr = (function (_super) {
            __extends(SQStartsWithExpr, _super);
            function SQStartsWithExpr(left, right) {
                debug.assertValue(left, 'left');
                debug.assertValue(right, 'right');
                _super.call(this, 13 /* StartsWith */);
                this.left = left;
                this.right = right;
            }
            SQStartsWithExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitStartsWith(this, arg);
            };
            return SQStartsWithExpr;
        }(SQExpr));
        data.SQStartsWithExpr = SQStartsWithExpr;
        var SQExistsExpr = (function (_super) {
            __extends(SQExistsExpr, _super);
            function SQExistsExpr(arg) {
                debug.assertValue(arg, 'arg');
                _super.call(this, 14 /* Exists */);
                this.arg = arg;
            }
            SQExistsExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitExists(this, arg);
            };
            return SQExistsExpr;
        }(SQExpr));
        data.SQExistsExpr = SQExistsExpr;
        var SQNotExpr = (function (_super) {
            __extends(SQNotExpr, _super);
            function SQNotExpr(arg) {
                debug.assertValue(arg, 'arg');
                _super.call(this, 15 /* Not */);
                this.arg = arg;
            }
            SQNotExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitNot(this, arg);
            };
            return SQNotExpr;
        }(SQExpr));
        data.SQNotExpr = SQNotExpr;
        var SQConstantExpr = (function (_super) {
            __extends(SQConstantExpr, _super);
            function SQConstantExpr(type, value, valueEncoded) {
                debug.assertValue(type, 'type');
                _super.call(this, 16 /* Constant */);
                this.type = type;
                this.value = value;
                this.valueEncoded = valueEncoded;
            }
            SQConstantExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitConstant(this, arg);
            };
            SQConstantExpr.prototype.getMetadata = function (federatedSchema) {
                debug.assertValue(federatedSchema, 'federatedSchema');
                return {
                    // Returning Measure as the kind for a SQConstantExpr is slightly ambiguous allowing the return object to conform to SQEXprMetadata.
                    // A getType or similiar function in the future would be more appropriate. 
                    kind: 1 /* Measure */,
                    type: this.type,
                };
            };
            return SQConstantExpr;
        }(SQExpr));
        data.SQConstantExpr = SQConstantExpr;
        var SQDateSpanExpr = (function (_super) {
            __extends(SQDateSpanExpr, _super);
            function SQDateSpanExpr(unit, arg) {
                debug.assertValue(unit, 'unit');
                debug.assertValue(arg, 'arg');
                _super.call(this, 17 /* DateSpan */);
                this.unit = unit;
                this.arg = arg;
            }
            SQDateSpanExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitDateSpan(this, arg);
            };
            return SQDateSpanExpr;
        }(SQExpr));
        data.SQDateSpanExpr = SQDateSpanExpr;
        var SQDateAddExpr = (function (_super) {
            __extends(SQDateAddExpr, _super);
            function SQDateAddExpr(unit, amount, arg) {
                debug.assertValue(unit, 'unit');
                debug.assertValue(amount, 'amount');
                debug.assertValue(arg, 'arg');
                _super.call(this, 18 /* DateAdd */);
                this.unit = unit;
                this.arg = arg;
                this.amount = amount;
            }
            SQDateAddExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitDateAdd(this, arg);
            };
            return SQDateAddExpr;
        }(SQExpr));
        data.SQDateAddExpr = SQDateAddExpr;
        var SQNowExpr = (function (_super) {
            __extends(SQNowExpr, _super);
            function SQNowExpr() {
                _super.call(this, 19 /* Now */);
            }
            SQNowExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitNow(this, arg);
            };
            return SQNowExpr;
        }(SQExpr));
        data.SQNowExpr = SQNowExpr;
        var SQDefaultValueExpr = (function (_super) {
            __extends(SQDefaultValueExpr, _super);
            function SQDefaultValueExpr() {
                _super.call(this, 21 /* DefaultValue */);
            }
            SQDefaultValueExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitDefaultValue(this, arg);
            };
            return SQDefaultValueExpr;
        }(SQExpr));
        data.SQDefaultValueExpr = SQDefaultValueExpr;
        var SQAnyValueExpr = (function (_super) {
            __extends(SQAnyValueExpr, _super);
            function SQAnyValueExpr() {
                _super.call(this, 20 /* AnyValue */);
            }
            SQAnyValueExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitAnyValue(this, arg);
            };
            return SQAnyValueExpr;
        }(SQExpr));
        data.SQAnyValueExpr = SQAnyValueExpr;
        var SQFillRuleExpr = (function (_super) {
            __extends(SQFillRuleExpr, _super);
            function SQFillRuleExpr(input, fillRule) {
                debug.assertValue(input, 'input');
                debug.assertValue(fillRule, 'fillRule');
                _super.call(this, 23 /* FillRule */);
                this.input = input;
                this.rule = fillRule;
            }
            SQFillRuleExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitFillRule(this, arg);
            };
            return SQFillRuleExpr;
        }(SQExpr));
        data.SQFillRuleExpr = SQFillRuleExpr;
        var SQResourcePackageItemExpr = (function (_super) {
            __extends(SQResourcePackageItemExpr, _super);
            function SQResourcePackageItemExpr(packageName, packageType, itemName) {
                debug.assertValue(packageName, 'packageName');
                debug.assertValue(itemName, 'itemName');
                _super.call(this, 24 /* ResourcePackageItem */);
                this.packageName = packageName;
                this.packageType = packageType;
                this.itemName = itemName;
            }
            SQResourcePackageItemExpr.prototype.accept = function (visitor, arg) {
                return visitor.visitResourcePackageItem(this, arg);
            };
            return SQResourcePackageItemExpr;
        }(SQExpr));
        data.SQResourcePackageItemExpr = SQResourcePackageItemExpr;
        /** Provides utilities for creating & manipulating expressions. */
        var SQExprBuilder;
        (function (SQExprBuilder) {
            function entity(schema, entity, variable) {
                return new SQEntityExpr(schema, entity, variable);
            }
            SQExprBuilder.entity = entity;
            function columnRef(source, prop) {
                return new SQColumnRefExpr(source, prop);
            }
            SQExprBuilder.columnRef = columnRef;
            function measureRef(source, prop) {
                return new SQMeasureRefExpr(source, prop);
            }
            SQExprBuilder.measureRef = measureRef;
            function aggregate(source, aggregate) {
                return new SQAggregationExpr(source, aggregate);
            }
            SQExprBuilder.aggregate = aggregate;
            function hierarchy(source, hierarchy) {
                return new SQHierarchyExpr(source, hierarchy);
            }
            SQExprBuilder.hierarchy = hierarchy;
            function propertyVariationSource(source, name, property) {
                return new SQPropertyVariationSourceExpr(source, name, property);
            }
            SQExprBuilder.propertyVariationSource = propertyVariationSource;
            function hierarchyLevel(source, level) {
                return new SQHierarchyLevelExpr(source, level);
            }
            SQExprBuilder.hierarchyLevel = hierarchyLevel;
            function and(left, right) {
                if (!left)
                    return right;
                if (!right)
                    return left;
                return new SQAndExpr(left, right);
            }
            SQExprBuilder.and = and;
            function between(arg, lower, upper) {
                return new SQBetweenExpr(arg, lower, upper);
            }
            SQExprBuilder.between = between;
            function inExpr(args, values) {
                return new SQInExpr(args, values);
            }
            SQExprBuilder.inExpr = inExpr;
            function or(left, right) {
                if (!left)
                    return right;
                if (!right)
                    return left;
                if (left instanceof SQInExpr && right instanceof SQInExpr) {
                    var inExpr_1 = tryUseInExprs(left, right);
                    if (inExpr_1)
                        return inExpr_1;
                }
                return new SQOrExpr(left, right);
            }
            SQExprBuilder.or = or;
            function tryUseInExprs(left, right) {
                if (!left.args || !right.args)
                    return;
                var leftArgLen = left.args.length;
                var rightArgLen = right.args.length;
                if (leftArgLen !== rightArgLen)
                    return;
                for (var i = 0; i < leftArgLen; ++i) {
                    if (!SQExpr.equals(left.args[i], right.args[i]))
                        return;
                }
                var combinedValues = left.values.concat(right.values);
                return SQExprBuilder.inExpr(left.args, combinedValues);
            }
            function compare(kind, left, right) {
                return new SQCompareExpr(kind, left, right);
            }
            SQExprBuilder.compare = compare;
            function contains(left, right) {
                return new SQContainsExpr(left, right);
            }
            SQExprBuilder.contains = contains;
            function exists(arg) {
                return new SQExistsExpr(arg);
            }
            SQExprBuilder.exists = exists;
            function equal(left, right) {
                return compare(data.QueryComparisonKind.Equal, left, right);
            }
            SQExprBuilder.equal = equal;
            function not(arg) {
                return new SQNotExpr(arg);
            }
            SQExprBuilder.not = not;
            function startsWith(left, right) {
                return new SQStartsWithExpr(left, right);
            }
            SQExprBuilder.startsWith = startsWith;
            function nullConstant() {
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Null), null, data.PrimitiveValueEncoding.nullEncoding());
            }
            SQExprBuilder.nullConstant = nullConstant;
            function now() {
                return new SQNowExpr();
            }
            SQExprBuilder.now = now;
            function defaultValue() {
                return new SQDefaultValueExpr();
            }
            SQExprBuilder.defaultValue = defaultValue;
            function anyValue() {
                return new SQAnyValueExpr();
            }
            SQExprBuilder.anyValue = anyValue;
            function boolean(value) {
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Boolean), value, data.PrimitiveValueEncoding.boolean(value));
            }
            SQExprBuilder.boolean = boolean;
            function dateAdd(unit, amount, arg) {
                return new SQDateAddExpr(unit, amount, arg);
            }
            SQExprBuilder.dateAdd = dateAdd;
            function dateTime(value, valueEncoded) {
                if (valueEncoded === undefined)
                    valueEncoded = data.PrimitiveValueEncoding.dateTime(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.DateTime), value, valueEncoded);
            }
            SQExprBuilder.dateTime = dateTime;
            function dateSpan(unit, arg) {
                return new SQDateSpanExpr(unit, arg);
            }
            SQExprBuilder.dateSpan = dateSpan;
            function decimal(value, valueEncoded) {
                if (valueEncoded === undefined)
                    valueEncoded = data.PrimitiveValueEncoding.decimal(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Decimal), value, valueEncoded);
            }
            SQExprBuilder.decimal = decimal;
            function double(value, valueEncoded) {
                if (valueEncoded === undefined)
                    valueEncoded = data.PrimitiveValueEncoding.double(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Double), value, valueEncoded);
            }
            SQExprBuilder.double = double;
            function integer(value, valueEncoded) {
                if (valueEncoded === undefined)
                    valueEncoded = data.PrimitiveValueEncoding.integer(value);
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Integer), value, valueEncoded);
            }
            SQExprBuilder.integer = integer;
            function text(value, valueEncoded) {
                debug.assert(!valueEncoded || valueEncoded === data.PrimitiveValueEncoding.text(value), 'Incorrect encoded value specified.');
                return new SQConstantExpr(powerbi.ValueType.fromExtendedType(powerbi.ExtendedType.Text), value, valueEncoded || data.PrimitiveValueEncoding.text(value));
            }
            SQExprBuilder.text = text;
            /** Returns an SQExpr that evaluates to the constant value. */
            function typedConstant(value, type) {
                if (value == null)
                    return nullConstant();
                if (_.isBoolean(value)) {
                    return boolean(value);
                }
                if (_.isString(value)) {
                    return text(value);
                }
                if (_.isNumber(value)) {
                    if (type.integer && powerbi.Double.isInteger(value))
                        return integer(value);
                    return double(value);
                }
                if (value instanceof Date) {
                    return dateTime(value);
                }
            }
            SQExprBuilder.typedConstant = typedConstant;
            function arithmetic(left, right, operator) {
                return new SQArithmeticExpr(left, right, operator);
            }
            SQExprBuilder.arithmetic = arithmetic;
            function scopedEval(expression, scope) {
                return new SQScopedEvalExpr(expression, scope);
            }
            SQExprBuilder.scopedEval = scopedEval;
            function setAggregate(expr, aggregate) {
                return SQExprChangeAggregateRewriter.rewrite(expr, aggregate);
            }
            SQExprBuilder.setAggregate = setAggregate;
            function removeAggregate(expr) {
                return SQExprRemoveAggregateRewriter.rewrite(expr);
            }
            SQExprBuilder.removeAggregate = removeAggregate;
            function removeEntityVariables(expr) {
                return SQExprRemoveEntityVariablesRewriter.rewrite(expr);
            }
            SQExprBuilder.removeEntityVariables = removeEntityVariables;
            function fillRule(expr, rule) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(rule, 'rule');
                return new SQFillRuleExpr(expr, rule);
            }
            SQExprBuilder.fillRule = fillRule;
            function resourcePackageItem(packageName, packageType, itemName) {
                return new SQResourcePackageItemExpr(packageName, packageType, itemName);
            }
            SQExprBuilder.resourcePackageItem = resourcePackageItem;
        })(SQExprBuilder = data.SQExprBuilder || (data.SQExprBuilder = {}));
        /** Provides utilities for obtaining information about expressions. */
        var SQExprInfo;
        (function (SQExprInfo) {
            function getAggregate(expr) {
                return SQExprAggregateInfoVisitor.getAggregate(expr);
            }
            SQExprInfo.getAggregate = getAggregate;
        })(SQExprInfo = data.SQExprInfo || (data.SQExprInfo = {}));
        var SQExprEqualityVisitor = (function () {
            function SQExprEqualityVisitor(ignoreCase) {
                this.ignoreCase = ignoreCase;
            }
            SQExprEqualityVisitor.run = function (x, y, ignoreCase) {
                // Normalize falsy to null
                x = x || null;
                y = y || null;
                if (x === y)
                    return true;
                if (!x !== !y)
                    return false;
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                if (ignoreCase)
                    return x.accept(SQExprEqualityVisitor.ignoreCaseInstance, y);
                return x.accept(SQExprEqualityVisitor.instance, y);
            };
            SQExprEqualityVisitor.prototype.visitColumnRef = function (expr, comparand) {
                return comparand instanceof SQColumnRefExpr &&
                    expr.ref === comparand.ref &&
                    this.equals(expr.source, comparand.source);
            };
            SQExprEqualityVisitor.prototype.visitMeasureRef = function (expr, comparand) {
                return comparand instanceof SQMeasureRefExpr &&
                    expr.ref === comparand.ref &&
                    this.equals(expr.source, comparand.source);
            };
            SQExprEqualityVisitor.prototype.visitAggr = function (expr, comparand) {
                return comparand instanceof SQAggregationExpr &&
                    expr.func === comparand.func &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitHierarchy = function (expr, comparand) {
                return comparand instanceof SQHierarchyExpr &&
                    expr.hierarchy === comparand.hierarchy &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitHierarchyLevel = function (expr, comparand) {
                return comparand instanceof SQHierarchyLevelExpr &&
                    expr.level === comparand.level &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitPropertyVariationSource = function (expr, comparand) {
                return comparand instanceof SQPropertyVariationSourceExpr &&
                    expr.name === comparand.name &&
                    expr.property === comparand.property &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitBetween = function (expr, comparand) {
                return comparand instanceof SQBetweenExpr &&
                    this.equals(expr.arg, comparand.arg) &&
                    this.equals(expr.lower, comparand.lower) &&
                    this.equals(expr.upper, comparand.upper);
            };
            SQExprEqualityVisitor.prototype.visitIn = function (expr, comparand) {
                if (!(comparand instanceof SQInExpr) || !this.equalsAll(expr.args, comparand.args))
                    return false;
                var values = expr.values, compareValues = comparand.values;
                if (values.length !== compareValues.length)
                    return false;
                for (var i = 0, len = values.length; i < len; i++) {
                    if (!this.equalsAll(values[i], compareValues[i]))
                        return false;
                }
                return true;
            };
            SQExprEqualityVisitor.prototype.visitEntity = function (expr, comparand) {
                return comparand instanceof SQEntityExpr &&
                    expr.schema === comparand.schema &&
                    expr.entity === comparand.entity &&
                    this.optionalEqual(expr.variable, comparand.variable);
            };
            SQExprEqualityVisitor.prototype.visitAnd = function (expr, comparand) {
                return comparand instanceof SQAndExpr &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitOr = function (expr, comparand) {
                return comparand instanceof SQOrExpr &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitCompare = function (expr, comparand) {
                return comparand instanceof SQCompareExpr &&
                    expr.comparison === comparand.comparison &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitContains = function (expr, comparand) {
                return comparand instanceof SQContainsExpr &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitDateSpan = function (expr, comparand) {
                return comparand instanceof SQDateSpanExpr &&
                    expr.unit === comparand.unit &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitDateAdd = function (expr, comparand) {
                return comparand instanceof SQDateAddExpr &&
                    expr.unit === comparand.unit &&
                    expr.amount === comparand.amount &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitExists = function (expr, comparand) {
                return comparand instanceof SQExistsExpr &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitNot = function (expr, comparand) {
                return comparand instanceof SQNotExpr &&
                    this.equals(expr.arg, comparand.arg);
            };
            SQExprEqualityVisitor.prototype.visitNow = function (expr, comparand) {
                return comparand instanceof SQNowExpr;
            };
            SQExprEqualityVisitor.prototype.visitDefaultValue = function (expr, comparand) {
                return comparand instanceof SQDefaultValueExpr;
            };
            SQExprEqualityVisitor.prototype.visitAnyValue = function (expr, comparand) {
                return comparand instanceof SQAnyValueExpr;
            };
            SQExprEqualityVisitor.prototype.visitResourcePackageItem = function (expr, comparand) {
                return comparand instanceof SQResourcePackageItemExpr &&
                    expr.packageName === comparand.packageName &&
                    expr.packageType === comparand.packageType &&
                    expr.itemName === comparand.itemName;
            };
            SQExprEqualityVisitor.prototype.visitStartsWith = function (expr, comparand) {
                return comparand instanceof SQStartsWithExpr &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitConstant = function (expr, comparand) {
                if (comparand instanceof SQConstantExpr && expr.type === comparand.type)
                    return expr.type.text && this.ignoreCase ?
                        StringExtensions.equalIgnoreCase(expr.valueEncoded, comparand.valueEncoded) :
                        expr.valueEncoded === comparand.valueEncoded;
                return false;
            };
            SQExprEqualityVisitor.prototype.visitFillRule = function (expr, comparand) {
                if (comparand instanceof SQFillRuleExpr && this.equals(expr.input, comparand.input)) {
                    var leftRule = expr.rule, rightRule = comparand.rule;
                    if (leftRule === rightRule)
                        return true;
                    var leftLinearGradient2 = leftRule.linearGradient2, rightLinearGradient2 = rightRule.linearGradient2;
                    if (leftLinearGradient2 && rightLinearGradient2) {
                        return this.visitLinearGradient2(leftLinearGradient2, rightLinearGradient2);
                    }
                    var leftLinearGradient3 = leftRule.linearGradient3, rightLinearGradient3 = rightRule.linearGradient3;
                    if (leftLinearGradient3 && rightLinearGradient3) {
                        return this.visitLinearGradient3(leftLinearGradient3, rightLinearGradient3);
                    }
                }
                return false;
            };
            SQExprEqualityVisitor.prototype.visitLinearGradient2 = function (left2, right2) {
                debug.assertValue(left2, 'left2');
                debug.assertValue(right2, 'right2');
                return this.equalsFillRuleStop(left2.min, right2.min) &&
                    this.equalsFillRuleStop(left2.max, right2.max);
            };
            SQExprEqualityVisitor.prototype.visitLinearGradient3 = function (left3, right3) {
                debug.assertValue(left3, 'left3');
                debug.assertValue(right3, 'right3');
                return this.equalsFillRuleStop(left3.min, right3.min) &&
                    this.equalsFillRuleStop(left3.mid, right3.mid) &&
                    this.equalsFillRuleStop(left3.max, right3.max);
            };
            SQExprEqualityVisitor.prototype.equalsFillRuleStop = function (stop1, stop2) {
                debug.assertValue(stop1, 'stop1');
                debug.assertValue(stop2, 'stop2');
                if (!this.equals(stop1.color, stop2.color))
                    return false;
                if (!stop1.value)
                    return stop1.value === stop2.value;
                return this.equals(stop1.value, stop2.value);
            };
            SQExprEqualityVisitor.prototype.visitArithmetic = function (expr, comparand) {
                return comparand instanceof SQArithmeticExpr &&
                    expr.operator === comparand.operator &&
                    this.equals(expr.left, comparand.left) &&
                    this.equals(expr.right, comparand.right);
            };
            SQExprEqualityVisitor.prototype.visitScopedEval = function (expr, comparand) {
                return comparand instanceof SQScopedEvalExpr &&
                    this.equals(expr.expression, comparand.expression) &&
                    this.equalsAll(expr.scope, comparand.scope);
            };
            SQExprEqualityVisitor.prototype.optionalEqual = function (x, y) {
                // Only check equality if both values are specified.
                if (x && y)
                    return x === y;
                return true;
            };
            SQExprEqualityVisitor.prototype.equals = function (x, y) {
                return x.accept(this, y);
            };
            SQExprEqualityVisitor.prototype.equalsAll = function (x, y) {
                var len = x.length;
                if (len !== y.length)
                    return false;
                for (var i = 0; i < len; i++) {
                    if (!this.equals(x[i], y[i]))
                        return false;
                }
                return true;
            };
            SQExprEqualityVisitor.instance = new SQExprEqualityVisitor(/* ignoreCase */ false);
            SQExprEqualityVisitor.ignoreCaseInstance = new SQExprEqualityVisitor(true);
            return SQExprEqualityVisitor;
        }());
        /** Rewrites a root-level expression. */
        var SQExprRootRewriter = (function (_super) {
            __extends(SQExprRootRewriter, _super);
            function SQExprRootRewriter() {
                _super.apply(this, arguments);
            }
            SQExprRootRewriter.prototype.visitDefault = function (expr) {
                return expr;
            };
            return SQExprRootRewriter;
        }(data.DefaultSQExprVisitor));
        var SQExprValidationVisitor = (function (_super) {
            __extends(SQExprValidationVisitor, _super);
            function SQExprValidationVisitor(schema, aggrUtils, errors) {
                debug.assertValue(schema, 'schema');
                debug.assertValue(aggrUtils, 'aggrUtils');
                _super.call(this);
                this.schema = schema;
                this.aggrUtils = aggrUtils;
                if (errors)
                    this.errors = errors;
            }
            SQExprValidationVisitor.prototype.visitIn = function (expr) {
                var inExpr = _super.prototype.visitIn.call(this, expr);
                var args = inExpr.args;
                var values = inExpr.values;
                for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
                    var valueTuple = values_2[_i];
                    debug.assert(valueTuple.length === args.length, 'args and value tuple are not the same length');
                    for (var i = 0, len = valueTuple.length; i < len; ++i)
                        this.validateCompatibleType(args[i], valueTuple[i]);
                }
                return inExpr;
            };
            SQExprValidationVisitor.prototype.visitCompare = function (expr) {
                var compareExpr = _super.prototype.visitCompare.call(this, expr);
                this.validateCompatibleType(compareExpr.left, compareExpr.right);
                return compareExpr;
            };
            SQExprValidationVisitor.prototype.visitColumnRef = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);
                    if (entity) {
                        var prop = entity.properties.withName(fieldExpr.column.name);
                        if (!prop ||
                            prop.kind !== 0 /* Column */ ||
                            !this.isQueryable(fieldExpr))
                            this.register(3 /* invalidColumnReference */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitMeasureRef = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                    var entity = this.validateEntity(fieldExprItem.schema, fieldExprItem.entity);
                    if (entity) {
                        var prop = entity.properties.withName(fieldExpr.measure.name);
                        if (!prop ||
                            prop.kind !== 1 /* Measure */ ||
                            !this.isQueryable(fieldExpr))
                            this.register(4 /* invalidMeasureReference */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitAggr = function (expr) {
                var aggregateExpr = _super.prototype.visitAggr.call(this, expr);
                var columnRefExpr = SQExprColumnRefInfoVisitor.getColumnRefSQExpr(this.schema, aggregateExpr.arg);
                if (columnRefExpr) {
                    if (!this.aggrUtils.isSupportedAggregate(expr, this.schema, expr.func, /*targetTypes*/ null))
                        this.register(0 /* invalidAggregateFunction */);
                }
                return aggregateExpr;
            };
            SQExprValidationVisitor.prototype.visitHierarchy = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    var fieldExprItem = fieldExpr.hierarchy;
                    if (fieldExprItem) {
                        this.validateHierarchy(fieldExprItem.schema, fieldExprItem.entity, fieldExprItem.name);
                    }
                    else {
                        this.register(5 /* invalidHierarchyReference */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitHierarchyLevel = function (expr) {
                var fieldExpr = data.SQExprConverter.asFieldPattern(expr);
                if (fieldExpr) {
                    var hierarchyLevelFieldExprItem = fieldExpr.hierarchyLevel;
                    if (hierarchyLevelFieldExprItem) {
                        this.validateHierarchyLevel(hierarchyLevelFieldExprItem.schema, hierarchyLevelFieldExprItem.entity, hierarchyLevelFieldExprItem.name, hierarchyLevelFieldExprItem.level);
                    }
                    else if (!fieldExpr.columnHierarchyLevelVariation) {
                        this.register(6 /* invalidHierarchyLevelReference */);
                    }
                }
                return expr;
            };
            SQExprValidationVisitor.prototype.visitEntity = function (expr) {
                this.validateEntity(expr.schema, expr.entity);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitContains = function (expr) {
                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitStartsWith = function (expr) {
                this.validateOperandsAndTypeForStartOrContains(expr.left, expr.right);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitArithmetic = function (expr) {
                this.validateArithmeticTypes(expr.left, expr.right);
                return expr;
            };
            SQExprValidationVisitor.prototype.visitScopedEval = function (expr) {
                // No validation necessary
                return expr;
            };
            SQExprValidationVisitor.prototype.validateOperandsAndTypeForStartOrContains = function (left, right) {
                if (left instanceof SQColumnRefExpr) {
                    this.visitColumnRef(left);
                }
                else if (left instanceof SQHierarchyLevelExpr) {
                    this.visitHierarchyLevel(left);
                }
                else {
                    this.register(7 /* invalidLeftOperandType */);
                }
                if (!(right instanceof SQConstantExpr) || !right.type.text)
                    this.register(8 /* invalidRightOperandType */);
                else
                    this.validateCompatibleType(left, right);
            };
            SQExprValidationVisitor.prototype.validateArithmeticTypes = function (left, right) {
                if (!data.SQExprUtils.supportsArithmetic(left, this.schema))
                    this.register(7 /* invalidLeftOperandType */);
                if (!data.SQExprUtils.supportsArithmetic(right, this.schema))
                    this.register(8 /* invalidRightOperandType */);
            };
            SQExprValidationVisitor.prototype.validateCompatibleType = function (left, right) {
                var leftMetadata = left.getMetadata(this.schema), leftType = leftMetadata && leftMetadata.type, rightMetadata = right.getMetadata(this.schema), rightType = rightMetadata && rightMetadata.type;
                if (leftType && rightType && !leftType.isCompatibleFrom(rightType))
                    this.register(9 /* invalidValueType */);
            };
            SQExprValidationVisitor.prototype.validateEntity = function (schemaName, entityName) {
                var schema = this.schema.schema(schemaName);
                if (schema) {
                    var entity = schema.entities.withName(entityName);
                    if (entity)
                        return entity;
                    this.register(2 /* invalidEntityReference */);
                }
                else {
                    this.register(1 /* invalidSchemaReference */);
                }
            };
            SQExprValidationVisitor.prototype.validateHierarchy = function (schemaName, entityName, hierarchyName) {
                var entity = this.validateEntity(schemaName, entityName);
                if (entity) {
                    var hierarchy = entity.hierarchies.withName(hierarchyName);
                    if (hierarchy)
                        return hierarchy;
                    this.register(5 /* invalidHierarchyReference */);
                }
            };
            SQExprValidationVisitor.prototype.validateHierarchyLevel = function (schemaName, entityName, hierarchyName, levelName) {
                var hierarchy = this.validateHierarchy(schemaName, entityName, hierarchyName);
                if (hierarchy) {
                    var hierarchyLevel = hierarchy.levels.withName(levelName);
                    if (hierarchyLevel)
                        return hierarchyLevel;
                    this.register(6 /* invalidHierarchyLevelReference */);
                }
            };
            SQExprValidationVisitor.prototype.register = function (error) {
                if (!this.errors)
                    this.errors = [];
                this.errors.push(error);
            };
            SQExprValidationVisitor.prototype.isQueryable = function (fieldExpr) {
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(fieldExpr);
                if (fieldExpr.hierarchyLevel || fieldExpr.hierarchyLevelAggr) {
                    var hierarchyLevelConceptualProperty = data.SQHierarchyExprUtils.getConceptualHierarchyLevelFromExpr(this.schema, fieldExpr);
                    return hierarchyLevelConceptualProperty && hierarchyLevelConceptualProperty.column.queryable !== 1 /* Error */;
                }
                return this.schema.schema(fieldExprItem.schema).findProperty(fieldExprItem.entity, data.FieldExprPattern.getPropertyName(fieldExpr)).queryable !== 1 /* Error */;
            };
            return SQExprValidationVisitor;
        }(data.SQExprRewriter));
        data.SQExprValidationVisitor = SQExprValidationVisitor;
        /** Returns an expression's aggregate function, or undefined if it doesn't have one. */
        var SQExprAggregateInfoVisitor = (function (_super) {
            __extends(SQExprAggregateInfoVisitor, _super);
            function SQExprAggregateInfoVisitor() {
                _super.apply(this, arguments);
            }
            SQExprAggregateInfoVisitor.prototype.visitAggr = function (expr) {
                return expr.func;
            };
            SQExprAggregateInfoVisitor.prototype.visitDefault = function (expr) {
                return;
            };
            SQExprAggregateInfoVisitor.getAggregate = function (expr) {
                var visitor = new SQExprAggregateInfoVisitor();
                return expr.accept(visitor);
            };
            return SQExprAggregateInfoVisitor;
        }(data.DefaultSQExprVisitor));
        /** Returns a SQExprColumnRef expression or undefined.*/
        var SQExprColumnRefInfoVisitor = (function (_super) {
            __extends(SQExprColumnRefInfoVisitor, _super);
            function SQExprColumnRefInfoVisitor(schema) {
                _super.call(this);
                this.schema = schema;
            }
            SQExprColumnRefInfoVisitor.prototype.visitColumnRef = function (expr) {
                return expr;
            };
            SQExprColumnRefInfoVisitor.prototype.visitHierarchyLevel = function (expr) {
                var ref = expr.level;
                var hierarchy = (expr.arg);
                var sourceExpr = hierarchy.accept(this);
                if (hierarchy && hierarchy.arg instanceof SQPropertyVariationSourceExpr) {
                    var propertyVariationSource = hierarchy.arg;
                    var targetEntity = sourceExpr.getTargetEntityForVariation(this.schema, propertyVariationSource.name);
                    if (sourceExpr && targetEntity) {
                        var schemaName = (sourceExpr.source).schema;
                        var targetEntityExpr = SQExprBuilder.entity(schemaName, targetEntity);
                        var schemaHierarchy = this.schema.schema(schemaName).findHierarchy(targetEntity, hierarchy.hierarchy);
                        if (schemaHierarchy) {
                            for (var _i = 0, _a = schemaHierarchy.levels; _i < _a.length; _i++) {
                                var level = _a[_i];
                                if (level.name === ref)
                                    return new SQColumnRefExpr(targetEntityExpr, level.column.name);
                            }
                        }
                    }
                }
                else {
                    var entityExpr = (hierarchy.arg);
                    var hierarchyLevelRef = data.SQHierarchyExprUtils.getConceptualHierarchyLevel(this.schema, entityExpr.schema, entityExpr.entity, hierarchy.hierarchy, expr.level);
                    if (hierarchyLevelRef)
                        return new SQColumnRefExpr(hierarchy.arg, hierarchyLevelRef.column.name);
                }
            };
            SQExprColumnRefInfoVisitor.prototype.visitHierarchy = function (expr) {
                return expr.arg.accept(this);
            };
            SQExprColumnRefInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {
                var propertyName = expr.property;
                return new SQColumnRefExpr(expr.arg, propertyName);
            };
            SQExprColumnRefInfoVisitor.prototype.visitAggr = function (expr) {
                return expr.arg.accept(this);
            };
            SQExprColumnRefInfoVisitor.prototype.visitDefault = function (expr) {
                return;
            };
            SQExprColumnRefInfoVisitor.getColumnRefSQExpr = function (schema, expr) {
                var visitor = new SQExprColumnRefInfoVisitor(schema);
                return expr.accept(visitor);
            };
            return SQExprColumnRefInfoVisitor;
        }(data.DefaultSQExprVisitor));
        /** Returns a SQEntityExpr expression or undefined.*/
        var SQEntityExprInfoVisitor = (function (_super) {
            __extends(SQEntityExprInfoVisitor, _super);
            function SQEntityExprInfoVisitor(schema) {
                _super.call(this);
                this.schema = schema;
            }
            SQEntityExprInfoVisitor.prototype.visitEntity = function (expr) {
                return expr;
            };
            SQEntityExprInfoVisitor.prototype.visitColumnRef = function (expr) {
                return SQEntityExprInfoVisitor.getEntity(expr);
            };
            SQEntityExprInfoVisitor.prototype.visitHierarchyLevel = function (expr) {
                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);
                return SQEntityExprInfoVisitor.getEntity(columnRef);
            };
            SQEntityExprInfoVisitor.prototype.visitHierarchy = function (expr) {
                return expr.arg.accept(this);
            };
            SQEntityExprInfoVisitor.prototype.visitPropertyVariationSource = function (expr) {
                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);
                return SQEntityExprInfoVisitor.getEntity(columnRef);
            };
            SQEntityExprInfoVisitor.prototype.visitAggr = function (expr) {
                var columnRef = SQEntityExprInfoVisitor.getColumnRefSQExpr(this.schema, expr);
                return SQEntityExprInfoVisitor.getEntity(columnRef);
            };
            SQEntityExprInfoVisitor.prototype.visitMeasureRef = function (expr) {
                return expr.source.accept(this);
            };
            SQEntityExprInfoVisitor.getColumnRefSQExpr = function (schema, expr) {
                var visitor = new SQExprColumnRefInfoVisitor(schema);
                return expr.accept(visitor);
            };
            SQEntityExprInfoVisitor.getEntity = function (columnRef) {
                var field = data.SQExprConverter.asFieldPattern(columnRef);
                var column = field.column;
                return SQExprBuilder.entity(column.schema, column.entity, column.entityVar);
            };
            SQEntityExprInfoVisitor.getEntityExpr = function (schema, expr) {
                var visitor = new SQEntityExprInfoVisitor(schema);
                return expr.accept(visitor);
            };
            return SQEntityExprInfoVisitor;
        }(data.DefaultSQExprVisitor));
        var SQExprChangeAggregateRewriter = (function (_super) {
            __extends(SQExprChangeAggregateRewriter, _super);
            function SQExprChangeAggregateRewriter(func) {
                debug.assertValue(func, 'func');
                _super.call(this);
                this.func = func;
            }
            SQExprChangeAggregateRewriter.prototype.visitAggr = function (expr) {
                if (expr.func === this.func)
                    return expr;
                return new SQAggregationExpr(expr.arg, this.func);
            };
            SQExprChangeAggregateRewriter.prototype.visitColumnRef = function (expr) {
                return new SQAggregationExpr(expr, this.func);
            };
            SQExprChangeAggregateRewriter.rewrite = function (expr, func) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(func, 'func');
                var rewriter = new SQExprChangeAggregateRewriter(func);
                return expr.accept(rewriter);
            };
            return SQExprChangeAggregateRewriter;
        }(SQExprRootRewriter));
        var SQExprRemoveAggregateRewriter = (function (_super) {
            __extends(SQExprRemoveAggregateRewriter, _super);
            function SQExprRemoveAggregateRewriter() {
                _super.apply(this, arguments);
            }
            SQExprRemoveAggregateRewriter.prototype.visitAggr = function (expr) {
                return expr.arg;
            };
            SQExprRemoveAggregateRewriter.rewrite = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(SQExprRemoveAggregateRewriter.instance);
            };
            SQExprRemoveAggregateRewriter.instance = new SQExprRemoveAggregateRewriter();
            return SQExprRemoveAggregateRewriter;
        }(SQExprRootRewriter));
        var SQExprRemoveEntityVariablesRewriter = (function (_super) {
            __extends(SQExprRemoveEntityVariablesRewriter, _super);
            function SQExprRemoveEntityVariablesRewriter() {
                _super.apply(this, arguments);
            }
            SQExprRemoveEntityVariablesRewriter.prototype.visitEntity = function (expr) {
                if (expr.variable)
                    return SQExprBuilder.entity(expr.schema, expr.entity);
                return expr;
            };
            SQExprRemoveEntityVariablesRewriter.rewrite = function (expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(SQExprRemoveEntityVariablesRewriter.instance);
            };
            SQExprRemoveEntityVariablesRewriter.instance = new SQExprRemoveEntityVariablesRewriter();
            return SQExprRemoveEntityVariablesRewriter;
        }(data.SQExprRewriter));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var StringExtensions = jsCommon.StringExtensions;
        var SQExprUtils;
        (function (SQExprUtils) {
            function supportsArithmetic(expr, schema) {
                var metadata = expr.getMetadata(schema), type = metadata && metadata.type;
                if (!metadata || !type) {
                    return false;
                }
                return type.numeric || type.dateTime || type.duration;
            }
            SQExprUtils.supportsArithmetic = supportsArithmetic;
            function indexOfExpr(items, searchElement) {
                debug.assertValue(items, 'items');
                debug.assertValue(searchElement, 'searchElement');
                for (var i = 0, len = items.length; i < len; i++) {
                    if (data.SQExpr.equals(items[i], searchElement))
                        return i;
                }
                return -1;
            }
            SQExprUtils.indexOfExpr = indexOfExpr;
            function sequenceEqual(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                var len = x.length;
                if (len !== y.length)
                    return false;
                for (var i = 0; i < len; i++) {
                    if (!data.SQExpr.equals(x[i], y[i]))
                        return false;
                }
                return true;
            }
            SQExprUtils.sequenceEqual = sequenceEqual;
            function uniqueName(namedItems, expr, exprDefaultName) {
                debug.assertValue(namedItems, 'namedItems');
                // Determine all names
                var names = {};
                for (var i = 0, len = namedItems.length; i < len; i++)
                    names[namedItems[i].name] = true;
                return StringExtensions.findUniqueName(names, exprDefaultName || defaultName(expr));
            }
            SQExprUtils.uniqueName = uniqueName;
            /** Generates a default expression name  */
            function defaultName(expr, fallback) {
                if (fallback === void 0) { fallback = 'select'; }
                if (!expr)
                    return fallback;
                return expr.accept(SQExprDefaultNameGenerator.instance, fallback);
            }
            SQExprUtils.defaultName = defaultName;
            /** Gets a value indicating whether the expr is a model measure or an aggregate. */
            function isMeasure(expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(IsMeasureVisitor.instance);
            }
            SQExprUtils.isMeasure = isMeasure;
            /** Gets a value indicating whether the expr is an AnyValue or equals comparison to AnyValue*/
            function isAnyValue(expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(IsAnyValueVisitor.instance);
            }
            SQExprUtils.isAnyValue = isAnyValue;
            /** Gets a value indicating whether the expr is a DefaultValue or equals comparison to DefaultValue*/
            function isDefaultValue(expr) {
                debug.assertValue(expr, 'expr');
                return expr.accept(IsDefaultValueVisitor.instance);
            }
            SQExprUtils.isDefaultValue = isDefaultValue;
            function discourageAggregation(expr, schema) {
                var capabilities = getSchemaCapabilities(expr, schema);
                return capabilities && capabilities.discourageQueryAggregateUsage;
            }
            SQExprUtils.discourageAggregation = discourageAggregation;
            function getAggregateBehavior(expr, schema) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                var column = getConceptualColumn(expr, schema);
                if (column)
                    return column.aggregateBehavior;
            }
            SQExprUtils.getAggregateBehavior = getAggregateBehavior;
            function getSchemaCapabilities(expr, schema) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(schema, 'schema');
                var field = data.SQExprConverter.asFieldPattern(expr);
                if (!field)
                    return;
                var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(field);
                var conceptualSchema = schema.schema(fieldExprItem.schema);
                if (conceptualSchema)
                    return conceptualSchema.capabilities;
            }
            SQExprUtils.getSchemaCapabilities = getSchemaCapabilities;
            function getKpiMetadata(expr, schema) {
                var kpiStatusProperty = getKpiStatusProperty(expr, schema);
                if (kpiStatusProperty)
                    return kpiStatusProperty.kpiValue.measure.kpi.statusMetadata;
                var kpiTrendProperty = getKpiTrendProperty(expr, schema);
                if (kpiTrendProperty)
                    return kpiTrendProperty.kpiValue.measure.kpi.trendMetadata;
            }
            SQExprUtils.getKpiMetadata = getKpiMetadata;
            function getConceptualEntity(entityExpr, schema) {
                debug.assertValue(entityExpr, 'entityExpr');
                var conceptualEntity = schema
                    .schema(entityExpr.schema)
                    .entities
                    .withName(entityExpr.entity);
                return conceptualEntity;
            }
            SQExprUtils.getConceptualEntity = getConceptualEntity;
            function getKpiStatusProperty(expr, schema) {
                var property = expr.getConceptualProperty(schema);
                if (!property)
                    return;
                var kpiValue = property.kpiValue;
                if (kpiValue && kpiValue.measure.kpi.status === property)
                    return property;
            }
            function getKpiTrendProperty(expr, schema) {
                var property = expr.getConceptualProperty(schema);
                if (!property)
                    return;
                var kpiValue = property.kpiValue;
                if (kpiValue && kpiValue.measure.kpi.trend === property)
                    return property;
            }
            function getDefaultValue(fieldSQExpr, schema) {
                var column = getConceptualColumn(fieldSQExpr, schema);
                if (column)
                    return column.defaultValue;
            }
            SQExprUtils.getDefaultValue = getDefaultValue;
            function getConceptualColumn(fieldSQExpr, schema) {
                if (!fieldSQExpr || !schema)
                    return;
                var sqField = data.SQExprConverter.asFieldPattern(fieldSQExpr);
                if (!sqField)
                    return;
                var column = sqField.column;
                if (column) {
                    if (schema.schema(column.schema) && sqField.column.name) {
                        var property = schema.schema(column.schema).findProperty(column.entity, sqField.column.name);
                        if (property)
                            return property.column;
                    }
                }
                else {
                    var hierarchyLevelField = sqField.hierarchyLevel;
                    if (hierarchyLevelField) {
                        var fieldExprItem = data.FieldExprPattern.toFieldExprEntityItemPattern(sqField);
                        var schemaName = fieldExprItem.schema;
                        if (schema.schema(schemaName)) {
                            var hierarchy = schema.schema(schemaName)
                                .findHierarchy(fieldExprItem.entity, hierarchyLevelField.name);
                            if (hierarchy) {
                                var hierarchyLevel = hierarchy.levels.withName(hierarchyLevelField.level);
                                if (hierarchyLevel && hierarchyLevel.column)
                                    return hierarchyLevel.column.column;
                            }
                        }
                    }
                }
            }
            function getDefaultValues(fieldSQExprs, schema) {
                if (_.isEmpty(fieldSQExprs) || !schema)
                    return;
                var result = [];
                for (var _i = 0, fieldSQExprs_2 = fieldSQExprs; _i < fieldSQExprs_2.length; _i++) {
                    var sqExpr = fieldSQExprs_2[_i];
                    var defaultValue = getDefaultValue(sqExpr, schema);
                    if (defaultValue)
                        result.push(defaultValue);
                }
                return result;
            }
            SQExprUtils.getDefaultValues = getDefaultValues;
            /** Return compare or and expression for key value pairs. */
            function getDataViewScopeIdentityComparisonExpr(fieldsExpr, values) {
                debug.assert(fieldsExpr.length === values.length, "fileds and values need to be the same size");
                var compareExprs = [];
                for (var i = 0; i < fieldsExpr.length; i++) {
                    compareExprs.push(data.SQExprBuilder.compare(data.QueryComparisonKind.Equal, fieldsExpr[i], values[i]));
                }
                if (_.isEmpty(compareExprs))
                    return;
                var resultExpr;
                for (var _i = 0, compareExprs_1 = compareExprs; _i < compareExprs_1.length; _i++) {
                    var compareExpr = compareExprs_1[_i];
                    resultExpr = data.SQExprBuilder.and(resultExpr, compareExpr);
                }
                return resultExpr;
            }
            SQExprUtils.getDataViewScopeIdentityComparisonExpr = getDataViewScopeIdentityComparisonExpr;
            function getActiveTablesNames(queryDefn) {
                var tables = [];
                if (queryDefn) {
                    var selectedItems = queryDefn.from();
                    if (selectedItems !== undefined) {
                        for (var _i = 0, _a = selectedItems.keys(); _i < _a.length; _i++) {
                            var key = _a[_i];
                            var entityObj = selectedItems.entity(key);
                            if (tables.indexOf(entityObj.entity) < 0)
                                tables.push(entityObj.entity);
                        }
                    }
                }
                return tables;
            }
            SQExprUtils.getActiveTablesNames = getActiveTablesNames;
            function isRelatedToMany(schema, sourceExpr, targetExpr) {
                return isRelated(schema, sourceExpr, targetExpr, 0 /* ZeroOrOne */, 2 /* Many */) ||
                    isRelated(schema, targetExpr, sourceExpr, 2 /* Many */, 0 /* ZeroOrOne */);
            }
            SQExprUtils.isRelatedToMany = isRelatedToMany;
            function isRelatedToOne(schema, sourceExpr, targetExpr) {
                return isRelated(schema, sourceExpr, targetExpr, 2 /* Many */, 0 /* ZeroOrOne */) ||
                    isRelated(schema, targetExpr, sourceExpr, 0 /* ZeroOrOne */, 2 /* Many */);
            }
            SQExprUtils.isRelatedToOne = isRelatedToOne;
            function isRelated(schema, sourceExpr, targetExpr, sourceMultiplicity, targetMultiplicity) {
                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);
                debug.assertValue(source, "could not resolve conceptual entity form sourceExpr.");
                if (_.isEmpty(source.navigationProperties))
                    return false;
                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);
                debug.assertValue(target, "could not resolve conceptual entity form targetExpr.");
                var queue = [];
                queue.push(source);
                // walk the relationship path from source.
                while (!_.isEmpty(queue)) {
                    var current = queue.shift();
                    var navProperties = current.navigationProperties;
                    if (_.isEmpty(navProperties))
                        continue;
                    for (var _i = 0, navProperties_1 = navProperties; _i < navProperties_1.length; _i++) {
                        var navProperty = navProperties_1[_i];
                        if (!navProperty.isActive)
                            continue;
                        if (navProperty.targetMultiplicity === targetMultiplicity && navProperty.sourceMultiplicity === sourceMultiplicity) {
                            if (navProperty.targetEntity === target)
                                return true;
                            queue.push(navProperty.targetEntity);
                        }
                    }
                }
                return false;
            }
            function isRelatedOneToOne(schema, sourceExpr, targetExpr) {
                var source = SQExprUtils.getConceptualEntity(sourceExpr, schema);
                debug.assertValue(source, "could not resolve conceptual entity form sourceExpr.");
                var target = SQExprUtils.getConceptualEntity(targetExpr, schema);
                debug.assertValue(target, "could not resolve conceptual entity form targetExpr.");
                var sourceNavigations = source.navigationProperties;
                var targetNavigations = target.navigationProperties;
                if (_.isEmpty(sourceNavigations) && _.isEmpty(targetNavigations))
                    return false;
                return hasOneToOneNavigation(sourceNavigations, target) || hasOneToOneNavigation(targetNavigations, source);
            }
            SQExprUtils.isRelatedOneToOne = isRelatedOneToOne;
            function hasOneToOneNavigation(navigationProperties, targetEntity) {
                if (_.isEmpty(navigationProperties))
                    return false;
                for (var _i = 0, navigationProperties_1 = navigationProperties; _i < navigationProperties_1.length; _i++) {
                    var navigationProperty = navigationProperties_1[_i];
                    if (!navigationProperty.isActive)
                        continue;
                    if (navigationProperty.targetEntity !== targetEntity)
                        continue;
                    if (navigationProperty.sourceMultiplicity === 0 /* ZeroOrOne */ &&
                        navigationProperty.targetMultiplicity === 0 /* ZeroOrOne */) {
                        return true;
                    }
                }
                return false;
            }
            /** Performs a union of the 2 arrays with SQExpr.equals as comparator to skip duplicate items,
                and returns a new array. When available, we should use _.unionWith from lodash. */
            function concatUnique(leftExprs, rightExprs) {
                debug.assertValue(leftExprs, 'leftExprs');
                debug.assertValue(rightExprs, 'rightExprs');
                var concatExprs = ArrayExtensions.copy(leftExprs);
                for (var _i = 0, rightExprs_1 = rightExprs; _i < rightExprs_1.length; _i++) {
                    var expr = rightExprs_1[_i];
                    if (indexOfExpr(concatExprs, expr) === -1) {
                        concatExprs.push(expr);
                    }
                }
                return concatExprs;
            }
            SQExprUtils.concatUnique = concatUnique;
            var SQExprDefaultNameGenerator = (function (_super) {
                __extends(SQExprDefaultNameGenerator, _super);
                function SQExprDefaultNameGenerator() {
                    _super.apply(this, arguments);
                }
                SQExprDefaultNameGenerator.prototype.visitEntity = function (expr) {
                    return expr.entity;
                };
                SQExprDefaultNameGenerator.prototype.visitColumnRef = function (expr) {
                    return expr.source.accept(this) + '.' + expr.ref;
                };
                SQExprDefaultNameGenerator.prototype.visitMeasureRef = function (expr, fallback) {
                    return expr.source.accept(this) + '.' + expr.ref;
                };
                SQExprDefaultNameGenerator.prototype.visitAggr = function (expr, fallback) {
                    return data.QueryAggregateFunction[expr.func] + '(' + expr.arg.accept(this) + ')';
                };
                SQExprDefaultNameGenerator.prototype.visitArithmetic = function (expr, fallback) {
                    return powerbi.data.getArithmeticOperatorName(expr.operator) + '(' + expr.left.accept(this) + ', ' + expr.right.accept(this) + ')';
                };
                SQExprDefaultNameGenerator.prototype.visitConstant = function (expr) {
                    return 'const';
                };
                SQExprDefaultNameGenerator.prototype.visitDefault = function (expr, fallback) {
                    return fallback || 'expr';
                };
                SQExprDefaultNameGenerator.instance = new SQExprDefaultNameGenerator();
                return SQExprDefaultNameGenerator;
            }(data.DefaultSQExprVisitorWithArg));
            var IsMeasureVisitor = (function (_super) {
                __extends(IsMeasureVisitor, _super);
                function IsMeasureVisitor() {
                    _super.apply(this, arguments);
                }
                IsMeasureVisitor.prototype.visitMeasureRef = function (expr) {
                    return true;
                };
                IsMeasureVisitor.prototype.visitAggr = function (expr) {
                    return true;
                };
                IsMeasureVisitor.prototype.visitArithmetic = function (expr) {
                    return true;
                };
                IsMeasureVisitor.prototype.visitDefault = function (expr) {
                    return false;
                };
                IsMeasureVisitor.instance = new IsMeasureVisitor();
                return IsMeasureVisitor;
            }(data.DefaultSQExprVisitor));
            var IsDefaultValueVisitor = (function (_super) {
                __extends(IsDefaultValueVisitor, _super);
                function IsDefaultValueVisitor() {
                    _super.apply(this, arguments);
                }
                IsDefaultValueVisitor.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== data.QueryComparisonKind.Equal)
                        return false;
                    return expr.right.accept(this);
                };
                IsDefaultValueVisitor.prototype.visitAnd = function (expr) {
                    return expr.left.accept(this) && expr.right.accept(this);
                };
                IsDefaultValueVisitor.prototype.visitDefaultValue = function (expr) {
                    return true;
                };
                IsDefaultValueVisitor.prototype.visitDefault = function (expr) {
                    return false;
                };
                IsDefaultValueVisitor.instance = new IsDefaultValueVisitor();
                return IsDefaultValueVisitor;
            }(data.DefaultSQExprVisitor));
            var IsAnyValueVisitor = (function (_super) {
                __extends(IsAnyValueVisitor, _super);
                function IsAnyValueVisitor() {
                    _super.apply(this, arguments);
                }
                IsAnyValueVisitor.prototype.visitCompare = function (expr) {
                    if (expr.comparison !== data.QueryComparisonKind.Equal)
                        return false;
                    return expr.right.accept(this);
                };
                IsAnyValueVisitor.prototype.visitAnd = function (expr) {
                    return expr.left.accept(this) && expr.right.accept(this);
                };
                IsAnyValueVisitor.prototype.visitAnyValue = function (expr) {
                    return true;
                };
                IsAnyValueVisitor.prototype.visitDefault = function (expr) {
                    return false;
                };
                IsAnyValueVisitor.instance = new IsAnyValueVisitor();
                return IsAnyValueVisitor;
            }(data.DefaultSQExprVisitor));
        })(SQExprUtils = data.SQExprUtils || (data.SQExprUtils = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SemanticQueryRewriter = (function () {
            function SemanticQueryRewriter(exprRewriter) {
                this.exprRewriter = exprRewriter;
            }
            SemanticQueryRewriter.prototype.rewriteFrom = function (fromValue) {
                var fromContents = {};
                var originalFrom = fromValue, originalFromKeys = originalFrom.keys();
                for (var i = 0, len = originalFromKeys.length; i < len; i++) {
                    var keyName = originalFromKeys[i], originalEntityRef = originalFrom.entity(keyName), originalEntityExpr = data.SQExprBuilder.entity(originalEntityRef.schema, originalEntityRef.entity, keyName), updatedEntityExpr = originalEntityExpr.accept(this.exprRewriter);
                    fromContents[keyName] = {
                        schema: updatedEntityExpr.schema,
                        entity: updatedEntityExpr.entity,
                    };
                }
                return new data.SQFrom(fromContents);
            };
            SemanticQueryRewriter.prototype.rewriteSelect = function (selectItems, from) {
                debug.assertValue(selectItems, 'selectItems');
                debug.assertValue(from, 'from');
                return this.rewriteNamedSQExpressions(selectItems, from);
            };
            SemanticQueryRewriter.prototype.rewriteGroupBy = function (groupByitems, from) {
                debug.assertAnyValue(groupByitems, 'groupByitems');
                debug.assertValue(from, 'from');
                if (_.isEmpty(groupByitems))
                    return;
                return this.rewriteNamedSQExpressions(groupByitems, from);
            };
            SemanticQueryRewriter.prototype.rewriteNamedSQExpressions = function (expressions, from) {
                var _this = this;
                debug.assertValue(expressions, 'expressions');
                return _.map(expressions, function (item) {
                    return {
                        name: item.name,
                        expr: data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(_this.exprRewriter), from)
                    };
                });
            };
            SemanticQueryRewriter.prototype.rewriteOrderBy = function (orderByItems, from) {
                debug.assertAnyValue(orderByItems, 'orderByItems');
                debug.assertValue(from, 'from');
                if (_.isEmpty(orderByItems))
                    return;
                var orderBy = [];
                for (var i = 0, len = orderByItems.length; i < len; i++) {
                    var item = orderByItems[i], updatedExpr = data.SQExprRewriterWithSourceRenames.rewrite(item.expr.accept(this.exprRewriter), from);
                    orderBy.push({
                        direction: item.direction,
                        expr: updatedExpr,
                    });
                }
                return orderBy;
            };
            SemanticQueryRewriter.prototype.rewriteWhere = function (whereItems, from) {
                var _this = this;
                debug.assertAnyValue(whereItems, 'whereItems');
                debug.assertValue(from, 'from');
                if (_.isEmpty(whereItems))
                    return;
                var where = [];
                for (var i = 0, len = whereItems.length; i < len; i++) {
                    var originalWhere = whereItems[i];
                    var updatedWhere = {
                        condition: data.SQExprRewriterWithSourceRenames.rewrite(originalWhere.condition.accept(this.exprRewriter), from),
                    };
                    if (originalWhere.target)
                        updatedWhere.target = _.map(originalWhere.target, function (e) { return data.SQExprRewriterWithSourceRenames.rewrite(e.accept(_this.exprRewriter), from); });
                    where.push(updatedWhere);
                }
                return where;
            };
            return SemanticQueryRewriter;
        }());
        data.SemanticQueryRewriter = SemanticQueryRewriter;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /**
         * Represents a semantic query that is:
         * 1) Round-trippable with a JSON QueryDefinition.
         * 2) Immutable
         * 3) Long-lived and does not have strong references to a conceptual model (only names).
         */
        var SemanticQuery = (function () {
            function SemanticQuery(from, where, orderBy, select, groupBy) {
                debug.assertValue(from, 'from');
                debug.assertValue(select, 'select');
                this.fromValue = from;
                this.whereItems = where;
                this.orderByItems = orderBy;
                this.selectItems = select;
                this.groupByItems = groupBy;
            }
            SemanticQuery.create = function () {
                if (!SemanticQuery.empty)
                    SemanticQuery.empty = new SemanticQuery(new SQFrom(), null, null, [], null);
                return SemanticQuery.empty;
            };
            SemanticQuery.createWithTrimmedFrom = function (from, where, orderBy, select, groupBy) {
                var unreferencedKeyFinder = new UnreferencedKeyFinder(from.keys());
                // Where
                if (where) {
                    for (var i = 0, len = where.length; i < len; i++) {
                        var filter = where[i];
                        filter.condition.accept(unreferencedKeyFinder);
                        var filterTarget = filter.target;
                        if (filterTarget) {
                            for (var j = 0, jlen = filterTarget.length; j < jlen; j++)
                                if (filterTarget[j])
                                    filterTarget[j].accept(unreferencedKeyFinder);
                        }
                    }
                }
                // OrderBy
                if (orderBy) {
                    for (var i = 0, len = orderBy.length; i < len; i++)
                        orderBy[i].expr.accept(unreferencedKeyFinder);
                }
                // Select
                for (var i = 0, len = select.length; i < len; i++)
                    select[i].expr.accept(unreferencedKeyFinder);
                // GroupBy
                if (groupBy) {
                    for (var i = 0, len = groupBy.length; i < len; i++)
                        groupBy[i].expr.accept(unreferencedKeyFinder);
                }
                var unreferencedKeys = unreferencedKeyFinder.result();
                for (var i = 0, len = unreferencedKeys.length; i < len; i++)
                    from.remove(unreferencedKeys[i]);
                return new SemanticQuery(from, where, orderBy, select, groupBy);
            };
            SemanticQuery.prototype.from = function () {
                return this.fromValue.clone();
            };
            SemanticQuery.prototype.select = function (values) {
                if (_.isEmpty(arguments))
                    return this.getSelect();
                return this.setSelect(values);
            };
            SemanticQuery.prototype.getSelect = function () {
                return SemanticQuery.createNamedExpressionArray(this.selectItems);
            };
            SemanticQuery.createNamedExpressionArray = function (items) {
                return ArrayExtensions.extendWithName(_.map(items, function (s) {
                    return {
                        name: s.name,
                        expr: s.expr,
                    };
                }));
            };
            SemanticQuery.prototype.setSelect = function (values) {
                var from = this.fromValue.clone();
                var selectItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);
            };
            SemanticQuery.rewriteExpressionsWithSourceRenames = function (values, from) {
                var items = [];
                for (var i = 0, len = values.length; i < len; i++) {
                    var value = values[i];
                    items.push({
                        name: value.name,
                        expr: SQExprRewriterWithSourceRenames.rewrite(value.expr, from)
                    });
                }
                return items;
            };
            /** Removes the given expression from the select. */
            SemanticQuery.prototype.removeSelect = function (expr) {
                debug.assertValue(expr, 'expr');
                var originalItems = this.selectItems, selectItems = [];
                for (var i = 0, len = originalItems.length; i < len; i++) {
                    var originalExpr = originalItems[i];
                    if (data.SQExpr.equals(originalExpr.expr, expr))
                        continue;
                    selectItems.push(originalExpr);
                }
                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, this.orderByItems, selectItems, this.groupByItems);
            };
            /** Removes the given expression from order by. */
            SemanticQuery.prototype.removeOrderBy = function (expr) {
                var sorts = this.orderBy();
                for (var i = sorts.length - 1; i >= 0; i--) {
                    if (data.SQExpr.equals(sorts[i].expr, expr))
                        sorts.splice(i, 1);
                }
                return SemanticQuery.createWithTrimmedFrom(this.fromValue.clone(), this.whereItems, sorts, this.selectItems, this.groupByItems);
            };
            SemanticQuery.prototype.selectNameOf = function (expr) {
                var index = data.SQExprUtils.indexOfExpr(_.map(this.selectItems, function (s) { return s.expr; }), expr);
                if (index >= 0)
                    return this.selectItems[index].name;
            };
            SemanticQuery.prototype.setSelectAt = function (index, expr) {
                debug.assertValue(expr, 'expr');
                if (index >= this.selectItems.length)
                    return;
                var select = this.select(), from = this.fromValue.clone(), originalName = select[index].name;
                select[index] = {
                    name: originalName,
                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)
                };
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, select, this.groupByItems);
            };
            /** Adds a the expression to the select clause. */
            SemanticQuery.prototype.addSelect = function (expr, exprName) {
                debug.assertValue(expr, 'expr');
                var selectItems = this.select(), from = this.fromValue.clone();
                selectItems.push(this.createNamedExpr(selectItems, from, expr, exprName));
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, selectItems, this.groupByItems);
            };
            SemanticQuery.prototype.createNamedExpr = function (currentNames, from, expr, exprName) {
                return {
                    name: data.SQExprUtils.uniqueName(currentNames, expr, exprName),
                    expr: SQExprRewriterWithSourceRenames.rewrite(expr, from)
                };
            };
            SemanticQuery.prototype.groupBy = function (values) {
                if (_.isEmpty(arguments))
                    return this.getGroupBy();
                return this.setGroupBy(values);
            };
            SemanticQuery.prototype.getGroupBy = function () {
                return SemanticQuery.createNamedExpressionArray(this.groupByItems);
            };
            SemanticQuery.prototype.setGroupBy = function (values) {
                var from = this.fromValue.clone();
                var groupByItems = SemanticQuery.rewriteExpressionsWithSourceRenames(values, from);
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);
            };
            SemanticQuery.prototype.addGroupBy = function (expr) {
                debug.assertValue(expr, 'expr');
                var groupByItems = this.groupBy(), from = this.fromValue.clone();
                groupByItems.push(this.createNamedExpr(groupByItems, from, expr));
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, this.orderByItems, this.selectItems, groupByItems);
            };
            SemanticQuery.prototype.orderBy = function (values) {
                if (_.isEmpty(arguments))
                    return this.getOrderBy();
                return this.setOrderBy(values);
            };
            SemanticQuery.prototype.getOrderBy = function () {
                var result = [];
                var orderBy = this.orderByItems;
                if (orderBy) {
                    for (var i = 0, len = orderBy.length; i < len; i++) {
                        var clause = orderBy[i];
                        result.push({
                            expr: clause.expr,
                            direction: clause.direction,
                        });
                    }
                }
                return result;
            };
            SemanticQuery.prototype.setOrderBy = function (values) {
                debug.assertValue(values, 'values');
                var updatedOrderBy = [], from = this.fromValue.clone();
                for (var i = 0, len = values.length; i < len; i++) {
                    var clause = values[i];
                    updatedOrderBy.push({
                        expr: SQExprRewriterWithSourceRenames.rewrite(clause.expr, from),
                        direction: clause.direction,
                    });
                }
                return SemanticQuery.createWithTrimmedFrom(from, this.whereItems, updatedOrderBy, this.selectItems, this.groupByItems);
            };
            SemanticQuery.prototype.where = function (values) {
                if (_.isEmpty(arguments))
                    return this.getWhere();
                return this.setWhere(values);
            };
            SemanticQuery.prototype.getWhere = function () {
                var result = [];
                var whereItems = this.whereItems;
                if (whereItems) {
                    for (var i = 0, len = whereItems.length; i < len; i++)
                        result.push(whereItems[i]);
                }
                return result;
            };
            SemanticQuery.prototype.setWhere = function (values) {
                debug.assertValue(values, 'values');
                var updatedWhere = [], from = this.fromValue.clone();
                for (var i = 0, len = values.length; i < len; i++) {
                    var filter = values[i];
                    var updatedFilter = {
                        condition: SQExprRewriterWithSourceRenames.rewrite(filter.condition, from),
                    };
                    var filterTarget = filter.target;
                    if (filterTarget) {
                        updatedFilter.target = [];
                        for (var j = 0, jlen = filterTarget.length; j < jlen; j++)
                            if (filterTarget[j]) {
                                var updatedTarget = SQExprRewriterWithSourceRenames.rewrite(filterTarget[j], from);
                                updatedFilter.target.push(updatedTarget);
                            }
                    }
                    updatedWhere.push(updatedFilter);
                }
                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);
            };
            SemanticQuery.prototype.addWhere = function (filter) {
                debug.assertValue(filter, 'filter');
                var updatedWhere = this.where(), incomingWhere = filter.where(), from = this.fromValue.clone();
                for (var i = 0, len = incomingWhere.length; i < len; i++) {
                    var clause = incomingWhere[i];
                    var updatedClause = {
                        condition: SQExprRewriterWithSourceRenames.rewrite(clause.condition, from),
                    };
                    if (clause.target)
                        updatedClause.target = _.map(clause.target, function (t) { return SQExprRewriterWithSourceRenames.rewrite(t, from); });
                    updatedWhere.push(updatedClause);
                }
                return SemanticQuery.createWithTrimmedFrom(from, updatedWhere, this.orderByItems, this.selectItems, this.groupByItems);
            };
            SemanticQuery.prototype.rewrite = function (exprRewriter) {
                var rewriter = new data.SemanticQueryRewriter(exprRewriter);
                var from = rewriter.rewriteFrom(this.fromValue);
                var where = rewriter.rewriteWhere(this.whereItems, from);
                var orderBy = rewriter.rewriteOrderBy(this.orderByItems, from);
                var select = rewriter.rewriteSelect(this.selectItems, from);
                var groupBy = rewriter.rewriteGroupBy(this.groupByItems, from);
                return SemanticQuery.createWithTrimmedFrom(from, where, orderBy, select, groupBy);
            };
            return SemanticQuery;
        }());
        data.SemanticQuery = SemanticQuery;
        /** Represents a semantic filter condition.  Round-trippable with a JSON FilterDefinition.  Instances of this class are immutable. */
        var SemanticFilter = (function () {
            function SemanticFilter(from, where) {
                debug.assertValue(from, 'from');
                debug.assertValue(where, 'where');
                this.fromValue = from;
                this.whereItems = where;
            }
            SemanticFilter.fromSQExpr = function (contract) {
                debug.assertValue(contract, 'contract');
                var from = new SQFrom();
                var rewrittenContract = SQExprRewriterWithSourceRenames.rewrite(contract, from);
                // DEVNOTE targets of some filters are visual specific and will get resolved only during query generation.
                //         Thus not setting a target here.
                var where = [{
                        condition: rewrittenContract
                    }];
                return new SemanticFilter(from, where);
            };
            SemanticFilter.getDefaultValueFilter = function (fieldSQExprs) {
                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.defaultValue());
            };
            SemanticFilter.getAnyValueFilter = function (fieldSQExprs) {
                return SemanticFilter.getDataViewScopeIdentityComparisonFilters(fieldSQExprs, data.SQExprBuilder.anyValue());
            };
            SemanticFilter.getDataViewScopeIdentityComparisonFilters = function (fieldSQExprs, value) {
                debug.assertValue(fieldSQExprs, 'fieldSQExprs');
                debug.assertValue(value, 'value');
                if (fieldSQExprs instanceof Array) {
                    var values = Array.apply(null, Array(fieldSQExprs.length)).map(function () { return value; });
                    return SemanticFilter.fromSQExpr(data.SQExprUtils.getDataViewScopeIdentityComparisonExpr(fieldSQExprs, values));
                }
                return SemanticFilter.fromSQExpr(data.SQExprBuilder.equal(fieldSQExprs, value));
            };
            SemanticFilter.prototype.from = function () {
                return this.fromValue.clone();
            };
            SemanticFilter.prototype.conditions = function () {
                var expressions = [];
                var where = this.whereItems;
                for (var i = 0, len = where.length; i < len; i++) {
                    var filter = where[i];
                    expressions.push(filter.condition);
                }
                return expressions;
            };
            SemanticFilter.prototype.where = function () {
                var result = [];
                var whereItems = this.whereItems;
                for (var i = 0, len = whereItems.length; i < len; i++)
                    result.push(whereItems[i]);
                return result;
            };
            SemanticFilter.prototype.rewrite = function (exprRewriter) {
                var rewriter = new data.SemanticQueryRewriter(exprRewriter);
                var from = rewriter.rewriteFrom(this.fromValue);
                var where = rewriter.rewriteWhere(this.whereItems, from);
                return new SemanticFilter(from, where);
            };
            SemanticFilter.prototype.validate = function (schema, aggrUtils, errors) {
                var validator = new data.SQExprValidationVisitor(schema, aggrUtils, errors);
                this.rewrite(validator);
                return validator.errors;
            };
            /** Merges a list of SemanticFilters into one. */
            SemanticFilter.merge = function (filters) {
                if (_.isEmpty(filters))
                    return null;
                if (filters.length === 1)
                    return filters[0];
                var firstFilter = filters[0];
                var from = firstFilter.from(), where = ArrayExtensions.take(firstFilter.whereItems, firstFilter.whereItems.length);
                for (var i = 1, len = filters.length; i < len; i++)
                    SemanticFilter.applyFilter(filters[i], from, where);
                return new SemanticFilter(from, where);
            };
            SemanticFilter.isDefaultFilter = function (filter) {
                if (!filter || filter.where().length !== 1)
                    return false;
                return data.SQExprUtils.isDefaultValue(filter.where()[0].condition);
            };
            SemanticFilter.isAnyFilter = function (filter) {
                if (!filter || filter.where().length !== 1)
                    return false;
                return data.SQExprUtils.isAnyValue(filter.where()[0].condition);
            };
            SemanticFilter.isSameFilter = function (leftFilter, rightFilter) {
                if (jsCommon.JsonComparer.equals(leftFilter, rightFilter)) {
                    return !((SemanticFilter.isDefaultFilter(leftFilter) && SemanticFilter.isAnyFilter(rightFilter))
                        || (SemanticFilter.isAnyFilter(leftFilter) && SemanticFilter.isDefaultFilter(rightFilter)));
                }
                return false;
            };
            SemanticFilter.applyFilter = function (filter, from, where) {
                debug.assertValue(filter, 'filter');
                debug.assertValue(from, 'from');
                debug.assertValue(where, 'where');
                // Where
                var filterWhereItems = filter.whereItems;
                for (var i = 0; i < filterWhereItems.length; i++) {
                    var filterWhereItem = filterWhereItems[i];
                    var updatedWhereItem = {
                        condition: SQExprRewriterWithSourceRenames.rewrite(filterWhereItem.condition, from),
                    };
                    if (filterWhereItem.target)
                        updatedWhereItem.target = _.map(filterWhereItem.target, function (e) { return SQExprRewriterWithSourceRenames.rewrite(e, from); });
                    where.push(updatedWhereItem);
                }
            };
            return SemanticFilter;
        }());
        data.SemanticFilter = SemanticFilter;
        /** Represents a SemanticQuery/SemanticFilter from clause. */
        var SQFrom = (function () {
            function SQFrom(items) {
                this.items = items || {};
            }
            SQFrom.prototype.keys = function () {
                return Object.keys(this.items);
            };
            SQFrom.prototype.entity = function (key) {
                return this.items[key];
            };
            SQFrom.prototype.ensureEntity = function (entity, desiredVariableName) {
                debug.assertValue(entity, 'entity');
                // 1) Reuse a reference to the entity among the already referenced
                var keys = this.keys();
                for (var i_1 = 0, len = keys.length; i_1 < len; i_1++) {
                    var key = keys[i_1], item = this.items[key];
                    if (item && entity.entity === item.entity && entity.schema === item.schema)
                        return { name: key };
                }
                // 2) Add a reference to the entity
                var candidateName = desiredVariableName || this.candidateName(entity.entity), uniqueName = candidateName, i = 2;
                while (this.items[uniqueName]) {
                    uniqueName = candidateName + i++;
                }
                this.items[uniqueName] = entity;
                return { name: uniqueName, new: true };
            };
            SQFrom.prototype.remove = function (key) {
                delete this.items[key];
            };
            /** Converts the entity name into a short reference name.  Follows the Semantic Query convention of a short name. */
            SQFrom.prototype.candidateName = function (ref) {
                debug.assertValue(ref, 'ref');
                var idx = ref.lastIndexOf('.');
                if (idx >= 0 && (idx !== ref.length - 1))
                    ref = ref.substr(idx + 1);
                return ref.substring(0, 1).toLowerCase();
            };
            SQFrom.prototype.clone = function () {
                // NOTE: consider deprecating this method and instead making QueryFrom be CopyOnWrite (currently we proactively clone).
                var cloned = new SQFrom();
                // NOTE: we use extend rather than prototypical inheritance on items because we use Object.keys.
                $.extend(cloned.items, this.items);
                return cloned;
            };
            return SQFrom;
        }());
        data.SQFrom = SQFrom;
        var SQExprRewriterWithSourceRenames = (function (_super) {
            __extends(SQExprRewriterWithSourceRenames, _super);
            function SQExprRewriterWithSourceRenames(renames) {
                debug.assertValue(renames, 'renames');
                _super.call(this);
                this.renames = renames;
            }
            SQExprRewriterWithSourceRenames.prototype.visitEntity = function (expr) {
                var updatedName = this.renames[expr.entity];
                if (updatedName)
                    return new data.SQEntityExpr(expr.schema, expr.entity, updatedName);
                return _super.prototype.visitEntity.call(this, expr);
            };
            SQExprRewriterWithSourceRenames.prototype.rewriteFilter = function (filter) {
                debug.assertValue(filter, 'filter');
                var updatedTargets = undefined;
                if (filter.target)
                    updatedTargets = this.rewriteArray(filter.target);
                var updatedCondition = filter.condition.accept(this);
                if (filter.condition === updatedCondition && filter.target === updatedTargets)
                    return filter;
                var updatedFilter = {
                    condition: updatedCondition,
                };
                if (updatedTargets)
                    updatedFilter.target = updatedTargets;
                return updatedFilter;
            };
            SQExprRewriterWithSourceRenames.prototype.rewriteArray = function (exprs) {
                debug.assertValue(exprs, 'exprs');
                var updatedExprs;
                for (var i = 0, len = exprs.length; i < len; i++) {
                    var expr = exprs[i], rewrittenExpr = expr.accept(this);
                    if (expr !== rewrittenExpr && !updatedExprs)
                        updatedExprs = ArrayExtensions.take(exprs, i);
                    if (updatedExprs)
                        updatedExprs.push(rewrittenExpr);
                }
                return updatedExprs || exprs;
            };
            SQExprRewriterWithSourceRenames.rewrite = function (expr, from) {
                debug.assertValue(expr, 'expr');
                debug.assertValue(from, 'from');
                var renames = QuerySourceRenameDetector.run(expr, from);
                var rewriter = new SQExprRewriterWithSourceRenames(renames);
                return expr.accept(rewriter);
            };
            return SQExprRewriterWithSourceRenames;
        }(data.SQExprRewriter));
        data.SQExprRewriterWithSourceRenames = SQExprRewriterWithSourceRenames;
        /** Responsible for updating a QueryFrom based on SQExpr references. */
        var QuerySourceRenameDetector = (function (_super) {
            __extends(QuerySourceRenameDetector, _super);
            function QuerySourceRenameDetector(from) {
                debug.assertValue(from, 'from');
                _super.call(this);
                this.from = from;
                this.renames = {};
            }
            QuerySourceRenameDetector.run = function (expr, from) {
                var detector = new QuerySourceRenameDetector(from);
                expr.accept(detector);
                return detector.renames;
            };
            QuerySourceRenameDetector.prototype.visitEntity = function (expr) {
                // TODO: Renames must take the schema into account, not just entity set name.
                var existingEntity = this.from.entity(expr.variable);
                if (existingEntity && existingEntity.schema === expr.schema && existingEntity.entity === expr.entity)
                    return;
                var actualEntity = this.from.ensureEntity({
                    schema: expr.schema,
                    entity: expr.entity,
                }, expr.variable);
                this.renames[expr.entity] = actualEntity.name;
            };
            return QuerySourceRenameDetector;
        }(data.DefaultSQExprVisitorWithTraversal));
        /** Visitor for finding unreferenced sources. */
        var UnreferencedKeyFinder = (function (_super) {
            __extends(UnreferencedKeyFinder, _super);
            function UnreferencedKeyFinder(keys) {
                debug.assertValue(keys, 'keys');
                _super.call(this);
                this.keys = keys;
            }
            UnreferencedKeyFinder.prototype.visitEntity = function (expr) {
                var index = this.keys.indexOf(expr.variable);
                if (index >= 0)
                    this.keys.splice(index, 1);
            };
            UnreferencedKeyFinder.prototype.result = function () {
                return this.keys;
            };
            return UnreferencedKeyFinder;
        }(data.DefaultSQExprVisitorWithTraversal));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data_4) {
        var DataViewTransform = powerbi.data.DataViewTransform;
        var SQExprBuilder = powerbi.data.SQExprBuilder;
        function createCategoricalDataViewBuilder() {
            return new CategoricalDataViewBuilder();
        }
        data_4.createCategoricalDataViewBuilder = createCategoricalDataViewBuilder;
        var CategoricalDataViewBuilder = (function () {
            function CategoricalDataViewBuilder() {
                this.categories = [];
                this.measureColumns = [];
                this.columnIndex = 0;
            }
            CategoricalDataViewBuilder.prototype.withCategory = function (options) {
                var categoryValues = options.values, identityFrom = options.identityFrom, type = options.source.type;
                var categoryColumn = {
                    source: options.source,
                    identityFields: options.identityFrom.fields,
                    identity: options.identityFrom.identities || [],
                    values: categoryValues,
                };
                if (!options.identityFrom.identities) {
                    for (var categoryIndex = 0, categoryLength = categoryValues.length; categoryIndex < categoryLength; categoryIndex++) {
                        categoryColumn.identity.push(getScopeIdentity(identityFrom, categoryIndex, categoryValues[categoryIndex], type));
                    }
                }
                if (!this.categories)
                    this.categories = [];
                this.categories.push(categoryColumn);
                return this;
            };
            CategoricalDataViewBuilder.prototype.withCategories = function (categories) {
                if (_.isEmpty(this.categories))
                    this.categories = categories;
                else
                    Array.prototype.push.apply(this.categories, categories);
                return this;
            };
            CategoricalDataViewBuilder.prototype.withValues = function (options) {
                debug.assertValue(options, 'options');
                var columns = options.columns;
                debug.assertValue(columns, 'columns');
                for (var _i = 0, columns_8 = columns; _i < columns_8.length; _i++) {
                    var column = columns_8[_i];
                    this.measureColumns.push(column.source);
                }
                this.data = columns;
                return this;
            };
            CategoricalDataViewBuilder.prototype.withGroupedValues = function (options) {
                debug.assertValue(options, 'options');
                this.hasDynamicSeries = true;
                var groupColumn = options.groupColumn;
                debug.assertValue(groupColumn, 'groupColumn');
                this.dynamicSeriesMetadata = {
                    column: groupColumn.source,
                    identityFrom: groupColumn.identityFrom,
                    values: groupColumn.values,
                };
                var valueColumns = options.valueColumns;
                for (var _i = 0, valueColumns_1 = valueColumns; _i < valueColumns_1.length; _i++) {
                    var valueColumn = valueColumns_1[_i];
                    this.measureColumns.push(valueColumn.source);
                }
                this.data = options.data;
                return this;
            };
            CategoricalDataViewBuilder.prototype.fillData = function (dataViewValues, groups) {
                var categoryColumn = _.first(this.categories);
                var categoryLength = (categoryColumn && categoryColumn.values) ? categoryColumn.values.length : 1;
                if (this.hasDynamicSeries) {
                    // Dynamic series
                    var data_5 = this.data;
                    for (var seriesIndex = 0; seriesIndex < this.dynamicSeriesMetadata.values.length; seriesIndex++) {
                        var seriesMeasures = data_5[seriesIndex];
                        debug.assert(seriesMeasures.length === this.measureColumns.length, 'seriesMeasures.length === this.measureColumns.length');
                        for (var measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {
                            var groupIndex = seriesIndex * measuresLen + measureIndex;
                            applySeriesData(dataViewValues[groupIndex], seriesMeasures[measureIndex], categoryLength);
                        }
                    }
                }
                else {
                    // Static series
                    var data_6 = this.data;
                    for (var measureIndex = 0, measuresLen = this.measureColumns.length; measureIndex < measuresLen; measureIndex++) {
                        applySeriesData(dataViewValues[measureIndex], data_6[measureIndex], categoryLength);
                    }
                }
            };
            CategoricalDataViewBuilder.prototype.build = function () {
                var metadataColumns = [];
                var categorical = {};
                var groups;
                var categoryMetadata = this.categories;
                var dynamicSeriesMetadata = this.dynamicSeriesMetadata;
                // --- Build metadata columns and value groups ---
                for (var _i = 0, categoryMetadata_1 = categoryMetadata; _i < categoryMetadata_1.length; _i++) {
                    var columnMetadata = categoryMetadata_1[_i];
                    pushIfNotExists(metadataColumns, columnMetadata.source);
                }
                if (this.hasDynamicSeries) {
                    pushIfNotExists(metadataColumns, dynamicSeriesMetadata.column);
                }
                if (this.hasDynamicSeries) {
                    // Dynamic series
                    categorical.values = DataViewTransform.createValueColumns([], dynamicSeriesMetadata.identityFrom.fields, dynamicSeriesMetadata.column);
                    var measures = this.measureColumns;
                    groups = [];
                    // For each series value we will make one column per measure
                    var seriesValues = dynamicSeriesMetadata.values;
                    for (var seriesIndex = 0; seriesIndex < seriesValues.length; seriesIndex++) {
                        var seriesValue = seriesValues[seriesIndex];
                        var seriesIdentity = getScopeIdentity(dynamicSeriesMetadata.identityFrom, seriesIndex, seriesValue, dynamicSeriesMetadata.column.type);
                        for (var _a = 0, measures_1 = measures; _a < measures_1.length; _a++) {
                            var measure = measures_1[_a];
                            var column = _.clone(measure);
                            column.groupName = seriesValue;
                            groups.push(column);
                            pushIfNotExists(metadataColumns, column);
                            categorical.values.push({
                                source: column,
                                values: [],
                                identity: seriesIdentity,
                            });
                        }
                    }
                }
                else {
                    // Static series / no series
                    categorical.values = DataViewTransform.createValueColumns();
                    groups = this.measureColumns;
                    for (var _b = 0, groups_2 = groups; _b < groups_2.length; _b++) {
                        var measure = groups_2[_b];
                        var column = measure;
                        pushIfNotExists(metadataColumns, column);
                        categorical.values.push({
                            source: column,
                            values: [],
                        });
                    }
                }
                var categories = this.categories;
                if (!_.isEmpty(categories))
                    categorical.categories = categories;
                // --- Fill in data point values ---
                this.fillData(categorical.values, groups);
                return {
                    metadata: {
                        columns: metadataColumns,
                    },
                    categorical: categorical,
                };
            };
            return CategoricalDataViewBuilder;
        }());
        function getScopeIdentity(source, index, value, valueType) {
            var identities = source.identities;
            if (identities) {
                return identities[index];
            }
            debug.assert(source.fields && source.fields.length === 1, 'Inferring identity, expect exactly one field.');
            return data_4.createDataViewScopeIdentity(SQExprBuilder.equal(source.fields[0], SQExprBuilder.typedConstant(value, valueType)));
        }
        function pushIfNotExists(items, itemToAdd) {
            if (_.contains(items, itemToAdd))
                return;
            items.push(itemToAdd);
        }
        function applySeriesData(target, source, categoryLength) {
            debug.assertValue(target, 'target');
            debug.assertValue(source, 'source');
            debug.assertValue(categoryLength, 'categoryLength');
            var values = source.values;
            debug.assert(categoryLength === values.length, 'categoryLength === values.length');
            target.values = values;
            var highlights = source.highlights;
            if (highlights) {
                debug.assert(categoryLength === highlights.length, 'categoryLength === highlights.length');
                target.highlights = highlights;
            }
            if (source.minLocal !== undefined)
                target.minLocal = source.minLocal;
            if (source.maxLocal !== undefined)
                target.maxLocal = source.maxLocal;
        }
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        var SQExpr = powerbi.data.SQExpr;
        function createStaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {
            return new StaticEvalContext(colorAllocatorCache || data.createColorAllocatorCache(), dataView || { metadata: { columns: [] } }, selectTransforms);
        }
        data.createStaticEvalContext = createStaticEvalContext;
        /**
         * Represents an eval context over a potentially empty DataView.  Only static repetition data view objects
         * are supported.
         */
        var StaticEvalContext = (function () {
            function StaticEvalContext(colorAllocatorCache, dataView, selectTransforms) {
                debug.assertValue(colorAllocatorCache, 'colorAllocatorCache');
                debug.assertValue(dataView, 'dataView');
                debug.assertAnyValue(selectTransforms, 'selectTransforms');
                this.colorAllocatorCache = colorAllocatorCache;
                this.dataView = dataView;
                this.selectTransforms = selectTransforms;
            }
            StaticEvalContext.prototype.getColorAllocator = function (expr) {
                return this.colorAllocatorCache.get(expr);
            };
            StaticEvalContext.prototype.getExprValue = function (expr) {
                var dataView = this.dataView, selectTransforms = this.selectTransforms;
                if (dataView && dataView.table && selectTransforms)
                    return getExprValueFromTable(expr, selectTransforms, dataView.table, /*rowIdx*/ 0);
            };
            StaticEvalContext.prototype.getRoleValue = function (roleName) {
                return;
            };
            return StaticEvalContext;
        }());
        function getExprValueFromTable(expr, selectTransforms, table, rowIdx) {
            debug.assertValue(expr, 'expr');
            debug.assertValue(selectTransforms, 'selectTransforms');
            debug.assertValue(table, 'table');
            debug.assertValue(rowIdx, 'rowIdx');
            var rows = table.rows;
            if (_.isEmpty(rows) || rows.length <= rowIdx)
                return;
            var cols = table.columns;
            for (var selectIdx = 0, selectLen = selectTransforms.length; selectIdx < selectLen; selectIdx++) {
                var selectTransform = selectTransforms[selectIdx];
                if (!SQExpr.equals(selectTransform.expr, expr) || !selectTransform.queryName)
                    continue;
                for (var colIdx = 0, colLen = cols.length; colIdx < colLen; colIdx++) {
                    if (selectIdx !== cols[colIdx].index)
                        continue;
                    return rows[rowIdx][colIdx];
                }
            }
        }
        data.getExprValueFromTable = getExprValueFromTable;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        function createMatrixEvalContext(colorAllocatorProvider, dataViewMatrix) {
            // NOTE: Matrix context-sensitive evaluation is not yet implemented.
            return data.createStaticEvalContext(colorAllocatorProvider);
        }
        data.createMatrixEvalContext = createMatrixEvalContext;
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi_1) {
    var StringExtensions = jsCommon.StringExtensions;
    var Formatting = jsCommon.Formatting;
    var RegExpExtensions = jsCommon.RegExpExtensions;
    /** Formatting Encoder */
    var FormattingEncoder;
    (function (FormattingEncoder) {
        function preserveEscaped(format, specialChars) {
            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences
            var length = specialChars.length;
            for (var i = 0; i < length; i++) {
                var oldText = "\\" + specialChars[i];
                var newText = String.fromCharCode(0xE000 + i);
                format = StringExtensions.replaceAll(format, oldText, newText);
            }
            return format;
        }
        FormattingEncoder.preserveEscaped = preserveEscaped;
        function restoreEscaped(format, specialChars) {
            // After formatting is complete we should restore the encoded escaped chars into the unescaped chars
            var length = specialChars.length;
            for (var i = 0; i < length; i++) {
                var oldText = String.fromCharCode(0xE000 + i);
                var newText = specialChars[i];
                format = StringExtensions.replaceAll(format, oldText, newText);
            }
            return StringExtensions.replaceAll(format, "\\", "");
        }
        FormattingEncoder.restoreEscaped = restoreEscaped;
        function preserveLiterals(format, literals) {
            // Unicode U+E000 - U+F8FF is a private area and so we can use the chars from the range to encode the escaped sequences
            format = StringExtensions.replaceAll(format, "\"", "'");
            for (var i = 0;; i++) {
                var fromIndex = format.indexOf("'");
                if (fromIndex < 0) {
                    break;
                }
                var toIndex = format.indexOf("'", fromIndex + 1);
                if (toIndex < 0) {
                    break;
                }
                var literal = format.substring(fromIndex, toIndex + 1);
                literals.push(literal.substring(1, toIndex - fromIndex));
                var token = String.fromCharCode(0xE100 + i);
                format = format.replace(literal, token);
            }
            return format;
        }
        FormattingEncoder.preserveLiterals = preserveLiterals;
        function restoreLiterals(format, literals) {
            var count = literals.length;
            for (var i = 0; i < count; i++) {
                var token = String.fromCharCode(0xE100 + i);
                var literal = literals[i];
                format = format.replace(token, literal);
            }
            return format;
        }
        FormattingEncoder.restoreLiterals = restoreLiterals;
    })(FormattingEncoder || (FormattingEncoder = {}));
    var IndexedTokensRegex = /({{)|(}})|{(\d+[^}]*)}/g;
    var ZeroPlaceholder = '0';
    var DigitPlaceholder = '#';
    var ExponentialFormatChar = 'E';
    var NumericPlaceholders = [ZeroPlaceholder, DigitPlaceholder];
    var NumericPlaceholderRegex = new RegExp(NumericPlaceholders.join('|'), 'g');
    /** Formatting Service */
    var FormattingService = (function () {
        function FormattingService() {
        }
        FormattingService.prototype.formatValue = function (value, format, culture) {
            // Handle special cases
            if (value === undefined || value === null) {
                return '';
            }
            var gculture = this.getCulture(culture);
            if (DateTimeFormat.canFormat(value)) {
                // Dates
                return DateTimeFormat.format(value, format, gculture);
            }
            else if (NumberFormat.canFormat(value)) {
                // Numbers
                return NumberFormat.format(value, format, gculture);
            }
            else {
                // Other data types - return as string
                return value.toString();
            }
        };
        FormattingService.prototype.format = function (formatWithIndexedTokens, args, culture) {
            var _this = this;
            if (!formatWithIndexedTokens) {
                return "";
            }
            var result = formatWithIndexedTokens.replace(IndexedTokensRegex, function (match, left, right, argToken) {
                if (left) {
                    return "{";
                }
                else if (right) {
                    return "}";
                }
                else {
                    var parts = argToken.split(":");
                    var argIndex = parseInt(parts[0], 10);
                    var argFormat = parts[1];
                    return _this.formatValue(args[argIndex], argFormat, culture);
                }
            });
            return result;
        };
        FormattingService.prototype.isStandardNumberFormat = function (format) {
            return NumberFormat.isStandardFormat(format);
        };
        FormattingService.prototype.formatNumberWithCustomOverride = function (value, format, nonScientificOverrideFormat, culture) {
            var gculture = this.getCulture(culture);
            return NumberFormat.formatWithCustomOverride(value, format, nonScientificOverrideFormat, gculture);
        };
        FormattingService.prototype.dateFormatString = function (unit) {
            if (!this._dateTimeScaleFormatInfo)
                this.initialize();
            return this._dateTimeScaleFormatInfo.getFormatString(unit);
        };
        /**
         * Sets the current localization culture
         * @param cultureSelector - name of a culture: "en", "en-UK", "fr-FR" etc. (See National Language Support (NLS) for full lists. Use "default" for invariant culture).
         */
        FormattingService.prototype.setCurrentCulture = function (cultureSelector) {
            if (this._currentCultureSelector !== cultureSelector) {
                this._currentCulture = this.getCulture(cultureSelector);
                this._currentCultureSelector = cultureSelector;
                this._dateTimeScaleFormatInfo = new DateTimeScaleFormatInfo(this._currentCulture);
            }
        };
        /**
         * Gets the culture assotiated with the specified cultureSelector ("en", "en-US", "fr-FR" etc).
         * @param cultureSelector - name of a culture: "en", "en-UK", "fr-FR" etc. (See National Language Support (NLS) for full lists. Use "default" for invariant culture).
         * Exposing this function for testability of unsupported cultures
         */
        FormattingService.prototype.getCulture = function (cultureSelector) {
            if (cultureSelector == null) {
                if (this._currentCulture == null) {
                    this.initialize();
                }
                return this._currentCulture;
            }
            else {
                var culture = Globalize.findClosestCulture(cultureSelector);
                if (!culture)
                    culture = Globalize.culture("en-US");
                return culture;
            }
        };
        /** By default the Globalization module initializes to the culture/calendar provided in the language/culture URL params */
        FormattingService.prototype.initialize = function () {
            var cultureName = this.getCurrentCulture();
            this.setCurrentCulture(cultureName);
            var calendarName = this.getUrlParam("calendar");
            if (calendarName) {
                var culture = this._currentCulture;
                var c = culture.calendars[calendarName];
                if (c) {
                    culture.calendar = c;
                }
            }
        };
        /**
         *  Exposing this function for testability
         */
        FormattingService.prototype.getCurrentCulture = function () {
            var urlParam = this.getUrlParam("language");
            if (urlParam) {
                return urlParam;
            }
            if (powerbi && powerbi.common && powerbi.common.cultureInfo) {
                // Get cultureInfo set in powerbi
                return powerbi.common.cultureInfo;
            }
            return window.navigator.userLanguage || window.navigator["language"] || Globalize.culture().name;
        };
        /**
         *  Exposing this function for testability
         *  @param name: queryString name
         */
        FormattingService.prototype.getUrlParam = function (name) {
            var param = window.location.search.match(RegExp("[?&]" + name + "=([^&]*)"));
            return param ? param[1] : undefined;
        };
        return FormattingService;
    }());
    /**
     * DateTimeFormat module contains the static methods for formatting the DateTimes.
     * It extends the JQuery.Globalize functionality to support complete set of .NET
     * formatting expressions for dates.
     */
    var DateTimeFormat;
    (function (DateTimeFormat) {
        var _currentCachedFormat;
        var _currentCachedProcessedFormat;
        /** Evaluates if the value can be formatted using the NumberFormat */
        function canFormat(value) {
            var result = value instanceof Date;
            return result;
        }
        DateTimeFormat.canFormat = canFormat;
        /** Formats the date using provided format and culture */
        function format(value, format, culture) {
            format = format || "G";
            var isStandard = format.length === 1;
            try {
                if (isStandard) {
                    return formatDateStandard(value, format, culture);
                }
                else {
                    return formatDateCustom(value, format, culture);
                }
            }
            catch (e) {
                return formatDateStandard(value, "G", culture);
            }
        }
        DateTimeFormat.format = format;
        /** Formats the date using standard format expression */
        function formatDateStandard(value, format, culture) {
            // In order to provide parity with .NET we have to support additional set of DateTime patterns.
            var patterns = culture.calendar.patterns;
            // Extend supported set of patterns
            ensurePatterns(culture.calendar);
            // Handle extended set of formats
            var output = Formatting.findDateFormat(value, format, culture.name);
            if (output.format.length === 1)
                format = patterns[output.format];
            else
                format = output.format;
            //need to revisit when globalization is enabled
            culture = Globalize.culture("en-US");
            return Globalize.format(output.value, format, culture);
        }
        /** Formats the date using custom format expression */
        function formatDateCustom(value, format, culture) {
            var result;
            var literals = [];
            format = FormattingEncoder.preserveEscaped(format, "\\dfFghHKmstyz:/%'\"");
            format = FormattingEncoder.preserveLiterals(format, literals);
            format = StringExtensions.replaceAll(format, "\"", "'");
            if (format.indexOf("F") > -1) {
                // F is not supported so we need to replace the F with f based on the milliseconds
                // Replace all sequences of F longer than 3 with "FFF"
                format = StringExtensions.replaceAll(format, "FFFF", "FFF");
                // Based on milliseconds update the format to use fff
                var milliseconds = value.getMilliseconds();
                if (milliseconds % 10 >= 1) {
                    format = StringExtensions.replaceAll(format, "FFF", "fff");
                }
                format = StringExtensions.replaceAll(format, "FFF", "FF");
                if ((milliseconds % 100) / 10 >= 1) {
                    format = StringExtensions.replaceAll(format, "FF", "ff");
                }
                format = StringExtensions.replaceAll(format, "FF", "F");
                if ((milliseconds % 1000) / 100 >= 1) {
                    format = StringExtensions.replaceAll(format, "F", "f");
                }
                format = StringExtensions.replaceAll(format, "F", "");
                if (format === "" || format === "%")
                    return "";
            }
            format = processCustomDateTimeFormat(format);
            result = Globalize.format(value, format, culture);
            result = localize(result, culture.calendar);
            result = FormattingEncoder.restoreLiterals(result, literals);
            result = FormattingEncoder.restoreEscaped(result, "\\dfFghHKmstyz:/%'\"");
            return result;
        }
        /** Translates unsupported .NET custom format expressions to the custom expressions supported by JQuery.Globalize */
        function processCustomDateTimeFormat(format) {
            if (format === _currentCachedFormat) {
                return _currentCachedProcessedFormat;
            }
            _currentCachedFormat = format;
            format = Formatting.fixDateTimeFormat(format);
            _currentCachedProcessedFormat = format;
            return format;
        }
        /** Localizes the time separator symbol */
        function localize(value, dictionary) {
            var timeSeparator = dictionary[":"];
            if (timeSeparator === ":") {
                return value;
            }
            var result = "";
            var count = value.length;
            for (var i = 0; i < count; i++) {
                var char = value.charAt(i);
                switch (char) {
                    case ":":
                        result += timeSeparator;
                        break;
                    default:
                        result += char;
                        break;
                }
            }
            return result;
        }
        function ensurePatterns(calendar) {
            var patterns = calendar.patterns;
            if (patterns["g"] === undefined) {
                patterns["g"] = patterns["f"].replace(patterns["D"], patterns["d"]); // Generic: Short date, short time
                patterns["G"] = patterns["F"].replace(patterns["D"], patterns["d"]); // Generic: Short date, long time
            }
        }
    })(DateTimeFormat || (DateTimeFormat = {}));
    /**
     * NumberFormat module contains the static methods for formatting the numbers.
     * It extends the JQuery.Globalize functionality to support complete set of .NET
     * formatting expressions for numeric types including custom formats.
     */
    var NumberFormat;
    (function (NumberFormat) {
        var NonScientificFormatRegex = /^\{.+\}.*/;
        var NumericalPlaceHolderRegex = /\{.+\}/;
        var ScientificFormatRegex = /e[+-]*[0#]+/i;
        var StandardFormatRegex = /^[a-z]\d{0,2}$/i; // a letter + up to 2 digits for precision specifier
        var TrailingZerosRegex = /0+$/;
        var DecimalFormatRegex = /\.([0#]*)/g;
        var NumericFormatRegex = /[0#,\.]+[0,#]*/g;
        var LastNumericPlaceholderRegex = /(0|#)([^(0|#)]*)$/;
        var DecimalFormatCharacter = '.';
        NumberFormat.NumberFormatComponentsDelimeter = ';';
        function getNonScientificFormatWithPrecision(baseFormat, numericFormat) {
            if (!numericFormat || baseFormat === undefined)
                return baseFormat;
            var newFormat = "{0:" + numericFormat + "}";
            return baseFormat.replace("{0}", newFormat);
        }
        function getNumericFormat(value, baseFormat) {
            if (baseFormat == null)
                return baseFormat;
            if (hasFormatComponents(baseFormat)) {
                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;
                if (value > 0)
                    return getNumericFormatFromComponent(value, positive);
                else if (value === 0)
                    return getNumericFormatFromComponent(value, zero);
                return getNumericFormatFromComponent(value, negative);
            }
            return getNumericFormatFromComponent(value, baseFormat);
        }
        NumberFormat.getNumericFormat = getNumericFormat;
        function getNumericFormatFromComponent(value, format) {
            var match = RegExpExtensions.run(NumericFormatRegex, format);
            if (match)
                return match[0];
            return format;
        }
        function addDecimalsToFormat(baseFormat, decimals, trailingZeros) {
            if (decimals == null)
                return baseFormat;
            // Default format string
            if (baseFormat == null)
                baseFormat = ZeroPlaceholder;
            if (hasFormatComponents(baseFormat)) {
                var _a = NumberFormat.getComponents(baseFormat), positive = _a.positive, negative = _a.negative, zero = _a.zero;
                var formats = [positive, negative, zero];
                for (var i = 0; i < formats.length; i++) {
                    // Update format in formats array
                    formats[i] = addDecimalsToFormatComponent(formats[i], decimals, trailingZeros);
                }
                return formats.join(NumberFormat.NumberFormatComponentsDelimeter);
            }
            return addDecimalsToFormatComponent(baseFormat, decimals, trailingZeros);
        }
        NumberFormat.addDecimalsToFormat = addDecimalsToFormat;
        function addDecimalsToFormatComponent(format, decimals, trailingZeros) {
            decimals = Math.abs(decimals);
            if (decimals >= 0) {
                var placeholder = trailingZeros ? ZeroPlaceholder : DigitPlaceholder;
                var decimalPlaceholders = StringExtensions.repeat(placeholder, Math.abs(decimals));
                var match = RegExpExtensions.run(DecimalFormatRegex, format);
                if (match) {
                    var beforeDecimal = format.substr(0, match.index);
                    var formatDecimal = format.substr(match.index + 1, match[1].length);
                    var afterDecimal = format.substr(match.index + match[0].length);
                    if (trailingZeros)
                        // Use explicit decimals argument as placeholders
                        formatDecimal = decimalPlaceholders;
                    else {
                        var decimalChange = decimalPlaceholders.length - formatDecimal.length;
                        if (decimalChange > 0)
                            // Append decimalPlaceholders to existing decimal portion of format string
                            formatDecimal = formatDecimal + decimalPlaceholders.slice(-decimalChange);
                        else if (decimalChange < 0)
                            // Remove decimals from formatDecimal
                            formatDecimal = formatDecimal.slice(0, decimalChange);
                    }
                    if (formatDecimal.length > 0)
                        formatDecimal = DecimalFormatCharacter + formatDecimal;
                    return beforeDecimal + formatDecimal + afterDecimal;
                }
                else if (decimalPlaceholders.length > 0)
                    // Replace last numeric placeholder with decimal portion
                    return format.replace(LastNumericPlaceholderRegex, '$1' + DecimalFormatCharacter + decimalPlaceholders);
            }
            return format;
        }
        function hasFormatComponents(format) {
            return format.indexOf(NumberFormat.NumberFormatComponentsDelimeter) !== -1;
        }
        NumberFormat.hasFormatComponents = hasFormatComponents;
        function getComponents(format) {
            var signFormat = {
                hasNegative: false,
                positive: format,
                negative: format,
                zero: format,
            };
            var signSpecificFormats = format.split(NumberFormat.NumberFormatComponentsDelimeter);
            var formatCount = signSpecificFormats.length;
            debug.assert(!(formatCount > 3), 'format string should be of form positive[;negative;zero]');
            if (formatCount > 1) {
                signFormat.hasNegative = true;
                signFormat.positive = signFormat.zero = signSpecificFormats[0];
                signFormat.negative = signSpecificFormats[1];
                if (formatCount > 2)
                    signFormat.zero = signSpecificFormats[2];
            }
            return signFormat;
        }
        NumberFormat.getComponents = getComponents;
        var _lastCustomFormatMeta;
        /** Evaluates if the value can be formatted using the NumberFormat */
        function canFormat(value) {
            var result = typeof (value) === "number";
            return result;
        }
        NumberFormat.canFormat = canFormat;
        function isStandardFormat(format) {
            debug.assertValue(format, 'format');
            return StandardFormatRegex.test(format);
        }
        NumberFormat.isStandardFormat = isStandardFormat;
        /** Formats the number using specified format expression and culture */
        function format(value, format, culture) {
            format = format || "G";
            try {
                if (isStandardFormat(format))
                    return formatNumberStandard(value, format, culture);
                return formatNumberCustom(value, format, culture);
            }
            catch (e) {
                return Globalize.format(value, undefined, culture);
            }
        }
        NumberFormat.format = format;
        /** Performs a custom format with a value override.  Typically used for custom formats showing scaled values. */
        function formatWithCustomOverride(value, format, nonScientificOverrideFormat, culture) {
            debug.assertValue(value, 'value');
            debug.assertValue(format, 'format');
            debug.assertValue(nonScientificOverrideFormat, 'nonScientificOverrideFormat');
            debug.assertValue(culture, 'culture');
            debug.assert(!isStandardFormat(format), 'Standard format');
            return formatNumberCustom(value, format, culture, nonScientificOverrideFormat);
        }
        NumberFormat.formatWithCustomOverride = formatWithCustomOverride;
        /** Formats the number using standard format expression */
        function formatNumberStandard(value, format, culture) {
            var result;
            var precision = (format.length > 1 ? parseInt(format.substr(1, format.length - 1), 10) : undefined);
            var numberFormatInfo = culture.numberFormat;
            var formatChar = format.charAt(0);
            switch (formatChar) {
                case "e":
                case "E":
                    if (precision === undefined) {
                        precision = 6;
                    }
                    var mantissaDecimalDigits = StringExtensions.repeat("0", precision);
                    format = "0." + mantissaDecimalDigits + formatChar + "+000";
                    result = formatNumberCustom(value, format, culture);
                    break;
                case "f":
                case "F":
                    result = precision !== undefined ? value.toFixed(precision) : value.toFixed(numberFormatInfo.decimals);
                    result = localize(result, numberFormatInfo);
                    break;
                case "g":
                case "G":
                    var abs = Math.abs(value);
                    if (abs === 0 || (1E-4 <= abs && abs < 1E15)) {
                        // For the range of 0.0001 to 1,000,000,000,000,000 - use the normal form
                        result = precision !== undefined ? value.toPrecision(precision) : value.toString();
                    }
                    else {
                        // Otherwise use exponential
                        // Assert that value is a number and fall back on returning value if it is not
                        debug.assert(typeof (value) === "number", "value must be a number");
                        if (typeof (value) !== "number")
                            return String(value);
                        result = precision !== undefined ? value.toExponential(precision) : value.toExponential();
                        result = result.replace("e", "E");
                    }
                    result = localize(result, numberFormatInfo);
                    break;
                case "r":
                case "R":
                    result = value.toString();
                    result = localize(result, numberFormatInfo);
                    break;
                case "x":
                case "X":
                    result = value.toString(16);
                    if (formatChar === "X") {
                        result = result.toUpperCase();
                    }
                    if (precision !== undefined) {
                        var actualPrecision = result.length;
                        var isNegative = value < 0;
                        if (isNegative) {
                            actualPrecision--;
                        }
                        var paddingZerosCount = precision - actualPrecision;
                        var paddingZeros = undefined;
                        if (paddingZerosCount > 0) {
                            paddingZeros = StringExtensions.repeat("0", paddingZerosCount);
                        }
                        if (isNegative) {
                            result = "-" + paddingZeros + result.substr(1);
                        }
                        else {
                            result = paddingZeros + result;
                        }
                    }
                    result = localize(result, numberFormatInfo);
                    break;
                default:
                    result = Globalize.format(value, format, culture);
            }
            return result;
        }
        /** Formats the number using custom format expression */
        function formatNumberCustom(value, format, culture, nonScientificOverrideFormat) {
            var result;
            var numberFormatInfo = culture.numberFormat;
            if (isFinite(value)) {
                // Split format by positive[;negative;zero] pattern
                var formatComponents = getComponents(format);
                // Pick a format based on the sign of value
                if (value > 0) {
                    format = formatComponents.positive;
                }
                else if (value === 0) {
                    format = formatComponents.zero;
                }
                else {
                    format = formatComponents.negative;
                }
                // Normalize value if we have an explicit negative format
                if (formatComponents.hasNegative)
                    value = Math.abs(value);
                // Get format metadata
                var formatMeta = getCustomFormatMetadata(format, true /*calculatePrecision*/);
                // Preserve literals and escaped chars
                if (formatMeta.hasEscapes) {
                    format = FormattingEncoder.preserveEscaped(format, "\\0#.,%‰");
                }
                var literals = [];
                if (formatMeta.hasQuotes) {
                    format = FormattingEncoder.preserveLiterals(format, literals);
                }
                // Scientific format
                if (formatMeta.hasE && !nonScientificOverrideFormat) {
                    var scientificMatch = RegExpExtensions.run(ScientificFormatRegex, format);
                    if (scientificMatch) {
                        // Case 2.1. Scientific custom format
                        var formatM = format.substr(0, scientificMatch.index);
                        var formatE = format.substr(scientificMatch.index + 2); // E(+|-)
                        var precision = getCustomFormatPrecision(formatM, formatMeta);
                        var scale = getCustomFormatScale(formatM, formatMeta);
                        if (scale !== 1) {
                            value = value * scale;
                        }
                        // Assert that value is a number and fall back on returning value if it is not
                        debug.assert(typeof (value) === "number", "value must be a number");
                        if (typeof (value) !== "number")
                            return String(value);
                        var s = value.toExponential(precision);
                        var indexOfE = s.indexOf("e");
                        var mantissa = s.substr(0, indexOfE);
                        var exp = s.substr(indexOfE + 1);
                        var resultM = fuseNumberWithCustomFormat(mantissa, formatM, numberFormatInfo);
                        var resultE = fuseNumberWithCustomFormat(exp, formatE, numberFormatInfo);
                        if (resultE.charAt(0) === "+" && scientificMatch[0].charAt(1) !== "+") {
                            resultE = resultE.substr(1);
                        }
                        var e = scientificMatch[0].charAt(0);
                        result = resultM + e + resultE;
                    }
                }
                // Non scientific format
                if (result === undefined) {
                    var valueFormatted = void 0;
                    var isValueGlobalized = false;
                    var precision = getCustomFormatPrecision(format, formatMeta);
                    var scale = getCustomFormatScale(format, formatMeta);
                    if (scale !== 1)
                        value = value * scale;
                    // Rounding
                    value = parseFloat(toNonScientific(value, precision));
                    if (nonScientificOverrideFormat) {
                        // Get numeric format from format string
                        var numericFormat = NumberFormat.getNumericFormat(value, format);
                        // Add separators and decimalFormat to nonScientificFormat
                        nonScientificOverrideFormat = getNonScientificFormatWithPrecision(nonScientificOverrideFormat, numericFormat);
                        // Format the value
                        valueFormatted = powerbi_1.formattingService.format(nonScientificOverrideFormat, [value], culture.name);
                        isValueGlobalized = true;
                    }
                    else
                        valueFormatted = toNonScientific(value, precision);
                    result = fuseNumberWithCustomFormat(valueFormatted, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized);
                }
                if (formatMeta.hasQuotes) {
                    result = FormattingEncoder.restoreLiterals(result, literals);
                }
                if (formatMeta.hasEscapes) {
                    result = FormattingEncoder.restoreEscaped(result, "\\0#.,%‰");
                }
                _lastCustomFormatMeta = formatMeta;
            }
            else {
                return Globalize.format(value, undefined);
            }
            return result;
        }
        /** Returns string with the fixed point respresentation of the number */
        function toNonScientific(value, precision) {
            var result = "";
            var precisionZeros = 0;
            // Double precision numbers support actual 15-16 decimal digits of precision.
            if (precision > 16) {
                precisionZeros = precision - 16;
                precision = 16;
            }
            var digitsBeforeDecimalPoint = powerbi_1.Double.log10(Math.abs(value));
            if (digitsBeforeDecimalPoint < 16) {
                if (digitsBeforeDecimalPoint > 0) {
                    var maxPrecision = 16 - digitsBeforeDecimalPoint;
                    if (precision > maxPrecision) {
                        precisionZeros += precision - maxPrecision;
                        precision = maxPrecision;
                    }
                }
                result = value.toFixed(precision);
            }
            else if (digitsBeforeDecimalPoint === 16) {
                result = value.toFixed(0);
                precisionZeros += precision;
                if (precisionZeros > 0) {
                    result += ".";
                }
            }
            else {
                // Different browsers have different implementations of the toFixed().
                // In IE it returns fixed format no matter what's the number. In FF and Chrome the method returns exponential format for numbers greater than 1E21.
                // So we need to check for range and convert the to exponential with the max precision.
                // Then we convert exponential string to fixed by removing the dot and padding with "power" zeros.
                // Assert that value is a number and fall back on returning value if it is not
                debug.assert(typeof (value) === "number", "value must be a number");
                if (typeof (value) !== "number")
                    return String(value);
                result = value.toExponential(15);
                var indexOfE = result.indexOf("e");
                if (indexOfE > 0) {
                    var indexOfDot = result.indexOf(".");
                    var mantissa = result.substr(0, indexOfE);
                    var exp = result.substr(indexOfE + 1);
                    var powerZeros = parseInt(exp, 10) - (mantissa.length - indexOfDot - 1);
                    result = mantissa.replace(".", "") + StringExtensions.repeat("0", powerZeros);
                    if (precision > 0) {
                        result = result + "." + StringExtensions.repeat("0", precision);
                    }
                }
            }
            if (precisionZeros > 0) {
                result = result + StringExtensions.repeat("0", precisionZeros);
            }
            return result;
        }
        /**
         * Returns the formatMetadata of the format
         * When calculating precision and scale, if format string of
         * positive[;negative;zero] => positive format will be used
         * @param (required) format - format string
         * @param (optional) calculatePrecision - calculate precision of positive format
         * @param (optional) calculateScale - calculate scale of positive format
         */
        function getCustomFormatMetadata(format, calculatePrecision, calculateScale) {
            if (_lastCustomFormatMeta !== undefined && format === _lastCustomFormatMeta.format) {
                return _lastCustomFormatMeta;
            }
            var result = {
                format: format,
                hasEscapes: false,
                hasQuotes: false,
                hasE: false,
                hasCommas: false,
                hasDots: false,
                hasPercent: false,
                hasPermile: false,
                precision: undefined,
                scale: undefined,
            };
            for (var i = 0, length_1 = format.length; i < length_1; i++) {
                var c = format.charAt(i);
                switch (c) {
                    case "\\":
                        result.hasEscapes = true;
                        break;
                    case "'":
                    case "\"":
                        result.hasQuotes = true;
                        break;
                    case "e":
                    case "E":
                        result.hasE = true;
                        break;
                    case ",":
                        result.hasCommas = true;
                        break;
                    case ".":
                        result.hasDots = true;
                        break;
                    case "%":
                        result.hasPercent = true;
                        break;
                    case "‰":
                        result.hasPermile = true;
                        break;
                }
            }
            // Use positive format for calculating these values
            var formatComponents = getComponents(format);
            if (calculatePrecision)
                result.precision = getCustomFormatPrecision(formatComponents.positive, result);
            if (calculateScale)
                result.scale = getCustomFormatScale(formatComponents.positive, result);
            return result;
        }
        NumberFormat.getCustomFormatMetadata = getCustomFormatMetadata;
        /** Returns the decimal precision of format based on the number of # and 0 chars after the decimal point
          * Important: The input format string needs to be split to the appropriate pos/neg/zero portion to work correctly */
        function getCustomFormatPrecision(format, formatMeta) {
            if (formatMeta.precision > -1) {
                return formatMeta.precision;
            }
            var result = 0;
            if (formatMeta.hasDots) {
                var dotIndex = format.indexOf(".");
                if (dotIndex > -1) {
                    var count = format.length;
                    for (var i = dotIndex; i < count; i++) {
                        var char = format.charAt(i);
                        if (char.match(NumericPlaceholderRegex))
                            result++;
                        // 0.00E+0 :: Break before counting 0 in
                        // exponential portion of format string
                        if (char === ExponentialFormatChar)
                            break;
                    }
                    result = Math.min(19, result);
                }
            }
            formatMeta.precision = result;
            return result;
        }
        /** Returns the scale factor of the format based on the "%" and scaling "," chars in the format */
        function getCustomFormatScale(format, formatMeta) {
            if (formatMeta.scale > -1) {
                return formatMeta.scale;
            }
            var result = 1;
            if (formatMeta.hasPercent && format.indexOf("%") > -1) {
                result = result * 100;
            }
            if (formatMeta.hasPermile && format.indexOf("‰") > -1) {
                result = result * 1000;
            }
            if (formatMeta.hasCommas) {
                var dotIndex = format.indexOf(".");
                if (dotIndex === -1) {
                    dotIndex = format.length;
                }
                for (var i = dotIndex - 1; i > -1; i--) {
                    var char = format.charAt(i);
                    if (char === ",") {
                        result = result / 1000;
                    }
                    else {
                        break;
                    }
                }
            }
            formatMeta.scale = result;
            return result;
        }
        function fuseNumberWithCustomFormat(value, format, numberFormatInfo, nonScientificOverrideFormat, isValueGlobalized) {
            var suppressModifyValue = !!nonScientificOverrideFormat;
            var formatParts = format.split(".", 2);
            if (formatParts.length === 2) {
                var wholeFormat = formatParts[0];
                var fractionFormat = formatParts[1];
                var displayUnit = "";
                // Remove display unit from value before splitting on "." as localized display units sometimes end with "."
                if (nonScientificOverrideFormat) {
                    debug.assert(NonScientificFormatRegex.test(nonScientificOverrideFormat), "Number should always precede the display unit");
                    displayUnit = nonScientificOverrideFormat.replace(NumericalPlaceHolderRegex, "");
                    value = value.replace(displayUnit, "");
                }
                var globalizedDecimalSeparator = numberFormatInfo["."];
                var decimalSeparator = isValueGlobalized ? globalizedDecimalSeparator : ".";
                var valueParts = value.split(decimalSeparator, 2);
                var wholeValue = valueParts.length === 1 ? valueParts[0] + displayUnit : valueParts[0];
                var fractionValue = valueParts.length === 2 ? valueParts[1] + displayUnit : "";
                fractionValue = fractionValue.replace(TrailingZerosRegex, "");
                var wholeFormattedValue = fuseNumberWithCustomFormatLeft(wholeValue, wholeFormat, numberFormatInfo, suppressModifyValue);
                var fractionFormattedValue = fuseNumberWithCustomFormatRight(fractionValue, fractionFormat, suppressModifyValue);
                if (fractionFormattedValue.fmtOnly || fractionFormattedValue.value === "")
                    return wholeFormattedValue + fractionFormattedValue.value;
                return wholeFormattedValue + globalizedDecimalSeparator + fractionFormattedValue.value;
            }
            return fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue);
        }
        function fuseNumberWithCustomFormatLeft(value, format, numberFormatInfo, suppressModifyValue) {
            var groupSymbolIndex = format.indexOf(",");
            var enableGroups = groupSymbolIndex > -1 && groupSymbolIndex < Math.max(format.lastIndexOf("0"), format.lastIndexOf("#")) && numberFormatInfo[","];
            var groupDigitCount = 0;
            var groupIndex = 0;
            var groupSizes = numberFormatInfo.groupSizes || [3];
            var groupSize = groupSizes[0];
            var groupSeparator = numberFormatInfo[","];
            var sign = "";
            var firstChar = value.charAt(0);
            if (firstChar === "+" || firstChar === "-") {
                sign = numberFormatInfo[firstChar];
                value = value.substr(1);
            }
            var isZero = value === "0";
            var result = "";
            var leftBuffer = "";
            var vi = value.length - 1;
            var fmtOnly = true;
            // Iterate through format chars and replace 0 and # with the digits from the value string
            for (var fi = format.length - 1; fi > -1; fi--) {
                var formatChar = format.charAt(fi);
                switch (formatChar) {
                    case ZeroPlaceholder:
                    case DigitPlaceholder:
                        fmtOnly = false;
                        if (leftBuffer !== "") {
                            result = leftBuffer + result;
                            leftBuffer = "";
                        }
                        if (!suppressModifyValue) {
                            if (vi > -1 || formatChar === ZeroPlaceholder) {
                                if (enableGroups) {
                                    // If the groups are enabled we'll need to keep track of the current group index and periodically insert group separator,
                                    if (groupDigitCount === groupSize) {
                                        result = groupSeparator + result;
                                        groupIndex++;
                                        if (groupIndex < groupSizes.length) {
                                            groupSize = groupSizes[groupIndex];
                                        }
                                        groupDigitCount = 1;
                                    }
                                    else {
                                        groupDigitCount++;
                                    }
                                }
                            }
                            if (vi > -1) {
                                if (isZero && formatChar === DigitPlaceholder) {
                                }
                                else {
                                    result = value.charAt(vi) + result;
                                }
                                vi--;
                            }
                            else if (formatChar !== DigitPlaceholder) {
                                result = formatChar + result;
                            }
                        }
                        break;
                    case ",":
                        // We should skip all the , chars
                        break;
                    default:
                        leftBuffer = formatChar + leftBuffer;
                        break;
                }
            }
            // If the value didn't fit into the number of zeros provided in the format then we should insert the missing part of the value into the result
            if (!suppressModifyValue) {
                if (vi > -1 && result !== "") {
                    if (enableGroups) {
                        while (vi > -1) {
                            if (groupDigitCount === groupSize) {
                                result = groupSeparator + result;
                                groupIndex++;
                                if (groupIndex < groupSizes.length) {
                                    groupSize = groupSizes[groupIndex];
                                }
                                groupDigitCount = 1;
                            }
                            else {
                                groupDigitCount++;
                            }
                            result = value.charAt(vi) + result;
                            vi--;
                        }
                    }
                    else {
                        result = value.substr(0, vi + 1) + result;
                    }
                }
                // Insert sign in front of the leftBuffer and result
                return sign + leftBuffer + result;
            }
            if (fmtOnly)
                // If the format doesn't specify any digits to be displayed, then just return the format we've parsed up until now.
                return sign + leftBuffer + result;
            return sign + leftBuffer + value + result;
        }
        function fuseNumberWithCustomFormatRight(value, format, suppressModifyValue) {
            var vi = 0;
            var fCount = format.length;
            var vCount = value.length;
            if (suppressModifyValue) {
                debug.assert(fCount > 0, "Empty formatting string");
                var lastChar = format.charAt(fCount - 1);
                if (!lastChar.match(NumericPlaceholderRegex))
                    return {
                        value: value + lastChar,
                        fmtOnly: value === "",
                    };
                return {
                    value: value,
                    fmtOnly: value === "",
                };
            }
            var result = "", fmtOnly = true;
            for (var fi = 0; fi < fCount; fi++) {
                var formatChar = format.charAt(fi);
                if (vi < vCount) {
                    switch (formatChar) {
                        case ZeroPlaceholder:
                        case DigitPlaceholder:
                            result += value[vi++];
                            fmtOnly = false;
                            break;
                        default:
                            result += formatChar;
                    }
                }
                else {
                    if (formatChar !== DigitPlaceholder) {
                        result += formatChar;
                        fmtOnly = fmtOnly && (formatChar !== ZeroPlaceholder);
                    }
                }
            }
            return {
                value: result,
                fmtOnly: fmtOnly,
            };
        }
        function localize(value, dictionary) {
            var plus = dictionary["+"];
            var minus = dictionary["-"];
            var dot = dictionary["."];
            var comma = dictionary[","];
            if (plus === "+" && minus === "-" && dot === "." && comma === ",") {
                return value;
            }
            var count = value.length;
            var result = "";
            for (var i = 0; i < count; i++) {
                var char = value.charAt(i);
                switch (char) {
                    case "+":
                        result = result + plus;
                        break;
                    case "-":
                        result = result + minus;
                        break;
                    case ".":
                        result = result + dot;
                        break;
                    case ",":
                        result = result + comma;
                        break;
                    default:
                        result = result + char;
                        break;
                }
            }
            return result;
        }
    })(NumberFormat = powerbi_1.NumberFormat || (powerbi_1.NumberFormat = {}));
    /** DateTimeScaleFormatInfo is used to calculate and keep the Date formats used for different units supported by the DateTimeScaleModel */
    var DateTimeScaleFormatInfo = (function () {
        // Constructor
        /**
         * Creates new instance of the DateTimeScaleFormatInfo class.
         * @param culture - culture which calendar info is going to be used to derive the formats.
         */
        function DateTimeScaleFormatInfo(culture) {
            var calendar = culture.calendar;
            var patterns = calendar.patterns;
            var monthAbbreviations = calendar["months"]["namesAbbr"];
            var cultureHasMonthAbbr = monthAbbreviations && monthAbbreviations[0];
            var yearMonthPattern = patterns["Y"];
            var monthDayPattern = patterns["M"];
            var fullPattern = patterns["f"];
            var longTimePattern = patterns["T"];
            var shortTimePattern = patterns["t"];
            var separator = fullPattern.indexOf(",") > -1 ? ", " : " ";
            var hasYearSymbol = yearMonthPattern.indexOf("yyyy'") === 0 && yearMonthPattern.length > 6 && yearMonthPattern[6] === '\'';
            this.YearPattern = hasYearSymbol ? yearMonthPattern.substr(0, 7) : "yyyy";
            var yearPos = fullPattern.indexOf("yy");
            var monthPos = fullPattern.indexOf("MMMM");
            this.MonthPattern = cultureHasMonthAbbr && monthPos > -1 ? (yearPos > monthPos ? "MMM yyyy" : "yyyy MMM") : yearMonthPattern;
            this.DayPattern = cultureHasMonthAbbr ? monthDayPattern.replace("MMMM", "MMM") : monthDayPattern;
            var minutePos = fullPattern.indexOf("mm");
            var pmPos = fullPattern.indexOf("tt");
            var shortHourPattern = pmPos > -1 ? shortTimePattern.replace(":mm ", "") : shortTimePattern;
            this.HourPattern = yearPos < minutePos ? this.DayPattern + separator + shortHourPattern : shortHourPattern + separator + this.DayPattern;
            this.MinutePattern = shortTimePattern;
            this.SecondPattern = longTimePattern;
            this.MillisecondPattern = longTimePattern.replace("ss", "ss.fff");
            // Special cases
            switch (culture.name) {
                case "fi-FI":
                    this.DayPattern = this.DayPattern.replace("'ta'", ""); // Fix for finish 'ta' suffix for month names.
                    this.HourPattern = this.HourPattern.replace("'ta'", "");
                    break;
            }
        }
        // Methods
        /**
         * Returns the format string of the provided DateTimeUnit.
         * @param unit - date or time unit
         */
        DateTimeScaleFormatInfo.prototype.getFormatString = function (unit) {
            switch (unit) {
                case powerbi_1.DateTimeUnit.Year:
                    return this.YearPattern;
                case powerbi_1.DateTimeUnit.Month:
                    return this.MonthPattern;
                case powerbi_1.DateTimeUnit.Week:
                case powerbi_1.DateTimeUnit.Day:
                    return this.DayPattern;
                case powerbi_1.DateTimeUnit.Hour:
                    return this.HourPattern;
                case powerbi_1.DateTimeUnit.Minute:
                    return this.MinutePattern;
                case powerbi_1.DateTimeUnit.Second:
                    return this.SecondPattern;
                case powerbi_1.DateTimeUnit.Millisecond:
                    return this.MillisecondPattern;
            }
            debug.assertFail('Unexpected unit: ' + unit);
        };
        return DateTimeScaleFormatInfo;
    }());
    powerbi_1.formattingService = new FormattingService();
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var data;
    (function (data) {
        /** Serializes SQExpr in a form optimized in-memory comparison, but not intended for storage on disk. */
        var SQExprShortSerializer;
        (function (SQExprShortSerializer) {
            function serialize(expr) {
                return JSON.stringify(expr.accept(SQExprSerializer.instance));
            }
            SQExprShortSerializer.serialize = serialize;
            function serializeArray(exprs) {
                var str = '[';
                for (var i = 0, len = exprs.length; i < len; i++) {
                    if (i > 0)
                        str += ',';
                    str += SQExprShortSerializer.serialize(exprs[i]);
                }
                return str + ']';
            }
            SQExprShortSerializer.serializeArray = serializeArray;
            /** Responsible for serializing an SQExpr into a comparable string. */
            var SQExprSerializer = (function (_super) {
                __extends(SQExprSerializer, _super);
                function SQExprSerializer() {
                    _super.apply(this, arguments);
                }
                SQExprSerializer.prototype.visitColumnRef = function (expr) {
                    return {
                        col: {
                            s: expr.source.accept(this),
                            r: expr.ref,
                        }
                    };
                };
                SQExprSerializer.prototype.visitMeasureRef = function (expr) {
                    return {
                        measure: {
                            s: expr.source.accept(this),
                            r: expr.ref,
                        }
                    };
                };
                SQExprSerializer.prototype.visitAggr = function (expr) {
                    return {
                        agg: {
                            a: expr.arg.accept(this),
                            f: expr.func,
                        }
                    };
                };
                SQExprSerializer.prototype.visitEntity = function (expr) {
                    debug.assertValue(expr, 'expr');
                    debug.assertValue(expr.entity, 'expr.entity');
                    return {
                        e: expr.entity
                    };
                };
                SQExprSerializer.prototype.visitHierarchyLevel = function (expr) {
                    return {
                        h: expr.arg.accept(this),
                        l: expr.level,
                    };
                };
                SQExprSerializer.prototype.visitHierarchy = function (expr) {
                    return {
                        e: expr.arg.accept(this),
                        h: expr.hierarchy,
                    };
                };
                SQExprSerializer.prototype.visitPropertyVariationSource = function (expr) {
                    return {
                        e: expr.arg.accept(this),
                        n: expr.name,
                        p: expr.property,
                    };
                };
                SQExprSerializer.prototype.visitAnd = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        and: {
                            l: expr.left.accept(this),
                            r: expr.right.accept(this),
                        }
                    };
                };
                SQExprSerializer.prototype.visitCompare = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        comp: {
                            k: expr.comparison,
                            l: expr.left.accept(this),
                            r: expr.right.accept(this),
                        }
                    };
                };
                SQExprSerializer.prototype.visitConstant = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        const: {
                            t: expr.type.primitiveType,
                            v: expr.value,
                        }
                    };
                };
                SQExprSerializer.prototype.visitArithmetic = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        arithmetic: {
                            o: expr.operator,
                            l: expr.left.accept(this),
                            r: expr.right.accept(this)
                        }
                    };
                };
                SQExprSerializer.prototype.visitScopedEval = function (expr) {
                    debug.assertValue(expr, 'expr');
                    return {
                        scopedEval: {
                            e: expr.expression.accept(this),
                            s: serializeArray(expr.scope)
                        }
                    };
                };
                SQExprSerializer.prototype.visitDefault = function (expr) {
                    debug.assertFail('Unexpected expression type found in DataViewScopeIdentity.');
                    return;
                };
                SQExprSerializer.instance = new SQExprSerializer();
                return SQExprSerializer;
            }(data.DefaultSQExprVisitor));
        })(SQExprShortSerializer = data.SQExprShortSerializer || (data.SQExprShortSerializer = {}));
    })(data = powerbi.data || (powerbi.data = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Selector = powerbi.data.Selector;
        /**
         * A combination of identifiers used to uniquely identify
         * data points and their bound geometry.
         */
        var SelectionId = (function () {
            function SelectionId(selector, highlight) {
                this.selector = selector;
                this.highlight = highlight;
                this.key = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null, highlight: highlight });
                this.keyWithoutHighlight = JSON.stringify({ selector: selector ? Selector.getKey(selector) : null });
            }
            SelectionId.prototype.equals = function (other) {
                if (!this.selector || !other.selector) {
                    return (!this.selector === !other.selector) && this.highlight === other.highlight;
                }
                return this.highlight === other.highlight && Selector.equals(this.selector, other.selector);
            };
            /**
             * Checks equality against other for all identifiers existing in this.
             */
            SelectionId.prototype.includes = function (other, ignoreHighlight) {
                if (ignoreHighlight === void 0) { ignoreHighlight = false; }
                var thisSelector = this.selector;
                var otherSelector = other.selector;
                if (!thisSelector || !otherSelector) {
                    return false;
                }
                var thisData = thisSelector.data;
                var otherData = otherSelector.data;
                if (!thisData && (thisSelector.metadata && thisSelector.metadata !== otherSelector.metadata))
                    return false;
                if (!ignoreHighlight && this.highlight !== other.highlight)
                    return false;
                if (thisData) {
                    if (!otherData)
                        return false;
                    if (thisData.length > 0) {
                        for (var i = 0, ilen = thisData.length; i < ilen; i++) {
                            var thisValue = thisData[i];
                            if (!otherData.some(function (otherValue) { return powerbi.DataViewScopeIdentity.equals(thisValue, otherValue); }))
                                return false;
                        }
                    }
                }
                return true;
            };
            SelectionId.prototype.getKey = function () {
                return this.key;
            };
            SelectionId.prototype.getKeyWithoutHighlight = function () {
                return this.keyWithoutHighlight;
            };
            /**
             * Temporary workaround since a few things currently rely on this, but won't need to.
             */
            SelectionId.prototype.hasIdentity = function () {
                return (this.selector && !!this.selector.data);
            };
            SelectionId.prototype.getSelector = function () {
                return this.selector;
            };
            SelectionId.prototype.getSelectorsByColumn = function () {
                return this.selectorsByColumn;
            };
            SelectionId.createNull = function (highlight) {
                if (highlight === void 0) { highlight = false; }
                return new SelectionId(null, highlight);
            };
            SelectionId.createWithId = function (id, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = null;
                if (id) {
                    selector = {
                        data: [id]
                    };
                }
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithMeasure = function (measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                debug.assertValue(measureId, 'measureId');
                var selector = {
                    metadata: measureId
                };
                var selectionId = new SelectionId(selector, highlight);
                selectionId.selectorsByColumn = { metadata: measureId };
                return selectionId;
            };
            SelectionId.createWithIdAndMeasure = function (id, measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = {};
                if (id) {
                    selector.data = [id];
                }
                if (measureId)
                    selector.metadata = measureId;
                if (!id && !measureId)
                    selector = null;
                var selectionId = new SelectionId(selector, highlight);
                return selectionId;
            };
            SelectionId.createWithIdAndMeasureAndCategory = function (id, measureId, queryName, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selectionId = this.createWithIdAndMeasure(id, measureId, highlight);
                if (selectionId.selector) {
                    selectionId.selectorsByColumn = {};
                    if (id && queryName) {
                        selectionId.selectorsByColumn.dataMap = {};
                        selectionId.selectorsByColumn.dataMap[queryName] = id;
                    }
                    if (measureId)
                        selectionId.selectorsByColumn.metadata = measureId;
                }
                return selectionId;
            };
            SelectionId.createWithIds = function (id1, id2, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = null;
                var selectorData = SelectionId.idArray(id1, id2);
                if (selectorData)
                    selector = { data: selectorData };
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithIdsAndMeasure = function (id1, id2, measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selector = {};
                var selectorData = SelectionId.idArray(id1, id2);
                if (selectorData)
                    selector.data = selectorData;
                if (measureId)
                    selector.metadata = measureId;
                if (!id1 && !id2 && !measureId)
                    selector = null;
                return new SelectionId(selector, highlight);
            };
            SelectionId.createWithSelectorForColumnAndMeasure = function (dataMap, measureId, highlight) {
                if (highlight === void 0) { highlight = false; }
                var selectionId;
                var keys = Object.keys(dataMap);
                if (keys.length === 2) {
                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], dataMap[keys[1]], measureId, highlight);
                }
                else if (keys.length === 1) {
                    selectionId = this.createWithIdsAndMeasure(dataMap[keys[0]], null, measureId, highlight);
                }
                else {
                    selectionId = this.createWithIdsAndMeasure(null, null, measureId, highlight);
                }
                var selectorsByColumn = {};
                if (!_.isEmpty(dataMap))
                    selectorsByColumn.dataMap = dataMap;
                if (measureId)
                    selectorsByColumn.metadata = measureId;
                if (!dataMap && !measureId)
                    selectorsByColumn = null;
                selectionId.selectorsByColumn = selectorsByColumn;
                return selectionId;
            };
            SelectionId.createWithHighlight = function (original) {
                debug.assertValue(original, 'original');
                debug.assert(!original.highlight, '!original.highlight');
                var newId = new SelectionId(original.getSelector(), /*highlight*/ true);
                newId.selectorsByColumn = original.selectorsByColumn;
                return newId;
            };
            SelectionId.idArray = function (id1, id2) {
                if (id1 || id2) {
                    var data_7 = [];
                    if (id1)
                        data_7.push(id1);
                    if (id2 && id2 !== id1)
                        data_7.push(id2);
                    return data_7;
                }
            };
            return SelectionId;
        }());
        visuals.SelectionId = SelectionId;
        /**
         * This class is designed to simplify the creation of SelectionId objects
         * It allows chaining to build up an object before calling 'create' to build a SelectionId
         */
        var SelectionIdBuilder = (function () {
            function SelectionIdBuilder() {
            }
            SelectionIdBuilder.builder = function () {
                return new SelectionIdBuilder();
            };
            SelectionIdBuilder.prototype.withCategory = function (categoryColumn, index) {
                if (categoryColumn && categoryColumn.source && categoryColumn.source.queryName && categoryColumn.identity)
                    this.ensureDataMap()[categoryColumn.source.queryName] = categoryColumn.identity[index];
                return this;
            };
            SelectionIdBuilder.prototype.withSeries = function (seriesColumn, valueColumn) {
                if (seriesColumn && seriesColumn.source && seriesColumn.source.queryName && valueColumn)
                    this.ensureDataMap()[seriesColumn.source.queryName] = valueColumn.identity;
                return this;
            };
            SelectionIdBuilder.prototype.withMeasure = function (measureId) {
                this.measure = measureId;
                return this;
            };
            SelectionIdBuilder.prototype.createSelectionId = function () {
                return SelectionId.createWithSelectorForColumnAndMeasure(this.ensureDataMap(), this.measure);
            };
            SelectionIdBuilder.prototype.ensureDataMap = function () {
                if (!this.dataMap)
                    this.dataMap = {};
                return this.dataMap;
            };
            return SelectionIdBuilder;
        }());
        visuals.SelectionIdBuilder = SelectionIdBuilder;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));


;var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
///<reference path="../../Typedefs/d3/d3.d.ts"/>
///<reference path="../../Typedefs/jquery-visible/jquery-visible.d.ts"/>
///<reference path="../../Typedefs/jquery/jquery.d.ts"/>
///<reference path="../../Typedefs/microsoftMaps/Microsoft.Maps.d.ts" />
///<reference path="../../Typedefs/moment/moment.d.ts"/>
///<reference path="../../Typedefs/velocity/velocity-animate.d.ts"/>
///<reference path="../../Typedefs/lodash/lodash.d.ts"/>
///<reference path="../../Typedefs/quill/quill.d.ts"/>
///<reference path="../../Typedefs/ie/ie.d.ts"/>
///<reference path="../../Typedefs/noUiSlider/noUiSlider.d.ts"/>
///<reference path="../../Typedefs/jquery.scrollbar/jquery.scrollbar.d.ts"/>
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Point = (function () {
            function Point(x, y) {
                this.x = x || 0;
                this.y = y || 0;
            }
            return Point;
        }());
        visuals.Point = Point;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Rect = (function () {
            // Constructor
            function Rect(left, top, width, height) {
                this.left = left || 0;
                this.top = top || 0;
                this.width = width || 0;
                this.height = height || 0;
            }
            return Rect;
        }());
        visuals.Rect = Rect;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        (function (LegendIcon) {
            LegendIcon[LegendIcon["Box"] = 0] = "Box";
            LegendIcon[LegendIcon["Circle"] = 1] = "Circle";
            LegendIcon[LegendIcon["Line"] = 2] = "Line";
        })(visuals.LegendIcon || (visuals.LegendIcon = {}));
        var LegendIcon = visuals.LegendIcon;
        (function (LegendPosition) {
            LegendPosition[LegendPosition["Top"] = 0] = "Top";
            LegendPosition[LegendPosition["Bottom"] = 1] = "Bottom";
            LegendPosition[LegendPosition["Right"] = 2] = "Right";
            LegendPosition[LegendPosition["Left"] = 3] = "Left";
            LegendPosition[LegendPosition["None"] = 4] = "None";
            LegendPosition[LegendPosition["TopCenter"] = 5] = "TopCenter";
            LegendPosition[LegendPosition["BottomCenter"] = 6] = "BottomCenter";
            LegendPosition[LegendPosition["RightCenter"] = 7] = "RightCenter";
            LegendPosition[LegendPosition["LeftCenter"] = 8] = "LeftCenter";
        })(visuals.LegendPosition || (visuals.LegendPosition = {}));
        var LegendPosition = visuals.LegendPosition;
        visuals.legendProps = {
            show: 'show',
            position: 'position',
            titleText: 'titleText',
            showTitle: 'showTitle',
            labelColor: 'labelColor',
            fontSize: 'fontSize',
        };
        function createLegend(legendParentElement, interactive, interactivityService, isScrollable, legendPosition) {
            if (isScrollable === void 0) { isScrollable = false; }
            if (legendPosition === void 0) { legendPosition = LegendPosition.Top; }
            if (interactive)
                return new CartesianChartInteractiveLegend(legendParentElement);
            else
                return new SVGLegend(legendParentElement, legendPosition, interactivityService, isScrollable);
        }
        visuals.createLegend = createLegend;
        var Legend;
        (function (Legend) {
            function isLeft(orientation) {
                switch (orientation) {
                    case LegendPosition.Left:
                    case LegendPosition.LeftCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isLeft = isLeft;
            function isTop(orientation) {
                switch (orientation) {
                    case LegendPosition.Top:
                    case LegendPosition.TopCenter:
                        return true;
                    default:
                        return false;
                }
            }
            Legend.isTop = isTop;
            function positionChartArea(chartArea, legend) {
                var legendMargins = legend.getMargins();
                var legendOrientation = legend.getOrientation();
                chartArea.style({
                    'margin-left': Legend.isLeft(legendOrientation) ? legendMargins.width + 'px' : null,
                    'margin-top': Legend.isTop(legendOrientation) ? legendMargins.height + 'px' : null,
                });
            }
            Legend.positionChartArea = positionChartArea;
        })(Legend = visuals.Legend || (visuals.Legend = {}));
        var SVGLegend = (function () {
            function SVGLegend(element, legendPosition, interactivityService, isScrollable) {
                this.legendDataStartIndex = 0;
                this.arrowPosWindow = 1;
                this.lastCalculatedWidth = 0;
                this.visibleLegendWidth = 0;
                this.visibleLegendHeight = 0;
                this.legendFontSizeMarginDifference = 0;
                this.legendFontSizeMarginValue = 0;
                this.svg = d3.select(element.get(0)).append('svg').style('position', 'absolute');
                this.svg.style('display', 'inherit');
                this.svg.classed('legend', true);
                if (interactivityService)
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.group = this.svg.append('g').attr('id', 'legendGroup');
                this.interactivityService = interactivityService;
                this.isScrollable = isScrollable;
                this.element = element;
                this.changeOrientation(legendPosition);
                this.parentViewport = { height: 0, width: 0 };
                this.calculateViewport();
                this.updateLayout();
            }
            SVGLegend.prototype.updateLayout = function () {
                var legendViewport = this.viewport;
                var orientation = this.orientation;
                this.svg.attr({
                    'height': legendViewport.height || (orientation === LegendPosition.None ? 0 : this.parentViewport.height),
                    'width': legendViewport.width || (orientation === LegendPosition.None ? 0 : this.parentViewport.width)
                });
                var isRight = orientation === LegendPosition.Right || orientation === LegendPosition.RightCenter;
                var isBottom = orientation === LegendPosition.Bottom || orientation === LegendPosition.BottomCenter;
                this.svg.style({
                    'margin-left': isRight ? (this.parentViewport.width - legendViewport.width) + 'px' : null,
                    'margin-top': isBottom ? (this.parentViewport.height - legendViewport.height) + 'px' : null,
                });
            };
            SVGLegend.prototype.calculateViewport = function () {
                switch (this.orientation) {
                    case LegendPosition.Top:
                    case LegendPosition.Bottom:
                    case LegendPosition.TopCenter:
                    case LegendPosition.BottomCenter:
                        var pixelHeight = PixelConverter.fromPointToPixel(this.data && this.data.fontSize ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt);
                        var fontHeightSize = SVGLegend.TopLegendHeight + (pixelHeight - SVGLegend.DefaultFontSizeInPt);
                        this.viewport = { height: fontHeightSize, width: 0 };
                        return;
                    case LegendPosition.Right:
                    case LegendPosition.Left:
                    case LegendPosition.RightCenter:
                    case LegendPosition.LeftCenter:
                        var width = this.lastCalculatedWidth ? this.lastCalculatedWidth : this.parentViewport.width * SVGLegend.LegendMaxWidthFactor;
                        this.viewport = { height: 0, width: width };
                        return;
                    case LegendPosition.None:
                        this.viewport = { height: 0, width: 0 };
                }
            };
            SVGLegend.prototype.getMargins = function () {
                return this.viewport;
            };
            SVGLegend.prototype.isVisible = function () {
                return this.orientation !== LegendPosition.None;
            };
            SVGLegend.prototype.changeOrientation = function (orientation) {
                if (orientation) {
                    this.orientation = orientation;
                }
                else {
                    this.orientation = LegendPosition.Top;
                }
                this.svg.attr('orientation', orientation);
            };
            SVGLegend.prototype.getOrientation = function () {
                return this.orientation;
            };
            SVGLegend.prototype.drawLegend = function (data, viewport) {
                // clone because we modify legend item label with ellipsis if it is truncated
                var clonedData = powerbi.Prototype.inherit(data);
                var newDataPoints = [];
                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    newDataPoints.push(powerbi.Prototype.inherit(dp));
                }
                clonedData.dataPoints = newDataPoints;
                this.setTooltipToLegendItems(clonedData);
                this.drawLegendInternal(clonedData, viewport, true /* perform auto width */);
            };
            SVGLegend.prototype.drawLegendInternal = function (data, viewport, autoWidth) {
                this.parentViewport = viewport;
                this.data = data;
                if (this.interactivityService)
                    this.interactivityService.applySelectionStateToData(data.dataPoints);
                if (data.dataPoints.length === 0) {
                    this.changeOrientation(LegendPosition.None);
                }
                if (this.getOrientation() === LegendPosition.None) {
                    data.dataPoints = [];
                }
                // Adding back the workaround for Legend Left/Right position for Map
                var mapControl = this.element.children(".mapControl");
                if (mapControl.length > 0 && !this.isTopOrBottom(this.orientation)) {
                    mapControl.css("display", "inline-block");
                }
                this.calculateViewport();
                var layout = this.calculateLayout(data, autoWidth);
                var titleLayout = layout.title;
                var titleData = titleLayout ? [titleLayout] : [];
                var hasSelection = this.interactivityService && powerbi.visuals.dataHasSelection(data.dataPoints);
                var group = this.group;
                //transform the wrapping group if position is centered
                if (this.isCentered(this.orientation)) {
                    var centerOffset = 0;
                    if (this.isTopOrBottom(this.orientation)) {
                        centerOffset = Math.max(0, (this.parentViewport.width - this.visibleLegendWidth) / 2);
                        group.attr('transform', visuals.SVGUtil.translate(centerOffset, 0));
                    }
                    else {
                        centerOffset = Math.max((this.parentViewport.height - this.visibleLegendHeight) / 2);
                        group.attr('transform', visuals.SVGUtil.translate(0, centerOffset));
                    }
                }
                else {
                    group.attr('transform', null);
                }
                var legendTitle = group
                    .selectAll(SVGLegend.LegendTitle.selector)
                    .data(titleData);
                legendTitle.enter()
                    .append('text')
                    .classed(SVGLegend.LegendTitle.class, true);
                legendTitle
                    .style({
                    'fill': data.labelColor,
                    'font-size': PixelConverter.fromPoint(data.fontSize),
                    'font-family': SVGLegend.DefaultTitleFontFamily
                })
                    .text(function (d) { return d.text; })
                    .attr({
                    'x': function (d) { return d.x; },
                    'y': function (d) { return d.y; }
                })
                    .append('title').text(data.title);
                legendTitle.exit().remove();
                var virtualizedDataPoints = data.dataPoints.slice(this.legendDataStartIndex, this.legendDataStartIndex + layout.numberOfItems);
                var iconRadius = powerbi.TextMeasurementService.estimateSvgTextHeight(SVGLegend.getTextProperties(false, '', this.data.fontSize)) / SVGLegend.LegendIconRadiusFactor;
                iconRadius = (this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin) && iconRadius > SVGLegend.LegendIconRadius
                    ? iconRadius :
                    SVGLegend.LegendIconRadius;
                var legendItems = group
                    .selectAll(SVGLegend.LegendItem.selector)
                    .data(virtualizedDataPoints, function (d) { return d.identity.getKey(); });
                var itemsEnter = legendItems.enter()
                    .append('g')
                    .classed(SVGLegend.LegendItem.class, true);
                itemsEnter
                    .append('circle')
                    .classed(SVGLegend.LegendIcon.class, true);
                itemsEnter
                    .append('text')
                    .classed(SVGLegend.LegendText.class, true);
                itemsEnter
                    .append('title')
                    .text(function (d) { return d.tooltip; });
                itemsEnter
                    .style({
                    'font-family': SVGLegend.DefaultFontFamily
                });
                legendItems
                    .select(SVGLegend.LegendIcon.selector)
                    .attr({
                    'cx': function (d, i) { return d.glyphPosition.x; },
                    'cy': function (d) { return d.glyphPosition.y; },
                    'r': iconRadius,
                })
                    .style({
                    'fill': function (d) {
                        if (hasSelection && !d.selected)
                            return visuals.LegendBehavior.dimmedLegendColor;
                        else
                            return d.color;
                    }
                });
                legendItems
                    .select('title')
                    .text(function (d) { return d.tooltip; });
                legendItems
                    .select(SVGLegend.LegendText.selector)
                    .attr({
                    'x': function (d) { return d.textPosition.x; },
                    'y': function (d) { return d.textPosition.y; },
                })
                    .text(function (d) { return d.label; })
                    .style({
                    'fill': data.labelColor,
                    'font-size': PixelConverter.fromPoint(data.fontSize)
                });
                if (this.interactivityService) {
                    var iconsSelection = legendItems.select(SVGLegend.LegendIcon.selector);
                    var behaviorOptions = {
                        legendItems: legendItems,
                        legendIcons: iconsSelection,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.bind(data.dataPoints, new visuals.LegendBehavior(), behaviorOptions, { isLegend: true });
                }
                legendItems.exit().remove();
                this.drawNavigationArrows(layout.navigationArrows);
                this.updateLayout();
            };
            SVGLegend.prototype.normalizePosition = function (points) {
                if (this.legendDataStartIndex >= points.length) {
                    this.legendDataStartIndex = points.length - 1;
                }
                if (this.legendDataStartIndex < 0) {
                    this.legendDataStartIndex = 0;
                }
            };
            SVGLegend.prototype.calculateTitleLayout = function (title) {
                var width = 0;
                var hasTitle = !_.isEmpty(title);
                if (hasTitle) {
                    var isHorizontal = this.isTopOrBottom(this.orientation);
                    var maxMeasureLength = void 0;
                    if (isHorizontal) {
                        var fontSizeMargin = this.legendFontSizeMarginValue > SVGLegend.DefaultTextMargin ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding;
                        var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius;
                        var fixedHorizontalTextShift = SVGLegend.LegendIconRadius + fontSizeMargin + fixedHorizontalIconShift;
                        maxMeasureLength = this.parentViewport.width * SVGLegend.LegendMaxWidthFactor - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                    }
                    else {
                        maxMeasureLength = this.legendFontSizeMarginValue < SVGLegend.DefaultTextMargin ? SVGLegend.MaxTitleLength :
                            SVGLegend.MaxTitleLength + (SVGLegend.DefaultMaxLegendFactor * this.legendFontSizeMarginDifference);
                    }
                    var textProperties = SVGLegend.getTextProperties(true, title, this.data.fontSize);
                    var text = title;
                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (width > maxMeasureLength) {
                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxMeasureLength);
                        width = maxMeasureLength;
                    }
                    ;
                    if (isHorizontal)
                        width += SVGLegend.TitlePadding;
                    else
                        text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, this.viewport.width);
                    return {
                        x: 0,
                        y: 0,
                        text: text,
                        width: width,
                        height: powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties)
                    };
                }
                return null;
            };
            /** Performs layout offline for optimal perfomance */
            SVGLegend.prototype.calculateLayout = function (data, autoWidth) {
                var dataPoints = data.dataPoints;
                if (data.dataPoints.length === 0) {
                    return {
                        startIndex: null,
                        numberOfItems: 0,
                        title: null,
                        navigationArrows: []
                    };
                }
                this.legendFontSizeMarginValue = PixelConverter.fromPointToPixel(this.data && this.data.fontSize !== undefined ? this.data.fontSize : SVGLegend.DefaultFontSizeInPt);
                this.legendFontSizeMarginDifference = (this.legendFontSizeMarginValue - SVGLegend.DefaultTextMargin);
                this.normalizePosition(dataPoints);
                if (this.legendDataStartIndex < dataPoints.length) {
                    dataPoints = dataPoints.slice(this.legendDataStartIndex);
                }
                var title = this.calculateTitleLayout(data.title);
                var navArrows;
                var numberOfItems;
                if (this.isTopOrBottom(this.orientation)) {
                    navArrows = this.isScrollable ? this.calculateHorizontalNavigationArrowsLayout(title) : [];
                    numberOfItems = this.calculateHorizontalLayout(dataPoints, title, navArrows);
                }
                else {
                    navArrows = this.isScrollable ? this.calculateVerticalNavigationArrowsLayout(title) : [];
                    numberOfItems = this.calculateVerticalLayout(dataPoints, title, navArrows, autoWidth);
                }
                return {
                    numberOfItems: numberOfItems,
                    title: title,
                    navigationArrows: navArrows
                };
            };
            SVGLegend.prototype.updateNavigationArrowLayout = function (navigationArrows, remainingDataLength, visibleDataLength) {
                if (this.legendDataStartIndex === 0) {
                    navigationArrows.shift();
                }
                var lastWindow = this.arrowPosWindow;
                this.arrowPosWindow = visibleDataLength;
                if (navigationArrows && navigationArrows.length > 0 && this.arrowPosWindow === remainingDataLength) {
                    this.arrowPosWindow = lastWindow;
                    navigationArrows.length = navigationArrows.length - 1;
                }
            };
            SVGLegend.prototype.calculateHorizontalNavigationArrowsLayout = function (title) {
                var height = SVGLegend.LegendArrowHeight;
                var width = SVGLegend.LegendArrowWidth;
                var translateY = (this.viewport.height / 2) - (height / 2);
                var data = [];
                var rightShift = title ? title.x + title.width : 0;
                var arrowLeft = visuals.SVGUtil.createArrow(width, height, 180 /*angle*/);
                var arrowRight = visuals.SVGUtil.createArrow(width, height, 0 /*angle*/);
                data.push({
                    x: rightShift,
                    y: translateY,
                    path: arrowLeft.path,
                    rotateTransform: arrowLeft.transform,
                    type: 1 /* Decrease */
                });
                data.push({
                    x: this.parentViewport.width - width,
                    y: translateY,
                    path: arrowRight.path,
                    rotateTransform: arrowRight.transform,
                    type: 0 /* Increase */
                });
                return data;
            };
            SVGLegend.prototype.calculateVerticalNavigationArrowsLayout = function (title) {
                var height = SVGLegend.LegendArrowHeight;
                var width = SVGLegend.LegendArrowWidth;
                var verticalCenter = this.viewport.height / 2;
                var data = [];
                var rightShift = verticalCenter + height / 2;
                var arrowTop = visuals.SVGUtil.createArrow(width, height, 270 /*angle*/);
                var arrowBottom = visuals.SVGUtil.createArrow(width, height, 90 /*angle*/);
                var titleHeight = title ? title.height : 0;
                data.push({
                    x: rightShift,
                    y: width + titleHeight,
                    path: arrowTop.path,
                    rotateTransform: arrowTop.transform,
                    type: 1 /* Decrease */
                });
                data.push({
                    x: rightShift,
                    y: this.parentViewport.height - height,
                    path: arrowBottom.path,
                    rotateTransform: arrowBottom.transform,
                    type: 0 /* Increase */
                });
                return data;
            };
            SVGLegend.prototype.calculateHorizontalLayout = function (dataPoints, title, navigationArrows) {
                debug.assertValue(navigationArrows, 'navigationArrows');
                // calculate the text shift
                var HorizontalTextShift = 4 + SVGLegend.LegendIconRadius;
                // check if we need more space for the margin, or use the default text padding
                var fontSizeBiggerThanDefault = this.legendFontSizeMarginDifference > 0;
                var fontSizeMargin = fontSizeBiggerThanDefault ? SVGLegend.TextAndIconPadding + this.legendFontSizeMarginDifference : SVGLegend.TextAndIconPadding;
                var fixedTextShift = (fontSizeMargin / (SVGLegend.LegendIconRadiusFactor / 2)) + HorizontalTextShift;
                var totalSpaceOccupiedThusFar = 0;
                // calculate the size of the space for both sides of the radius
                var iconTotalItemPadding = SVGLegend.LegendIconRadius * 2 + fontSizeMargin * 1.5;
                var numberOfItems = dataPoints.length;
                // get the Y coordinate which is the middle of the container + the middle of the text height - the delta of the text 
                var defaultTextProperties = SVGLegend.getTextProperties(false, '', this.data.fontSize);
                var verticalCenter = this.viewport.height / 2;
                var textYCoordinate = verticalCenter + powerbi.TextMeasurementService.estimateSvgTextHeight(defaultTextProperties) / 2
                    - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(defaultTextProperties);
                if (title) {
                    totalSpaceOccupiedThusFar += title.width;
                    // get the Y coordinate which is the middle of the container + the middle of the text height - the delta of the text 
                    title.y = verticalCenter + title.height / 2 - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(SVGLegend.getTextProperties(true, title.text, this.data.fontSize));
                }
                // if an arrow should be added, we add space for it
                if (this.legendDataStartIndex > 0) {
                    totalSpaceOccupiedThusFar += SVGLegend.LegendArrowOffset;
                }
                // This bit expands the max lengh if there are only a few items
                // so longer labels can potentially get more space, and not be
                // ellipsed. 
                var dataPointsLength = dataPoints.length;
                var parentWidth = this.parentViewport.width;
                var maxTextLength = dataPointsLength > 0
                    ? (((parentWidth - totalSpaceOccupiedThusFar) - (iconTotalItemPadding * dataPointsLength)) / dataPointsLength) | 0
                    : 0;
                maxTextLength = maxTextLength > SVGLegend.MaxTextLength ? maxTextLength : SVGLegend.MaxTextLength;
                for (var i = 0; i < dataPointsLength; i++) {
                    var dp = dataPoints[i];
                    var textProperties = SVGLegend.getTextProperties(false, dp.label, this.data.fontSize);
                    dp.glyphPosition = {
                        // the space taken so far + the radius + the margin / radiusFactor to prevent huge spaces
                        x: totalSpaceOccupiedThusFar + SVGLegend.LegendIconRadius + (this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor),
                        // The middle of the container but a bit lower due to text not being in the middle (qP for example making middle between q and P)
                        y: (this.viewport.height * SVGLegend.LegendIconYRatio),
                    };
                    dp.textPosition = {
                        x: totalSpaceOccupiedThusFar + fixedTextShift,
                        y: textYCoordinate,
                    };
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    var spaceTakenByItem = 0;
                    if (width < maxTextLength) {
                        spaceTakenByItem = iconTotalItemPadding + width;
                    }
                    else {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxTextLength);
                        dp.label = text;
                        spaceTakenByItem = iconTotalItemPadding + maxTextLength;
                    }
                    totalSpaceOccupiedThusFar += spaceTakenByItem;
                    if (totalSpaceOccupiedThusFar > parentWidth) {
                        numberOfItems = i;
                        break;
                    }
                }
                this.visibleLegendWidth = totalSpaceOccupiedThusFar;
                this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems);
                return numberOfItems;
            };
            SVGLegend.prototype.calculateVerticalLayout = function (dataPoints, title, navigationArrows, autoWidth) {
                var _this = this;
                // check if we need more space for the margin, or use the default text padding
                var fontSizeBiggerThenDefault = this.legendFontSizeMarginDifference > 0;
                var fontFactor = fontSizeBiggerThenDefault ? this.legendFontSizeMarginDifference : 0;
                // calculate the size needed after font size change
                var verticalLegendHeight = 20 + fontFactor;
                var spaceNeededByTitle = 15 + fontFactor;
                var extraShiftForTextAlignmentToIcon = 4 + fontFactor;
                var totalSpaceOccupiedThusFar = verticalLegendHeight;
                // the default space for text and icon radius + the margin after the font size change
                var fixedHorizontalIconShift = SVGLegend.TextAndIconPadding + SVGLegend.LegendIconRadius + (this.legendFontSizeMarginDifference / SVGLegend.LegendIconRadiusFactor);
                var fixedHorizontalTextShift = fixedHorizontalIconShift * 2;
                // check how much space is needed
                var maxHorizontalSpaceAvaliable = autoWidth
                    ? this.parentViewport.width * SVGLegend.LegendMaxWidthFactor
                        - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth
                    : this.lastCalculatedWidth
                        - fixedHorizontalTextShift - SVGLegend.LegendEdgeMariginWidth;
                var numberOfItems = dataPoints.length;
                var maxHorizontalSpaceUsed = 0;
                var parentHeight = this.parentViewport.height;
                if (title) {
                    totalSpaceOccupiedThusFar += spaceNeededByTitle;
                    title.x = SVGLegend.TextAndIconPadding;
                    title.y = spaceNeededByTitle;
                    maxHorizontalSpaceUsed = title.width || 0;
                }
                // if an arrow should be added, we add space for it
                if (this.legendDataStartIndex > 0)
                    totalSpaceOccupiedThusFar += SVGLegend.LegendArrowOffset;
                var dataPointsLength = dataPoints.length;
                for (var i = 0; i < dataPointsLength; i++) {
                    var dp = dataPoints[i];
                    var textProperties = SVGLegend.getTextProperties(false, dp.label, this.data.fontSize);
                    dp.glyphPosition = {
                        x: fixedHorizontalIconShift,
                        y: (totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties)
                    };
                    dp.textPosition = {
                        x: fixedHorizontalTextShift,
                        y: totalSpaceOccupiedThusFar + extraShiftForTextAlignmentToIcon
                    };
                    // TODO: [PERF] Get rid of this extra measurement, and modify
                    // getTailoredTextToReturnWidth + Text
                    var width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (width > maxHorizontalSpaceUsed) {
                        maxHorizontalSpaceUsed = width;
                    }
                    if (width > maxHorizontalSpaceAvaliable) {
                        var text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxHorizontalSpaceAvaliable);
                        dp.label = text;
                    }
                    totalSpaceOccupiedThusFar += verticalLegendHeight;
                    if (totalSpaceOccupiedThusFar > parentHeight) {
                        numberOfItems = i;
                        break;
                    }
                }
                if (autoWidth) {
                    if (maxHorizontalSpaceUsed < maxHorizontalSpaceAvaliable) {
                        this.lastCalculatedWidth = this.viewport.width = Math.ceil(maxHorizontalSpaceUsed + fixedHorizontalTextShift + SVGLegend.LegendEdgeMariginWidth);
                    }
                    else {
                        this.lastCalculatedWidth = this.viewport.width = Math.ceil(this.parentViewport.width * SVGLegend.LegendMaxWidthFactor);
                    }
                }
                else {
                    this.viewport.width = this.lastCalculatedWidth;
                }
                this.visibleLegendHeight = totalSpaceOccupiedThusFar;
                navigationArrows.forEach(function (d) { return d.x = _this.lastCalculatedWidth / 2; });
                this.updateNavigationArrowLayout(navigationArrows, dataPointsLength, numberOfItems);
                return numberOfItems;
            };
            SVGLegend.prototype.drawNavigationArrows = function (layout) {
                var _this = this;
                var arrows = this.group.selectAll(SVGLegend.NavigationArrow.selector)
                    .data(layout);
                arrows
                    .enter()
                    .append('g')
                    .on('click', function (d) {
                    var pos = _this.legendDataStartIndex;
                    _this.legendDataStartIndex = d.type === 0 /* Increase */
                        ? pos + _this.arrowPosWindow : pos - _this.arrowPosWindow;
                    _this.drawLegendInternal(_this.data, _this.parentViewport, false);
                })
                    .classed(SVGLegend.NavigationArrow.class, true)
                    .append('path');
                arrows
                    .attr('transform', function (d) { return visuals.SVGUtil.translate(d.x, d.y); })
                    .select('path')
                    .attr({
                    'd': function (d) { return d.path; },
                    'transform': function (d) { return d.rotateTransform; }
                });
                arrows.exit().remove();
            };
            SVGLegend.prototype.isTopOrBottom = function (orientation) {
                switch (orientation) {
                    case LegendPosition.Top:
                    case LegendPosition.Bottom:
                    case LegendPosition.BottomCenter:
                    case LegendPosition.TopCenter:
                        return true;
                    default:
                        return false;
                }
            };
            SVGLegend.prototype.isCentered = function (orientation) {
                switch (orientation) {
                    case LegendPosition.BottomCenter:
                    case LegendPosition.LeftCenter:
                    case LegendPosition.RightCenter:
                    case LegendPosition.TopCenter:
                        return true;
                    default:
                        return false;
                }
            };
            SVGLegend.prototype.reset = function () {
                // Intentionally left blank. 
            };
            SVGLegend.getTextProperties = function (isTitle, text, fontSize) {
                return {
                    text: text,
                    fontFamily: isTitle ? SVGLegend.DefaultTitleFontFamily : SVGLegend.DefaultFontFamily,
                    fontSize: PixelConverter.fromPoint(fontSize || SVGLegend.DefaultFontSizeInPt)
                };
            };
            SVGLegend.prototype.setTooltipToLegendItems = function (data) {
                //we save the values to tooltip before cut
                for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                    var dataPoint = _a[_i];
                    dataPoint.tooltip = dataPoint.label;
                }
            };
            SVGLegend.DefaultFontSizeInPt = 8;
            SVGLegend.LegendIconRadius = 5;
            SVGLegend.LegendIconRadiusFactor = 5;
            SVGLegend.MaxTextLength = 60;
            SVGLegend.MaxTitleLength = 80;
            SVGLegend.TextAndIconPadding = 5;
            SVGLegend.TitlePadding = 15;
            SVGLegend.LegendEdgeMariginWidth = 10;
            SVGLegend.LegendMaxWidthFactor = 0.3;
            SVGLegend.TopLegendHeight = 24;
            SVGLegend.DefaultTextMargin = PixelConverter.fromPointToPixel(SVGLegend.DefaultFontSizeInPt);
            SVGLegend.DefaultMaxLegendFactor = SVGLegend.MaxTitleLength / SVGLegend.DefaultTextMargin;
            SVGLegend.LegendIconYRatio = 0.52;
            // Navigation Arrow constants
            SVGLegend.LegendArrowOffset = 10;
            SVGLegend.LegendArrowHeight = 15;
            SVGLegend.LegendArrowWidth = 7.5;
            SVGLegend.DefaultFontFamily = 'wf_segoe-ui_normal';
            SVGLegend.DefaultTitleFontFamily = 'wf_segoe-ui_Semibold';
            SVGLegend.LegendItem = createClassAndSelector('legendItem');
            SVGLegend.LegendText = createClassAndSelector('legendText');
            SVGLegend.LegendIcon = createClassAndSelector('legendIcon');
            SVGLegend.LegendTitle = createClassAndSelector('legendTitle');
            SVGLegend.NavigationArrow = createClassAndSelector('navArrow');
            return SVGLegend;
        }());
        visuals.SVGLegend = SVGLegend;
        var CartesianChartInteractiveLegend = (function () {
            function CartesianChartInteractiveLegend(element) {
                this.legendContainerParent = d3.select(element.get(0));
            }
            CartesianChartInteractiveLegend.prototype.getMargins = function () {
                return {
                    height: CartesianChartInteractiveLegend.LegendHeight,
                    width: 0
                };
            };
            CartesianChartInteractiveLegend.prototype.drawLegend = function (legendData) {
                debug.assertValue(legendData, 'legendData');
                var data = legendData.dataPoints;
                debug.assertValue(data, 'dataPoints');
                if (data.length < 1)
                    return;
                var legendContainerDiv = this.legendContainerParent.select(CartesianChartInteractiveLegend.LegendContainerSelector);
                if (legendContainerDiv.empty()) {
                    if (!data.length)
                        return;
                    var divToPrepend = $('<div></div>')
                        .height(this.getMargins().height)
                        .addClass(CartesianChartInteractiveLegend.LegendContainerClass);
                    // Prepending, as legend should always be on topmost visual.
                    $(this.legendContainerParent[0]).prepend(divToPrepend);
                    legendContainerDiv = d3.select(divToPrepend.get(0));
                }
                this.legendContainerDiv = legendContainerDiv;
                // Construct the legend title and items.
                this.drawTitle(data);
                this.drawLegendItems(data);
            };
            CartesianChartInteractiveLegend.prototype.reset = function () {
                if (this.legendContainerDiv) {
                    this.legendContainerDiv.remove();
                    this.legendContainerDiv = null;
                }
            };
            CartesianChartInteractiveLegend.prototype.isVisible = function () {
                return true;
            };
            CartesianChartInteractiveLegend.prototype.changeOrientation = function (orientation) {
                // Not supported
            };
            CartesianChartInteractiveLegend.prototype.getOrientation = function () {
                return LegendPosition.Top;
            };
            /**
             * Draw the legend title
             */
            CartesianChartInteractiveLegend.prototype.drawTitle = function (data) {
                debug.assert(data && data.length > 0, 'data is null or empty');
                var titleDiv = this.legendContainerDiv.selectAll('div.' + CartesianChartInteractiveLegend.LegendTitleClass);
                var item = titleDiv.data([data[0]]);
                // Enter
                var itemEnter = item.enter();
                var titleDivEnter = itemEnter.append('div').attr('class', CartesianChartInteractiveLegend.LegendTitleClass);
                titleDivEnter
                    .filter(function (d) { return d.iconOnlyOnLabel; })
                    .append('span')
                    .attr('class', CartesianChartInteractiveLegend.legendIconClass)
                    .html(CartesianChartInteractiveLegend.legendPlaceSelector);
                titleDivEnter.append('span');
                // Update
                item.filter(function (d) { return d.iconOnlyOnLabel; })
                    .select('span.' + CartesianChartInteractiveLegend.legendIconClass)
                    .style(CartesianChartInteractiveLegend.legendColorCss, function (d) { return d.color; });
                item.select('span:last-child').text(function (d) { return d.category; });
            };
            /**
             * Draw the legend items
             */
            CartesianChartInteractiveLegend.prototype.drawLegendItems = function (data) {
                // Add Mesaures - the items of the category in the legend
                this.ensureLegendTableCreated();
                var dataPointsMatrix = CartesianChartInteractiveLegend.splitArrayToOddEven(data);
                var legendItemsContainer = this.legendContainerDiv.select('tbody').selectAll('tr').data(dataPointsMatrix);
                // trs is table rows. 
                // there are two table rows.
                // the order of insertion to the legend table is:
                // Even data points got inserted into the 1st line
                // Odd data points got inserted into the 2nd line
                // ----------------------------
                // | value0 | value 2 | value 4
                // ----------------------------
                // | value1 | value 3 | 
                // ----------------------------
                // 
                // Enter
                var legendItemsEnter = legendItemsContainer.enter();
                var rowEnter = legendItemsEnter.append('tr');
                var cellEnter = rowEnter.selectAll('td')
                    .data(function (d) { return d; }, function (d) { return d.label; })
                    .enter()
                    .append('td').attr('class', CartesianChartInteractiveLegend.LegendItem);
                var cellSpanEnter = cellEnter.append('span');
                cellSpanEnter.filter(function (d) { return !d.iconOnlyOnLabel; })
                    .append('span')
                    .html(CartesianChartInteractiveLegend.legendPlaceSelector)
                    .attr('class', CartesianChartInteractiveLegend.legendIconClass)
                    .attr('white-space', 'nowrap');
                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemNameClass);
                cellSpanEnter.append('span').attr('class', CartesianChartInteractiveLegend.legendItemMeasureClass);
                // Update
                var legendCells = legendItemsContainer.selectAll('td').data(function (d) { return d; }, function (d) { return d.label; });
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemNameClass).html(function (d) { return powerbi.visuals.TextUtil.removeBreakingSpaces(d.label); });
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendItemMeasureClass).html(function (d) { return '&nbsp;' + d.measure; });
                legendCells.select('span.' + CartesianChartInteractiveLegend.legendIconClass).style('color', function (d) { return d.color; });
                // Exit
                legendCells.exit().remove();
            };
            /**
             * Ensure legend table is created and set horizontal pan gestures on it
             */
            CartesianChartInteractiveLegend.prototype.ensureLegendTableCreated = function () {
                if (this.legendContainerDiv.select('div table').empty()) {
                    var legendTable = this.legendContainerDiv.append('div').append('table');
                    legendTable.style('table-layout', 'fixed').append('tbody');
                    // Setup Pan Gestures of the legend
                    this.setPanGestureOnLegend(legendTable);
                }
            };
            /**
             * Set Horizontal Pan gesture for the legend
             */
            CartesianChartInteractiveLegend.prototype.setPanGestureOnLegend = function (legendTable) {
                var viewportWidth = $(this.legendContainerDiv.select('div:nth-child(2)')[0]).width();
                var xscale = d3.scale.linear().domain([0, viewportWidth]).range([0, viewportWidth]);
                var zoom = d3.behavior.zoom()
                    .scaleExtent([1, 1]) // disable scaling
                    .x(xscale)
                    .on("zoom", function () {
                    // horizontal pan is valid only in case the legend items width are bigger than the viewport width
                    if ($(legendTable[0]).width() > viewportWidth) {
                        var t = zoom.translate();
                        var tx_1 = t[0];
                        var ty = t[1];
                        tx_1 = Math.min(tx_1, 0);
                        tx_1 = Math.max(tx_1, viewportWidth - $(legendTable[0]).width());
                        zoom.translate([tx_1, ty]);
                        legendTable.style("-ms-transform", function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        });
                        legendTable.style("-webkit-transform", function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        });
                        legendTable.style("transform", function () {
                            return visuals.SVGUtil.translateXWithPixels(tx_1);
                        });
                    }
                });
                if (this.legendContainerDiv) {
                    this.legendContainerDiv.call(zoom);
                }
                else {
                    legendTable.call(zoom);
                }
            };
            /**
             * Split legend data points array into odd and even arrays
             * Even array will be the legend first line and Odd array will be the 2nd legend line
             */
            CartesianChartInteractiveLegend.splitArrayToOddEven = function (data) {
                var oddData = [];
                var evenData = [];
                for (var i = 0; i < data.length; ++i) {
                    if (i % 2 === 0) {
                        evenData.push(data[i]);
                    }
                    else {
                        oddData.push(data[i]);
                    }
                }
                return [evenData, oddData];
            };
            CartesianChartInteractiveLegend.LegendHeight = 70;
            CartesianChartInteractiveLegend.LegendContainerClass = 'interactive-legend';
            CartesianChartInteractiveLegend.LegendContainerSelector = '.interactive-legend';
            CartesianChartInteractiveLegend.LegendTitleClass = 'title';
            CartesianChartInteractiveLegend.LegendItem = 'item';
            CartesianChartInteractiveLegend.legendPlaceSelector = '\u25A0';
            CartesianChartInteractiveLegend.legendIconClass = 'icon';
            CartesianChartInteractiveLegend.legendColorCss = 'color';
            CartesianChartInteractiveLegend.legendItemNameClass = 'itemName';
            CartesianChartInteractiveLegend.legendItemMeasureClass = 'itemMeasure';
            return CartesianChartInteractiveLegend;
        }());
        var LegendData;
        (function (LegendData) {
            LegendData.DefaultLegendLabelFillColor = '#666666';
            function update(legendData, legendObject) {
                debug.assertValue(legendData, 'legendData');
                debug.assertValue(legendObject, 'legendObject');
                if (legendObject[visuals.legendProps.show] == null) {
                    legendObject[visuals.legendProps.show] = true;
                }
                if (legendObject[visuals.legendProps.show] === false)
                    legendData.dataPoints = [];
                if (legendObject[visuals.legendProps.show] === true && legendObject[visuals.legendProps.position] == null)
                    legendObject[visuals.legendProps.position] = visuals.legendPosition.top;
                if (legendObject[visuals.legendProps.fontSize] !== undefined)
                    legendData.fontSize = legendObject[visuals.legendProps.fontSize];
                if (legendObject[visuals.legendProps.labelColor] !== undefined) {
                    var fillColor = legendObject[visuals.legendProps.labelColor];
                    if (fillColor != null) {
                        legendData.labelColor = fillColor.solid.color;
                    }
                }
                if (legendObject[visuals.legendProps.showTitle] === false)
                    legendData.title = "";
                else if (legendObject[visuals.legendProps.titleText] !== undefined) {
                    legendData.title = legendObject[visuals.legendProps.titleText];
                }
            }
            LegendData.update = update;
        })(LegendData = visuals.LegendData || (visuals.LegendData = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisScale;
        (function (axisScale) {
            axisScale.linear = 'linear';
            axisScale.log = 'log';
            axisScale.type = powerbi.createEnumType([
                { value: axisScale.linear, displayName: function (resources) { return resources.get('Visual_Axis_Linear'); } },
                { value: axisScale.log, displayName: function (resources) { return resources.get('Visual_Axis_Log'); } }
            ]);
        })(axisScale = visuals.axisScale || (visuals.axisScale = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisStyle;
        (function (axisStyle) {
            axisStyle.showBoth = 'showBoth';
            axisStyle.showTitleOnly = 'showTitleOnly';
            axisStyle.showUnitOnly = 'showUnitOnly';
            axisStyle.type = powerbi.createEnumType([
                { value: axisStyle.showTitleOnly, displayName: function (resources) { return resources.get('Visual_Axis_ShowTitleOnly'); } },
                { value: axisStyle.showUnitOnly, displayName: function (resources) { return resources.get('Visual_Axis_ShowUnitOnly'); } },
                { value: axisStyle.showBoth, displayName: function (resources) { return resources.get('Visual_Axis_ShowBoth'); } }
            ]);
        })(axisStyle = visuals.axisStyle || (visuals.axisStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var axisType;
        (function (axisType) {
            axisType.scalar = 'Scalar';
            axisType.categorical = 'Categorical';
            axisType.both = 'Both';
            axisType.type = powerbi.createEnumType([
                { value: axisType.scalar, displayName: function (resources) { return resources.get('Visual_Axis_Scalar'); } },
                { value: axisType.categorical, displayName: function (resources) { return resources.get('Visual_Axis_Categorical'); } },
            ]);
        })(axisType = visuals.axisType || (visuals.axisType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var basicShapeType;
        (function (basicShapeType) {
            basicShapeType.rectangle = 'rectangle';
            basicShapeType.oval = 'oval';
            basicShapeType.line = 'line';
            basicShapeType.arrow = 'arrow';
            basicShapeType.triangle = 'triangle';
            basicShapeType.type = powerbi.createEnumType([
                { value: basicShapeType.rectangle, displayName: 'rectangle' },
                { value: basicShapeType.oval, displayName: 'oval' },
                { value: basicShapeType.line, displayName: 'line' },
                { value: basicShapeType.arrow, displayName: 'arrow' },
                { value: basicShapeType.triangle, displayName: 'triangle' }
            ]);
        })(basicShapeType = visuals.basicShapeType || (visuals.basicShapeType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var imageScalingType;
        (function (imageScalingType) {
            imageScalingType.normal = 'Normal';
            imageScalingType.fit = 'Fit';
            imageScalingType.fill = 'Fill';
            imageScalingType.type = powerbi.createEnumType([
                { value: imageScalingType.normal, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Normal'); } },
                { value: imageScalingType.fit, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Fit'); } },
                { value: imageScalingType.fill, displayName: function (resources) { return resources.get('Visual_ImageScalingType_Fill'); } },
            ]);
        })(imageScalingType = visuals.imageScalingType || (visuals.imageScalingType = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var labelPosition;
        (function (labelPosition) {
            labelPosition.insideEnd = 'InsideEnd';
            labelPosition.insideCenter = 'InsideCenter';
            labelPosition.outsideEnd = 'OutsideEnd';
            labelPosition.insideBase = 'InsideBase';
            labelPosition.type = powerbi.createEnumType([
                { value: labelPosition.insideEnd, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideEnd'); } },
                { value: labelPosition.outsideEnd, displayName: function (resources) { return resources.get('Visual_LabelPosition_OutsideEnd'); } },
                { value: labelPosition.insideCenter, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideCenter'); } },
                { value: labelPosition.insideBase, displayName: function (resources) { return resources.get('Visual_LabelPosition_InsideBase'); } },
            ]);
        })(labelPosition = visuals.labelPosition || (visuals.labelPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var labelStyle;
        (function (labelStyle) {
            labelStyle.category = 'Category';
            labelStyle.data = 'Data';
            labelStyle.both = 'Both';
            labelStyle.type = powerbi.createEnumType([
                { value: labelStyle.category, displayName: function (resources) { return resources.get('Visual_LabelStyle_Category'); } },
                { value: labelStyle.data, displayName: function (resources) { return resources.get('Visual_LabelStyle_DataValue'); } },
                { value: labelStyle.both, displayName: function (resources) { return resources.get('Visual_LabelStyle_Both'); } },
            ]);
        })(labelStyle = visuals.labelStyle || (visuals.labelStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var legendPosition;
        (function (legendPosition) {
            legendPosition.top = 'Top';
            legendPosition.bottom = 'Bottom';
            legendPosition.left = 'Left';
            legendPosition.right = 'Right';
            legendPosition.topCenter = 'TopCenter';
            legendPosition.bottomCenter = 'BottomCenter';
            legendPosition.leftCenter = 'LeftCenter';
            legendPosition.rightCenter = 'RightCenter';
            legendPosition.type = powerbi.createEnumType([
                { value: legendPosition.top, displayName: function (resources) { return resources.get('Visual_LegendPosition_Top'); } },
                { value: legendPosition.bottom, displayName: function (resources) { return resources.get('Visual_LegendPosition_Bottom'); } },
                { value: legendPosition.left, displayName: function (resources) { return resources.get('Visual_LegendPosition_Left'); } },
                { value: legendPosition.right, displayName: function (resources) { return resources.get('Visual_LegendPosition_Right'); } },
                { value: legendPosition.topCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_TopCenter'); } },
                { value: legendPosition.bottomCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_BottomCenter'); } },
                { value: legendPosition.leftCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_LeftCenter'); } },
                { value: legendPosition.rightCenter, displayName: function (resources) { return resources.get('Visual_LegendPosition_RightCenter'); } },
            ]);
        })(legendPosition = visuals.legendPosition || (visuals.legendPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var kpiDirection;
        (function (kpiDirection) {
            kpiDirection.positive = 'Positive';
            kpiDirection.negative = 'Negative';
            kpiDirection.type = powerbi.createEnumType([
                { value: kpiDirection.positive, displayName: function (resources) { return resources.get('Visual_KPI_Direction_Positive'); } },
                { value: kpiDirection.negative, displayName: function (resources) { return resources.get('Visual_KPI_Direction_Negative'); } }
            ]);
        })(kpiDirection = visuals.kpiDirection || (visuals.kpiDirection = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var lineStyle;
        (function (lineStyle) {
            lineStyle.dashed = 'dashed';
            lineStyle.solid = 'solid';
            lineStyle.dotted = 'dotted';
            lineStyle.type = powerbi.createEnumType([
                { value: lineStyle.dashed, displayName: function (resources) { return resources.get('Visual_LineStyle_Dashed'); } },
                { value: lineStyle.solid, displayName: function (resources) { return resources.get('Visual_LineStyle_Solid'); } },
                { value: lineStyle.dotted, displayName: function (resources) { return resources.get('Visual_LineStyle_Dotted'); } }
            ]);
        })(lineStyle = visuals.lineStyle || (visuals.lineStyle = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var outline;
        (function (outline_1) {
            outline_1.none = 'None';
            outline_1.bottomOnly = 'BottomOnly';
            outline_1.topOnly = 'TopOnly';
            outline_1.leftOnly = 'LeftOnly';
            outline_1.rightOnly = 'RightOnly';
            outline_1.topBottom = 'TopBottom';
            outline_1.leftRight = 'LeftRight';
            outline_1.frame = 'Frame';
            function showTop(outline) {
                return [outline_1.topOnly, outline_1.topBottom, outline_1.frame].some(function (o) { return o === outline; });
            }
            outline_1.showTop = showTop;
            function showRight(outline) {
                return [outline_1.rightOnly, outline_1.leftRight, outline_1.frame].some(function (o) { return o === outline; });
            }
            outline_1.showRight = showRight;
            function showBottom(outline) {
                return [outline_1.bottomOnly, outline_1.topBottom, outline_1.frame].some(function (o) { return o === outline; });
            }
            outline_1.showBottom = showBottom;
            function showLeft(outline) {
                return [outline_1.leftOnly, outline_1.leftRight, outline_1.frame].some(function (o) { return o === outline; });
            }
            outline_1.showLeft = showLeft;
            outline_1.type = powerbi.createEnumType([
                { value: outline_1.none, displayName: function (resources) { return resources.get('Visual_Outline_none'); } },
                { value: outline_1.bottomOnly, displayName: function (resources) { return resources.get('Visual_Outline_bottom_only'); } },
                { value: outline_1.topOnly, displayName: function (resources) { return resources.get('Visual_Outline_top_only'); } },
                { value: outline_1.leftOnly, displayName: function (resources) { return resources.get('Visual_Outline_LeftOnly'); } },
                { value: outline_1.rightOnly, displayName: function (resources) { return resources.get('Visual_Outline_RightOnly'); } },
                { value: outline_1.topBottom, displayName: function (resources) { return resources.get('Visual_Outline_top_Bottom'); } },
                { value: outline_1.leftRight, displayName: function (resources) { return resources.get('Visual_Outline_leftRight'); } },
                { value: outline_1.frame, displayName: function (resources) { return resources.get('Visual_Outline_frame'); } }
            ]);
        })(outline = visuals.outline || (visuals.outline = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var referenceLinePosition;
        (function (referenceLinePosition) {
            referenceLinePosition.back = 'back';
            referenceLinePosition.front = 'front';
            referenceLinePosition.type = powerbi.createEnumType([
                { value: referenceLinePosition.back, displayName: function (resources) { return resources.get('Visual_Reference_Line_Behind'); } },
                { value: referenceLinePosition.front, displayName: function (resources) { return resources.get('Visual_Reference_Line_InFront'); } },
            ]);
        })(referenceLinePosition = visuals.referenceLinePosition || (visuals.referenceLinePosition = {}));
        var referenceLineDataLabelHorizontalPosition;
        (function (referenceLineDataLabelHorizontalPosition) {
            referenceLineDataLabelHorizontalPosition.left = 'left';
            referenceLineDataLabelHorizontalPosition.right = 'right';
            referenceLineDataLabelHorizontalPosition.type = powerbi.createEnumType([
                { value: referenceLineDataLabelHorizontalPosition.left, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Left'); } },
                { value: referenceLineDataLabelHorizontalPosition.right, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Right'); } },
            ]);
        })(referenceLineDataLabelHorizontalPosition = visuals.referenceLineDataLabelHorizontalPosition || (visuals.referenceLineDataLabelHorizontalPosition = {}));
        var referenceLineDataLabelVerticalPosition;
        (function (referenceLineDataLabelVerticalPosition) {
            referenceLineDataLabelVerticalPosition.above = 'above';
            referenceLineDataLabelVerticalPosition.under = 'under';
            referenceLineDataLabelVerticalPosition.type = powerbi.createEnumType([
                { value: referenceLineDataLabelVerticalPosition.above, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Above'); } },
                { value: referenceLineDataLabelVerticalPosition.under, displayName: function (resources) { return resources.get('Visual_Reference_Line_Data_Label_Under'); } },
            ]);
        })(referenceLineDataLabelVerticalPosition = visuals.referenceLineDataLabelVerticalPosition || (visuals.referenceLineDataLabelVerticalPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var slicerOrientation;
        (function (slicerOrientation) {
            slicerOrientation.type = powerbi.createEnumType([
                { value: 0 /* Vertical */, displayName: function (resources) { return resources.get('Slicer_Orientation_Vertical'); } },
                { value: 1 /* Horizontal */, displayName: function (resources) { return resources.get('Slicer_Orientation_Horizontal'); } },
            ]);
        })(slicerOrientation = visuals.slicerOrientation || (visuals.slicerOrientation = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var yAxisPosition;
        (function (yAxisPosition) {
            yAxisPosition.left = 'Left';
            yAxisPosition.right = 'Right';
            yAxisPosition.type = powerbi.createEnumType([
                { value: yAxisPosition.left, displayName: function (resources) { return resources.get('Visual_yAxis_Left'); } },
                { value: yAxisPosition.right, displayName: function (resources) { return resources.get('Visual_yAxis_Right'); } },
            ]);
        })(yAxisPosition = visuals.yAxisPosition || (visuals.yAxisPosition = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var AnimatorCommon;
        (function (AnimatorCommon) {
            AnimatorCommon.MinervaAnimationDuration = 250;
            // The maximum number of data points we can performantly animate with SVG. If we have more, turn off animations.
            AnimatorCommon.MaxDataPointsToAnimate = 1000;
            function GetAnimationDuration(animator, suppressAnimations) {
                return (suppressAnimations || !animator) ? 0 : animator.getDuration();
            }
            AnimatorCommon.GetAnimationDuration = GetAnimationDuration;
        })(AnimatorCommon = visuals.AnimatorCommon || (visuals.AnimatorCommon = {}));
        /**
         * We just need to have a non-null animator to allow axis animations in cartesianChart.
         * Note: Use this temporarily for Line/Scatter until we add more animations (MinervaPlugins only).
         */
        var BaseAnimator = (function () {
            function BaseAnimator(options) {
                if (options && options.duration) {
                    this.animationDuration = options.duration;
                }
                this.animationDuration = this.animationDuration >= 0 ? this.animationDuration : AnimatorCommon.MinervaAnimationDuration;
            }
            BaseAnimator.prototype.getDuration = function () {
                return this.animationDuration;
            };
            BaseAnimator.prototype.animate = function (options) {
                return null;
            };
            return BaseAnimator;
        }());
        visuals.BaseAnimator = BaseAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebColumnChartAnimator = (function (_super) {
            __extends(WebColumnChartAnimator, _super);
            function WebColumnChartAnimator(options) {
                _super.call(this, options);
            }
            WebColumnChartAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                var dataPointCount = viewModel.categories.length * viewModel.series.length;
                if (dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate) {
                    // Too many data points to animate.
                    return result;
                }
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebColumnChartAnimator.prototype.animateNormalToHighlighted = function (options) {
                var data = options.viewModel;
                var itemCS = options.itemCS;
                var shapeSelection = options.series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                var hasHighlights = data.hasHighlights;
                shapes
                    .enter()
                    .append('rect')
                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); })
                    .attr(options.layout.shapeLayoutWithoutHighlights); // Start out at the non-highlight layout
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.shapeLayout);
                shapes
                    .exit()
                    .remove();
                return {
                    failed: false,
                    shapes: shapes,
                };
            };
            WebColumnChartAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options.viewModel, options.series, options.layout, options.itemCS);
                return {
                    failed: false,
                    shapes: shapes,
                };
            };
            WebColumnChartAnimator.prototype.animateHighlightedToNormal = function (options) {
                var itemCS = options.itemCS;
                var shapeSelection = options.series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                shapes
                    .enter()
                    .append('rect')
                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, d.selected, !d.selected); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.shapeLayout)
                    .transition()
                    .duration(0)
                    .delay(this.animationDuration)
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
                shapes
                    .exit()
                    .transition()
                    .duration(this.animationDuration)
                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayoutWithoutHighlights)
                    .remove();
                return {
                    failed: false,
                    shapes: shapes,
                };
            };
            WebColumnChartAnimator.prototype.animateDefaultShapes = function (data, series, layout, itemCS) {
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(function (d) { return d.data; }, function (d) { return d.key; });
                shapes
                    .enter()
                    .append('rect')
                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, data.hasHighlights); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.shapeLayout);
                shapes
                    .exit()
                    .remove();
                return shapes;
            };
            return WebColumnChartAnimator;
        }(visuals.BaseAnimator));
        visuals.WebColumnChartAnimator = WebColumnChartAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebDonutChartAnimator = (function (_super) {
            __extends(WebDonutChartAnimator, _super);
            function WebDonutChartAnimator(options) {
                _super.call(this, options);
            }
            WebDonutChartAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    highlightShapes: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebDonutChartAnimator.prototype.animateNormalToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options);
                var highlightShapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice-highlight')
                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter()
                    .insert('path')
                    .classed('slice-highlight', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
                highlightShapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .attr(options.layout.shapeLayout) // Start at the non-highlight layout, then transition to the highlight layout.
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.highlightShapeLayout);
                highlightShapes.exit()
                    .remove();
                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var shapes = this.animateDefaultShapes(options);
                var highlightShapes = this.animateDefaultHighlightShapes(options);
                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateHighlightedToNormal = function (options) {
                var hasSelection = options.interactivityService && options.interactivityService.hasSelection();
                var duration = this.animationDuration;
                var shapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice')
                    .data(options.viewModel.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter()
                    .insert('path')
                    .classed('slice', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints);
                // For any slice that is selected we want to keep showing it as dimmed (partially highlighted). After the highlight animation
                // finishes we will set the opacity based on the selection state.
                shapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, d.data.selected, !d.data.selected); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .transition()
                    .duration(duration)
                    .attr(options.layout.shapeLayout)
                    .transition()
                    .duration(0)
                    .delay(duration)
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); });
                ;
                shapes.exit()
                    .remove();
                var highlightShapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice-highlight')
                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter()
                    .insert('path')
                    .classed('slice-highlight', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
                highlightShapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(false, true, false, true); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .transition()
                    .duration(duration)
                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout) // Transition to the non-highlight layout
                    .remove();
                highlightShapes.exit()
                    .remove();
                visuals.NewDataLabelUtils.drawDefaultLabels(options.labelGraphicsContext, options.labels, false, true, true /*has tooltip */);
                visuals.NewDataLabelUtils.drawLabelLeaderLines(options.labelGraphicsContext, options.labels);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                };
            };
            WebDonutChartAnimator.prototype.animateDefaultShapes = function (options) {
                var shapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice')
                    .data(options.viewModel.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter()
                    .insert('path')
                    .classed('slice', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints);
                shapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, options.viewModel.hasHighlights); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.shapeLayout);
                shapes.exit()
                    .remove();
                return shapes;
            };
            WebDonutChartAnimator.prototype.animateDefaultHighlightShapes = function (options) {
                var highlightShapes = options.graphicsContext.select('.slices')
                    .selectAll('path.slice-highlight')
                    .data(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                highlightShapes.enter()
                    .insert('path')
                    .classed('slice-highlight', true)
                    .each(function (d) { this._current = d; });
                visuals.DonutChart.isSingleColor(options.viewModel.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }));
                highlightShapes
                    .style('fill', function (d) { return d.data.color ? d.data.color : options.colors.getNewColorScale().getColor(d.data.identity.getKey()).value; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, options.viewModel.hasHighlights); })
                    .style("stroke-dasharray", function (d) { return visuals.DonutChart.drawStrokeForDonutChart(options.radius, options.innerArcRadiusRatio, d, options.sliceWidthRatio, d.data.highlightRatio); })
                    .style("stroke-width", function (d) { return d.data.strokeWidth; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.highlightShapeLayout);
                highlightShapes.exit()
                    .remove();
                return highlightShapes;
            };
            return WebDonutChartAnimator;
        }(visuals.BaseAnimator));
        visuals.WebDonutChartAnimator = WebDonutChartAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebFunnelAnimator = (function (_super) {
            __extends(WebFunnelAnimator, _super);
            function WebFunnelAnimator(options) {
                _super.call(this, options);
            }
            WebFunnelAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    dataLabels: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebFunnelAnimator.prototype.animateNormalToHighlighted = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                var hasHighlights = true;
                var hasSelection = false;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.slices, function (d) { return d.key; });
                shapes.enter()
                    .append('rect')
                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; })
                    .attr(layout.shapeLayoutWithoutHighlights); // Start by laying out all rectangles ignoring highlights
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.shapeLayout); // Then transition to the layout that uses highlights
                shapes.exit().remove();
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                // Simply animate to the new shapes.
                var shapes = this.animateDefaultShapes(data, data.slices, options.shapeGraphicsContext, layout);
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateHighlightedToNormal = function (options) {
                var data = options.viewModel;
                var layout = options.layout;
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
                this.animateDefaultAxis(options.axisGraphicsContext, options.axisOptions, options.isHidingPercentBars);
                var shapes = options.shapeGraphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(data.slices, function (d) { return d.key; });
                shapes.enter()
                    .append('rect')
                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; });
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, !d.selected); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.shapeLayoutWithoutHighlights) // Transition to layout without highlights
                    .transition()
                    .duration(0)
                    .delay(this.animationDuration)
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
                var exitShapes = shapes.exit();
                exitShapes
                    .transition()
                    .duration(this.animationDuration)
                    .attr(hasSelection ? layout.zeroShapeLayout : layout.shapeLayoutWithoutHighlights) // Transition to layout without highlights
                    .remove();
                this.animatePercentBars(options);
                var dataLabels = this.animateDefaultDataLabels(options);
                return {
                    failed: false,
                    shapes: shapes,
                    dataLabels: dataLabels,
                };
            };
            WebFunnelAnimator.prototype.animateDefaultAxis = function (graphicsContext, axisOptions, isHidingPercentBars) {
                var xScaleForAxis = d3.scale.ordinal()
                    .domain(axisOptions.categoryLabels)
                    .rangeBands([axisOptions.rangeStart, axisOptions.rangeEnd], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : visuals.FunnelChart.PercentBarToBarRatio);
                var xAxis = d3.svg.axis()
                    .scale(xScaleForAxis)
                    .orient("right")
                    .tickPadding(visuals.FunnelChart.TickPadding)
                    .innerTickSize(visuals.FunnelChart.InnerTickSize);
                graphicsContext.classed('axis', true)
                    .transition()
                    .duration(this.animationDuration)
                    .attr('transform', visuals.SVGUtil.translate(0, axisOptions.margin.top))
                    .call(xAxis);
            };
            WebFunnelAnimator.prototype.animateDefaultShapes = function (data, slices, graphicsContext, layout) {
                var hasHighlights = data.hasHighlights;
                var shapes = graphicsContext.selectAll(visuals.FunnelChart.Selectors.funnel.bars.selector).data(slices, function (d) { return d.key; });
                shapes.enter()
                    .append('rect')
                    .attr("class", function (d) { return d.highlight ? visuals.FunnelChart.FunnelBarHighlightClass : visuals.FunnelChart.Selectors.funnel.bars.class; });
                shapes
                    .style("fill", function (d) { return d.color; })
                    .style("fill-opacity", function (d) { return function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, false, hasHighlights); }; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebFunnelAnimator.prototype.animateDefaultDataLabels = function (options) {
                var dataLabels;
                if (options.viewModel.dataLabelsSettings.show && options.viewModel.canShowDataLabels) {
                    dataLabels = visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(options.viewModel.slices, options.labelGraphicsContext, options.labelLayout, true, this.animationDuration);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(options.labelGraphicsContext);
                }
                return dataLabels;
            };
            WebFunnelAnimator.prototype.animatePercentBars = function (options) {
                var data = options.viewModel;
                var isHidingPercentBars = options.isHidingPercentBars;
                if (isHidingPercentBars || !data.slices || (data.hasHighlights ? data.slices.length / 2 : data.slices.length) < 2) {
                    // TODO: call percentBarComponents with flag with empty data to clear drawing smoothly
                    this.animatePercentBarComponents([], options);
                    return;
                }
                var slices = [data.slices[data.hasHighlights ? 1 : 0], data.slices[data.slices.length - 1]];
                var baseline = visuals.FunnelChart.getFunnelSliceValue(slices[0]);
                if (baseline <= 0) {
                    // TODO: call percentBarComponents with flag with empty data to clear drawing smoothly
                    this.animatePercentBarComponents([], options);
                    return;
                }
                var percentData = slices.map(function (slice, i) { return {
                    value: visuals.FunnelChart.getFunnelSliceValue(slice),
                    percent: i === 0 ? 1 : visuals.FunnelChart.getFunnelSliceValue(slice) / baseline,
                    isTop: i === 0,
                }; });
                this.animatePercentBarComponents(percentData, options);
            };
            WebFunnelAnimator.prototype.animateToFunnelPercent = function (context, targetData, layout) {
                return context
                    .data(targetData)
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout);
            };
            WebFunnelAnimator.prototype.animatePercentBarComponents = function (data, options) {
                var graphicsContext = options.percentGraphicsContext;
                var layout = options.layout;
                var zeroData = [
                    { percent: 0, value: 0, isTop: true },
                    { percent: 0, value: 0, isTop: false },
                ];
                // Main line
                var mainLine = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
                this.animateToFunnelPercent(mainLine.exit(), zeroData, layout.percentBarLayout.mainLine)
                    .remove();
                mainLine.enter()
                    .append('line')
                    .classed(visuals.FunnelChart.Selectors.percentBar.mainLine.class, true)
                    .data(zeroData)
                    .attr(layout.percentBarLayout.mainLine);
                this.animateToFunnelPercent(mainLine, data, layout.percentBarLayout.mainLine);
                // Left tick
                var leftTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
                this.animateToFunnelPercent(leftTick.exit(), zeroData, layout.percentBarLayout.leftTick)
                    .remove();
                leftTick.enter()
                    .append('line')
                    .classed(visuals.FunnelChart.Selectors.percentBar.leftTick.class, true)
                    .data(zeroData)
                    .attr(layout.percentBarLayout.leftTick);
                this.animateToFunnelPercent(leftTick, data, layout.percentBarLayout.leftTick);
                // Right tick
                var rightTick = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
                this.animateToFunnelPercent(rightTick.exit(), zeroData, layout.percentBarLayout.rightTick)
                    .remove();
                rightTick.enter()
                    .append('line')
                    .classed(visuals.FunnelChart.Selectors.percentBar.rightTick.class, true)
                    .data(zeroData)
                    .attr(layout.percentBarLayout.rightTick);
                this.animateToFunnelPercent(rightTick, data, layout.percentBarLayout.rightTick);
                // Text
                var text = graphicsContext.selectAll(visuals.FunnelChart.Selectors.percentBar.text.selector).data(data);
                this.animateToFunnelPercent(text.exit(), zeroData, layout.percentBarLayout.text)
                    .remove();
                text.enter()
                    .append('text')
                    .classed(visuals.FunnelChart.Selectors.percentBar.text.class, true)
                    .data(zeroData)
                    .attr(layout.percentBarLayout.text);
                this.animateToFunnelPercent(text, data, layout.percentBarLayout.text)
                    .text(function (fp) {
                    return powerbi.formattingService.formatValue(fp.percent, visuals.valueFormatter.getLocalizedString("Percentage1"));
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(options.visualInitOptions);
            };
            return WebFunnelAnimator;
        }(visuals.BaseAnimator));
        visuals.WebFunnelAnimator = WebFunnelAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WebTreemapAnimator = (function (_super) {
            __extends(WebTreemapAnimator, _super);
            function WebTreemapAnimator(options) {
                _super.call(this, options);
            }
            WebTreemapAnimator.prototype.animate = function (options) {
                var result = {
                    failed: true,
                    shapes: null,
                    highlightShapes: null,
                    majorLabels: null,
                    minorLabels: null,
                };
                var viewModel = options.viewModel;
                var previousViewModel = this.previousViewModel;
                if (!previousViewModel) {
                }
                else if (viewModel.hasHighlights && !previousViewModel.hasHighlights) {
                    result = this.animateNormalToHighlighted(options);
                }
                else if (viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToHighlighted(options);
                }
                else if (!viewModel.hasHighlights && previousViewModel.hasHighlights) {
                    result = this.animateHighlightedToNormal(options);
                }
                this.previousViewModel = viewModel;
                return result;
            };
            WebTreemapAnimator.prototype.animateNormalToHighlighted = function (options) {
                var hasSelection = false;
                var hasHighlights = true;
                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout);
                var highlightShapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
                    .data(options.highlightNodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect')
                    .attr('class', options.layout.highlightShapeClass)
                    .attr(options.layout.shapeLayout); // Start using the normal shape layout
                highlightShapes
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, true); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, true); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(options.layout.highlightShapeLayout); // Animate to the highlighted positions
                highlightShapes.exit().remove();
                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels,
                };
            };
            WebTreemapAnimator.prototype.animateHighlightedToHighlighted = function (options) {
                var hasSelection = false;
                var hasHighlights = true;
                var shapes = this.animateDefaultShapes(options.shapeGraphicsContext, options.nodes, hasSelection, hasHighlights, options.layout);
                options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
                    .data(options.highlightNodes, function (d) { return d.key + "highlight"; });
                var highlightShapes = this.animateDefaultHighlightShapes(options.shapeGraphicsContext, options.highlightNodes, hasSelection, hasHighlights, options.layout);
                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels,
                };
            };
            WebTreemapAnimator.prototype.animateHighlightedToNormal = function (options) {
                var hasSelection = options.interactivityService ? options.interactivityService.hasSelection() : false;
                var shapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.TreemapNodeClassName)
                    .data(options.nodes, function (d) { return d.key; });
                shapes.enter().append('rect')
                    .attr('class', options.layout.shapeClass);
                shapes
                    .transition()
                    .duration(this.animationDuration)
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, false); })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, d.selected, !d.selected); })
                    .attr(options.layout.shapeLayout)
                    .transition()
                    .duration(0)
                    .delay(this.animationDuration)
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                shapes.exit().remove();
                var highlightShapes = options.shapeGraphicsContext.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
                    .data(options.nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect')
                    .attr('class', options.layout.highlightShapeClass);
                highlightShapes
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, true); })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, true, d.selected, !d.selected); })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(hasSelection ? options.layout.zeroShapeLayout : options.layout.shapeLayout) // Animate to the normal shape layout or zero shape layout depending on whether we have a selection or not
                    .remove();
                highlightShapes.exit().remove();
                var majorLabels = this.animateDefaultMajorLabels(options.labelGraphicsContext, options.majorLabeledNodes, options.labelSettings, options.layout);
                var minorLabels = this.animateDefaultMinorLabels(options.labelGraphicsContext, options.minorLabeledNodes, options.labelSettings, options.layout);
                return {
                    failed: false,
                    shapes: shapes,
                    highlightShapes: highlightShapes,
                    majorLabels: majorLabels,
                    minorLabels: minorLabels,
                };
            };
            WebTreemapAnimator.prototype.animateDefaultShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = false;
                var shapes = context.selectAll('.' + visuals.Treemap.TreemapNodeClassName)
                    .data(nodes, function (d) { return d.key; });
                shapes.enter().append('rect')
                    .attr('class', layout.shapeClass);
                shapes
                    .transition()
                    .duration(this.animationDuration)
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, isHighlightShape); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
                    .attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            WebTreemapAnimator.prototype.animateDefaultHighlightShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = true;
                var highlightShapes = context.selectAll('.' + visuals.Treemap.HighlightNodeClassName)
                    .data(nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect')
                    .attr('class', layout.highlightShapeClass);
                highlightShapes
                    .transition()
                    .duration(this.animationDuration)
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, isHighlightShape); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
                    .attr(layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            WebTreemapAnimator.prototype.animateDefaultMajorLabels = function (context, nodes, labelSettings, layout) {
                var labels = context
                    .selectAll('.' + visuals.Treemap.MajorLabelClassName)
                    .data(nodes, function (d) { return d.key; });
                labels.enter().append('text')
                    .attr('class', layout.majorLabelClass);
                labels
                    .text(layout.majorLabelText)
                    .style('fill', function () { return labelSettings.labelColor; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.majorLabelLayout);
                labels.exit().remove();
                return labels;
            };
            WebTreemapAnimator.prototype.animateDefaultMinorLabels = function (context, nodes, labelSettings, layout) {
                var labels = context
                    .selectAll('.' + visuals.Treemap.MinorLabelClassName)
                    .data(nodes, function (d) { return d.key; });
                labels.enter().append('text')
                    .attr('class', layout.minorLabelClass);
                labels
                    .text(layout.minorLabelText)
                    .style('fill', function () { return labelSettings.labelColor; })
                    .transition()
                    .duration(this.animationDuration)
                    .attr(layout.minorLabelLayout);
                labels.exit().remove();
                return labels;
            };
            return WebTreemapAnimator;
        }(visuals.BaseAnimator));
        visuals.WebTreemapAnimator = WebTreemapAnimator;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * This is the baseline for some most common used object properties across visuals.
         * When adding new properties, please try to reuse the existing ones.
         */
        visuals.StandardObjectProperties = {
            axisEnd: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                type: { numeric: true },
                suppressFormatPainterCopy: true,
            },
            axisScale: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Scale'),
                type: { enumeration: visuals.axisScale.type }
            },
            axisStart: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                type: { numeric: true },
                suppressFormatPainterCopy: true,
            },
            axisStyle: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Style'),
                type: { enumeration: visuals.axisStyle.type }
            },
            axisType: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Type'),
                type: { enumeration: visuals.axisType.type },
            },
            backColor: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor'),
                description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColor_Desc'),
                type: { fill: { solid: { color: true } } }
            },
            dataColor: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_LabelsFill'),
                description: powerbi.data.createDisplayNameGetter('Visual_LabelsFillDescription'),
                type: { fill: { solid: { color: true } } }
            },
            dataLabelColor: {
                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label_Color"),
                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Color_Description'),
                type: { fill: { solid: { color: true } } }
            },
            dataLabelDecimalPoints: {
                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Decimal_Points"),
                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                type: { numeric: true }
            },
            dataLabelDisplayUnits: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                type: { formatting: { labelDisplayUnits: true } },
                suppressFormatPainterCopy: true,
            },
            dataLabelHorizontalPosition: {
                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Horizontal_Position"),
                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Horizontal_Position_Description'),
                type: { enumeration: visuals.referenceLineDataLabelHorizontalPosition.type }
            },
            dataLabelShow: {
                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Label"),
                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Show_Description'),
                type: { bool: true }
            },
            dataLabelVerticalPosition: {
                displayName: powerbi.data.createDisplayNameGetter("Visual_Reference_Line_Data_Vertical_Position"),
                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Data_Label_Vertical_Position_Description'),
                type: { enumeration: visuals.referenceLineDataLabelVerticalPosition.type }
            },
            defaultColor: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColor'),
                type: { fill: { solid: { color: true } } }
            },
            fill: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                type: { fill: { solid: { color: true } } }
            },
            fontColor: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_FontColor'),
                description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColor_Desc'),
                type: { fill: { solid: { color: true } } }
            },
            fontSize: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                type: { formatting: { fontSize: true } }
            },
            formatString: {
                type: { formatting: { formatString: true } },
            },
            image: {
                type: { image: {} },
            },
            labelColor: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendTitleColor'),
                type: { fill: { solid: { color: true } } }
            },
            labelDisplayUnits: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                type: { formatting: { labelDisplayUnits: true } }
            },
            labelPrecision: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                type: { numeric: true }
            },
            legendPosition: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendPosition'),
                description: powerbi.data.createDisplayNameGetter('Visual_LegendPositionDescription'),
                type: { enumeration: visuals.legendPosition.type },
            },
            legendTitle: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendName'),
                description: powerbi.data.createDisplayNameGetter('Visual_LegendNameDescription'),
                type: { text: true },
            },
            lineColor: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color'),
                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Color_Description'),
                type: { fill: { solid: { color: true } } }
            },
            outline: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                type: { enumeration: visuals.outline.type }
            },
            outlineColor: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineColor'),
                description: powerbi.data.createDisplayNameGetter('Visual_OutlineColor_Desc'),
                type: { fill: { solid: { color: true } } }
            },
            outlineWeight: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight'),
                description: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight_Desc'),
                type: { numeric: true }
            },
            show: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                type: { bool: true }
            },
            showAllDataPoints: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint_Show_All'),
                type: { bool: true }
            },
            showLegendTitle: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitle'),
                description: powerbi.data.createDisplayNameGetter('Visual_LegendShowTitleDescription'),
                type: { bool: true }
            },
            referenceLinePosition: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange'),
                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Arrange_Description'),
                type: { enumeration: visuals.referenceLinePosition.type }
            },
            referenceLineStyle: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style'),
                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Style_Description'),
                type: { enumeration: visuals.lineStyle.type }
            },
            transparency: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_Background_Transparency'),
                description: powerbi.data.createDisplayNameGetter('Visual_Background_TransparencyDescription'),
                type: { numeric: true }
            },
            yAxisPosition: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                description: powerbi.data.createDisplayNameGetter('Visual_YAxis_PositionDescription'),
                type: { enumeration: visuals.yAxisPosition.type },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.animatedTextObjectDescs = {
            general: {
                properties: {
                    formatString: visuals.StandardObjectProperties.formatString,
                },
            }
        };
        visuals.animatedNumberCapabilities = {
            objects: visuals.animatedTextObjectDescs,
            dataViewMappings: [{
                    single: { role: "Values" }
                }],
            supportsSelection: false,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.basicShapeCapabilities = {
            objects: {
                line: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Line'),
                    properties: {
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_LineColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: visuals.StandardObjectProperties.transparency,
                        weight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Weight'),
                            type: { numeric: true }
                        },
                        roundEdge: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_RoundEdges'),
                            type: { numeric: true }
                        }
                    }
                },
                fill: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        fillColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_FillColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: visuals.StandardObjectProperties.transparency,
                    }
                },
                rotation: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Rotate'),
                    properties: {
                        angle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_BasicShape_Rotate'),
                            type: { numeric: true }
                        }
                    }
                },
                general: {
                    properties: {
                        shapeType: {
                            type: { text: true },
                            suppressFormatPainterCopy: true,
                        }
                    }
                }
            },
            suppressDefaultTitle: true,
            suppressDefaultPadding: true,
            canRotate: false,
            supportsSelection: false,
        };
        visuals.basicShapeProps = {
            general: {
                shapeType: { objectName: 'general', propertyName: 'shapeType' },
            },
            line: {
                transparency: { objectName: 'line', propertyName: 'transparency' },
                weight: { objectName: 'line', propertyName: 'weight' },
                roundEdge: { objectName: 'line', propertyName: 'roundEdge' },
                lineColor: { objectName: 'line', propertyName: 'lineColor' }
            },
            fill: {
                transparency: { objectName: 'fill', propertyName: 'transparency' },
                fillColor: { objectName: 'fill', propertyName: 'fillColor' },
                show: { objectName: 'fill', propertyName: 'show' }
            },
            rotation: {
                angle: { objectName: 'rotation', propertyName: 'angle' }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function getColumnChartCapabilities(transposeAxes) {
            if (transposeAxes === void 0) { transposeAxes = false; }
            return {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription'),
                        cartesianKind: 0 /* X */,
                    }, {
                        name: 'Series',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                    }, {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                        cartesianKind: 1 /* Y */,
                    }, {
                        name: 'Gradient',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                        requiredTypes: [{ numeric: true }, { integer: true }],
                    }
                ],
                objects: {
                    general: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                        properties: {
                            formatString: visuals.StandardObjectProperties.formatString,
                        },
                    },
                    legend: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                        description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.legendPosition,
                            showTitle: visuals.StandardObjectProperties.showLegendTitle,
                            titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                                suppressFormatPainterCopy: true
                            }),
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            fontSize: visuals.StandardObjectProperties.fontSize,
                        }
                    },
                    categoryAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_YAxis') : powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.yAxisPosition,
                            axisScale: visuals.StandardObjectProperties.axisScale,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            axisType: visuals.StandardObjectProperties.axisType,
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                description: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription') : powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                        }
                    },
                    valueAxis: {
                        displayName: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_XAxis') : powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            position: visuals.StandardObjectProperties.yAxisPosition,
                            axisScale: visuals.StandardObjectProperties.axisScale,
                            start: visuals.StandardObjectProperties.axisStart,
                            end: visuals.StandardObjectProperties.axisEnd,
                            intersection: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Intersection'),
                                type: { numeric: true },
                                placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            },
                            showAxisTitle: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                                description: transposeAxes ? powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription') : powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                                type: { bool: true }
                            },
                            axisStyle: visuals.StandardObjectProperties.axisStyle,
                            labelColor: visuals.StandardObjectProperties.labelColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                            labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                        }
                    },
                    y1AxisReferenceLine: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
                        description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            value: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                                type: { numeric: true }
                            },
                            lineColor: visuals.StandardObjectProperties.lineColor,
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                                type: { numeric: true }
                            },
                            style: visuals.StandardObjectProperties.referenceLineStyle,
                            position: visuals.StandardObjectProperties.referenceLinePosition,
                            dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                            dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                            dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                            dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                            dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                            dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                        },
                    },
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                        properties: {
                            defaultColor: visuals.StandardObjectProperties.defaultColor,
                            showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                            fill: visuals.StandardObjectProperties.fill,
                            fillRule: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                                type: { fillRule: {} },
                                rule: {
                                    inputRole: 'Gradient',
                                    output: {
                                        property: 'fill',
                                        selector: ['Category'],
                                    },
                                },
                            }
                        }
                    },
                    trend: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
                        properties: {
                            show: {
                                type: { bool: true }
                            },
                            lineColor: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                                type: { fill: { solid: { color: true } } }
                            },
                            transparency: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                                type: { numeric: true }
                            },
                            style: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                                type: { enumeration: visuals.lineStyle.type }
                            },
                            combineSeries: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
                                type: { bool: true }
                            },
                            useHighlightValues: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
                                description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
                                type: { bool: true }
                            },
                        }
                    },
                    labels: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                        properties: {
                            show: visuals.StandardObjectProperties.show,
                            showSeries: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                                type: { bool: true }
                            },
                            color: visuals.StandardObjectProperties.dataColor,
                            labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                            labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                                suppressFormatPainterCopy: true
                            }),
                            showAll: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                                type: { bool: true }
                            },
                            fontSize: visuals.StandardObjectProperties.fontSize,
                        },
                    },
                    plotArea: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                        //description: data.createDisplayNameGetter('Visual_PlotDescription'),
                        properties: {
                            transparency: visuals.StandardObjectProperties.transparency,
                            image: visuals.StandardObjectProperties.image,
                        },
                    },
                },
                dataViewMappings: [{
                        conditions: [
                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                            { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 }, 'Gradient': { max: 1 } },
                        ],
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                                dataReductionAlgorithm: { top: {} }
                            },
                            values: {
                                group: {
                                    by: 'Series',
                                    select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }],
                                    dataReductionAlgorithm: { top: {} }
                                }
                            },
                            rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                        },
                    }, {
                        conditions: [
                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Gradient': { max: 0 } },
                            { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 0 } },
                            { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y': { min: 0, max: 1 }, 'Gradient': { max: 1 } },
                        ],
                        requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                        usage: {
                            regression: {
                                combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                            },
                        },
                        categorical: {
                            categories: {
                                for: { in: 'regression.X' },
                            },
                            values: {
                                group: {
                                    by: 'regression.Series',
                                    select: [{ for: { in: 'regression.Y' } }],
                                },
                            }
                        }
                    }],
                supportsHighlight: true,
                sorting: {
                    default: {},
                },
                drilldown: {
                    roles: ['Category']
                },
            };
        }
        visuals.getColumnChartCapabilities = getColumnChartCapabilities;
        visuals.columnChartProps = {
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            categoryAxis: {
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.comboChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Category'),
                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_CategoryDescription'),
                    cartesianKind: 0 /* X */,
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Series'),
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y'),
                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_YDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 1 /* Y */,
                }, {
                    name: 'Y2',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y2'),
                    description: powerbi.data.createDisplayNameGetter('Role_ComboChart_Y2Description'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 1 /* Y */,
                },
            ],
            objects: {
                general: {
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                        visualType1: {
                            type: { text: true }
                        },
                        visualType2: {
                            type: { text: true }
                        },
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.legendPosition,
                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                            suppressFormatPainterCopy: true
                        }),
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        axisScale: visuals.StandardObjectProperties.axisScale,
                        start: visuals.StandardObjectProperties.axisStart,
                        end: visuals.StandardObjectProperties.axisEnd,
                        axisType: visuals.StandardObjectProperties.axisType,
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: visuals.StandardObjectProperties.axisStyle,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        axisLabel: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ColumnTitle'),
                            type: { none: true },
                        },
                        position: visuals.StandardObjectProperties.yAxisPosition,
                        axisScale: visuals.StandardObjectProperties.axisScale,
                        start: visuals.StandardObjectProperties.axisStart,
                        end: visuals.StandardObjectProperties.axisEnd,
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: visuals.StandardObjectProperties.axisStyle,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                        secShow: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ShowSecondary'),
                            type: { bool: true },
                        },
                        secAxisLabel: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_LineTitle'),
                            type: { none: true },
                        },
                        secPosition: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_Position'),
                            type: { enumeration: visuals.yAxisPosition.type },
                        },
                        secAxisScale: visuals.StandardObjectProperties.axisScale,
                        secStart: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Start'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_StartDescription'),
                            type: { numeric: true },
                        },
                        secEnd: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_End'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_EndDescription'),
                            type: { numeric: true },
                        },
                        secShowAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true },
                        },
                        secAxisStyle: visuals.StandardObjectProperties.axisStyle,
                        secLabelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        secLabelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: $.extend({}, visuals.StandardObjectProperties.defaultColor, {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DefaultColumnColor'),
                        }),
                        showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                        fill: visuals.StandardObjectProperties.fill,
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                            suppressFormatPainterCopy: true,
                        }),
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    },
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                    properties: {
                        transparency: visuals.StandardObjectProperties.transparency,
                        image: visuals.StandardObjectProperties.image,
                    },
                },
                trend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
                    properties: {
                        show: {
                            type: { bool: true }
                        },
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                        combineSeries: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
                            type: { bool: true }
                        },
                        useHighlightValues: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
                            type: { bool: true }
                        },
                    }
                },
            },
            dataViewMappings: [
                {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { for: { in: 'Y' } }
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'Y2': { min: 1 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 }, 'Y2': { min: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [
                                { for: { in: 'Y2' } }
                            ],
                        },
                        rowCount: { preferred: { min: 2 }, supported: { min: 0 } }
                    },
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } },
                    ],
                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                    usage: {
                        regression: {
                            combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                        },
                    },
                    categorical: {
                        categories: {
                            for: { in: 'regression.X' }
                        },
                        values: {
                            group: {
                                by: 'regression.Series',
                                select: [{ for: { in: 'regression.Y' } }],
                            },
                        },
                    }
                },
            ],
            supportsHighlight: true,
            sorting: {
                default: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.comboChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            valueAxis: {
                secShow: { objectName: 'valueAxis', propertyName: 'secShow' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            dataPoint: {
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.donutChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_DetailsDonutChartDescription'),
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.legendPosition,
                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                            suppressFormatPainterCopy: true
                        }),
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: visuals.StandardObjectProperties.defaultColor,
                        fill: visuals.StandardObjectProperties.fill,
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DetailLabels'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                            suppressFormatPainterCopy: true,
                        }),
                        fontSize: $.extend({}, visuals.StandardObjectProperties.fontSize, {
                            suppressFormatPainterCopy: true,
                        }),
                        labelStyle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelStyle'),
                            type: { enumeration: visuals.labelStyle.type }
                        },
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [{ bind: { to: 'Y' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 }, supported: { min: 1 } }
                    },
                }],
            sorting: {
                default: {},
            },
            supportsHighlight: true,
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.donutChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        // I support a categorical (ordinal) X with measure Y for a single series
        visuals.dataDotChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
                    requiredTypes: [{ numeric: true }, { integer: true }]
                },
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{
                                    for: { in: 'Y' },
                                    dataReductionAlgorithm: { top: {} }
                                }]
                        },
                    },
                }]
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.filledMapCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LocationFilledMapDescription'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'X',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Longitude'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LongitudeFilledMapDescription'),
                    preferredTypes: [
                        { geography: { longitude: true } }
                    ],
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Latitude'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LatitudeFilledMapDescription'),
                    preferredTypes: [
                        { geography: { latitude: true } }
                    ],
                }, {
                    name: 'Size',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.legendPosition,
                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
                        titleText: visuals.StandardObjectProperties.legendTitle,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: visuals.StandardObjectProperties.defaultColor,
                        showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                        fill: visuals.StandardObjectProperties.fill,
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                            description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Size',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    },
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                    },
                }
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'X' } },
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Size' } },
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                        dataVolume: 4,
                    },
                }],
            sorting: {
                custom: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.filledMapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
            labels: {
                show: { objectName: 'labels', propertyName: 'show' },
                color: { objectName: 'labels', propertyName: 'color' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
            },
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.funnelChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Group'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GroupFunnelDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            dataViewMappings: [{
                    conditions: [
                        // NOTE: Ordering of the roles prefers to add measures to Y before Gradient.
                        { 'Category': { max: 0 }, 'Gradient': { max: 0 } },
                        { 'Category': { max: 1 }, 'Y': { max: 1 }, 'Gradient': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{ for: { in: 'Y' } }, { bind: { to: 'Gradient' } }],
                            dataReductionAlgorithm: { top: {} }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: visuals.StandardObjectProperties.defaultColor,
                        fill: visuals.StandardObjectProperties.fill,
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        labelPosition: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Position'),
                            type: { enumeration: visuals.labelPosition.type },
                            suppressFormatPainterCopy: true,
                        },
                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                            suppressFormatPainterCopy: true,
                        }),
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                percentBarLabel: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_PercentBarLabel'),
                    description: powerbi.data.createDisplayNameGetter('Visual_PercentBarLabelDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
            },
            supportsHighlight: true,
            sorting: {
                default: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.funnelChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.gaugeRoleNames = {
            y: 'Y',
            minValue: 'MinValue',
            maxValue: 'MaxValue',
            targetValue: 'TargetValue'
        };
        visuals.gaugeCapabilities = {
            dataRoles: [
                {
                    name: visuals.gaugeRoleNames.y,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Value'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.minValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_MinValue'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_MinValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.maxValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_MaxValue'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_MaxValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: visuals.gaugeRoleNames.targetValue,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_TargetValue'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_TargetValueDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                axis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis'),
                    properties: {
                        min: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Min'),
                            type: { numeric: true }
                        },
                        max: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Max'),
                            type: { numeric: true }
                        },
                        target: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Target'),
                            type: { numeric: true }
                        },
                    },
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    },
                },
                calloutValue: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_CalloutValue'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    },
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    properties: {
                        fill: visuals.StandardObjectProperties.fill,
                        target: {
                            // TODO find a better string
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gauge_Axis_Target'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                }
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Y': { max: 1 }, 'MinValue': { max: 1 }, 'MaxValue': { max: 1 }, 'TargetValue': { max: 1 } },
                    ],
                    categorical: {
                        values: {
                            select: [
                                { bind: { to: 'Y' } },
                                { bind: { to: 'MinValue' } },
                                { bind: { to: 'MaxValue' } },
                                { bind: { to: 'TargetValue' } },
                            ]
                        },
                    },
                }],
            supportsSelection: false,
        };
        visuals.gaugeProps = {
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                target: { objectName: 'dataPoint', propertyName: 'target' }
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.imageVisualCapabilities = {
            objects: {
                general: {
                    properties: {
                        imageUrl: {
                            type: { misc: { imageUrl: true } }
                        }
                    }
                },
                imageScaling: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Image_Scaling_Type'),
                    properties: {
                        imageScalingType: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Image_Scaling_Type'),
                            type: { enumeration: visuals.imageScalingType.type }
                        },
                    }
                },
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.scriptVisualCapabilities = {
            dataRoles: [{
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                }],
            dataViewMappings: [{
                    scriptResult: {
                        dataInput: {
                            table: {
                                rows: {
                                    for: {
                                        in: 'Values'
                                    },
                                    dataReductionAlgorithm: {
                                        top: {}
                                    }
                                },
                            },
                        },
                        script: {
                            source: {
                                objectName: 'script',
                                propertyName: 'source'
                            },
                            provider: {
                                objectName: 'script',
                                propertyName: 'provider'
                            },
                        }
                    }
                }],
            objects: {
                script: {
                    properties: {
                        provider: {
                            type: { text: true }
                        },
                        source: {
                            type: { scripting: { source: true }
                            }
                        },
                    }
                },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            samples.consoleWriterCapabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription')
                    },
                    {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                        displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
                        description: powerbi.data.createDisplayNameGetter('Role_DisplayName_YDescription')
                    },
                ],
                dataViewMappings: [{
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                            },
                        },
                    }],
            };
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var ConsoleWriter = (function () {
                function ConsoleWriter() {
                }
                ConsoleWriter.converter = function (dataView) {
                    window.console.log('converter');
                    window.console.log(dataView);
                    return {};
                };
                ConsoleWriter.prototype.init = function (options) {
                    var div = d3.select(options.element.get(0)).append("div");
                    div.append("h1").text("ConsoleWriter");
                    div.append("p").text("This IVisual writes messages passed to it to the javscript console output. Check your console for the actual messages passed. For more information, click below");
                    var anchor = div.append('a');
                    anchor.attr('href', "http://microsoft.github.io/PowerBI-visuals/modules/powerbi.html")
                        .text("Online help");
                    window.console.log('init');
                    window.console.log(options);
                };
                ConsoleWriter.prototype.onResizing = function (viewport) { };
                ConsoleWriter.prototype.update = function (options) {
                    window.console.log('update');
                    window.console.log(options);
                };
                return ConsoleWriter;
            }());
            samples.ConsoleWriter = ConsoleWriter;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.lineChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription'),
                    cartesianKind: 0 /* X */,
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 1 /* Y */,
                },
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.legendPosition,
                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                            suppressFormatPainterCopy: true
                        }),
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: visuals.StandardObjectProperties.defaultColor,
                        fill: visuals.StandardObjectProperties.fill,
                    }
                },
                trend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                        combineSeries: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
                            type: { bool: true }
                        },
                        useHighlightValues: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_UseHighlightValues_Description'),
                            type: { bool: true }
                        },
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        axisScale: visuals.StandardObjectProperties.axisScale,
                        start: visuals.StandardObjectProperties.axisStart,
                        end: visuals.StandardObjectProperties.axisEnd,
                        axisType: visuals.StandardObjectProperties.axisType,
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: visuals.StandardObjectProperties.axisStyle,
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.yAxisPosition,
                        axisScale: visuals.StandardObjectProperties.axisScale,
                        start: visuals.StandardObjectProperties.axisStart,
                        end: visuals.StandardObjectProperties.axisEnd,
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: visuals.StandardObjectProperties.axisStyle,
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    }
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: visuals.StandardObjectProperties.lineColor,
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: visuals.StandardObjectProperties.referenceLineStyle,
                        position: visuals.StandardObjectProperties.referenceLinePosition,
                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                    },
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        showSeries: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Show'),
                            type: { bool: true }
                        },
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                            suppressFormatPainterCopy: true,
                        }),
                        showAll: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelSeriesShowAll'),
                            type: { bool: true }
                        },
                        fontSize: visuals.StandardObjectProperties.fontSize,
                        labelDensity: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_LabelDensity'),
                            type: { formatting: { labelDensity: true } },
                        },
                    },
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                    //description: data.createDisplayNameGetter('Visual_PlotDescription'),
                    properties: {
                        transparency: visuals.StandardObjectProperties.transparency,
                        image: visuals.StandardObjectProperties.image,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [{ for: { in: 'Y' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                    },
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { min: 1, max: 1 }, 'Y': { max: 1 } }
                    ],
                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                    usage: {
                        regression: {
                            combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                        },
                    },
                    categorical: {
                        categories: {
                            for: { in: 'regression.X' },
                        },
                        values: {
                            group: {
                                by: 'regression.Series',
                                select: [{ for: { in: 'regression.Y' } }],
                            },
                        }
                    }
                }],
            sorting: {
                default: {},
            },
        };
        visuals.lineChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            trend: {
                show: { objectName: 'trend', propertyName: 'show' },
            },
            categoryAxis: {
                axisType: { objectName: 'categoryAxis', propertyName: 'axisType' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            labels: {
                labelDensity: { objectName: 'labels', propertyName: 'labelDensity' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.mapCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Location'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LocationMapDescription'),
                    preferredTypes: [
                        { geography: { address: true } },
                        { geography: { city: true } },
                        { geography: { continent: true } },
                        { geography: { country: true } },
                        { geography: { county: true } },
                        { geography: { place: true } },
                        { geography: { postalCode: true } },
                        { geography: { region: true } },
                        { geography: { stateOrProvince: true } },
                    ],
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'X',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Longitude'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LongitudeMapDescription'),
                    preferredTypes: [
                        { geography: { longitude: true } }
                    ],
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Latitude'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LatitudeMapDescription'),
                    preferredTypes: [
                        { geography: { latitude: true } }
                    ],
                }, {
                    name: 'Size',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_SizeDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.legendPosition,
                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
                        titleText: visuals.StandardObjectProperties.legendTitle,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: visuals.StandardObjectProperties.defaultColor,
                        showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                        fill: visuals.StandardObjectProperties.fill,
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { min: 1, max: 1 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { min: 1, max: 1 }, 'Series': { max: 0 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Measure }, 'Size': { max: 1 }, 'Gradient': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'X' } },
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Size' } },
                                    { bind: { to: 'Gradient' } },
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                        dataVolume: 4,
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 0 }, 'Series': { max: 1 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1 }, 'Gradient': { max: 0 } },
                        { 'Category': { max: 0 }, 'Series': { max: 0 }, 'X': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Y': { max: 1, kind: powerbi.VisualDataRoleKind.Grouping }, 'Size': { max: 1 }, 'Gradient': { max: 1 } }
                    ],
                    categorical: {
                        categories: {
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                            ],
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'Size' } },
                                    { bind: { to: 'Gradient' } },
                                ],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                        dataVolume: 4,
                    },
                }],
            sorting: {
                custom: {},
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.mapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
                showAllDataPoints: { objectName: 'dataPoint', propertyName: 'showAllDataPoints' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.multiRowCardCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Fields'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldsDescription')
                }
            ],
            objects: {
                general: {
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                cardTitle: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CardTitle'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CardTitleDescription'),
                    properties: {
                        color: visuals.StandardObjectProperties.dataColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                dataLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        color: visuals.StandardObjectProperties.dataColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                card: {
                    displayName: powerbi.data.createDisplayNameGetter('Card_ToolTip'),
                    properties: {
                        outline: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Outline'),
                            type: { enumeration: visuals.outline.type }
                        },
                        outlineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineColor'),
                            description: powerbi.data.createDisplayNameGetter('Visual_OutlineColor_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outlineWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_OutlineWeight_Desc'),
                            type: { numeric: true }
                        },
                        barShow: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarShow'),
                            description: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarShow_Desc'),
                            type: { bool: true }
                        },
                        barColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarColor'),
                            type: { fill: { solid: { color: true } } }
                        },
                        barWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarWeight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_BarWeight_Desc'),
                            type: { numeric: true }
                        },
                        cardPadding: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_CardPadding'),
                            description: powerbi.data.createDisplayNameGetter('Visual_MultiRowCard_CardBackground'),
                            type: { numeric: true }
                        },
                        cardBackground: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        }
                    }
                }
            },
            dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: {} }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            sorting: {
                default: {},
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
            disableVisualDetails: true,
        };
        visuals.multiRowCardProps = {
            card: {
                outline: { objectName: 'card', propertyName: 'outline' },
                outlineColor: { objectName: 'card', propertyName: 'outlineColor' },
                outlineWeight: { objectName: 'card', propertyName: 'outlineWeight' },
                barShow: { objectName: 'card', propertyName: 'barShow' },
                barColor: { objectName: 'card', propertyName: 'barColor' },
                barWeight: { objectName: 'card', propertyName: 'barWeight' },
                cardPadding: { objectName: 'card', propertyName: 'cardPadding' },
                cardBackground: { objectName: 'card', propertyName: 'cardBackground' },
            }
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.textboxCapabilities = {
            objects: {
                general: {
                    properties: {
                        paragraphs: {
                            type: { paragraphs: {} },
                            suppressFormatPainterCopy: true,
                        }
                    }
                }
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.cheerMeterCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Axis'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_AxisDescription')
                },
                {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_YDescription')
                },
            ],
            dataViewMappings: [{
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                        },
                    },
                }],
            dataPoint: {
                displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                properties: {
                    fill: visuals.StandardObjectProperties.fill,
                }
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.scatterChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_DetailsScatterChartDescription'),
                }, {
                    name: 'Series',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_LegendDescription')
                }, {
                    name: 'X',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_X'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_XScatterChartDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 0 /* X */,
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_YScatterChartDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    cartesianKind: 1 /* Y */,
                }, {
                    name: 'Size',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Size'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_SizeDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Play',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: 'Play Axis' //TODO: data.createDisplayNameGetter('Role_DisplayName_Play'),
                }
            ],
            objects: {
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        defaultColor: visuals.StandardObjectProperties.defaultColor,
                        showAllDataPoints: visuals.StandardObjectProperties.showAllDataPoints,
                        fill: visuals.StandardObjectProperties.fill,
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Category'],
                                },
                            },
                        }
                    }
                },
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                trend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        lineColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Color_Description'),
                            type: { fill: { solid: { color: true } } }
                        },
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Style_Description'),
                            type: { enumeration: visuals.lineStyle.type }
                        },
                        combineSeries: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Trend_Line_Combine_Series_Description'),
                            type: { bool: true }
                        },
                    }
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        axisScale: visuals.StandardObjectProperties.axisScale,
                        start: visuals.StandardObjectProperties.axisStart,
                        end: visuals.StandardObjectProperties.axisEnd,
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: visuals.StandardObjectProperties.axisStyle,
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.yAxisPosition,
                        axisScale: visuals.StandardObjectProperties.axisScale,
                        start: visuals.StandardObjectProperties.axisStart,
                        end: visuals.StandardObjectProperties.axisEnd,
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: visuals.StandardObjectProperties.axisStyle,
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    }
                },
                xAxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_X'),
                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: visuals.StandardObjectProperties.lineColor,
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: visuals.StandardObjectProperties.referenceLineStyle,
                        position: visuals.StandardObjectProperties.referenceLinePosition,
                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                    },
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Y'),
                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: visuals.StandardObjectProperties.lineColor,
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: visuals.StandardObjectProperties.referenceLineStyle,
                        position: visuals.StandardObjectProperties.referenceLinePosition,
                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.legendPosition,
                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                            suppressFormatPainterCopy: true
                        }),
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    },
                },
                colorBorder: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_ColorBorder'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                    },
                },
                fillPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_FillPoint'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                    },
                },
                colorByCategory: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_ColorByCategory'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                    }
                },
                currentFrameIndex: {
                    properties: {
                        index: {
                            type: { numeric: true },
                        }
                    }
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                    //description: data.createDisplayNameGetter('Visual_PlotDescription'),
                    properties: {
                        transparency: visuals.StandardObjectProperties.transparency,
                        image: visuals.StandardObjectProperties.image,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                        },
                        values: {
                            group: {
                                by: 'Series',
                                select: [
                                    { bind: { to: 'X' } },
                                    { bind: { to: 'Y' } },
                                    { bind: { to: 'Size' } },
                                    { bind: { to: 'Gradient' } },
                                ],
                            }
                        },
                        rowCount: { preferred: { min: 2 } },
                        dataReductionAlgorithm: { sample: {} },
                        dataVolume: 4,
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 0 }, 'Play': { min: 1, max: 1 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 1 }, 'Gradient': { max: 1 }, 'Play': { min: 1, max: 1 } },
                    ],
                    // Long term: consider adding the 'name' concept and have this be a reference to the other dataViewMapping above.
                    // Then we'd also move the splitting logic of Matrix->Categorical[] into DataViewTransform, and other visuals would benefit.
                    matrix: {
                        rows: {
                            select: [
                                { bind: { to: 'Play' } },
                                { bind: { to: 'Category' } },
                            ],
                            /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
                            dataReductionAlgorithm: { bottom: { count: 5000 } }
                        },
                        columns: {
                            for: { in: 'Series' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix/play. */
                            dataReductionAlgorithm: { top: { count: 60 } }
                        },
                        values: {
                            select: [
                                { bind: { to: 'X' } },
                                { bind: { to: 'Y' } },
                                { bind: { to: 'Size' } },
                            ]
                        }
                    }
                }, {
                    conditions: [
                        { 'Category': { max: 1 }, 'Series': { max: 1 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 0 }, 'Play': { max: 0 } },
                        { 'Category': { max: 1 }, 'Series': { max: 0 }, 'X': { max: 1 }, 'Y': { max: 1 }, 'Size': { max: 0 }, 'Gradient': { max: 1 }, 'Play': { max: 0 } },
                    ],
                    requiredProperties: [{ objectName: 'trend', propertyName: 'show' }],
                    usage: {
                        regression: {
                            combineSeries: { objectName: 'trend', propertyName: 'combineSeries' }
                        },
                    },
                    categorical: {
                        categories: {
                            for: { in: 'regression.X' }
                        },
                        values: {
                            group: {
                                by: 'regression.Series',
                                select: [{ for: { in: 'regression.Y' } }],
                            },
                        },
                        dataReductionAlgorithm: { sample: {} },
                        dataVolume: 4,
                    }
                }],
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Play', direction: 1 /* Ascending */ }] //typically a datetime field, sort asc
                },
            },
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.scatterChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                defaultColor: { objectName: 'dataPoint', propertyName: 'defaultColor' },
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            trend: {
                show: { objectName: 'trend', propertyName: 'show' },
            },
            colorBorder: {
                show: { objectName: 'colorBorder', propertyName: 'show' },
            },
            fillPoint: {
                show: { objectName: 'fillPoint', propertyName: 'show' },
            },
            colorByCategory: {
                show: { objectName: 'colorByCategory', propertyName: 'show' },
            },
            currentFrameIndex: {
                index: { objectName: 'currentFrameIndex', propertyName: 'index' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            plotArea: {
                image: { objectName: 'plotArea', propertyName: 'image' },
                transparency: { objectName: 'plotArea', propertyName: 'transparency' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.slicerCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Field'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldDescription')
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        filter: {
                            type: { filter: {} },
                        },
                        defaultValue: {
                            type: { expression: { defaultValue: true } },
                        },
                        formatString: visuals.StandardObjectProperties.formatString,
                        outlineColor: visuals.StandardObjectProperties.outlineColor,
                        outlineWeight: visuals.StandardObjectProperties.outlineWeight,
                        orientation: {
                            displayName: powerbi.data.createDisplayNameGetter('Slicer_Orientation'),
                            type: { enumeration: visuals.slicerOrientation.type }
                        },
                        count: {
                            type: { integer: true }
                        },
                    },
                },
                selection: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_SelectionControls'),
                    properties: {
                        selectAllCheckboxEnabled: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_SelectAll'),
                            type: { bool: true }
                        },
                        singleSelect: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_SingleSelect'),
                            type: { bool: true }
                        }
                    },
                },
                header: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Header'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        fontColor: visuals.StandardObjectProperties.fontColor,
                        background: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outline: visuals.StandardObjectProperties.outline,
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    }
                },
                items: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Items'),
                    properties: {
                        fontColor: visuals.StandardObjectProperties.fontColor,
                        background: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Background'),
                            type: { fill: { solid: { color: true } } }
                        },
                        outline: visuals.StandardObjectProperties.outline,
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    }
                }
            },
            dataViewMappings: [{
                    conditions: [{ 'Values': { max: 1 } }],
                    categorical: {
                        categories: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: {} }
                        },
                        includeEmptyGroups: true,
                    }
                }],
            sorting: {
                default: {},
            },
            suppressDefaultTitle: true,
            disableVisualDetails: true,
        };
        // TODO: Generate these from above, defining twice just introduces potential for error
        visuals.slicerProps = {
            general: {
                outlineColor: { objectName: 'general', propertyName: 'outlineColor' },
                outlineWeight: { objectName: 'general', propertyName: 'outlineWeight' },
                orientation: { objectName: 'general', propertyName: 'orientation' },
                count: { objectName: 'general', propertyName: 'count' },
            },
            selection: {
                selectAllCheckboxEnabled: { objectName: 'selection', propertyName: 'selectAllCheckboxEnabled' },
                singleSelect: { objectName: 'selection', propertyName: 'singleSelect' }
            },
            header: {
                show: { objectName: 'header', propertyName: 'show' },
                fontColor: { objectName: 'header', propertyName: 'fontColor' },
                background: { objectName: 'header', propertyName: 'background' },
                outline: { objectName: 'header', propertyName: 'outline' },
                textSize: { objectName: 'header', propertyName: 'textSize' },
            },
            items: {
                fontColor: { objectName: 'items', propertyName: 'fontColor' },
                background: { objectName: 'items', propertyName: 'background' },
                outline: { objectName: 'items', propertyName: 'outline' },
                textSize: { objectName: 'items', propertyName: 'textSize' },
            },
            selectedPropertyIdentifier: { objectName: 'general', propertyName: 'selected' },
            filterPropertyIdentifier: { objectName: 'general', propertyName: 'filter' },
            formatString: { objectName: 'general', propertyName: 'formatString' },
            defaultValue: { objectName: 'general', propertyName: 'defaultValue' },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.tableCapabilities = {
            dataRoles: [{
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.GroupingOrMeasure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                }],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                        columnWidth: {
                            type: { numeric: true }
                        },
                        totals: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Totals')
                        },
                        autoSizeColumnWidth: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Adjust_Column_Width')
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    },
                },
                grid: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Grid'),
                    properties: {
                        outlineColor: visuals.StandardObjectProperties.outlineColor,
                        outlineWeight: visuals.StandardObjectProperties.outlineWeight,
                        gridVertical: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Desc'),
                            type: { bool: true }
                        },
                        gridVerticalColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridVerticalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
                            type: { numeric: true }
                        },
                        gridHorizontal: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Desc'),
                            type: { bool: true }
                        },
                        gridHorizontalColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridHorizontalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
                            type: { numeric: true }
                        },
                        rowPadding: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_RowPadding'),
                            description: powerbi.data.createDisplayNameGetter('Visual_RowPadding_Desc'),
                            type: { numeric: true }
                        },
                        imageHeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ImageHeight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_ImageHeight_Desc'),
                            type: { numeric: true }
                        },
                    }
                },
                columnHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
                    properties: {
                        outline: visuals.StandardObjectProperties.outline,
                        fontColor: visuals.StandardObjectProperties.fontColor,
                        backColor: visuals.StandardObjectProperties.backColor,
                    }
                },
                values: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_Values'),
                    properties: {
                        outline: visuals.StandardObjectProperties.outline,
                        // TODO: VSTS 7167767: Remove temporary code for product demo.
                        backgroundColorConditional: {
                            displayName: 'Conditional Formatting',
                            type: { bool: true }
                        },
                        fontColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        urlIcon: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_UrlIcon'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_UrlIcon_Desc'),
                            type: { bool: true }
                        },
                    }
                },
                total: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_TotalGrand'),
                    properties: {
                        outline: visuals.StandardObjectProperties.outline,
                        fontColor: visuals.StandardObjectProperties.fontColor,
                        backColor: visuals.StandardObjectProperties.backColor,
                    }
                },
            },
            dataViewMappings: [{
                    table: {
                        rows: {
                            for: { in: 'Values' },
                            dataReductionAlgorithm: { window: { count: 500 } }
                        },
                        rowCount: { preferred: { min: 1 } }
                    },
                }],
            sorting: {
                custom: {},
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
            disableVisualDetails: true,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.matrixRoleNames = {
            rows: 'Rows',
            columns: 'Columns',
            values: 'Values',
        };
        visuals.matrixCapabilities = {
            dataRoles: [
                {
                    name: visuals.matrixRoleNames.rows,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Rows'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_RowsDescription')
                }, {
                    name: visuals.matrixRoleNames.columns,
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Columns'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ColumnsDescription')
                }, {
                    name: visuals.matrixRoleNames.values,
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values')
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                        columnWidth: {
                            type: { numeric: true }
                        },
                        rowSubtotals: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TotalRow')
                        },
                        columnSubtotals: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TotalColumn')
                        },
                        autoSizeColumnWidth: {
                            type: { bool: true },
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Adjust_Column_Width')
                        },
                        textSize: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_TextSize'),
                            type: { numeric: true }
                        },
                    },
                },
                grid: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Grid'),
                    properties: {
                        outlineColor: visuals.StandardObjectProperties.outlineColor,
                        outlineWeight: visuals.StandardObjectProperties.outlineWeight,
                        gridVertical: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Desc'),
                            type: { bool: true }
                        },
                        gridVerticalColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridVerticalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridVertical_Weight_Desc'),
                            type: { numeric: true }
                        },
                        gridHorizontal: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Desc'),
                            type: { bool: true }
                        },
                        gridHorizontalColor: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Color_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        gridHorizontalWeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_GridHorizontal_Weight_Desc'),
                            type: { numeric: true }
                        },
                        rowPadding: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_RowPadding'),
                            description: powerbi.data.createDisplayNameGetter('Visual_RowPadding_Desc'),
                            type: { numeric: true }
                        },
                        imageHeight: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ImageHeight'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_ImageHeight_Desc'),
                            type: { numeric: true }
                        },
                    },
                },
                columnHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_ColumnHeaders'),
                    properties: {
                        outline: visuals.StandardObjectProperties.outline,
                        fontColor: visuals.StandardObjectProperties.fontColor,
                        backColor: visuals.StandardObjectProperties.backColor,
                    }
                },
                rowHeaders: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_RowHeaders'),
                    properties: {
                        outline: visuals.StandardObjectProperties.outline,
                        fontColor: visuals.StandardObjectProperties.fontColor,
                        backColor: visuals.StandardObjectProperties.backColor,
                    }
                },
                values: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_Values'),
                    properties: {
                        outline: visuals.StandardObjectProperties.outline,
                        fontColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorPrimary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorPrimary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        fontColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_FontColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                        backColorSecondary: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Tablix_BackColorSecondary_Desc'),
                            type: { fill: { solid: { color: true } } }
                        },
                    }
                },
                subTotals: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Tablix_TotalSub'),
                    properties: {
                        outline: visuals.StandardObjectProperties.outline,
                        fontColor: visuals.StandardObjectProperties.fontColor,
                        backColor: visuals.StandardObjectProperties.backColor,
                    }
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Rows': { max: 0 }, 'Columns': { max: 0 }, 'Values': { min: 1 } },
                        { 'Rows': { min: 1 }, 'Columns': { min: 0 }, 'Values': { min: 0 } },
                        { 'Rows': { min: 0 }, 'Columns': { min: 1 }, 'Values': { min: 0 } }
                    ],
                    matrix: {
                        rows: {
                            for: { in: 'Rows' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { window: { count: 500 } }
                        },
                        columns: {
                            for: { in: 'Columns' },
                            /* Explicitly override the server data reduction to make it appropriate for matrix. */
                            dataReductionAlgorithm: { top: { count: 100 } }
                        },
                        values: {
                            for: { in: 'Values' }
                        }
                    }
                }],
            filterMappings: {
                measureFilter: {
                    targetRoles: [visuals.matrixRoleNames.rows]
                }
            },
            sorting: {
                custom: {},
            },
            suppressDefaultTitle: true,
            supportsSelection: false,
            disableVisualDetails: true,
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.treemapCapabilities = {
            dataRoles: [
                {
                    name: 'Group',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Group'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GroupTreemapDescription')
                }, {
                    name: 'Details',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Details'),
                }, {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Values'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_ValuesDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }, {
                    name: 'Gradient',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Gradient'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_GradientDescription'),
                    requiredTypes: [{ numeric: true }, { integer: true }],
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.legendPosition,
                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
                        titleText: visuals.StandardObjectProperties.legendTitle,
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                dataPoint: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                    properties: {
                        fill: {
                            type: { fill: { solid: { color: true } } }
                        },
                        fillRule: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Gradient'),
                            type: { fillRule: {} },
                            rule: {
                                inputRole: 'Gradient',
                                output: {
                                    property: 'fill',
                                    selector: ['Group'],
                                }
                            }
                        }
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    }
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_CategoryLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Group': { max: 1 }, 'Details': { max: 0 }, 'Gradient': { max: 1 } },
                        { 'Group': { max: 1 }, 'Details': { min: 1, max: 1 }, 'Values': { max: 1 }, 'Gradient': { max: 0 } }
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Group' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            group: {
                                by: 'Details',
                                select: [{ bind: { to: 'Values' } }, { bind: { to: 'Gradient' } }],
                                dataReductionAlgorithm: { top: {} }
                            }
                        },
                        rowCount: { preferred: { min: 2 } }
                    }
                }],
            supportsHighlight: true,
            sorting: {
                custom: {},
                implicit: {
                    clauses: [{ role: 'Values', direction: 2 /* Descending */ }]
                },
            },
            drilldown: {
                roles: ['Group']
            },
        };
        visuals.treemapProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            dataPoint: {
                fill: { objectName: 'dataPoint', propertyName: 'fill' },
            },
            legend: {
                show: { objectName: 'legend', propertyName: 'show' },
                position: { objectName: 'legend', propertyName: 'position' },
                showTitle: { objectName: 'legend', propertyName: 'showTitle' },
                titleText: { objectName: 'legend', propertyName: 'titleText' },
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
            labels: {
                show: { objectName: 'labels', propertyName: 'show' },
                color: { objectName: 'labels', propertyName: 'color' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
            },
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.cardCapabilities = {
            dataRoles: [
                {
                    name: 'Values',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Fields'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_FieldsDescription'),
                }
            ],
            objects: {
                general: {
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointLabel'),
                    properties: {
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                        // NOTE: Consider adding a ValueType for fontSize.
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    },
                },
                categoryLabels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_CategoryLabel'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        // NOTE: Consider adding a ValueType for fontSize.
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    },
                },
                wordWrap: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_WordWrap'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Values': { max: 1 } }
                    ],
                    single: { role: "Values" }
                }],
            suppressDefaultTitle: true,
            supportsSelection: false,
        };
        visuals.cardProps = {
            categoryLabels: {
                show: { objectName: 'categoryLabels', propertyName: 'show' },
                color: { objectName: 'categoryLabels', propertyName: 'color' },
                fontSize: { objectName: 'categoryLabels', propertyName: 'fontSize' },
            },
            labels: {
                color: { objectName: 'labels', propertyName: 'color' },
                labelPrecision: { objectName: 'labels', propertyName: 'labelPrecision' },
                labelDisplayUnits: { objectName: 'labels', propertyName: 'labelDisplayUnits' },
                fontSize: { objectName: 'labels', propertyName: 'fontSize' },
            },
            wordWrap: {
                show: { objectName: 'wordWrap', propertyName: 'show' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.waterfallChartCapabilities = {
            dataRoles: [
                {
                    name: 'Category',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Category'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_CategoryWaterfallDescription')
                }, {
                    name: 'Y',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    requiredTypes: [{ numeric: true }, { integer: true }],
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_Y'),
                }
            ],
            objects: {
                general: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                legend: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Legend'),
                    description: powerbi.data.createDisplayNameGetter('Visual_LegendDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.legendPosition,
                        showTitle: visuals.StandardObjectProperties.showLegendTitle,
                        titleText: $.extend({}, visuals.StandardObjectProperties.legendTitle, {
                            suppressFormatPainterCopy: true,
                        }),
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                labels: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabels'),
                    description: powerbi.data.createDisplayNameGetter('Visual_DataPointsLabelsDescription'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        color: visuals.StandardObjectProperties.dataColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                        labelPrecision: $.extend({}, visuals.StandardObjectProperties.labelPrecision, {
                            suppressFormatPainterCopy: true,
                        }),
                        fontSize: visuals.StandardObjectProperties.fontSize,
                    }
                },
                sentimentColors: {
                    displayName: powerbi.data.createDisplayNameGetter('Waterfall_SentimentColors'),
                    properties: {
                        increaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_IncreaseLabel'),
                            type: { fill: { solid: { color: true } } }
                        },
                        decreaseFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_DecreaseLabel'),
                            type: { fill: { solid: { color: true } } }
                        },
                        totalFill: {
                            displayName: powerbi.data.createDisplayNameGetter('Waterfall_TotalLabel'),
                            type: { fill: { solid: { color: true } } }
                        }
                    },
                },
                categoryAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_XAxis'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_XTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: visuals.StandardObjectProperties.axisStyle,
                        labelColor: visuals.StandardObjectProperties.labelColor,
                    }
                },
                valueAxis: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        position: visuals.StandardObjectProperties.yAxisPosition,
                        start: visuals.StandardObjectProperties.axisStart,
                        end: visuals.StandardObjectProperties.axisEnd,
                        showAxisTitle: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Axis_Title'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Axis_YTitleDescription'),
                            type: { bool: true }
                        },
                        axisStyle: visuals.StandardObjectProperties.axisStyle,
                        labelColor: visuals.StandardObjectProperties.labelColor,
                        labelDisplayUnits: visuals.StandardObjectProperties.labelDisplayUnits,
                        labelPrecision: visuals.StandardObjectProperties.labelPrecision,
                    }
                },
                y1AxisReferenceLine: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line'),
                    description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Description'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                        value: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Value_Description'),
                            type: { numeric: true }
                        },
                        lineColor: visuals.StandardObjectProperties.lineColor,
                        transparency: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency'),
                            description: powerbi.data.createDisplayNameGetter('Visual_Reference_Line_Transparency_Description'),
                            type: { numeric: true }
                        },
                        style: visuals.StandardObjectProperties.referenceLineStyle,
                        position: visuals.StandardObjectProperties.referenceLinePosition,
                        dataLabelShow: visuals.StandardObjectProperties.dataLabelShow,
                        dataLabelColor: visuals.StandardObjectProperties.dataLabelColor,
                        dataLabelDecimalPoints: visuals.StandardObjectProperties.dataLabelDecimalPoints,
                        dataLabelHorizontalPosition: visuals.StandardObjectProperties.dataLabelHorizontalPosition,
                        dataLabelVerticalPosition: visuals.StandardObjectProperties.dataLabelVerticalPosition,
                        dataLabelDisplayUnits: visuals.StandardObjectProperties.dataLabelDisplayUnits,
                    },
                },
                plotArea: {
                    displayName: powerbi.data.createDisplayNameGetter('Visual_Plot'),
                    properties: {
                        transparency: visuals.StandardObjectProperties.transparency,
                        image: visuals.StandardObjectProperties.image,
                    },
                },
            },
            dataViewMappings: [{
                    conditions: [
                        { 'Category': { max: 1 }, 'Y': { max: 1 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{ bind: { to: 'Y' } }]
                        },
                    },
                }],
            drilldown: {
                roles: ['Category']
            },
        };
        visuals.waterfallChartProps = {
            general: {
                formatString: { objectName: 'general', propertyName: 'formatString' },
            },
            sentimentColors: {
                increaseFill: { objectName: 'sentimentColors', propertyName: 'increaseFill' },
                decreaseFill: { objectName: 'sentimentColors', propertyName: 'decreaseFill' },
                totalFill: { objectName: 'sentimentColors', propertyName: 'totalFill' },
            },
            legend: {
                labelColor: { objectName: 'legend', propertyName: 'labelColor' },
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        visuals.KPIStatusWithHistoryCapabilities = {
            dataRoles: [
                {
                    name: 'Indicator',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Indicator'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_IndicatorDescription')
                }, {
                    name: 'TrendLine',
                    kind: powerbi.VisualDataRoleKind.Grouping,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_TrendLine'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Trendline_Description')
                }, {
                    name: 'Goal',
                    kind: powerbi.VisualDataRoleKind.Measure,
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goal'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_GoalDescription')
                }],
            dataViewMappings: [{
                    conditions: [
                        { 'Indicator': { max: 1 }, 'TrendLine': { max: 1 }, 'Goal': { max: 2 } },
                    ],
                    categorical: {
                        categories: {
                            for: { in: 'TrendLine' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [
                                { bind: { to: 'Indicator' } },
                                { bind: { to: 'Goal' } }
                            ]
                        }
                    },
                }],
            objects: {
                general: {
                    properties: {
                        formatString: visuals.StandardObjectProperties.formatString,
                    },
                },
                indicator: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Indicator'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_IndicatorDescription'),
                    properties: {
                        indicatorDisplayUnits: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_DisplayUnits'),
                            description: powerbi.data.createDisplayNameGetter('Visual_DisplayUnitsDescription'),
                            type: { formatting: { labelDisplayUnits: true } }
                        },
                        indicatorPrecision: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_Precision'),
                            description: powerbi.data.createDisplayNameGetter('Visual_PrecisionDescription'),
                            placeHolderText: powerbi.data.createDisplayNameGetter('Visual_Precision_Auto'),
                            type: { numeric: true }
                        },
                        kpiFormat: {
                            displayName: powerbi.data.createDisplayNameGetter('TaskPane_Format'),
                            type: { text: true },
                        }
                    }
                },
                trendline: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_TrendLine'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Trendline_Description'),
                    properties: {
                        show: visuals.StandardObjectProperties.show,
                    }
                },
                goals: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goals'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Goals'),
                    properties: {
                        showGoal: {
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Show_Goal'),
                            type: { bool: true }
                        },
                        showDistance: {
                            displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Show_Distance'),
                            type: { bool: true }
                        },
                    }
                },
                status: {
                    displayName: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Status'),
                    description: powerbi.data.createDisplayNameGetter('Role_DisplayName_KPI_Status'),
                    properties: {
                        direction: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_KPI_Direction'),
                            type: { enumeration: visuals.kpiDirection.type }
                        }
                    }
                }
            },
        };
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var capabilities;
        (function (capabilities) {
            // This file registers the built-in capabilities
            // Please use this file to register the capabilities in the plugins.ts/pluginsNotForOSS.ts
            capabilities.animatedNumber = powerbi.visuals.animatedNumberCapabilities;
            capabilities.areaChart = powerbi.visuals.lineChartCapabilities;
            capabilities.barChart = powerbi.visuals.getColumnChartCapabilities(true);
            capabilities.card = powerbi.visuals.cardCapabilities;
            capabilities.multiRowCard = powerbi.visuals.multiRowCardCapabilities;
            capabilities.clusteredBarChart = powerbi.visuals.getColumnChartCapabilities(true);
            capabilities.clusteredColumnChart = powerbi.visuals.getColumnChartCapabilities();
            capabilities.columnChart = powerbi.visuals.getColumnChartCapabilities();
            capabilities.comboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.dataDotChart = powerbi.visuals.dataDotChartCapabilities;
            capabilities.dataDotClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.dataDotStackedColumnComboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.donutChart = powerbi.visuals.donutChartCapabilities;
            capabilities.funnel = powerbi.visuals.funnelChartCapabilities;
            capabilities.gauge = powerbi.visuals.gaugeCapabilities;
            capabilities.hundredPercentStackedBarChart = powerbi.visuals.getColumnChartCapabilities(true);
            capabilities.hundredPercentStackedColumnChart = powerbi.visuals.getColumnChartCapabilities();
            capabilities.image = powerbi.visuals.imageVisualCapabilities;
            capabilities.lineChart = powerbi.visuals.lineChartCapabilities;
            capabilities.lineStackedColumnComboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.lineClusteredColumnComboChart = powerbi.visuals.comboChartCapabilities;
            capabilities.map = powerbi.visuals.mapCapabilities;
            capabilities.filledMap = powerbi.visuals.filledMapCapabilities;
            capabilities.treemap = powerbi.visuals.treemapCapabilities;
            capabilities.pieChart = powerbi.visuals.donutChartCapabilities;
            capabilities.scatterChart = powerbi.visuals.scatterChartCapabilities;
            capabilities.table = powerbi.visuals.tableCapabilities;
            capabilities.matrix = powerbi.visuals.matrixCapabilities;
            capabilities.slicer = powerbi.visuals.slicerCapabilities;
            capabilities.textbox = powerbi.visuals.textboxCapabilities;
            capabilities.waterfallChart = powerbi.visuals.waterfallChartCapabilities;
            capabilities.cheerMeter = powerbi.visuals.cheerMeterCapabilities;
            capabilities.scriptVisual = powerbi.visuals.scriptVisualCapabilities;
            capabilities.kpi = powerbi.visuals.KPIStatusWithHistoryCapabilities;
        })(capabilities = visuals.capabilities || (visuals.capabilities = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ColumnChartWebBehavior = (function () {
            function ColumnChartWebBehavior() {
            }
            ColumnChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.options = options;
                var eventGroup = options.eventGroup;
                eventGroup.on('click', function () {
                    var d = ColumnChartWebBehavior.getDatumForLastInputEvent();
                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
                });
                eventGroup.on('contextmenu', function () {
                    if (d3.event.ctrlKey)
                        return;
                    d3.event.preventDefault();
                    var d = ColumnChartWebBehavior.getDatumForLastInputEvent();
                    var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                    selectionHandler.handleContextMenu(d, position);
                });
            };
            ColumnChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                var options = this.options;
                options.bars.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && options.hasHighlights); });
            };
            ColumnChartWebBehavior.getDatumForLastInputEvent = function () {
                var target = d3.event.target;
                return d3.select(target).datum();
            };
            return ColumnChartWebBehavior;
        }());
        visuals.ColumnChartWebBehavior = ColumnChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataDotChartWebBehavior = (function () {
            function DataDotChartWebBehavior() {
            }
            DataDotChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var dots = this.dots = options.dots;
                var dotLabels = options.dotLabels;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler);
                if (dotLabels) {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(dotLabels, selectionHandler);
                }
            };
            DataDotChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                this.dots.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
            };
            return DataDotChartWebBehavior;
        }());
        visuals.DataDotChartWebBehavior = DataDotChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DonutChartWebBehavior = (function () {
            function DonutChartWebBehavior() {
            }
            DonutChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var slices = this.slices = options.slices;
                var highlightSlices = this.highlightSlices = options.highlightSlices;
                var clearCatcher = options.clearCatcher;
                this.hasHighlights = options.hasHighlights;
                var clickHandler = function (d) {
                    selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                };
                var contextMenuHandler = function (d) {
                    if (d3.event.ctrlKey)
                        return;
                    var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                    selectionHandler.handleContextMenu(d.data, position);
                    d3.event.preventDefault();
                };
                slices.on('click', clickHandler);
                slices.on('contextmenu', contextMenuHandler);
                highlightSlices.on('click', clickHandler);
                highlightSlices.on('contextmenu', contextMenuHandler);
                clearCatcher.on('click', function () {
                    selectionHandler.handleClearSelection();
                });
            };
            DonutChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.slices.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, hasHighlights && !d.data.selected); });
                this.highlightSlices.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, hasHighlights); });
            };
            return DonutChartWebBehavior;
        }());
        visuals.DonutChartWebBehavior = DonutChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var FunnelWebBehavior = (function () {
            function FunnelWebBehavior() {
            }
            FunnelWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var bars = this.bars = options.bars;
                var interactors = this.interactors = options.interactors;
                var clearCatcher = options.clearCatcher;
                this.hasHighlights = options.hasHighlights;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(bars, selectionHandler);
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(interactors, selectionHandler);
                clearCatcher.on('click', function () {
                    selectionHandler.handleClearSelection();
                });
            };
            FunnelWebBehavior.prototype.renderSelection = function (hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.bars.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights); });
            };
            return FunnelWebBehavior;
        }());
        visuals.FunnelWebBehavior = FunnelWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LineChartWebBehavior = (function () {
            function LineChartWebBehavior() {
            }
            LineChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.lines = options.lines;
                var interactivityLines = options.interactivityLines;
                var dots = this.dots = options.dots;
                var areas = this.areas = options.areas;
                var tooltipOverlay = this.tooltipOverlay = options.tooltipOverlay;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(interactivityLines, selectionHandler);
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(dots, selectionHandler);
                if (areas) {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(areas, selectionHandler);
                }
                if (tooltipOverlay)
                    tooltipOverlay.on('click', function () { return selectionHandler.handleClearSelection(); });
            };
            LineChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                this.lines.style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                this.dots.style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                if (this.areas)
                    this.areas.style("fill-opacity", function (d) { return (hasSelection && !d.selected) ? visuals.LineChart.DimmedAreaFillOpacity : visuals.LineChart.AreaFillOpacity; });
            };
            return LineChartWebBehavior;
        }());
        visuals.LineChartWebBehavior = LineChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var MapBehavior = (function () {
            function MapBehavior() {
                this.mapPointerEventsDisabled = false;
                this.mapPointerTimeoutSet = false;
                this.viewChangedSinceLastClearMouseDown = false;
                this.receivedZoomOrPanEvent = false;
            }
            MapBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var _this = this;
                var bubbles = this.bubbles = options.bubbles;
                var slices = this.slices = options.slices;
                var shapes = this.shapes = options.shapes;
                var clearCatcher = options.clearCatcher;
                var clickHandler = function (d) {
                    if (bubbles)
                        bubbles.style("pointer-events", "all");
                    if (shapes)
                        shapes.style("pointer-events", "all");
                    selectionHandler.handleSelection(d, d3.event.ctrlKey);
                };
                if (!this.mapPointerEventsDisabled) {
                    if (bubbles)
                        bubbles.style("pointer-events", "all");
                    if (slices)
                        slices.style("pointer-events", "all");
                    if (shapes)
                        shapes.style("pointer-events", "all");
                }
                if (bubbles) {
                    bubbles.on('click', clickHandler);
                    bubbles.on('mousewheel', function () {
                        if (!_this.mapPointerEventsDisabled)
                            bubbles.style("pointer-events", "none");
                        _this.mapPointerEventsDisabled = true;
                        if (!_this.mapPointerTimeoutSet) {
                            _this.mapPointerTimeoutSet = true;
                            setTimeout(function () {
                                if (bubbles)
                                    bubbles.style("pointer-events", "all");
                                _this.mapPointerEventsDisabled = false;
                                _this.mapPointerTimeoutSet = false;
                            }, 200);
                        }
                    });
                    visuals.InteractivityUtils.registerStandardContextMenuHandler(bubbles, selectionHandler);
                }
                if (slices) {
                    slices.on('click', function (d) {
                        slices.style("pointer-events", "all");
                        _this.mapPointerEventsDisabled = false;
                        selectionHandler.handleSelection(d.data, d3.event.ctrlKey);
                    });
                    slices.on('mousewheel', function () {
                        if (!_this.mapPointerEventsDisabled)
                            slices.style("pointer-events", "none");
                        _this.mapPointerEventsDisabled = true;
                        if (!_this.mapPointerTimeoutSet) {
                            _this.mapPointerTimeoutSet = true;
                            setTimeout(function () {
                                if (slices)
                                    slices.style("pointer-events", "all");
                                _this.mapPointerEventsDisabled = false;
                                _this.mapPointerTimeoutSet = false;
                            }, 200);
                        }
                    });
                    slices.on('contextmenu', function (slice) {
                        if (d3.event.ctrlKey)
                            return;
                        d3.event.preventDefault();
                        var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                        selectionHandler.handleContextMenu(slice.data, position);
                    });
                }
                if (shapes) {
                    shapes.on('click', clickHandler);
                    shapes.on('mousewheel', function () {
                        if (!_this.mapPointerEventsDisabled) {
                            shapes.style("pointer-events", "none");
                        }
                        _this.mapPointerEventsDisabled = true;
                        if (!_this.mapPointerTimeoutSet) {
                            _this.mapPointerTimeoutSet = true;
                            setTimeout(function () {
                                if (shapes)
                                    shapes.style("pointer-events", "all");
                                _this.mapPointerEventsDisabled = false;
                                _this.mapPointerTimeoutSet = false;
                            }, 200);
                        }
                    });
                    visuals.InteractivityUtils.registerStandardContextMenuHandler(shapes, selectionHandler);
                }
                clearCatcher.on('mouseup', function () {
                    if (!_this.viewChangedSinceLastClearMouseDown) {
                        selectionHandler.handleClearSelection();
                        _this.receivedZoomOrPanEvent = true;
                    }
                });
                clearCatcher.on('mousedown', function () {
                    _this.viewChangedSinceLastClearMouseDown = false;
                });
                clearCatcher.on('mousewheel', function () {
                    _this.receivedZoomOrPanEvent = true;
                });
            };
            MapBehavior.prototype.renderSelection = function (hasSelection) {
                if (this.bubbles) {
                    this.bubbles
                        .style({
                        'fill-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                        'stroke-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                    });
                }
                if (this.slices) {
                    this.slices
                        .style({
                        "fill-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); },
                        "stroke-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); },
                    });
                }
                if (this.shapes) {
                    this.shapes
                        .style({
                        "fill-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                        "stroke-opacity": function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); },
                    });
                }
            };
            MapBehavior.prototype.viewChanged = function () {
                this.viewChangedSinceLastClearMouseDown = true;
            };
            MapBehavior.prototype.resetZoomPan = function () {
                this.receivedZoomOrPanEvent = false;
            };
            MapBehavior.prototype.hasReceivedZoomOrPanEvent = function () {
                return this.receivedZoomOrPanEvent;
            };
            return MapBehavior;
        }());
        visuals.MapBehavior = MapBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var ScatterChartWebBehavior = (function () {
            function ScatterChartWebBehavior() {
            }
            ScatterChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var bubbles = this.bubbles = options.dataPointsSelection;
                var data = options.data;
                var eventGroup = options.eventGroup;
                // If we are removing play-axis, remove the trace lines as well
                // TODO: revisit this design, I think ideally this is done when rendering scatter.
                if (this.playOptions
                    && this.playOptions.traceLineRenderer
                    && (!options.playOptions || !options.playOptions.traceLineRenderer)) {
                    this.playOptions.traceLineRenderer.remove();
                }
                this.playOptions = options.playOptions;
                this.shouldEnableFill = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint;
                this.colorBorder = data.colorBorder;
                if (eventGroup) {
                    visuals.InteractivityUtils.registerGroupInteractivityHandlers(eventGroup, selectionHandler);
                }
                else {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(bubbles, selectionHandler);
                }
            };
            ScatterChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                var shouldEnableFill = this.shouldEnableFill;
                var colorBorder = this.colorBorder;
                this.bubbles.style("fill-opacity", function (d) { return visuals.ScatterChart.getMarkerFillOpacity(d.size != null, shouldEnableFill, hasSelection, d.selected); });
                this.bubbles.style("stroke-opacity", function (d) { return visuals.ScatterChart.getMarkerStrokeOpacity(d.size != null, colorBorder, hasSelection, d.selected); });
                if (this.playOptions && this.bubbles) {
                    var selectedPoints = this.bubbles.filter(function (d) { return d.selected; }).data();
                    var traceLineRenderer = this.playOptions.traceLineRenderer;
                    if (selectedPoints && selectedPoints.length > 0 && traceLineRenderer != null) {
                        traceLineRenderer.render(selectedPoints, true);
                    }
                    else {
                        traceLineRenderer.remove();
                    }
                }
            };
            return ScatterChartWebBehavior;
        }());
        visuals.ScatterChartWebBehavior = ScatterChartWebBehavior;
        var ScatterChartMobileBehavior = (function () {
            function ScatterChartMobileBehavior() {
            }
            ScatterChartMobileBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.setOptions(options);
                if (!options.visualInitOptions || !options.visualInitOptions.interactivity.isInteractiveLegend) {
                    // Don't bind events if we are not in interactiveLegend mode
                    // This case happend when on mobile we show the whole dashboard in still not on focus
                    return;
                }
                this.makeDataPointsSelectable(options.dataPointsSelection);
                this.makeRootSelectable(options.root);
                this.makeDragable(options.root);
                this.disableDefaultTouchInteractions(options.root);
                this.selectRoot();
            };
            ScatterChartMobileBehavior.prototype.renderSelection = function (HasSelection) { };
            ScatterChartMobileBehavior.prototype.setSelectionHandler = function (selectionHandler) { };
            ScatterChartMobileBehavior.prototype.makeDataPointsSelectable = function () {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i - 0] = arguments[_i];
                }
                for (var i = 0, len = selection.length; i < len; i++) {
                    var sel = selection[i];
                    sel.on('click', function (d, i) {
                        _this.select(i);
                    });
                }
            };
            ScatterChartMobileBehavior.prototype.makeRootSelectable = function (selection) {
                var _this = this;
                selection.on('click', function (d, i) {
                    _this.selectRoot();
                });
            };
            ScatterChartMobileBehavior.prototype.makeDragable = function () {
                var _this = this;
                var selection = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    selection[_i - 0] = arguments[_i];
                }
                for (var i = 0, len = selection.length; i < len; i++) {
                    var sel = selection[i];
                    var drag = d3.behavior.drag()
                        .on('drag', function (d) { _this.drag(0 /* Drag */); })
                        .on('dragend', function (d) { _this.drag(1 /* DragEnd */); });
                    sel.call(drag);
                }
            };
            ScatterChartMobileBehavior.prototype.disableDefaultTouchInteractions = function (selection) {
                selection.style('touch-action', 'none');
            };
            ScatterChartMobileBehavior.prototype.setOptions = function (options) {
                this.data = options.data;
                this.mainGraphicsContext = options.plotContext;
                this.xAxisProperties = options.xAxisProperties;
                this.yAxisProperties = options.yAxisProperties;
                this.host = options.host;
            };
            ScatterChartMobileBehavior.prototype.select = function (index) {
                this.selectDotByIndex(index);
            };
            ScatterChartMobileBehavior.prototype.selectRoot = function () {
                var marker = jsCommon.PerformanceUtil.create('selectRoot');
                this.onClick();
                marker.end();
            };
            ScatterChartMobileBehavior.prototype.drag = function (t) {
                switch (t) {
                    case 0 /* Drag */:
                        this.onDrag();
                        break;
                    case 1 /* DragEnd */:
                        this.onClick();
                        break;
                    default:
                        debug.assertFail('Unknown Drag Type');
                }
            };
            ScatterChartMobileBehavior.prototype.onDrag = function () {
                //find the current x and y position
                var xy = this.getMouseCoordinates();
                //move the crosshair to the current position
                this.moveCrosshairToXY(xy.x, xy.y);
                //update the style and the legend of the dots
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                this.selectDot(selectedIndex);
                this.updateLegend(selectedIndex);
            };
            ScatterChartMobileBehavior.prototype.onClick = function () {
                //find the current x and y position
                var xy = this.getMouseCoordinates();
                var selectedIndex = this.findClosestDotIndex(xy.x, xy.y);
                if (selectedIndex !== -1)
                    this.selectDotByIndex(selectedIndex);
            };
            ScatterChartMobileBehavior.prototype.getMouseCoordinates = function () {
                var mainGfxContext = this.mainGraphicsContext;
                // select (0,0) in cartesian coordinates
                var x = 0;
                var y = parseInt(mainGfxContext.attr('height'), 10);
                y = y || 0;
                try {
                    var mouse = d3.mouse(mainGfxContext.node());
                    x = mouse[0];
                    y = mouse[1];
                }
                catch (e) {
                }
                return { x: x, y: y, };
            };
            ScatterChartMobileBehavior.prototype.selectDotByIndex = function (index) {
                this.selectDot(index);
                this.moveCrosshairToIndexDot(index);
                this.updateLegend(index);
            };
            ScatterChartMobileBehavior.prototype.selectDot = function (dotIndex) {
                var _this = this;
                var root = this.mainGraphicsContext;
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).classed({ selected: false, notSelected: true });
                root.selectAll(ScatterChartMobileBehavior.ScatterChartCircleTagName + ScatterChartMobileBehavior.DotClassSelector).filter(function (d, i) {
                    var dataPoints = _this.data.dataPoints;
                    debug.assert(dataPoints.length > dotIndex, "dataPoints length:" + dataPoints.length + "is smaller than index:" + dotIndex);
                    var currentPoint = dataPoints[dotIndex];
                    return (d.x === currentPoint.x) && (d.y === currentPoint.y);
                }).classed({ selected: true, notSelected: false });
            };
            ScatterChartMobileBehavior.prototype.moveCrosshairToIndexDot = function (index) {
                var dataPoints = this.data.dataPoints;
                var root = this.mainGraphicsContext;
                debug.assert(dataPoints.length > index, "dataPoints length:" + dataPoints.length + "is smaller than index:" + index);
                var x = this.xAxisProperties.scale(dataPoints[index].x);
                var y = this.yAxisProperties.scale(dataPoints[index].y);
                if (this.crosshair == null) {
                    var width = +root.attr('width');
                    var height = +root.attr('height');
                    this.crosshair = this.drawCrosshair(root, x, y, width, height);
                    this.crosshairHorizontal = this.crosshair.select(ScatterChartMobileBehavior.Horizontal.selector);
                    this.crosshairVertical = this.crosshair.select(ScatterChartMobileBehavior.Vertical.selector);
                }
                else {
                    this.moveCrosshairToXY(x, y);
                }
            };
            ScatterChartMobileBehavior.prototype.moveCrosshairToXY = function (x, y) {
                this.crosshairHorizontal.attr({ y1: y, y2: y });
                this.crosshairVertical.attr({ x1: x, x2: x });
            };
            ScatterChartMobileBehavior.prototype.drawCrosshair = function (addTo, x, y, width, height) {
                var crosshair = addTo.append("g");
                crosshair.classed(ScatterChartMobileBehavior.CrosshairClassName, true);
                crosshair.append('line').classed(ScatterChartMobileBehavior.Horizontal.class, true).attr({ x1: 0, x2: width, y1: y, y2: y });
                crosshair.append('line').classed(ScatterChartMobileBehavior.Vertical.class, true).attr({ x1: x, x2: x, y1: height, y2: 0 });
                return crosshair;
            };
            ScatterChartMobileBehavior.prototype.findClosestDotIndex = function (x, y) {
                var selectedIndex = -1;
                var minDistance = Number.MAX_VALUE;
                var dataPoints = this.data.dataPoints;
                var xAxisPropertiesScale = this.xAxisProperties.scale;
                var yAxisPropertiesScale = this.yAxisProperties.scale;
                for (var i in dataPoints) {
                    var currentPoint = dataPoints[i];
                    var circleX = xAxisPropertiesScale(currentPoint.x);
                    var circleY = yAxisPropertiesScale(currentPoint.y);
                    var horizontalDistance = circleX - x;
                    var verticalDistance = circleY - y;
                    var distanceSqrd = (horizontalDistance * horizontalDistance) + (verticalDistance * verticalDistance);
                    if (minDistance === Number.MAX_VALUE) {
                        selectedIndex = i;
                        minDistance = distanceSqrd;
                    }
                    else if (minDistance && minDistance > distanceSqrd) {
                        selectedIndex = i;
                        minDistance = distanceSqrd;
                    }
                }
                return selectedIndex;
            };
            ScatterChartMobileBehavior.prototype.updateLegend = function (dotIndex) {
                if (this.lastDotIndex == null || this.lastDotIndex !== dotIndex) {
                    var legendItems = this.createLegendDataPoints(dotIndex);
                    this.host.updateLegend(legendItems);
                    this.lastDotIndex = dotIndex;
                }
            };
            ScatterChartMobileBehavior.prototype.createLegendDataPoints = function (dotIndex) {
                var formatStringProp = visuals.scatterChartProps.general.formatString;
                var legendItems = [];
                var data = this.data;
                debug.assert(data.dataPoints.length > dotIndex, "dataPoints length:" + data.dataPoints.length + "is smaller than index:" + dotIndex);
                var point = data.dataPoints[dotIndex];
                //set the title of the legend to be the category or radius or group or blank
                var blank = visuals.valueFormatter.format(null);
                var title = blank;
                var legendData = data.legendData;
                debug.assertValue(legendData, "legendData");
                debug.assertValue(legendData.dataPoints, "legendData");
                var legendDataPoints = legendData.dataPoints;
                var category = point.formattedCategory.getValue();
                if (category !== blank) {
                    title = category;
                }
                else if (point.radius.sizeMeasure != null) {
                    title = visuals.valueFormatter.format(point.radius.sizeMeasure.source.groupName);
                }
                else if (legendDataPoints.length >= dotIndex && legendDataPoints[dotIndex].label !== blank) {
                    title = legendDataPoints[dotIndex].label;
                }
                if (data.xCol != null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.xCol.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(this.data.axesLabels.x),
                        measure: visuals.valueFormatter.format(point.x, visuals.valueFormatter.getFormatString(data.xCol, formatStringProp)),
                        iconOnlyOnLabel: true,
                    });
                }
                if (data.yCol != null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.yCol.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(data.axesLabels.y),
                        measure: visuals.valueFormatter.format(point.y, visuals.valueFormatter.getFormatString(data.yCol, formatStringProp)),
                        iconOnlyOnLabel: true,
                    });
                }
                if (data.size != null) {
                    legendItems.push({
                        category: title,
                        color: point.fill,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure(data.size.queryName).createSelectionId(),
                        selected: point.selected,
                        icon: visuals.LegendIcon.Box,
                        label: visuals.valueFormatter.format(data.size.displayName),
                        measure: visuals.valueFormatter.format(point.radius.sizeMeasure.values[point.radius.index], visuals.valueFormatter.getFormatString(data.size, formatStringProp)),
                        iconOnlyOnLabel: true
                    });
                }
                return { dataPoints: legendItems };
            };
            ScatterChartMobileBehavior.CrosshairClassName = 'crosshair';
            ScatterChartMobileBehavior.ScatterChartCircleTagName = 'circle';
            ScatterChartMobileBehavior.DotClassName = 'dot';
            ScatterChartMobileBehavior.DotClassSelector = '.' + ScatterChartMobileBehavior.DotClassName;
            ScatterChartMobileBehavior.Horizontal = createClassAndSelector('horizontal');
            ScatterChartMobileBehavior.Vertical = createClassAndSelector('vertical');
            return ScatterChartMobileBehavior;
        }());
        visuals.ScatterChartMobileBehavior = ScatterChartMobileBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var HorizontalSlicerWebBehavior = (function () {
            function HorizontalSlicerWebBehavior() {
            }
            HorizontalSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.itemLabels = options.itemLabels;
                this.dataPoints = options.dataPoints;
                this.interactivityService = options.interactivityService;
                this.slicerSettings = options.settings;
                visuals.SlicerWebBehavior.bindSlicerEvents(options.slicerContainer, this.itemLabels, options.clear, selectionHandler, this.slicerSettings, this.interactivityService);
            };
            HorizontalSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
                visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemLabels, this.itemLabels, hasSelection, this.interactivityService, this.slicerSettings);
            };
            return HorizontalSlicerWebBehavior;
        }());
        visuals.HorizontalSlicerWebBehavior = HorizontalSlicerWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var VerticalSlicerWebBehavior = (function () {
            function VerticalSlicerWebBehavior() {
            }
            VerticalSlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var slicers = options.itemContainers;
                this.itemLabels = options.itemLabels;
                this.itemInputs = options.itemInputs;
                this.dataPoints = options.dataPoints;
                this.interactivityService = options.interactivityService;
                this.settings = options.settings;
                visuals.SlicerWebBehavior.bindSlicerEvents(options.slicerContainer, slicers, options.clear, selectionHandler, this.settings, this.interactivityService);
            };
            VerticalSlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
                visuals.SlicerWebBehavior.setSelectionOnSlicerItems(this.itemInputs, this.itemLabels, hasSelection, this.interactivityService, this.settings);
            };
            return VerticalSlicerWebBehavior;
        }());
        visuals.VerticalSlicerWebBehavior = VerticalSlicerWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SlicerWebBehavior = (function () {
            function SlicerWebBehavior() {
            }
            SlicerWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.behavior = this.createWebBehavior(options);
                this.behavior.bindEvents(options.behaviorOptions, selectionHandler);
            };
            SlicerWebBehavior.prototype.renderSelection = function (hasSelection) {
                this.behavior.renderSelection(hasSelection);
            };
            SlicerWebBehavior.bindSlicerEvents = function (slicerContainer, slicers, slicerClear, selectionHandler, slicerSettings, interactivityService) {
                SlicerWebBehavior.bindSlicerItemSelectionEvent(slicers, selectionHandler, slicerSettings, interactivityService);
                SlicerWebBehavior.bindSlicerClearEvent(slicerClear, selectionHandler);
                SlicerWebBehavior.styleSlicerContainer(slicerContainer, interactivityService);
            };
            SlicerWebBehavior.setSelectionOnSlicerItems = function (selectableItems, itemLabel, hasSelection, interactivityService, slicerSettings) {
                if (!hasSelection && !interactivityService.isSelectionModeInverted()) {
                    selectableItems.filter('.selected').classed('selected', false);
                    selectableItems.filter('.partiallySelected').classed('partiallySelected', false);
                    var input = selectableItems.selectAll('input');
                    if (input) {
                        input.property('checked', false);
                    }
                    itemLabel.style('color', slicerSettings.slicerText.color);
                }
                else {
                    SlicerWebBehavior.styleSlicerItems(selectableItems, hasSelection, interactivityService.isSelectionModeInverted());
                }
            };
            SlicerWebBehavior.styleSlicerItems = function (slicerItems, hasSelection, isSelectionInverted) {
                slicerItems.each(function (d) {
                    var slicerItem = this;
                    var shouldCheck = false;
                    if (d.isSelectAllDataPoint) {
                        if (hasSelection) {
                            slicerItem.classList.add('partiallySelected');
                            shouldCheck = false;
                        }
                        else {
                            slicerItem.classList.remove('partiallySelected');
                            shouldCheck = isSelectionInverted;
                        }
                    }
                    else {
                        shouldCheck = jsCommon.LogicExtensions.XOR(d.selected, isSelectionInverted);
                    }
                    if (shouldCheck)
                        slicerItem.classList.add('selected');
                    else
                        slicerItem.classList.remove('selected');
                    // Set input selected state to match selection
                    var input = slicerItem.getElementsByTagName('input')[0];
                    if (input)
                        input.checked = shouldCheck;
                });
            };
            SlicerWebBehavior.bindSlicerItemSelectionEvent = function (slicers, selectionHandler, slicerSettings, interactivityService) {
                SlicerWebBehavior.isTouch = false;
                slicers.on("touchstart", function (d) {
                    SlicerWebBehavior.isTouch = true;
                });
                slicers.on("pointerdown", function (d) {
                    var e = d3.event;
                    if (e && e.pointerType === "touch") {
                        SlicerWebBehavior.isTouch = true;
                    }
                });
                slicers.on("click", function (d) {
                    d3.event.preventDefault();
                    if (d.isSelectAllDataPoint) {
                        selectionHandler.toggleSelectionModeInversion();
                    }
                    else {
                        selectionHandler.handleSelection(d, SlicerWebBehavior.isTouch || SlicerWebBehavior.isMultiSelect(d3.event, slicerSettings, interactivityService));
                    }
                    selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
                    SlicerWebBehavior.isTouch = false;
                });
            };
            SlicerWebBehavior.bindSlicerClearEvent = function (slicerClear, selectionHandler) {
                if (slicerClear) {
                    slicerClear.on("click", function (d) {
                        selectionHandler.handleClearSelection();
                        selectionHandler.persistSelectionFilter(visuals.slicerProps.filterPropertyIdentifier);
                    });
                }
            };
            SlicerWebBehavior.styleSlicerContainer = function (slicerContainer, interactivityService) {
                var hasSelection = (interactivityService.hasSelection() && interactivityService.isDefaultValueEnabled() === undefined)
                    || interactivityService.isDefaultValueEnabled() === false;
                slicerContainer.classed('hasSelection', hasSelection);
            };
            SlicerWebBehavior.isMultiSelect = function (event, settings, interactivityService) {
                // If selection is inverted, assume we're always in multi-select mode;
                // Also, Ctrl can be used to multi-select even in single-select mode.
                return interactivityService.isSelectionModeInverted()
                    || !settings.selection.singleSelect
                    || event.ctrlKey;
            };
            SlicerWebBehavior.prototype.createWebBehavior = function (options) {
                var behavior;
                var orientation = options.orientation;
                switch (orientation) {
                    case 1 /* Horizontal */:
                        behavior = new visuals.HorizontalSlicerWebBehavior();
                        break;
                    case 0 /* Vertical */:
                    default:
                        behavior = new visuals.VerticalSlicerWebBehavior();
                        break;
                }
                return behavior;
            };
            return SlicerWebBehavior;
        }());
        visuals.SlicerWebBehavior = SlicerWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LegendBehavior = (function () {
            function LegendBehavior() {
            }
            LegendBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var legendItems = options.legendItems;
                this.legendIcons = options.legendIcons;
                var clearCatcher = options.clearCatcher;
                visuals.InteractivityUtils.registerStandardSelectionHandler(legendItems, selectionHandler);
                clearCatcher.on('click', function () {
                    selectionHandler.handleClearSelection();
                });
            };
            LegendBehavior.prototype.renderSelection = function (hasSelection) {
                if (hasSelection) {
                    this.legendIcons.style({
                        'fill': function (d) {
                            if (!d.selected)
                                return LegendBehavior.dimmedLegendColor;
                            else
                                return d.color;
                        }
                    });
                }
                else {
                    this.legendIcons.style({
                        'fill': function (d) {
                            return d.color;
                        }
                    });
                }
            };
            LegendBehavior.dimmedLegendColor = '#A6A6A6';
            return LegendBehavior;
        }());
        visuals.LegendBehavior = LegendBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TreemapWebBehavior = (function () {
            function TreemapWebBehavior() {
            }
            TreemapWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var shapes = this.shapes = options.shapes;
                var highlightShapes = this.highlightShapes = options.highlightShapes;
                var majorLabels = options.majorLabels;
                var minorLabels = options.minorLabels;
                this.hasHighlights = options.hasHighlights;
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(shapes, selectionHandler);
                visuals.InteractivityUtils.registerStandardInteractivityHandlers(highlightShapes, selectionHandler);
                if (majorLabels) {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(majorLabels, selectionHandler);
                }
                if (minorLabels) {
                    visuals.InteractivityUtils.registerStandardInteractivityHandlers(minorLabels, selectionHandler);
                }
            };
            TreemapWebBehavior.prototype.renderSelection = function (hasSelection) {
                var hasHighlights = this.hasHighlights;
                this.shapes
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, /* isHighlightRect */ false); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, /* isHighlightRect */ false); });
                this.highlightShapes
                    .style("fill", function (d) { return visuals.Treemap.getFill(d, /* isHighlightRect */ true); })
                    .style("fill-opacity", function (d) { return visuals.Treemap.getFillOpacity(d, hasSelection, !d.selected && hasHighlights, /* isHighlightRect */ true); });
            };
            return TreemapWebBehavior;
        }());
        visuals.TreemapWebBehavior = TreemapWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var WaterfallChartWebBehavior = (function () {
            function WaterfallChartWebBehavior() {
            }
            WaterfallChartWebBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var bars = this.bars = options.bars;
                bars.on('click', function (d) {
                    if (!d.isTotal) {
                        selectionHandler.handleSelection(d, d3.event.ctrlKey);
                    }
                });
                bars.on('contextmenu', function (d) {
                    if (d3.event.ctrlKey)
                        return;
                    d3.event.preventDefault();
                    if (!d.isTotal) {
                        var position = visuals.InteractivityUtils.getPositionOfLastInputEvent();
                        selectionHandler.handleContextMenu(d, position);
                    }
                });
            };
            WaterfallChartWebBehavior.prototype.renderSelection = function (hasSelection) {
                this.bars.style("fill-opacity", function (d) { return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, false); });
            };
            return WaterfallChartWebBehavior;
        }());
        visuals.WaterfallChartWebBehavior = WaterfallChartWebBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var LabelsBehavior = (function () {
            function LabelsBehavior() {
            }
            LabelsBehavior.prototype.bindEvents = function (options, selectionHandler) {
                this.labelItems = options.labelItems;
                visuals.InteractivityUtils.registerStandardSelectionHandler(this.labelItems, selectionHandler);
            };
            LabelsBehavior.prototype.renderSelection = function (hasSelection) {
                if (hasSelection) {
                    this.labelItems.style({
                        'opacity': function (d) {
                            if (!d.selected)
                                return LabelsBehavior.DimmedLabelOpacity;
                            else
                                return LabelsBehavior.DefaultLabelOpacity;
                        }
                    });
                }
                else {
                    this.labelItems.style({
                        'opacity': LabelsBehavior.DefaultLabelOpacity,
                    });
                }
            };
            LabelsBehavior.DefaultLabelOpacity = 1;
            LabelsBehavior.DimmedLabelOpacity = 0.6;
            return LabelsBehavior;
        }());
        visuals.LabelsBehavior = LabelsBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CartesianChartBehavior = (function () {
            function CartesianChartBehavior(behaviors) {
                this.behaviors = behaviors;
            }
            CartesianChartBehavior.prototype.bindEvents = function (options, selectionHandler) {
                var behaviors = this.behaviors;
                for (var i = 0, ilen = behaviors.length; i < ilen; i++) {
                    behaviors[i].bindEvents(options.layerOptions[i], selectionHandler);
                }
                options.clearCatcher.on('click', function () {
                    selectionHandler.handleClearSelection();
                });
            };
            CartesianChartBehavior.prototype.renderSelection = function (hasSelection) {
                for (var _i = 0, _a = this.behaviors; _i < _a.length; _i++) {
                    var behavior = _a[_i];
                    behavior.renderSelection(hasSelection);
                }
            };
            return CartesianChartBehavior;
        }());
        visuals.CartesianChartBehavior = CartesianChartBehavior;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Default ranges are for when we have a field chosen for the axis,
         * but no values are returned by the query.
         */
        visuals.emptyDomain = [0, 0];
        var AxisHelper;
        (function (AxisHelper) {
            var XLabelMaxAllowedOverflow = 35;
            var TextHeightConstant = 10;
            var MinTickCount = 2;
            var DefaultBestTickCount = 3;
            var LeftPadding = 10;
            var ScalarTickLabelPadding = 3;
            function getRecommendedNumberOfTicksForXAxis(availableWidth) {
                if (availableWidth < 300)
                    return 3;
                if (availableWidth < 500)
                    return 5;
                return 8;
            }
            AxisHelper.getRecommendedNumberOfTicksForXAxis = getRecommendedNumberOfTicksForXAxis;
            function getRecommendedNumberOfTicksForYAxis(availableWidth) {
                if (availableWidth < 150)
                    return 3;
                if (availableWidth < 300)
                    return 5;
                return 8;
            }
            AxisHelper.getRecommendedNumberOfTicksForYAxis = getRecommendedNumberOfTicksForYAxis;
            /**
             * Get the best number of ticks based on minimum value, maximum value,
             * measure metadata and max tick count.
             *
             * @param min The minimum of the data domain.
             * @param max The maximum of the data domain.
             * @param valuesMetadata The measure metadata array.
             * @param maxTickCount The max count of intervals.
             * @param isDateTime - flag to show single tick when min is equal to max.
             */
            function getBestNumberOfTicks(min, max, valuesMetadata, maxTickCount, isDateTime) {
                debug.assert(maxTickCount >= 0, "maxTickCount must be greater or equal to zero");
                if (isNaN(min) || isNaN(max))
                    return DefaultBestTickCount;
                debug.assert(min <= max, "min value needs to be less or equal to max value");
                if (maxTickCount <= 1 || (max <= 1 && min >= -1))
                    return maxTickCount;
                if (min === max) {
                    // datetime needs to only show one tick value in this case so formatting works correctly
                    if (!!isDateTime)
                        return 1;
                    return DefaultBestTickCount;
                }
                if (hasNonIntegerData(valuesMetadata))
                    return maxTickCount;
                // e.g. 5 - 2 + 1 = 4, => [2,3,4,5]
                return Math.min(max - min + 1, maxTickCount);
            }
            AxisHelper.getBestNumberOfTicks = getBestNumberOfTicks;
            function hasNonIntegerData(valuesMetadata) {
                for (var i = 0, len = valuesMetadata.length; i < len; i++) {
                    var currentMetadata = valuesMetadata[i];
                    if (currentMetadata && currentMetadata.type && !currentMetadata.type.integer) {
                        return true;
                    }
                }
                return false;
            }
            AxisHelper.hasNonIntegerData = hasNonIntegerData;
            function getRecommendedTickValues(maxTicks, scale, axisType, isScalar, minTickInterval) {
                if (!isScalar || isOrdinalScale(scale)) {
                    return getRecommendedTickValuesForAnOrdinalRange(maxTicks, scale.domain());
                }
                else if (isDateTime(axisType)) {
                    return getRecommendedTickValuesForADateTimeRange(maxTicks, scale.domain());
                }
                return getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minTickInterval);
            }
            AxisHelper.getRecommendedTickValues = getRecommendedTickValues;
            function getRecommendedTickValuesForAnOrdinalRange(maxTicks, labels) {
                var tickLabels = [];
                // return no ticks in this case
                if (maxTicks <= 0)
                    return tickLabels;
                var len = labels.length;
                if (maxTicks > len)
                    return labels;
                for (var i = 0, step = Math.ceil(len / maxTicks); i < len; i += step) {
                    tickLabels.push(labels[i]);
                }
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForAnOrdinalRange = getRecommendedTickValuesForAnOrdinalRange;
            function getRecommendedTickValuesForAQuantitativeRange(maxTicks, scale, minInterval) {
                var tickLabels = [];
                //if maxticks is zero return none
                if (maxTicks === 0)
                    return tickLabels;
                var quantitiveScale = scale;
                if (quantitiveScale.ticks) {
                    tickLabels = quantitiveScale.ticks(maxTicks);
                    if (tickLabels.length > maxTicks && maxTicks > 1)
                        tickLabels = quantitiveScale.ticks(maxTicks - 1);
                    if (tickLabels.length < MinTickCount) {
                        tickLabels = quantitiveScale.ticks(maxTicks + 1);
                    }
                    tickLabels = createTrueZeroTickLabel(tickLabels);
                    if (minInterval && tickLabels.length > 1) {
                        var tickInterval = tickLabels[1] - tickLabels[0];
                        while (tickInterval > 0 && tickInterval < minInterval) {
                            for (var i = 1; i < tickLabels.length; i++) {
                                tickLabels.splice(i, 1);
                            }
                            tickInterval = tickInterval * 2;
                        }
                        // keep at least two labels - the loop above may trim all but one if we have odd # of tick labels and dynamic range < minInterval
                        if (tickLabels.length === 1) {
                            tickLabels.push(tickLabels[0] + minInterval);
                        }
                    }
                    return tickLabels;
                }
                debug.assertFail('must pass a quantitative scale to this method');
                return tickLabels;
            }
            AxisHelper.getRecommendedTickValuesForAQuantitativeRange = getRecommendedTickValuesForAQuantitativeRange;
            /**
             * Round out very small zero tick values (e.g. -1e-33 becomes 0).
             *
             * @param ticks Array of numbers (from d3.scale.ticks([maxTicks])).
             * @param epsilon Max ratio of calculated tick interval which we will recognize as zero.
             *
             * e.g.
             *     ticks = [-2, -1, 1e-10, 3, 4]; epsilon = 1e-5;
             *     closeZero = 1e-5 * | 2 - 1 | = 1e-5
             *     // Tick values <= 1e-5 replaced with 0
             *     return [-2, -1, 0, 3, 4];
             */
            function createTrueZeroTickLabel(ticks, epsilon) {
                if (epsilon === void 0) { epsilon = 1e-5; }
                if (!ticks || ticks.length < 2)
                    return ticks;
                var closeZero = epsilon * Math.abs(ticks[1] - ticks[0]);
                return ticks.map(function (tick) { return Math.abs(tick) <= closeZero ? 0 : tick; });
            }
            function getRecommendedTickValuesForADateTimeRange(maxTicks, dataDomain) {
                var tickLabels = [];
                if (dataDomain[0] === 0 && dataDomain[1] === 0)
                    return [];
                var dateTimeTickLabels = powerbi.DateTimeSequence.calculate(new Date(dataDomain[0]), new Date(dataDomain[1]), maxTicks).sequence;
                tickLabels = dateTimeTickLabels.map(function (d) { return d.getTime(); });
                tickLabels = ensureValuesInRange(tickLabels, dataDomain[0], dataDomain[1]);
                return tickLabels;
            }
            function normalizeLinearDomain(domain) {
                if (isNaN(domain.min) || isNaN(domain.max)) {
                    domain.min = visuals.emptyDomain[0];
                    domain.max = visuals.emptyDomain[1];
                }
                else if (domain.min === domain.max) {
                    // d3 linear scale will give zero tickValues if max === min, so extend a little
                    domain.min = domain.min < 0 ? domain.min * 1.2 : domain.min * 0.8;
                    domain.max = domain.max < 0 ? domain.max * 0.8 : domain.max * 1.2;
                }
                else {
                    // Check that min is very small and is a negligable portion of the whole domain.
                    // (fix floating pt precision bugs)
                    // sometimes highlight value math causes small negative numbers which makes the axis add
                    // a large tick interval instead of just rendering at zero.
                    if (Math.abs(domain.min) < 0.0001 && domain.min / (domain.max - domain.min) < 0.0001) {
                        domain.min = 0;
                    }
                }
                return domain;
            }
            function getMargin(availableWidth, availableHeight, xMargin, yMargin) {
                if (getRecommendedNumberOfTicksForXAxis(availableWidth - xMargin) === 0
                    || getRecommendedNumberOfTicksForYAxis(availableHeight - yMargin) === 0) {
                    return {
                        top: 0,
                        right: xMargin,
                        bottom: yMargin,
                        left: 0
                    };
                }
                return {
                    top: 20,
                    right: 30,
                    bottom: 40,
                    left: 30
                };
            }
            AxisHelper.getMargin = getMargin;
            // TODO: Put the parameters into one object
            function getTickLabelMargins(viewport, yMarginLimit, textWidthMeasurer, textHeightMeasurer, axes, bottomMarginLimit, properties, scrollbarVisible, showOnRight, renderXAxis, renderY1Axis, renderY2Axis) {
                debug.assertValue(axes, 'axes');
                var xAxisProperties = axes.x;
                var y1AxisProperties = axes.y1;
                var y2AxisProperties = axes.y2;
                debug.assertValue(viewport, 'viewport');
                debug.assertValue(textWidthMeasurer, 'textWidthMeasurer');
                debug.assertValue(textHeightMeasurer, 'textHeightMeasurer');
                debug.assertValue(xAxisProperties, 'xAxis');
                debug.assertValue(y1AxisProperties, 'yAxis');
                var xLabels = xAxisProperties.values;
                var y1Labels = y1AxisProperties.values;
                var leftOverflow = 0;
                var rightOverflow = 0;
                var maxWidthY1 = 0;
                var maxWidthY2 = 0;
                var xMax = 0; // bottom margin
                var ordinalLabelOffset = xAxisProperties.categoryThickness ? xAxisProperties.categoryThickness / 2 : 0;
                var scaleIsOrdinal = isOrdinalScale(xAxisProperties.scale);
                var xLabelOuterPadding = 0;
                if (xAxisProperties.outerPadding !== undefined) {
                    xLabelOuterPadding = xAxisProperties.outerPadding;
                }
                else if (xAxisProperties.xLabelMaxWidth !== undefined) {
                    xLabelOuterPadding = Math.max(0, (viewport.width - xAxisProperties.xLabelMaxWidth * xLabels.length) / 2);
                }
                if (getRecommendedNumberOfTicksForXAxis(viewport.width) !== 0
                    || getRecommendedNumberOfTicksForYAxis(viewport.height) !== 0) {
                    var rotation = void 0;
                    if (scrollbarVisible)
                        rotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    else
                        rotation = LabelLayoutStrategy.DefaultRotation;
                    if (renderY1Axis) {
                        for (var i = 0, len = y1Labels.length; i < len; i++) {
                            properties.text = y1Labels[i];
                            maxWidthY1 = Math.max(maxWidthY1, textWidthMeasurer(properties));
                        }
                    }
                    if (y2AxisProperties && renderY2Axis) {
                        var y2Labels = y2AxisProperties.values;
                        for (var i = 0, len = y2Labels.length; i < len; i++) {
                            properties.text = y2Labels[i];
                            maxWidthY2 = Math.max(maxWidthY2, textWidthMeasurer(properties));
                        }
                    }
                    var textHeight = textHeightMeasurer(properties);
                    var maxNumLines = Math.floor(bottomMarginLimit / textHeight);
                    var xScale = xAxisProperties.scale;
                    var xDomain = xScale.domain();
                    if (renderXAxis && xLabels.length > 0) {
                        for (var i = 0, len = xLabels.length; i < len; i++) {
                            // find the max height of the x-labels, perhaps rotated or wrapped
                            var height = void 0;
                            properties.text = xLabels[i];
                            var width = textWidthMeasurer(properties);
                            if (xAxisProperties.willLabelsWordBreak) {
                                // Split label and count rows
                                var wordBreaks = jsCommon.WordBreaker.splitByWidth(properties.text, properties, textWidthMeasurer, xAxisProperties.xLabelMaxWidth, maxNumLines);
                                height = wordBreaks.length * textHeight;
                                // word wrapping will truncate at xLabelMaxWidth
                                width = xAxisProperties.xLabelMaxWidth;
                            }
                            else if (!xAxisProperties.willLabelsFit && scaleIsOrdinal) {
                                height = width * rotation.sine;
                                width = width * rotation.cosine;
                            }
                            else {
                                height = TextHeightConstant;
                            }
                            // calculate left and right overflow due to wide X labels
                            // (Note: no right overflow when rotated)
                            if (i === 0) {
                                if (scaleIsOrdinal) {
                                    if (!xAxisProperties.willLabelsFit /*rotated text*/)
                                        leftOverflow = width - ordinalLabelOffset - xLabelOuterPadding;
                                    else
                                        leftOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
                                    leftOverflow = Math.max(leftOverflow, 0);
                                }
                                else if (xDomain.length > 1) {
                                    // Scalar - do some math
                                    var xPos = xScale(xDomain[0]);
                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
                                    leftOverflow = (width / 2) - xPos;
                                    leftOverflow = Math.max(leftOverflow, 0);
                                }
                            }
                            else if (i === len - 1) {
                                if (scaleIsOrdinal) {
                                    // if we are rotating text (!willLabelsFit) there won't be any right overflow
                                    if (xAxisProperties.willLabelsFit || xAxisProperties.willLabelsWordBreak) {
                                        // assume this label is placed near the edge
                                        rightOverflow = (width / 2) - ordinalLabelOffset - xLabelOuterPadding;
                                        rightOverflow = Math.max(rightOverflow, 0);
                                    }
                                }
                                else if (xDomain.length > 1) {
                                    // Scalar - do some math
                                    var xPos = xScale(xDomain[1]);
                                    // xPos already incorporates xLabelOuterPadding, don't subtract it twice
                                    rightOverflow = (width / 2) - (viewport.width - xPos);
                                    rightOverflow = Math.max(rightOverflow, 0);
                                }
                            }
                            xMax = Math.max(xMax, height);
                        }
                        // trim any actual overflow to the limit
                        leftOverflow = Math.min(leftOverflow, XLabelMaxAllowedOverflow);
                        rightOverflow = Math.min(rightOverflow, XLabelMaxAllowedOverflow);
                    }
                }
                var rightMargin = 0, leftMargin = 0, bottomMargin = Math.min(Math.ceil(xMax), bottomMarginLimit);
                if (showOnRight) {
                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY2), yMarginLimit);
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY1), yMarginLimit);
                }
                else {
                    leftMargin = Math.min(Math.max(leftOverflow, maxWidthY1), yMarginLimit);
                    rightMargin = Math.min(Math.max(rightOverflow, maxWidthY2), yMarginLimit);
                }
                return {
                    xMax: Math.ceil(bottomMargin),
                    yLeft: Math.ceil(leftMargin),
                    yRight: Math.ceil(rightMargin),
                };
            }
            AxisHelper.getTickLabelMargins = getTickLabelMargins;
            function columnDataTypeHasValue(dataType) {
                return dataType && (dataType.bool || dataType.numeric || dataType.text || dataType.dateTime);
            }
            AxisHelper.columnDataTypeHasValue = columnDataTypeHasValue;
            function createOrdinalType() {
                return powerbi.ValueType.fromDescriptor({ text: true });
            }
            AxisHelper.createOrdinalType = createOrdinalType;
            function isOrdinal(type) {
                return !!(type && (type.text || type.bool));
            }
            AxisHelper.isOrdinal = isOrdinal;
            function isOrdinalScale(scale) {
                return typeof scale.invert === 'undefined';
            }
            AxisHelper.isOrdinalScale = isOrdinalScale;
            function isDateTime(type) {
                return !!(type && type.dateTime);
            }
            AxisHelper.isDateTime = isDateTime;
            function invertScale(scale, x) {
                if (isOrdinalScale(scale)) {
                    return invertOrdinalScale(scale, x);
                }
                return scale.invert(x);
            }
            AxisHelper.invertScale = invertScale;
            function extent(scale) {
                if (isOrdinalScale(scale)) {
                    return scale.rangeExtent();
                }
                return scale.range();
            }
            AxisHelper.extent = extent;
            function invertOrdinalScale(scale, x) {
                var leftEdges = scale.range();
                if (leftEdges.length < 2)
                    return 0;
                var width = scale.rangeBand();
                var halfInnerPadding = (leftEdges[1] - leftEdges[0] - width) / 2;
                var j;
                for (j = 0; x > (leftEdges[j] + width + halfInnerPadding) && j < (leftEdges.length - 1); j++)
                    ;
                return scale.domain()[j];
            }
            AxisHelper.invertOrdinalScale = invertOrdinalScale;
            function findClosestXAxisIndex(categoryValue, categoryAxisValues) {
                var closestValueIndex = -1;
                var minDistance = Number.MAX_VALUE;
                for (var i in categoryAxisValues) {
                    var distance = Math.abs(categoryValue - categoryAxisValues[i].categoryValue);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestValueIndex = parseInt(i, 10);
                    }
                }
                return closestValueIndex;
            }
            AxisHelper.findClosestXAxisIndex = findClosestXAxisIndex;
            function lookupOrdinalIndex(scale, pixelValue) {
                var closestValueIndex = -1;
                var minDistance = Number.MAX_VALUE;
                var domain = scale.domain();
                if (domain.length < 2)
                    return 0;
                var halfWidth = (scale(1) - scale(0)) / 2;
                for (var idx in domain) {
                    var leftEdgeInPixels = scale(idx);
                    var midPoint = leftEdgeInPixels + halfWidth;
                    var distance = Math.abs(pixelValue - midPoint);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestValueIndex = parseInt(idx, 10);
                    }
                }
                return closestValueIndex;
            }
            AxisHelper.lookupOrdinalIndex = lookupOrdinalIndex;
            /** scale(value1) - scale(value2) with zero checking and min(+/-1, result) */
            function diffScaled(scale, value1, value2) {
                debug.assertValue(scale, 'scale');
                var value = scale(value1) - scale(value2);
                if (value === 0)
                    return 0;
                if (value < 0)
                    return Math.min(value, -1);
                return Math.max(value, 1);
            }
            AxisHelper.diffScaled = diffScaled;
            function createDomain(data, axisType, isScalar, forcedScalarDomain, ensureDomain) {
                if (isScalar && !isOrdinal(axisType)) {
                    var userMin = void 0, userMax = void 0;
                    if (forcedScalarDomain && forcedScalarDomain.length === 2) {
                        userMin = forcedScalarDomain[0];
                        userMax = forcedScalarDomain[1];
                    }
                    return createScalarDomain(data, userMin, userMax, axisType, ensureDomain);
                }
                return createOrdinalDomain(data);
            }
            AxisHelper.createDomain = createDomain;
            function ensureValuesInRange(values, min, max) {
                debug.assert(min <= max, "min must be less or equal to max");
                var filteredValues = values.filter(function (v) { return v >= min && v <= max; });
                if (filteredValues.length < 2)
                    filteredValues = [min, max];
                return filteredValues;
            }
            AxisHelper.ensureValuesInRange = ensureValuesInRange;
            /**
             * Gets the ValueType of a category column, defaults to Text if the type is not present.
             */
            function getCategoryValueType(metadataColumn, isScalar) {
                if (metadataColumn && columnDataTypeHasValue(metadataColumn.type))
                    return metadataColumn.type;
                if (isScalar) {
                    return powerbi.ValueType.fromDescriptor({ numeric: true });
                }
                return powerbi.ValueType.fromDescriptor({ text: true });
            }
            AxisHelper.getCategoryValueType = getCategoryValueType;
            /**
             * Create a D3 axis including scale. Can be vertical or horizontal, and either datetime, numeric, or text.
             * @param options The properties used to create the axis.
             */
            function createAxis(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, formatString = options.formatString, outerPadding = options.outerPadding || 0, isCategoryAxis = !!options.isCategoryAxis, isScalar = !!options.isScalar, isVertical = !!options.isVertical, useTickIntervalForDisplayUnits = !!options.useTickIntervalForDisplayUnits, // DEPRECATE: same meaning as isScalar?
                getValueFn = options.getValueFn, categoryThickness = options.categoryThickness, axisDisplayUnits = options.axisDisplayUnits, axisPrecision = options.axisPrecision, is100Pct = !!options.is100Pct;
                var dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
                // Create the Scale
                var scaleResult = AxisHelper.createScale(options);
                var scale = scaleResult.scale;
                var bestTickCount = scaleResult.bestTickCount;
                var scaleDomain = scale.domain();
                var isLogScaleAllowed = AxisHelper.isLogScalePossible(dataDomain, dataType);
                // fix categoryThickness if scalar and the domain was adjusted when making the scale "nice"
                if (categoryThickness && isScalar && dataDomain && dataDomain.length === 2) {
                    var oldSpan = dataDomain[1] - dataDomain[0];
                    var newSpan = scaleDomain[1] - scaleDomain[0];
                    if (oldSpan > 0 && newSpan > 0) {
                        categoryThickness = categoryThickness * oldSpan / newSpan;
                    }
                }
                // Prepare Tick Values for formatting
                var tickValues;
                if (isScalar && bestTickCount === 1) {
                    tickValues = [dataDomain[0]];
                }
                else {
                    var minTickInterval = isScalar ? getMinTickValueInterval(formatString, dataType, is100Pct) : undefined;
                    tickValues = getRecommendedTickValues(bestTickCount, scale, dataType, isScalar, minTickInterval);
                }
                if (options.scaleType && options.scaleType === visuals.axisScale.log && isLogScaleAllowed) {
                    tickValues = tickValues.filter(function (d) { return AxisHelper.powerOfTen(d); });
                }
                var formatter = createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision);
                // sets default orientation only, cartesianChart will fix y2 for comboChart
                // tickSize(pixelSpan) is used to create gridLines
                var axis = d3.svg.axis()
                    .scale(scale)
                    .tickSize(6, 0)
                    .orient(isVertical ? 'left' : 'bottom')
                    .ticks(bestTickCount)
                    .tickValues(tickValues);
                var formattedTickValues = [];
                if (metaDataColumn)
                    formattedTickValues = formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn);
                var xLabelMaxWidth;
                // Use category layout of labels if specified, otherwise use scalar layout of labels
                if (!isScalar && categoryThickness) {
                    xLabelMaxWidth = Math.max(1, categoryThickness - visuals.CartesianChart.TickLabelPadding * 2);
                }
                else {
                    // When there are 0 or 1 ticks, then xLabelMaxWidth = pixelSpan       
                    xLabelMaxWidth = tickValues.length > 1 ? getScalarLabelMaxWidth(scale, tickValues) : pixelSpan;
                    xLabelMaxWidth = xLabelMaxWidth - ScalarTickLabelPadding * 2;
                }
                return {
                    scale: scale,
                    axis: axis,
                    formatter: formatter,
                    values: formattedTickValues,
                    axisType: dataType,
                    axisLabel: null,
                    isCategoryAxis: isCategoryAxis,
                    xLabelMaxWidth: xLabelMaxWidth,
                    categoryThickness: categoryThickness,
                    outerPadding: outerPadding,
                    usingDefaultDomain: scaleResult.usingDefaultDomain,
                    isLogScaleAllowed: isLogScaleAllowed,
                    dataDomain: dataDomain,
                };
            }
            AxisHelper.createAxis = createAxis;
            function getScalarLabelMaxWidth(scale, tickValues) {
                debug.assertValue(scale, "scale");
                debug.assertNonEmpty(tickValues, "tickValues");
                // find the distance between two ticks. scalar ticks can be anywhere, such as:
                // |---50----------100--------|
                if (scale && !_.isEmpty(tickValues)) {
                    return Math.abs(scale(tickValues[1]) - scale(tickValues[0]));
                }
                return 1;
            }
            function createScale(options) {
                var pixelSpan = options.pixelSpan, dataDomain = options.dataDomain, metaDataColumn = options.metaDataColumn, outerPadding = options.outerPadding || 0, isScalar = !!options.isScalar, isVertical = !!options.isVertical, forcedTickCount = options.forcedTickCount, categoryThickness = options.categoryThickness, shouldClamp = !!options.shouldClamp;
                var dataType = AxisHelper.getCategoryValueType(metaDataColumn, isScalar);
                var maxTicks = isVertical ? getRecommendedNumberOfTicksForYAxis(pixelSpan) : getRecommendedNumberOfTicksForXAxis(pixelSpan);
                var scalarDomain = dataDomain ? dataDomain.slice() : null;
                var bestTickCount = maxTicks;
                var scale;
                var usingDefaultDomain = false;
                if (dataDomain == null || (dataDomain.length === 2 && dataDomain[0] == null && dataDomain[1] == null) || (dataDomain.length !== 2 && isScalar)) {
                    usingDefaultDomain = true;
                    if (dataType.dateTime || !isOrdinal(dataType))
                        dataDomain = visuals.emptyDomain;
                    else
                        dataDomain = [];
                    if (isOrdinal(dataType)) {
                        scale = createOrdinalScale(pixelSpan, dataDomain, categoryThickness ? outerPadding / categoryThickness : 0);
                    }
                    else {
                        scale = createNumericalScale(options.scaleType, pixelSpan, dataDomain, dataType, outerPadding, bestTickCount);
                    }
                }
                else {
                    if (isScalar && dataDomain.length > 0) {
                        bestTickCount = forcedTickCount !== undefined
                            ? (maxTicks !== 0 ? forcedTickCount : 0)
                            : AxisHelper.getBestNumberOfTicks(dataDomain[0], dataDomain[dataDomain.length - 1], [metaDataColumn], maxTicks, dataType.dateTime);
                        var normalizedRange = normalizeLinearDomain({ min: dataDomain[0], max: dataDomain[dataDomain.length - 1] });
                        scalarDomain = [normalizedRange.min, normalizedRange.max];
                    }
                    if (isScalar && dataType.numeric && !dataType.dateTime) {
                        scale = createNumericalScale(options.scaleType, pixelSpan, scalarDomain, dataType, outerPadding, bestTickCount, shouldClamp);
                    }
                    else if (isScalar && dataType.dateTime) {
                        // Use of a linear scale, instead of a D3.time.scale, is intentional since we want
                        // to control the formatting of the time values, since d3's implementation isn't
                        // in accordance to our design.
                        //     scalarDomain: should already be in long-int time (via category.values[0].getTime())
                        scale = createLinearScale(pixelSpan, scalarDomain, outerPadding, null, shouldClamp); // DO NOT PASS TICKCOUNT
                    }
                    else if (dataType.text || dataType.dateTime || dataType.numeric || dataType.bool) {
                        scale = createOrdinalScale(pixelSpan, scalarDomain, categoryThickness ? outerPadding / categoryThickness : 0);
                        bestTickCount = maxTicks === 0 ? 0
                            : Math.min(scalarDomain.length, (pixelSpan - outerPadding * 2) / visuals.CartesianChart.MinOrdinalRectThickness);
                    }
                    else {
                        debug.assertFail('unsupported dataType, something other than text or numeric');
                    }
                }
                // vertical ordinal axis (e.g. categorical bar chart) does not need to reverse
                if (isVertical && isScalar) {
                    scale.range(scale.range().reverse());
                }
                visuals.ColumnUtil.normalizeInfinityInScale(scale);
                return {
                    scale: scale,
                    bestTickCount: bestTickCount,
                    usingDefaultDomain: usingDefaultDomain,
                };
            }
            AxisHelper.createScale = createScale;
            function createFormatter(scaleDomain, dataDomain, dataType, isScalar, formatString, bestTickCount, tickValues, getValueFn, useTickIntervalForDisplayUnits, axisDisplayUnits, axisPrecision) {
                if (useTickIntervalForDisplayUnits === void 0) { useTickIntervalForDisplayUnits = false; }
                var formatter;
                if (dataType.dateTime) {
                    if (isScalar) {
                        var value = new Date(scaleDomain[0]);
                        var value2 = new Date(scaleDomain[1]);
                        // datetime with only one value needs to pass the same value
                        // (from the original dataDomain value, not the adjusted scaleDomain)
                        // so formatting works correctly.
                        if (bestTickCount === 1)
                            value = value2 = new Date(dataDomain[0]);
                        // this will ignore the formatString and create one based on the smallest non-zero portion of the values supplied.
                        formatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: value,
                            value2: value2,
                            tickCount: bestTickCount,
                        });
                    }
                    else {
                        // Use the model formatString for ordinal datetime
                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                }
                else {
                    if (getValueFn == null && !isScalar) {
                        debug.assertFail('getValueFn must be supplied for ordinal tickValues');
                    }
                    if (useTickIntervalForDisplayUnits && isScalar && tickValues.length > 1) {
                        var value1 = axisDisplayUnits ? axisDisplayUnits : tickValues[1] - tickValues[0];
                        var options = {
                            format: formatString,
                            value: value1,
                            value2: 0,
                            allowFormatBeautification: true,
                        };
                        if (axisPrecision)
                            options.precision = axisPrecision;
                        else
                            options.detectAxisPrecision = true;
                        formatter = visuals.valueFormatter.create(options);
                    }
                    else {
                        // do not use display units, just the basic value formatter
                        // datetime is handled above, so we are ordinal and either boolean, numeric, or text.
                        formatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                }
                return formatter;
            }
            AxisHelper.createFormatter = createFormatter;
            /**
             * Format the linear tick labels or the category labels.
             */
            function formatAxisTickValues(axis, tickValues, formatter, dataType, getValueFn) {
                var formattedTickValues = [];
                if (!getValueFn)
                    getValueFn = function (data) { return data; };
                if (formatter) {
                    axis.tickFormat(function (d) { return formatter.format(getValueFn(d, dataType)); });
                    formattedTickValues = tickValues.map(function (d) { return formatter.format(getValueFn(d, dataType)); });
                }
                else {
                    formattedTickValues = tickValues.map(function (d) { return getValueFn(d, dataType); });
                }
                return formattedTickValues;
            }
            function getMinTickValueInterval(formatString, columnType, is100Pct) {
                var isCustomFormat = formatString && !powerbi.NumberFormat.isStandardFormat(formatString);
                if (isCustomFormat) {
                    var precision = powerbi.NumberFormat.getCustomFormatMetadata(formatString, true /*calculatePrecision*/).precision;
                    if (formatString.indexOf('%') > -1)
                        precision += 2; //percent values are multiplied by 100 during formatting
                    return Math.pow(10, -precision);
                }
                else if (is100Pct)
                    return 0.01;
                else if (columnType.integer)
                    return 1;
                return 0;
            }
            AxisHelper.getMinTickValueInterval = getMinTickValueInterval;
            function createScalarDomain(data, userMin, userMax, axisType, ensureDomain) {
                debug.assertValue(data, 'data');
                if (data.length === 0) {
                    return null;
                }
                var defaultMinX = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.categoryValue; }); });
                var defaultMaxX = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.categoryValue; }); });
                return combineDomain([userMin, userMax], [defaultMinX, defaultMaxX], ensureDomain);
            }
            /**
             * Creates a [min,max] from your Cartiesian data values.
             *
             * @param data The series array of CartesianDataPoints.
             * @param includeZero Columns and bars includeZero, line and scatter do not.
             */
            function createValueDomain(data, includeZero) {
                debug.assertValue(data, 'data');
                if (data.length === 0)
                    return null;
                var minY = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.value; }); });
                var maxY = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.value; }); });
                if (includeZero)
                    return [Math.min(minY, 0), Math.max(maxY, 0)];
                return [minY, maxY];
            }
            AxisHelper.createValueDomain = createValueDomain;
            function createOrdinalDomain(data) {
                if (_.isEmpty(data))
                    return [];
                // each series shares the same categories for oridinal axes (even if a series has some nulls)
                var domain = [];
                var firstSeries = data[0];
                for (var _i = 0, _a = firstSeries.data; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    if (!dp.highlight)
                        domain.push(dp.categoryIndex);
                }
                return domain;
            }
            var LabelLayoutStrategy;
            (function (LabelLayoutStrategy) {
                function willLabelsFit(axisProperties, availableWidth, textMeasurer, properties) {
                    var labels = axisProperties.values;
                    if (labels.length === 0)
                        return false;
                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined
                        ? axisProperties.xLabelMaxWidth
                        : availableWidth / labels.length;
                    return !labels.some(function (d) {
                        properties.text = d;
                        return textMeasurer(properties) > labelMaxWidth;
                    });
                }
                LabelLayoutStrategy.willLabelsFit = willLabelsFit;
                function willLabelsWordBreak(axisProperties, margin, availableWidth, textWidthMeasurer, textHeightMeasurer, textTruncator, properties) {
                    var labels = axisProperties.values;
                    var labelMaxWidth = axisProperties.xLabelMaxWidth !== undefined
                        ? axisProperties.xLabelMaxWidth
                        : availableWidth / labels.length;
                    var maxRotatedLength = margin.bottom / LabelLayoutStrategy.DefaultRotation.sine;
                    var height = textHeightMeasurer(properties);
                    var maxNumLines = Math.max(1, Math.floor(margin.bottom / height)); // TODO: not taking axis label into account
                    if (labels.length === 0)
                        return false;
                    // If no break character and exceeds max width, word breaking will not work, return false
                    var mustRotate = labels.some(function (label) {
                        // Detect must rotate and return immediately
                        properties.text = label;
                        return !jsCommon.WordBreaker.hasBreakers(label) && textWidthMeasurer(properties) > labelMaxWidth;
                    });
                    if (mustRotate)
                        return false;
                    var moreWordBreakChars = labels.filter(function (label, index) {
                        // ...otherwise compare rotation versus word breaking
                        var allowedLengthProjectedOnXAxis = 
                        // Left margin is the width of Y axis.
                        margin.left
                            + axisProperties.outerPadding
                            + axisProperties.categoryThickness * (index + 0.5)
                            - LeftPadding;
                        var allowedLength = allowedLengthProjectedOnXAxis / LabelLayoutStrategy.DefaultRotation.cosine;
                        var rotatedLength = Math.min(allowedLength, maxRotatedLength);
                        // Which shows more characters? Rotated or maxNumLines truncated to labelMaxWidth?
                        var wordBreakChars = jsCommon.WordBreaker.splitByWidth(label, properties, textWidthMeasurer, labelMaxWidth, maxNumLines, textTruncator).join(' ');
                        properties.text = label;
                        var rotateChars = textTruncator(properties, rotatedLength);
                        // prefer word break (>=) as it takes up less plot area
                        return visuals.TextUtil.removeEllipses(wordBreakChars).length >= visuals.TextUtil.removeEllipses(rotateChars).length;
                    });
                    // prefer word break (>=) as it takes up less plot area
                    return moreWordBreakChars.length >= Math.floor(labels.length / 2);
                }
                LabelLayoutStrategy.willLabelsWordBreak = willLabelsWordBreak;
                LabelLayoutStrategy.DefaultRotation = {
                    sine: Math.sin(Math.PI * (35 / 180)),
                    cosine: Math.cos(Math.PI * (35 / 180)),
                    tangent: Math.tan(Math.PI * (35 / 180)),
                    transform: 'rotate(-35)',
                    dy: '-0.5em',
                };
                LabelLayoutStrategy.DefaultRotationWithScrollbar = {
                    sine: Math.sin(Math.PI * (90 / 180)),
                    cosine: Math.cos(Math.PI * (90 / 180)),
                    tangent: Math.tan(Math.PI * (90 / 180)),
                    transform: 'rotate(-90)',
                    dy: '-0.8em',
                };
                function rotate(labelSelection, maxBottomMargin, textTruncator, textProperties, needRotate, needEllipsis, axisProperties, margin, scrollbarVisible) {
                    var rotatedLength;
                    var defaultRotation;
                    if (scrollbarVisible)
                        defaultRotation = LabelLayoutStrategy.DefaultRotationWithScrollbar;
                    else
                        defaultRotation = LabelLayoutStrategy.DefaultRotation;
                    if (needRotate) {
                        rotatedLength = maxBottomMargin / defaultRotation.sine;
                    }
                    labelSelection.each(function () {
                        var axisLabel = d3.select(this);
                        var labelText = axisLabel.text();
                        textProperties.text = labelText;
                        if (needRotate) {
                            var textContentIndex = axisProperties.values.indexOf(this.textContent);
                            var allowedLengthProjectedOnXAxis = 
                            // Left margin is the width of Y axis.
                            margin.left
                                + axisProperties.outerPadding
                                + axisProperties.categoryThickness * (textContentIndex + 0.5);
                            // Subtracting the left padding space from the allowed length.
                            if (!scrollbarVisible)
                                allowedLengthProjectedOnXAxis -= LeftPadding;
                            // Truncate if scrollbar is visible or rotatedLength exceeds allowedLength
                            var allowedLength = allowedLengthProjectedOnXAxis / defaultRotation.cosine;
                            if (scrollbarVisible || needEllipsis || (allowedLength < rotatedLength)) {
                                labelText = textTruncator(textProperties, Math.min(allowedLength, rotatedLength));
                                axisLabel.text(labelText);
                            }
                            axisLabel.style('text-anchor', 'end')
                                .attr({
                                'dx': '-0.5em',
                                'dy': defaultRotation.dy,
                                'transform': defaultRotation.transform
                            });
                        }
                        else {
                            var newLabelText = textTruncator(textProperties, axisProperties.xLabelMaxWidth);
                            if (newLabelText !== labelText)
                                axisLabel.text(newLabelText);
                            axisLabel.style('text-anchor', 'middle')
                                .attr({
                                'dx': '0em',
                                'dy': '1em',
                                'transform': 'rotate(0)'
                            });
                        }
                    });
                }
                LabelLayoutStrategy.rotate = rotate;
                function wordBreak(text, axisProperties, maxHeight) {
                    var allowedLength = axisProperties.xLabelMaxWidth;
                    text.each(function () {
                        var node = d3.select(this);
                        // Reset style of text node
                        node
                            .style('text-anchor', 'middle')
                            .attr({
                            'dx': '0em',
                            'dy': '1em',
                            'transform': 'rotate(0)'
                        });
                        powerbi.TextMeasurementService.wordBreak(this, allowedLength, maxHeight);
                    });
                }
                LabelLayoutStrategy.wordBreak = wordBreak;
                function clip(text, availableWidth, svgEllipsis) {
                    if (text.size() === 0)
                        return;
                    text.each(function () {
                        var text = d3.select(this);
                        svgEllipsis(text[0][0], availableWidth);
                    });
                }
                LabelLayoutStrategy.clip = clip;
            })(LabelLayoutStrategy = AxisHelper.LabelLayoutStrategy || (AxisHelper.LabelLayoutStrategy = {}));
            function createOrdinalScale(pixelSpan, dataDomain, outerPaddingRatio) {
                if (outerPaddingRatio === void 0) { outerPaddingRatio = 0; }
                debug.assert(outerPaddingRatio >= 0 && outerPaddingRatio < 4, 'outerPaddingRatio should be a value between zero and four');
                var scale = d3.scale.ordinal()
                    .rangeBands([0, pixelSpan], visuals.CartesianChart.InnerPaddingRatio, outerPaddingRatio)
                    .domain(dataDomain);
                return scale;
            }
            AxisHelper.createOrdinalScale = createOrdinalScale;
            function isLogScalePossible(domain, axisType) {
                if (domain == null)
                    return false;
                if (isDateTime(axisType))
                    return false;
                return (domain[0] > 0 && domain[1] > 0) || (domain[0] < 0 && domain[1] < 0); //doman must exclude 0
            }
            AxisHelper.isLogScalePossible = isLogScalePossible;
            //this function can return different scales e.g. log, linear
            // NOTE: export only for testing, do not access directly
            function createNumericalScale(axisScaleType, pixelSpan, dataDomain, dataType, outerPadding, niceCount, shouldClamp) {
                if (outerPadding === void 0) { outerPadding = 0; }
                if (axisScaleType === visuals.axisScale.log && isLogScalePossible(dataDomain, dataType)) {
                    return createLogScale(pixelSpan, dataDomain, outerPadding, niceCount);
                }
                else {
                    return createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp);
                }
            }
            AxisHelper.createNumericalScale = createNumericalScale;
            function createLogScale(pixelSpan, dataDomain, outerPadding, niceCount) {
                if (outerPadding === void 0) { outerPadding = 0; }
                debug.assert(isLogScalePossible(dataDomain), "dataDomain cannot include 0");
                var scale = d3.scale.log()
                    .range([outerPadding, pixelSpan - outerPadding])
                    .domain([dataDomain[0], dataDomain[1]])
                    .clamp(true);
                if (niceCount) {
                    scale.nice(niceCount);
                }
                return scale;
            }
            // NOTE: export only for testing, do not access directly
            function createLinearScale(pixelSpan, dataDomain, outerPadding, niceCount, shouldClamp) {
                if (outerPadding === void 0) { outerPadding = 0; }
                var scale = d3.scale.linear()
                    .range([outerPadding, pixelSpan - outerPadding])
                    .domain([dataDomain[0], dataDomain[1]])
                    .clamp(shouldClamp);
                // .nice(undefined) still modifies the scale boundaries, and for datetime this messes things up.
                // we use millisecond ticks since epoch for datetime, so we don't want any "nice" with numbers like 17398203392.
                if (niceCount) {
                    scale.nice(niceCount);
                }
                return scale;
            }
            AxisHelper.createLinearScale = createLinearScale;
            function getRangeForColumn(sizeColumn) {
                var result = {};
                if (sizeColumn) {
                    result.min = sizeColumn.min == null
                        ? sizeColumn.minLocal == null ? d3.min(sizeColumn.values) : sizeColumn.minLocal
                        : sizeColumn.min;
                    result.max = sizeColumn.max == null
                        ? sizeColumn.maxLocal == null ? d3.max(sizeColumn.values) : sizeColumn.maxLocal
                        : sizeColumn.max;
                }
                return result;
            }
            AxisHelper.getRangeForColumn = getRangeForColumn;
            /**
             * Set customized domain, but don't change when nothing is set
             */
            function applyCustomizedDomain(customizedDomain, forcedDomain) {
                var domain = [undefined, undefined];
                if (forcedDomain && forcedDomain.length === 2) {
                    domain = [forcedDomain[0], forcedDomain[1]];
                }
                if (customizedDomain && customizedDomain.length === 2) {
                    if (customizedDomain[0] != null) {
                        domain[0] = customizedDomain[0];
                    }
                    if (customizedDomain[1] != null) {
                        domain[1] = customizedDomain[1];
                    }
                }
                if (domain[0] == null && domain[1] == null) {
                    return forcedDomain; //return untouched object
                }
                //do extra check to see if the user input was valid with the merged axis values.
                if (domain[0] != null && domain[1] != null) {
                    if (domain[0] > domain[1]) {
                        return forcedDomain;
                    }
                }
                return domain;
            }
            AxisHelper.applyCustomizedDomain = applyCustomizedDomain;
            /**
             * Combine the forced domain with the actual domain if one of the values was set.
             * The forcedDomain is in 1st priority. Extends the domain if the any reference point requires it.
             */
            function combineDomain(forcedDomain, domain, ensureDomain) {
                var combinedDomain = domain ? [domain[0], domain[1]] : [];
                if (ensureDomain) {
                    if (combinedDomain[0] == null || ensureDomain.min < combinedDomain[0])
                        combinedDomain[0] = ensureDomain.min;
                    if (combinedDomain[1] == null || ensureDomain.max > combinedDomain[1])
                        combinedDomain[1] = ensureDomain.max;
                }
                var domainBeforeForced = [combinedDomain[0], combinedDomain[1]];
                if (forcedDomain && forcedDomain.length === 2) {
                    if (forcedDomain[0] != null) {
                        combinedDomain[0] = forcedDomain[0];
                    }
                    if (forcedDomain[1] != null) {
                        combinedDomain[1] = forcedDomain[1];
                    }
                    if (combinedDomain[0] > combinedDomain[1]) {
                        combinedDomain = domainBeforeForced; //this is invalid, so take the original domain considering the values and the reference line
                    }
                }
                return combinedDomain;
            }
            AxisHelper.combineDomain = combineDomain;
            function createAxisLabel(properties, label, unitType, y2) {
                if (y2 === void 0) { y2 = false; }
                var propertyName = y2 ? 'secAxisStyle' : 'axisStyle';
                if (!properties || !properties[propertyName]) {
                    return label;
                }
                var modifiedLabel;
                if (properties[propertyName] === visuals.axisStyle.showBoth) {
                    modifiedLabel = label + ' (' + unitType + ')'; //todo: localize
                }
                else if (properties[propertyName] === visuals.axisStyle.showUnitOnly) {
                    modifiedLabel = unitType;
                }
                else {
                    modifiedLabel = label;
                }
                return modifiedLabel;
            }
            AxisHelper.createAxisLabel = createAxisLabel;
            function scaleShouldClamp(combinedDomain, domain) {
                if (!combinedDomain || !domain || combinedDomain.length < 2 || domain.length < 2)
                    return false;
                //when the start or end is different, clamp it
                return combinedDomain[0] !== domain[0] || combinedDomain[1] !== domain[1];
            }
            AxisHelper.scaleShouldClamp = scaleShouldClamp;
            function normalizeNonFiniteNumber(value) {
                if (isNaN(value))
                    return null;
                else if (value === Number.POSITIVE_INFINITY)
                    return Number.MAX_VALUE;
                else if (value === Number.NEGATIVE_INFINITY)
                    return -Number.MAX_VALUE;
                return value;
            }
            AxisHelper.normalizeNonFiniteNumber = normalizeNonFiniteNumber;
            function powerOfTen(d) {
                return d / Math.pow(10, Math.ceil(Math.log(d) / Math.LN10 - 1e-12)) === 1;
            }
            AxisHelper.powerOfTen = powerOfTen;
        })(AxisHelper = visuals.AxisHelper || (visuals.AxisHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ShapeFactory;
        (function (ShapeFactory) {
            var ShapeFactoryConsts;
            (function (ShapeFactoryConsts) {
                ShapeFactoryConsts.PaddingConstRatio = 0.01;
                ShapeFactoryConsts.TrianglePaddingConstRatio = 0.15;
                ShapeFactoryConsts.TriangleEndPaddingConstRatio = 0.85;
                ShapeFactoryConsts.ShapeConstRatio = 1.0 - (ShapeFactoryConsts.PaddingConstRatio * 2);
                ShapeFactoryConsts.SmallPaddingConstValue = 10;
                ShapeFactoryConsts.OvalRadiusConst = 2;
                ShapeFactoryConsts.OvalRadiusConstPadding = 0.2;
                ShapeFactoryConsts.ArrowLeftHeadPoint = { x: 0.05, y: 0.42 };
                ShapeFactoryConsts.ArrowMiddleHeadPoint = { x: 0.5, y: 0.016 };
                ShapeFactoryConsts.ArrowRightHeadPoint = { x: 0.95, y: 0.42 };
                ShapeFactoryConsts.ArrowRightMiddleHeadPoint = { x: 0.764, y: 0.42 };
                ShapeFactoryConsts.ArrowBottomRightPoint = { x: 0.764, y: 0.993 };
                ShapeFactoryConsts.ArrowBottomLeftPoint = { x: 0.246, y: 0.993 };
                ShapeFactoryConsts.ArrowLeftMiddleHeadPoint = { x: 0.246, y: 0.42 };
            })(ShapeFactoryConsts = ShapeFactory.ShapeFactoryConsts || (ShapeFactory.ShapeFactoryConsts = {}));
            /** this function creates a rectangle svg   */
            function createRectangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var x = (viewportWidth * ShapeFactoryConsts.PaddingConstRatio) + (data.lineWeight / 2);
                var y = (viewportHeight * ShapeFactoryConsts.PaddingConstRatio) + (data.lineWeight / 2);
                var width = (viewportWidth * ShapeFactoryConsts.ShapeConstRatio) - (data.lineWeight);
                var height = (viewportHeight * ShapeFactoryConsts.ShapeConstRatio) - (data.lineWeight);
                var attrs = { x: x, y: y, width: width, height: height, rx: data.roundEdge, ry: data.roundEdge };
                var scale = getScale(width, height, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'rect', attrs);
            }
            ShapeFactory.createRectangle = createRectangle;
            /** this function creates a oval svg   */
            function createOval(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var widthForCircle = (viewportWidth / ShapeFactoryConsts.OvalRadiusConst).toString();
                var heightForCircle = (viewportHeight / ShapeFactoryConsts.OvalRadiusConst).toString();
                var radiusXForCircle = ((viewportWidth / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding)) - data.lineWeight);
                var radiusYForCircle = ((viewportHeight / (ShapeFactoryConsts.OvalRadiusConst + ShapeFactoryConsts.OvalRadiusConstPadding)) - data.lineWeight);
                var attrs = { cx: widthForCircle, cy: heightForCircle, rx: radiusXForCircle, ry: radiusYForCircle };
                var scale = getScale(viewportWidth, viewportHeight, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'ellipse', attrs);
            }
            ShapeFactory.createOval = createOval;
            /** this function creates a line svg   */
            function createLine(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var x1, y1, x2, y2;
                var width = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - ShapeFactoryConsts.SmallPaddingConstValue;
                var height = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - ShapeFactoryConsts.SmallPaddingConstValue;
                var ratio;
                if (degrees <= 45) {
                    ratio = degrees / 90;
                    x1 = viewportWidth / 2 + width * ratio;
                    y1 = ShapeFactoryConsts.SmallPaddingConstValue;
                    x2 = viewportWidth / 2 - width * ratio;
                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
                }
                else if (degrees <= 135) {
                    ratio = (degrees - 45) / 90;
                    x1 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue);
                    y1 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio;
                    x2 = ShapeFactoryConsts.SmallPaddingConstValue;
                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - height * ratio;
                }
                else if (degrees <= 225) {
                    ratio = (degrees - 135) / 90;
                    x1 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - width * ratio;
                    y1 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
                    x2 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio;
                    y2 = ShapeFactoryConsts.SmallPaddingConstValue;
                }
                else if (degrees <= 315) {
                    ratio = (degrees - 225) / 90;
                    x1 = ShapeFactoryConsts.SmallPaddingConstValue;
                    y1 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) - height * ratio;
                    x2 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue);
                    y2 = ShapeFactoryConsts.SmallPaddingConstValue + height * ratio;
                }
                else if (degrees <= 360) {
                    ratio = (degrees - 315) / 90;
                    x1 = ShapeFactoryConsts.SmallPaddingConstValue + width * ratio;
                    y1 = ShapeFactoryConsts.SmallPaddingConstValue;
                    x2 = (viewportWidth - ShapeFactoryConsts.SmallPaddingConstValue) - width * ratio;
                    y2 = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue);
                }
                // create the inner path with the wanted shape
                selectedElement
                    .append('svg')
                    .attr({
                    width: viewportWidth,
                    height: viewportHeight
                })
                    .append('line')
                    .attr({
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                })
                    .style({
                    'vector-effect': 'non-scaling-stroke',
                    'stroke-width': data.lineWeight + 'px',
                    'stroke-opacity': (100 - data.lineTransparency) / 100,
                    'stroke': data.lineColor
                });
            }
            ShapeFactory.createLine = createLine;
            /** this function creates a arrow svg   */
            function createUpArrow(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var lineWeight = data.lineWeight;
                var viewportHeightWeight = viewportHeight - lineWeight;
                var viewportWidthWeight = viewportWidth - lineWeight;
                var arrowPoints = [
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftHeadPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowMiddleHeadPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowRightHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowRightHeadPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowRightMiddleHeadPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomRightPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomRightPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowBottomLeftPoint.y).toString() },
                    { 'x': (viewportWidthWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.x).toString(), 'y': (viewportHeightWeight * ShapeFactoryConsts.ArrowLeftMiddleHeadPoint.y).toString() },
                ];
                // create the inner path with the wanted shape
                createPathFromArray(data, arrowPoints, selectedElement, viewportHeight, viewportWidth, degrees);
            }
            ShapeFactory.createUpArrow = createUpArrow;
            /** this function creates a triangle svg   */
            function createTriangle(data, viewportHeight, viewportWidth, selectedElement, degrees) {
                var lineWeight = data.lineWeight;
                // remove the basic line weight
                if (lineWeight > 3) {
                    lineWeight -= 3;
                }
                var firstPointX = ((viewportWidth + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio);
                var firstPointY = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight) < 0 ?
                    (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) : (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight);
                var secondPointY = ((viewportHeight + lineWeight) * ShapeFactoryConsts.TrianglePaddingConstRatio);
                var thirdPointX = ((viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio) < 0 ?
                    (viewportWidth * ShapeFactoryConsts.TriangleEndPaddingConstRatio) : ((viewportWidth - lineWeight) * ShapeFactoryConsts.TriangleEndPaddingConstRatio);
                var thirdPointY = (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue - lineWeight) < 0 ?
                    (viewportHeight - ShapeFactoryConsts.SmallPaddingConstValue) : (viewportHeight - lineWeight - ShapeFactoryConsts.SmallPaddingConstValue);
                var secondPointX = ((firstPointX + thirdPointX) / 2);
                if (firstPointX < 10) {
                    firstPointX = ShapeFactoryConsts.SmallPaddingConstValue;
                }
                if (secondPointY < 10) {
                    secondPointY = ShapeFactoryConsts.SmallPaddingConstValue;
                }
                var trianglePoints = [
                    { 'x': firstPointX, 'y': firstPointY },
                    { 'x': secondPointX, 'y': secondPointY },
                    { 'x': thirdPointX, 'y': thirdPointY },
                ];
                createPathFromArray(data, trianglePoints, selectedElement, viewportHeight, viewportWidth, degrees);
            }
            ShapeFactory.createTriangle = createTriangle;
            /** this funcion adds a path to an svg element from an array of points (x,y) */
            function createPathFromArray(data, points, selectedElement, viewportHeight, viewportWidth, degrees) {
                var lineFunction = d3.svg.line()
                    .x(function (d) { return d.x; })
                    .y(function (d) { return d.y; })
                    .interpolate('linear');
                var attrs = { d: lineFunction(points) + ' Z' };
                var scale = getScale(viewportWidth, viewportHeight, degrees);
                createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, 'path', attrs);
            }
            function createShape(data, viewportHeight, viewportWidth, selectedElement, degrees, scale, shapeType, shapeAttrs) {
                selectedElement
                    .append('div')
                    .style({
                    'transform': 'rotate(' + degrees + 'deg) scale(' + scale + ')',
                    'transform-origin': 'center',
                    // for testing with phantomjs we need the webkit prefix
                    '-webkit-transform': 'rotate(' + degrees + 'deg) scale(' + scale + ')',
                    '-webkit-transform-origin': 'center',
                    'width': viewportWidth + 'px',
                    'height': viewportHeight + 'px'
                })
                    .append('svg')
                    .attr({
                    width: viewportWidth,
                    height: viewportHeight
                })
                    .append(shapeType)
                    .attr(shapeAttrs)
                    .style({
                    'vector-effect': 'non-scaling-stroke',
                    'stroke-width': data.lineWeight + 'px',
                    'stroke': data.lineColor,
                    'stroke-opacity': (100 - data.lineTransparency) / 100,
                    'fill': data.fillColor,
                    'fill-opacity': data.showFill === true ? ((100 - data.shapeTransparency) / 100) : 0
                });
            }
            // this function return the scale to add to the shape. 
            // it calculate it by the ratio of the original shape's diagonal and the shape's diagonal after rotate (the maximum diagonal that still fit to the container).
            // it calculate the shape's diagonal by the rotate angle.
            function getScale(width, height, degrees) {
                var originalWidth = width;
                var originalHeight = height;
                var offsetAngle = Math.atan2(height, width);
                var originalFactor = Math.sqrt(Math.pow(height, 2) + Math.pow(width, 2));
                var radians = (degrees / 180) * Math.PI;
                if (width >= height) {
                    if (degrees < 90) {
                        radians += offsetAngle;
                    }
                    else if (degrees < 180) {
                        radians -= offsetAngle;
                    }
                    else if (degrees < 270) {
                        radians += offsetAngle;
                    }
                    else {
                        radians -= offsetAngle;
                    }
                    return (originalHeight / Math.abs(Math.sin(radians))) / originalFactor;
                }
                else {
                    if (degrees < 90) {
                        radians -= offsetAngle;
                    }
                    else if (degrees < 180) {
                        radians += offsetAngle;
                    }
                    else if (degrees < 270) {
                        radians -= offsetAngle;
                    }
                    else {
                        radians += offsetAngle;
                    }
                    return (originalWidth / Math.abs(Math.cos(radians))) / originalFactor;
                }
            }
        })(ShapeFactory = visuals.ShapeFactory || (visuals.ShapeFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CartesianHelper;
        (function (CartesianHelper) {
            function getCategoryAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata)
                    return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var categoryAxisObject = objects['categoryAxis'];
                    if (categoryAxisObject) {
                        toReturn = {
                            show: categoryAxisObject['show'],
                            axisType: categoryAxisObject['axisType'],
                            axisScale: categoryAxisObject['axisScale'],
                            start: categoryAxisObject['start'],
                            end: categoryAxisObject['end'],
                            showAxisTitle: categoryAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : categoryAxisObject['showAxisTitle'],
                            axisStyle: categoryAxisObject['axisStyle'],
                            labelColor: categoryAxisObject['labelColor'],
                            labelDisplayUnits: categoryAxisObject['labelDisplayUnits'],
                            labelPrecision: categoryAxisObject['labelPrecision'],
                        };
                    }
                }
                return toReturn;
            }
            CartesianHelper.getCategoryAxisProperties = getCategoryAxisProperties;
            function getValueAxisProperties(dataViewMetadata, axisTitleOnByDefault) {
                var toReturn = {};
                if (!dataViewMetadata)
                    return toReturn;
                var objects = dataViewMetadata.objects;
                if (objects) {
                    var valueAxisObject = objects['valueAxis'];
                    if (valueAxisObject) {
                        toReturn = {
                            show: valueAxisObject['show'],
                            position: valueAxisObject['position'],
                            axisScale: valueAxisObject['axisScale'],
                            start: valueAxisObject['start'],
                            end: valueAxisObject['end'],
                            showAxisTitle: valueAxisObject['showAxisTitle'] == null ? axisTitleOnByDefault : valueAxisObject['showAxisTitle'],
                            axisStyle: valueAxisObject['axisStyle'],
                            labelColor: valueAxisObject['labelColor'],
                            labelDisplayUnits: valueAxisObject['labelDisplayUnits'],
                            labelPrecision: valueAxisObject['labelPrecision'],
                            secShow: valueAxisObject['secShow'],
                            secPosition: valueAxisObject['secPosition'],
                            secAxisScale: valueAxisObject['secAxisScale'],
                            secStart: valueAxisObject['secStart'],
                            secEnd: valueAxisObject['secEnd'],
                            secShowAxisTitle: valueAxisObject['secShowAxisTitle'],
                            secAxisStyle: valueAxisObject['secAxisStyle'],
                            secLabelColor: valueAxisObject['secLabelColor'],
                            secLabelDisplayUnits: valueAxisObject['secLabelDisplayUnits'],
                            secLabelPrecision: valueAxisObject['secLabelPrecision'],
                        };
                    }
                }
                return toReturn;
            }
            CartesianHelper.getValueAxisProperties = getValueAxisProperties;
            function isScalar(isScalar, xAxisCardProperties) {
                if (isScalar) {
                    //now check what the user wants
                    isScalar = xAxisCardProperties && xAxisCardProperties['axisType'] ? xAxisCardProperties['axisType'] === visuals.axisType.scalar : true;
                }
                return isScalar;
            }
            CartesianHelper.isScalar = isScalar;
            function getPrecision(precision) {
                if (precision != null) {
                    if (precision < 0) {
                        return 0;
                    }
                    return precision;
                }
                return null;
            }
            CartesianHelper.getPrecision = getPrecision;
            function lookupXValue(data, index, type, isScalar) {
                debug.assertValue(data, 'data');
                debug.assertValue(type, 'type');
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isScalar) {
                    if (isDateTime)
                        return new Date(index);
                    // index is the numeric value
                    return index;
                }
                if (type.text) {
                    debug.assert(index < data.categories.length, 'category index out of range');
                    return data.categories[index];
                }
                if (data && data.series && data.series.length > 0) {
                    var firstSeries = data.series[0];
                    if (firstSeries) {
                        var seriesValues = firstSeries.data;
                        if (seriesValues) {
                            if (data.hasHighlights)
                                index = index * 2;
                            var dataAtIndex = seriesValues[index];
                            if (dataAtIndex) {
                                if (isDateTime && dataAtIndex.categoryValue != null)
                                    return new Date(dataAtIndex.categoryValue);
                                return dataAtIndex.categoryValue;
                            }
                        }
                    }
                }
                return index;
            }
            CartesianHelper.lookupXValue = lookupXValue;
            function findMaxCategoryIndex(series) {
                if (_.isEmpty(series)) {
                    return 0;
                }
                var maxCategoryIndex = 0;
                for (var _i = 0, series_1 = series; _i < series_1.length; _i++) {
                    var singleSeries = series_1[_i];
                    if (!_.isEmpty(singleSeries.data)) {
                        var lastIndex = singleSeries.data[singleSeries.data.length - 1].categoryIndex;
                        maxCategoryIndex = Math.max(lastIndex, maxCategoryIndex);
                    }
                }
                return maxCategoryIndex;
            }
            CartesianHelper.findMaxCategoryIndex = findMaxCategoryIndex;
        })(CartesianHelper = visuals.CartesianHelper || (visuals.CartesianHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SQExprShortSerializer = powerbi.data.SQExprShortSerializer;
        var ColorHelper = (function () {
            function ColorHelper(colors, fillProp, defaultDataPointColor) {
                this.colors = colors;
                this.fillProp = fillProp;
                this.defaultDataPointColor = defaultDataPointColor;
                this.defaultColorScale = colors.getNewColorScale();
            }
            /**
             * Gets the color for the given series value.
             * If no explicit color or default color has been set then the color is
             * allocated from the color scale for this series.
             */
            ColorHelper.prototype.getColorForSeriesValue = function (objects, fieldIds, value) {
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
                    || this.defaultDataPointColor
                    || this.getColorScaleForSeries(fieldIds).getColor(value).value;
            };
            /**
             * Gets the color scale for the given series.
             */
            ColorHelper.prototype.getColorScaleForSeries = function (fieldIds) {
                return this.colors.getColorScaleByKey(SQExprShortSerializer.serializeArray(fieldIds || []));
            };
            /**
             * Gets the color for the given measure.
             */
            ColorHelper.prototype.getColorForMeasure = function (objects, measureKey) {
                // Note, this allocates the color from the scale regardless of if we use it or not which helps keep colors stable.
                var scaleColor = this.defaultColorScale.getColor(measureKey).value;
                return (this.fillProp && powerbi.DataViewObjects.getFillColor(objects, this.fillProp))
                    || this.defaultDataPointColor
                    || scaleColor;
            };
            ColorHelper.normalizeSelector = function (selector, isSingleSeries) {
                debug.assertAnyValue(selector, 'selector');
                // For dynamic series charts, colors are set per category.  So, exclude any measure (metadata repetition) from the selector.
                if (selector && (isSingleSeries || selector.data))
                    return { data: selector.data };
                return selector;
            };
            return ColorHelper;
        }());
        visuals.ColorHelper = ColorHelper;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var rectName = 'rect';
        var ColumnUtil;
        (function (ColumnUtil) {
            ColumnUtil.DimmedOpacity = 0.4;
            ColumnUtil.DefaultOpacity = 1.0;
            function applyUserMinMax(isScalar, dataView, xAxisCardProperties) {
                if (isScalar) {
                    var min = xAxisCardProperties['start'];
                    var max = xAxisCardProperties['end'];
                    return ColumnUtil.transformDomain(dataView, min, max);
                }
                return dataView;
            }
            ColumnUtil.applyUserMinMax = applyUserMinMax;
            function transformDomain(dataView, min, max) {
                if (!dataView.categories || !dataView.values || dataView.categories.length === 0 || dataView.values.length === 0)
                    return dataView; // no need to do something when there are no categories  
                if (typeof min !== "number" && typeof max !== "number")
                    return dataView; //user did not set min max, nothing to do here        
                var category = dataView.categories[0]; //at the moment we only support one category
                var categoryValues = category.values;
                var categoryObjects = category.objects;
                if (!categoryValues || !categoryObjects)
                    return dataView;
                var newcategoryValues = [];
                var newValues = [];
                var newObjects = [];
                //get new min max
                if (typeof min !== "number") {
                    min = categoryValues[0];
                }
                if (typeof max !== "number") {
                    max = categoryValues[categoryValues.length - 1];
                }
                //don't allow this
                if (min > max)
                    return dataView;
                //build measure array
                for (var j = 0, len = dataView.values.length; j < len; j++) {
                    newValues.push([]);
                }
                for (var t = 0, len = categoryValues.length; t < len; t++) {
                    if (categoryValues[t] >= min && categoryValues[t] <= max) {
                        newcategoryValues.push(categoryValues[t]);
                        if (categoryObjects) {
                            newObjects.push(categoryObjects[t]);
                        }
                        //on each measure set the new range
                        if (dataView.values) {
                            for (var k = 0; k < dataView.values.length; k++) {
                                newValues[k].push(dataView.values[k].values[t]);
                            }
                        }
                    }
                }
                //don't write directly to dataview
                var resultDataView = powerbi.Prototype.inherit(dataView);
                var resultDataViewValues = resultDataView.values = powerbi.Prototype.inherit(resultDataView.values);
                var resultDataViewCategories = resultDataView.categories = powerbi.Prototype.inherit(dataView.categories);
                var resultDataViewCategories0 = resultDataView.categories[0] = powerbi.Prototype.inherit(resultDataViewCategories[0]);
                resultDataViewCategories0.values = newcategoryValues;
                //only if we had objects, then you set the new objects
                if (resultDataViewCategories0.objects) {
                    resultDataViewCategories0.objects = newObjects;
                }
                //update measure array
                for (var t = 0, len = dataView.values.length; t < len; t++) {
                    var measureArray = resultDataViewValues[t] = powerbi.Prototype.inherit(resultDataViewValues[t]);
                    measureArray.values = newValues[t];
                }
                return resultDataView;
            }
            ColumnUtil.transformDomain = transformDomain;
            function getCategoryAxis(data, size, layout, isVertical, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                var categoryThickness = layout.categoryThickness;
                var isScalar = layout.isScalar;
                var outerPaddingRatio = layout.outerPaddingRatio;
                var domain = visuals.AxisHelper.createDomain(data.series, data.categoryMetadata ? data.categoryMetadata.type : powerbi.ValueType.fromDescriptor({ text: true }), isScalar, [forcedXMin, forcedXMax], ensureXDomain);
                var axisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: size,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, visuals.columnChartProps.general.formatString),
                    outerPadding: categoryThickness * outerPaddingRatio,
                    isCategoryAxis: true,
                    isScalar: isScalar,
                    isVertical: isVertical,
                    categoryThickness: categoryThickness,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function (index, type) { return visuals.CartesianHelper.lookupXValue(data, index, type, isScalar); },
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision
                });
                // intentionally updating the input layout by ref
                layout.categoryThickness = axisProperties.categoryThickness;
                return axisProperties;
            }
            ColumnUtil.getCategoryAxis = getCategoryAxis;
            function applyInteractivity(columns, onDragStart) {
                debug.assertValue(columns, 'columns');
                if (onDragStart) {
                    columns
                        .attr('draggable', 'true')
                        .on('dragstart', onDragStart);
                }
            }
            ColumnUtil.applyInteractivity = applyInteractivity;
            function getFillOpacity(selected, highlight, hasSelection, hasPartialHighlights) {
                if ((hasPartialHighlights && !highlight) || (hasSelection && !selected))
                    return ColumnUtil.DimmedOpacity;
                return ColumnUtil.DefaultOpacity;
            }
            ColumnUtil.getFillOpacity = getFillOpacity;
            function getClosestColumnIndex(coordinate, columnsCenters) {
                var currentIndex = 0;
                var distance = Number.MAX_VALUE;
                for (var i = 0, ilen = columnsCenters.length; i < ilen; i++) {
                    var currentDistance = Math.abs(coordinate - columnsCenters[i]);
                    if (currentDistance < distance) {
                        distance = currentDistance;
                        currentIndex = i;
                    }
                }
                return currentIndex;
            }
            ColumnUtil.getClosestColumnIndex = getClosestColumnIndex;
            function setChosenColumnOpacity(mainGraphicsContext, columnGroupSelector, selectedColumnIndex, lastColumnIndex) {
                var series = mainGraphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
                var lastColumnUndefined = typeof lastColumnIndex === 'undefined';
                // find all columns that do not belong to the selected column and set a dimmed opacity with a smooth animation to those columns
                series.selectAll(rectName + columnGroupSelector).filter(function (d) {
                    return (d.categoryIndex !== selectedColumnIndex) && (lastColumnUndefined || d.categoryIndex === lastColumnIndex);
                }).transition().style('fill-opacity', ColumnUtil.DimmedOpacity);
                // set the default opacity for the selected column
                series.selectAll(rectName + columnGroupSelector).filter(function (d) {
                    return d.categoryIndex === selectedColumnIndex;
                }).style('fill-opacity', ColumnUtil.DefaultOpacity);
            }
            ColumnUtil.setChosenColumnOpacity = setChosenColumnOpacity;
            function drawSeries(data, graphicsContext, axisOptions) {
                var colGroupSelection = graphicsContext.selectAll(visuals.ColumnChart.SeriesClasses.selector);
                var series = colGroupSelection.data(data.series, function (d) { return d.key; });
                series
                    .enter()
                    .append('g')
                    .classed(visuals.ColumnChart.SeriesClasses.class, true);
                series
                    .style({
                    fill: function (d) { return d.color; },
                });
                series
                    .exit()
                    .remove();
                return series;
            }
            ColumnUtil.drawSeries = drawSeries;
            function drawDefaultShapes(data, series, layout, itemCS, filterZeros, hasSelection) {
                // We filter out invisible (0, null, etc.) values from the dataset
                // based on whether animations are enabled or not, Dashboard and
                // Exploration mode, respectively.
                var dataSelector;
                if (filterZeros) {
                    dataSelector = function (d) {
                        var filteredData = _.filter(d.data, function (datapoint) { return !!datapoint.value; });
                        return filteredData;
                    };
                }
                else {
                    dataSelector = function (d) { return d.data; };
                }
                var shapeSelection = series.selectAll(itemCS.selector);
                var shapes = shapeSelection.data(dataSelector, function (d) { return d.key; });
                shapes.enter()
                    .append(rectName)
                    .attr("class", function (d) { return itemCS.class.concat(d.highlight ? " highlight" : ""); });
                shapes
                    .style("fill-opacity", function (d) { return ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, data.hasHighlights); })
                    .style("fill", function (d) { return d.color !== data.series[d.seriesIndex].color ? d.color : null; }) // PERF: Only set the fill color if it is different than series.
                    .attr(layout.shapeLayout);
                shapes
                    .exit()
                    .remove();
                return shapes;
            }
            ColumnUtil.drawDefaultShapes = drawDefaultShapes;
            function drawDefaultLabels(series, context, layout, viewPort, isAnimator, animationDuration) {
                if (isAnimator === void 0) { isAnimator = false; }
                if (series) {
                    var seriesData = series.data();
                    var dataPoints = [];
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        Array.prototype.push.apply(dataPoints, seriesData[i].data);
                    }
                    return visuals.dataLabelUtils.drawDefaultLabelsForDataPointChart(dataPoints, context, layout, viewPort, isAnimator, animationDuration);
                }
                else {
                    visuals.dataLabelUtils.cleanDataLabels(context);
                }
            }
            ColumnUtil.drawDefaultLabels = drawDefaultLabels;
            function normalizeInfinityInScale(scale) {
                // When large values (eg Number.MAX_VALUE) are involved, a call to scale.nice occasionally
                // results in infinite values being included in the domain. To correct for that, we need to
                // re-normalize the domain now to not include infinities.
                var scaledDomain = scale.domain();
                for (var i = 0, len = scaledDomain.length; i < len; ++i) {
                    if (scaledDomain[i] === Number.POSITIVE_INFINITY)
                        scaledDomain[i] = Number.MAX_VALUE;
                    else if (scaledDomain[i] === Number.NEGATIVE_INFINITY)
                        scaledDomain[i] = -Number.MAX_VALUE;
                }
                scale.domain(scaledDomain);
            }
            ColumnUtil.normalizeInfinityInScale = normalizeInfinityInScale;
            function calculatePosition(d, axisOptions) {
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var scaledY0 = yScale(0);
                var scaledX0 = xScale(0);
                switch (d.chartType) {
                    case visuals.ColumnChartType.stackedBar:
                    case visuals.ColumnChartType.hundredPercentStackedBar:
                        return scaledX0 + Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.valueAbsolute)) +
                            visuals.AxisHelper.diffScaled(xScale, d.position - d.valueAbsolute, 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case visuals.ColumnChartType.clusteredBar:
                        return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.max(0, d.value), 0) + visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case visuals.ColumnChartType.stackedColumn:
                    case visuals.ColumnChartType.hundredPercentStackedColumn:
                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, d.position, 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                    case visuals.ColumnChartType.clusteredColumn:
                        return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0) - visuals.dataLabelUtils.defaultColumnLabelMargin;
                }
            }
            ColumnUtil.calculatePosition = calculatePosition;
        })(ColumnUtil = visuals.ColumnUtil || (visuals.ColumnUtil = {}));
        var ClusteredUtil;
        (function (ClusteredUtil) {
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
                debug.assertValue(itemCS, 'itemCS');
                var cols = mainGraphicsContext.selectAll(itemCS.selector)
                    .data([]);
                cols.exit().remove();
            }
            ClusteredUtil.clearColumns = clearColumns;
        })(ClusteredUtil = visuals.ClusteredUtil || (visuals.ClusteredUtil = {}));
        var StackedUtil;
        (function (StackedUtil) {
            var PctRoundingError = 0.0001;
            function getSize(scale, size, zeroVal) {
                if (zeroVal === void 0) { zeroVal = 0; }
                return visuals.AxisHelper.diffScaled(scale, zeroVal, size);
            }
            StackedUtil.getSize = getSize;
            function calcValueDomain(data, is100pct) {
                var defaultNumberRange = {
                    min: 0,
                    max: 10
                };
                if (data.length === 0)
                    return defaultNumberRange;
                // Can't use AxisHelper because Stacked layout has a slightly different calc, (position - valueAbs)
                var min = d3.min(data, function (d) { return d3.min(d.data, function (e) { return e.position - e.valueAbsolute; }); });
                var max = d3.max(data, function (d) { return d3.max(d.data, function (e) { return e.position; }); });
                if (is100pct) {
                    min = powerbi.Double.roundToPrecision(min, PctRoundingError);
                    max = powerbi.Double.roundToPrecision(max, PctRoundingError);
                }
                return {
                    min: min,
                    max: max,
                };
            }
            StackedUtil.calcValueDomain = calcValueDomain;
            function getStackedMultiplier(dataView, rowIdx, seriesCount, categoryCount, converterStrategy) {
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(rowIdx, 'rowIdx');
                var pos = 0, neg = 0;
                for (var i = 0; i < seriesCount; i++) {
                    var value = converterStrategy.getValueBySeriesAndCategory(i, rowIdx);
                    value = visuals.AxisHelper.normalizeNonFiniteNumber(value);
                    if (value > 0)
                        pos += value;
                    else if (value < 0)
                        neg -= value;
                }
                var absTotal = pos + neg;
                return {
                    pos: pos ? (pos / absTotal) / pos : 1,
                    neg: neg ? (neg / absTotal) / neg : 1,
                };
            }
            StackedUtil.getStackedMultiplier = getStackedMultiplier;
            function clearColumns(mainGraphicsContext, itemCS) {
                debug.assertValue(mainGraphicsContext, 'mainGraphicsContext');
                debug.assertValue(itemCS, 'itemCS');
                var bars = mainGraphicsContext.selectAll(itemCS.selector)
                    .data([]);
                bars.exit().remove();
            }
            StackedUtil.clearColumns = clearColumns;
        })(StackedUtil = visuals.StackedUtil || (visuals.StackedUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var converterHelper;
        (function (converterHelper) {
            function categoryIsAlsoSeriesRole(dataView, seriesRoleName, categoryRoleName) {
                if (dataView.categories && dataView.categories.length > 0) {
                    // Need to pivot data if our category soure is a series role
                    var category = dataView.categories[0];
                    return category.source &&
                        DataRoleHelper.hasRole(category.source, seriesRoleName) &&
                        DataRoleHelper.hasRole(category.source, categoryRoleName);
                }
                return false;
            }
            converterHelper.categoryIsAlsoSeriesRole = categoryIsAlsoSeriesRole;
            function getPivotedCategories(dataView, formatStringProp) {
                if (dataView.categories && dataView.categories.length > 0) {
                    var category = dataView.categories[0];
                    var categoryValues = category.values;
                    return category.values.length > 0
                        ? {
                            categories: categoryValues,
                            categoryFormatter: visuals.valueFormatter.create({
                                format: visuals.valueFormatter.getFormatString(category.source, formatStringProp),
                                value: categoryValues[0],
                                value2: categoryValues[categoryValues.length - 1],
                                // Do not use display units such as K/M/bn etc. on the x-axis.
                                // PowerView does not use units either as large ranges will make the x-axis indecipherable.
                                displayUnitSystemType: powerbi.DisplayUnitSystemType.Verbose,
                            }),
                            categoryIdentities: category.identity,
                            categoryObjects: category.objects,
                        }
                        : {
                            categories: [],
                            categoryFormatter: { format: visuals.valueFormatter.format },
                        };
                }
                // For cases where the category source is just a series role, we are pivoting the data on the role which means we
                // will have no categories.
                return defaultCategories();
            }
            converterHelper.getPivotedCategories = getPivotedCategories;
            function getSeriesName(source) {
                debug.assertValue(source, 'source');
                return (source.groupName !== undefined)
                    ? source.groupName
                    : source.queryName;
            }
            converterHelper.getSeriesName = getSeriesName;
            function getFormattedLegendLabel(source, values, formatStringProp) {
                debug.assertValue(source, 'source');
                debug.assertValue(values, 'values');
                var sourceForFormat = source;
                var nameForFormat = source.displayName;
                if (source.groupName !== undefined) {
                    sourceForFormat = values.source;
                    nameForFormat = source.groupName;
                }
                return visuals.valueFormatter.format(nameForFormat, visuals.valueFormatter.getFormatString(sourceForFormat, formatStringProp));
            }
            converterHelper.getFormattedLegendLabel = getFormattedLegendLabel;
            function defaultCategories() {
                return {
                    categories: [null],
                    categoryFormatter: { format: visuals.valueFormatter.format },
                };
            }
            function createAxesLabels(categoryAxisProperties, valueAxisProperties, category, values) {
                var xAxisLabel = null;
                var yAxisLabel = null;
                if (categoryAxisProperties) {
                    // Take the value only if it's there
                    if (category && category.displayName) {
                        xAxisLabel = category.displayName;
                    }
                }
                if (valueAxisProperties) {
                    var valuesNames = [];
                    if (values) {
                        // Take the name from the values, and make it unique because there are sometimes duplications
                        valuesNames = values.map(function (v) { return v ? v.displayName : ''; }).filter(function (value, index, self) { return value !== '' && self.indexOf(value) === index; });
                        yAxisLabel = visuals.valueFormatter.formatListAnd(valuesNames);
                    }
                }
                return { xAxisLabel: xAxisLabel, yAxisLabel: yAxisLabel };
            }
            converterHelper.createAxesLabels = createAxesLabels;
            function isImageUrlColumn(column) {
                var misc = getMiscellaneousTypeDescriptor(column);
                return misc != null && misc.imageUrl === true;
            }
            converterHelper.isImageUrlColumn = isImageUrlColumn;
            function isWebUrlColumn(column) {
                var misc = getMiscellaneousTypeDescriptor(column);
                return misc != null && misc.webUrl === true;
            }
            converterHelper.isWebUrlColumn = isWebUrlColumn;
            function getMiscellaneousTypeDescriptor(column) {
                return column
                    && column.type
                    && column.type.misc;
            }
            function hasImageUrlColumn(dataView) {
                if (!dataView || !dataView.metadata || _.isEmpty(dataView.metadata.columns))
                    return false;
                return _.any(dataView.metadata.columns, function (column) { return isImageUrlColumn(column) === true; });
            }
            converterHelper.hasImageUrlColumn = hasImageUrlColumn;
            function formatFromMetadataColumn(value, column, formatStringProp) {
                debug.assertValue(column, 'column should exist');
                var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, true);
                formatString = formatString || column ? column.format : undefined;
                return visuals.valueFormatter.format(value, formatString);
            }
            converterHelper.formatFromMetadataColumn = formatFromMetadataColumn;
        })(converterHelper = visuals.converterHelper || (visuals.converterHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var LabelStyle = visuals.labelStyle;
        var dataLabelUtils;
        (function (dataLabelUtils) {
            dataLabelUtils.minLabelFontSize = 8;
            dataLabelUtils.labelMargin = 8;
            dataLabelUtils.maxLabelWidth = 50;
            dataLabelUtils.defaultColumnLabelMargin = 5;
            dataLabelUtils.defaultColumnHalfLabelHeight = 4;
            dataLabelUtils.DefaultDy = '-0.15em';
            dataLabelUtils.DefaultFontSizeInPt = 9;
            dataLabelUtils.StandardFontFamily = 'wf_segoe-ui_normal';
            dataLabelUtils.LabelTextProperties = {
                fontFamily: 'wf_standard-font',
                fontSize: PixelConverter.fromPoint(dataLabelUtils.DefaultFontSizeInPt),
                fontWeight: 'normal',
            };
            dataLabelUtils.defaultLabelColor = "#777777";
            dataLabelUtils.defaultInsideLabelColor = "#ffffff";
            dataLabelUtils.hundredPercentFormat = "0.00 %;-0.00 %;0.00 %";
            dataLabelUtils.defaultLabelPrecision = undefined;
            var defaultCountLabelPrecision = 0;
            var labelGraphicsContextClass = createClassAndSelector('labels');
            var linesGraphicsContextClass = createClassAndSelector('lines');
            var labelsClass = createClassAndSelector('data-labels');
            var lineClass = createClassAndSelector('line-label');
            function updateLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
                if (labelsObj) {
                    if (labelsObj.show !== undefined)
                        labelSettings.show = labelsObj.show;
                    if (labelsObj.showSeries !== undefined)
                        labelSettings.show = labelsObj.showSeries;
                    if (labelsObj.color !== undefined)
                        labelSettings.labelColor = labelsObj.color.solid.color;
                    if (labelsObj.labelDisplayUnits !== undefined)
                        labelSettings.displayUnits = labelsObj.labelDisplayUnits;
                    if (labelsObj.labelPrecision !== undefined)
                        labelSettings.precision = (labelsObj.labelPrecision >= 0) ? labelsObj.labelPrecision : dataLabelUtils.defaultLabelPrecision;
                    if (labelsObj.fontSize !== undefined)
                        labelSettings.fontSize = labelsObj.fontSize;
                    if (labelsObj.showAll !== undefined)
                        labelSettings.showLabelPerSeries = labelsObj.showAll;
                    if (labelsObj.labelStyle !== undefined)
                        labelSettings.labelStyle = labelsObj.labelStyle;
                }
            }
            dataLabelUtils.updateLabelSettingsFromLabelsObject = updateLabelSettingsFromLabelsObject;
            function updateLineChartLabelSettingsFromLabelsObject(labelsObj, labelSettings) {
                updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
                if (labelsObj && labelsObj.labelDensity !== undefined)
                    labelSettings.labelDensity = labelsObj.labelDensity;
            }
            dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject = updateLineChartLabelSettingsFromLabelsObject;
            function getDefaultLabelSettings(show, labelColor, fontSize) {
                if (show === void 0) { show = false; }
                return {
                    show: show,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: labelColor || dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: fontSize || dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultLabelSettings = getDefaultLabelSettings;
            function getDefaultCardLabelSettings(labelColor, categoryLabelColor, fontSize) {
                var labelSettings = getDefaultLabelSettings(true, labelColor, fontSize);
                labelSettings.showCategory = true;
                labelSettings.categoryLabelColor = categoryLabelColor;
                return labelSettings;
            }
            dataLabelUtils.getDefaultCardLabelSettings = getDefaultCardLabelSettings;
            function getDefaultTreemapLabelSettings() {
                return {
                    show: false,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    showCategory: true,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultTreemapLabelSettings = getDefaultTreemapLabelSettings;
            function getDefaultSunburstLabelSettings() {
                return {
                    show: false,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    showCategory: true,
                };
            }
            dataLabelUtils.getDefaultSunburstLabelSettings = getDefaultSunburstLabelSettings;
            function getDefaultColumnLabelSettings(isLabelPositionInside) {
                var labelSettings = getDefaultLabelSettings(false, undefined);
                labelSettings.position = null;
                labelSettings.labelColor = undefined;
                return labelSettings;
            }
            dataLabelUtils.getDefaultColumnLabelSettings = getDefaultColumnLabelSettings;
            function getDefaultPointLabelSettings() {
                return {
                    show: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultPointLabelSettings = getDefaultPointLabelSettings;
            function getDefaultLineChartLabelSettings(isComboChart) {
                return {
                    show: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                    labelDensity: isComboChart ? visuals.NewDataLabelUtils.LabelDensityMax : visuals.NewDataLabelUtils.LabelDensityMin,
                };
            }
            dataLabelUtils.getDefaultLineChartLabelSettings = getDefaultLineChartLabelSettings;
            function getDefaultMapLabelSettings() {
                return {
                    show: false,
                    showCategory: false,
                    position: 0 /* Above */,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultInsideLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultMapLabelSettings = getDefaultMapLabelSettings;
            function getDefaultDonutLabelSettings() {
                var labelSettings = dataLabelUtils.getDefaultLabelSettings(true, dataLabelUtils.defaultLabelColor, dataLabelUtils.DefaultFontSizeInPt);
                labelSettings.labelStyle = LabelStyle.category;
                return labelSettings;
            }
            dataLabelUtils.getDefaultDonutLabelSettings = getDefaultDonutLabelSettings;
            function getDefaultGaugeLabelSettings() {
                return {
                    show: true,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: null,
                    position: null,
                    fontSize: dataLabelUtils.minLabelFontSize,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultGaugeLabelSettings = getDefaultGaugeLabelSettings;
            function getDefaultFunnelLabelSettings() {
                return {
                    show: true,
                    position: powerbi.visuals.labelPosition.insideCenter,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    formatterOptions: null,
                    fontSize: dataLabelUtils.DefaultFontSizeInPt,
                };
            }
            dataLabelUtils.getDefaultFunnelLabelSettings = getDefaultFunnelLabelSettings;
            function getDefaultKpiLabelSettings() {
                return {
                    show: false,
                    displayUnits: 0,
                    precision: dataLabelUtils.defaultLabelPrecision,
                    labelColor: dataLabelUtils.defaultLabelColor,
                    position: null,
                    showCategory: true,
                    formatterOptions: null,
                };
            }
            dataLabelUtils.getDefaultKpiLabelSettings = getDefaultKpiLabelSettings;
            function getLabelPrecision(precision, format) {
                debug.assertAnyValue(format, 'format');
                if (precision !== dataLabelUtils.defaultLabelPrecision)
                    return precision;
                if (format === 'g' || format === 'G')
                    return;
                if (format) {
                    // Calculate precision from positive format by default
                    var positiveFormat = format.split(";")[0];
                    var formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
                    if (formatMetadata.hasDots) {
                        return formatMetadata.precision;
                    }
                }
                // For count fields we do not want a precision by default
                return defaultCountLabelPrecision;
            }
            dataLabelUtils.getLabelPrecision = getLabelPrecision;
            function drawDefaultLabelsForDataPointChart(data, context, layout, viewport, isAnimator, animationDuration, hasSelection) {
                if (isAnimator === void 0) { isAnimator = false; }
                debug.assertValue(data, 'data cannot be null or undefined');
                // Hide and reposition labels that overlap
                var dataLabelManager = new powerbi.DataLabelManager();
                var filteredData = dataLabelManager.hideCollidedLabels(viewport, data, layout);
                var hasAnimation = isAnimator && !!animationDuration;
                var labels = selectLabels(filteredData, context, false, hasAnimation);
                if (!labels)
                    return;
                if (hasAnimation) {
                    labels
                        .text(function (d) { return d.labeltext; })
                        .transition()
                        .duration(animationDuration)
                        .style(layout.style)
                        .style('opacity', hasSelection ? function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); } : 1)
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } });
                    labels
                        .exit()
                        .transition()
                        .duration(animationDuration)
                        .style('opacity', 0) //fade out labels that are removed
                        .remove();
                }
                else {
                    labels
                        .attr({ x: function (d) { return d.labelX; }, y: function (d) { return d.labelY; } })
                        .text(function (d) { return d.labeltext; })
                        .style(layout.style);
                    labels
                        .exit()
                        .remove();
                }
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForDataPointChart = drawDefaultLabelsForDataPointChart;
            /**
             * Note: Funnel chart uses animation and does not use collision detection.
             */
            function drawDefaultLabelsForFunnelChart(data, context, layout, isAnimator, animationDuration) {
                if (isAnimator === void 0) { isAnimator = false; }
                debug.assertValue(data, 'data could not be null or undefined');
                var filteredData = data.filter(layout.filter);
                var labels = selectLabels(filteredData, context);
                if (!labels)
                    return;
                labels
                    .attr(layout.labelLayout)
                    .text(layout.labelText)
                    .style(layout.style);
                if (isAnimator && animationDuration) {
                    labels.transition().duration(animationDuration);
                }
                labels
                    .exit()
                    .remove();
                return labels;
            }
            dataLabelUtils.drawDefaultLabelsForFunnelChart = drawDefaultLabelsForFunnelChart;
            function selectLabels(filteredData, context, isDonut, forAnimation) {
                if (isDonut === void 0) { isDonut = false; }
                if (forAnimation === void 0) { forAnimation = false; }
                // Check for a case where resizing leaves no labels - then we need to remove the labels 'g'
                if (filteredData.length === 0) {
                    cleanDataLabels(context, true);
                    return null;
                }
                if (context.select(labelGraphicsContextClass.selector).empty())
                    context.append('g').classed(labelGraphicsContextClass.class, true);
                // line chart ViewModel has a special 'key' property for point identification since the 'identity' field is set to the series identity
                var hasKey = filteredData[0].key != null;
                var hasDataPointIdentity = filteredData[0].identity != null;
                var getIdentifier = hasKey ?
                    function (d) { return d.key; }
                    : hasDataPointIdentity ?
                        function (d) { return d.identity.getKey(); }
                        : undefined;
                var labels = isDonut ?
                    context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, function (d) { return d.data.identity.getKey(); })
                    : getIdentifier != null ?
                        context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData, getIdentifier)
                        : context.select(labelGraphicsContextClass.selector).selectAll(labelsClass.selector).data(filteredData);
                var newLabels = labels.enter()
                    .append('text')
                    .classed(labelsClass.class, true);
                if (forAnimation)
                    newLabels.style('opacity', 0);
                return labels;
            }
            function cleanDataLabels(context, removeLines) {
                if (removeLines === void 0) { removeLines = false; }
                var empty = [];
                var labels = context.selectAll(labelsClass.selector).data(empty);
                labels.exit().remove();
                context.selectAll(labelGraphicsContextClass.selector).remove();
                if (removeLines) {
                    var lines = context.selectAll(lineClass.selector).data(empty);
                    lines.exit().remove();
                    context.selectAll(linesGraphicsContextClass.selector).remove();
                }
            }
            dataLabelUtils.cleanDataLabels = cleanDataLabels;
            function setHighlightedLabelsOpacity(context, hasSelection, hasHighlights) {
                context.selectAll(labelsClass.selector).style("fill-opacity", function (d) {
                    var labelOpacity = visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) < 1 ? 0 : 1;
                    return labelOpacity;
                });
            }
            dataLabelUtils.setHighlightedLabelsOpacity = setHighlightedLabelsOpacity;
            function getLabelFormattedText(options) {
                var properties = {
                    text: options.formatter
                        ? options.formatter.format(options.label)
                        : powerbi.formattingService.formatValue(options.label, options.format),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: PixelConverter.fromPoint(options.fontSize),
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(properties, options.maxWidth ? options.maxWidth : dataLabelUtils.maxLabelWidth);
            }
            dataLabelUtils.getLabelFormattedText = getLabelFormattedText;
            function getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, dataDomain) {
                return {
                    x: function (d) { return xAxisProperties.scale(d.categoryIndex) + (categoryWidth / 2); },
                    y: function (d) { return getWaterfallLabelYPosition(yAxisProperties.scale, d, dataDomain); }
                };
            }
            dataLabelUtils.getLabelLayoutXYForWaterfall = getLabelLayoutXYForWaterfall;
            function getWaterfallLabelYPosition(scale, d, dataDomain) {
                var yValue = scale(0) - scale(Math.abs(d.value));
                var yPos = scale(d.position);
                var scaleMinDomain = scale(dataDomain[0]);
                var endPosition = scale(d.position + d.value);
                if (d.value < 0) {
                    var properties = {
                        text: d.labeltext,
                        fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                        fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                    };
                    var outsideBelowPosition = yPos + yValue + powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                    if (scaleMinDomain > outsideBelowPosition) {
                        return outsideBelowPosition;
                    }
                }
                else {
                    var outsideAbovePosition = yPos - yValue - dataLabelUtils.labelMargin;
                    // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                    if (outsideAbovePosition > 0) {
                        return outsideAbovePosition;
                    }
                }
                d.isLabelInside = true;
                return getWaterfallInsideLabelYPosition(yPos, endPosition, scaleMinDomain);
            }
            function getWaterfallInsideLabelYPosition(startPosition, endPosition, scaleMinDomain) {
                // Get the start and end position of the column
                // If the start or end is outside of the visual because of clipping - adjust the position
                startPosition = startPosition < 0 ? 0 : startPosition;
                startPosition = startPosition > scaleMinDomain ? scaleMinDomain : startPosition;
                endPosition = endPosition < 0 ? 0 : endPosition;
                endPosition = endPosition > scaleMinDomain ? scaleMinDomain : endPosition;
                return (Math.abs(endPosition - startPosition) / 2) + Math.min(startPosition, endPosition);
            }
            function doesDataLabelFitInShape(d, yAxisProperties, layout) {
                if (d == null || d.value === null)
                    return false;
                var properties = {
                    text: layout.labelText(d),
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                var outsidePosition = visuals.WaterfallChart.getRectTop(yAxisProperties.scale, d.position, d.value) - dataLabelUtils.labelMargin;
                // The shape is fit to be outside
                if (outsidePosition > 0)
                    return true;
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                var shapeWidth = layout.categoryWidth;
                var shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yAxisProperties.scale, Math.max(0, Math.abs(d.value)), 0));
                //checking that labels aren't greater than shape
                if ((textWidth > shapeWidth) || (textHeight > shapeHeight))
                    return false;
                return true;
            }
            dataLabelUtils.doesDataLabelFitInShape = doesDataLabelFitInShape;
            function getMapLabelLayout(labelSettings) {
                return {
                    labelText: function (d) {
                        return getLabelFormattedText({
                            label: d.labeltext,
                            fontSize: labelSettings.fontSize
                        });
                    },
                    labelLayout: {
                        x: function (d) { return d.x; },
                        y: function (d) {
                            var margin = d.radius + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 /* Above */ ? d.y - margin : d.y + margin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.labeltext != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'font-size': PixelConverter.fromPoint(labelSettings.fontSize),
                    },
                };
            }
            dataLabelUtils.getMapLabelLayout = getMapLabelLayout;
            function getColumnChartLabelLayout(data, labelLayoutXY, isColumn, isHundredPercent, axisFormatter, axisOptions, interactivityService, visualWidth) {
                var formatOverride = (isHundredPercent) ? dataLabelUtils.hundredPercentFormat : null;
                var formattersCache = createColumnFormatterCacheManager();
                var hasSelection = interactivityService ? interactivityService.hasSelection() : false;
                return {
                    labelText: function (d) {
                        var formatString = (formatOverride != null) ? formatOverride : d.labelFormatString;
                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings);
                        var formatter = formattersCache.getOrCreate(formatString, d.labelSettings, value2);
                        return getLabelFormattedText({
                            label: formatter.format(d.value),
                            maxWidth: dataLabelUtils.maxLabelWidth
                        });
                    },
                    labelLayout: labelLayoutXY,
                    filter: function (d) { return dataLabelUtils.getColumnChartLabelFilter(d, hasSelection, data.hasHighlights, axisOptions, visualWidth); },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'text-anchor': isColumn ? 'middle' : 'start',
                    },
                };
            }
            dataLabelUtils.getColumnChartLabelLayout = getColumnChartLabelLayout;
            /**
             * Valide for stacked column/bar chart and 100% stacked column/bar chart,
             * that labels that should to be inside the shape aren't bigger then shapes.
             */
            function validateLabelsSize(d, axisOptions, visualWidth) {
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var columnWidth = axisOptions.columnWidth;
                var properties = {
                    text: d.labeltext,
                    fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                };
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                var shapeWidth, shapeHeight;
                var inside = false;
                var outsidePosition = visuals.ColumnUtil.calculatePosition(d, axisOptions);
                switch (d.chartType) {
                    case visuals.ColumnChartType.stackedBar:
                    case visuals.ColumnChartType.hundredPercentStackedBar:
                        // if the series isn't last or the label doesn't fit where specified, then it should be inside 
                        if (!d.lastSeries || (outsidePosition + textWidth > visualWidth) || d.chartType === visuals.ColumnChartType.hundredPercentStackedBar) {
                            shapeWidth = -visuals.StackedUtil.getSize(xScale, d.valueAbsolute);
                            shapeHeight = columnWidth;
                            inside = true;
                        }
                        break;
                    case visuals.ColumnChartType.clusteredBar:
                        // if the label doesn't fit where specified, then it should be inside 
                        if ((outsidePosition + textWidth) > visualWidth) {
                            shapeWidth = Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value));
                            shapeHeight = columnWidth;
                            inside = true;
                        }
                        break;
                    case visuals.ColumnChartType.stackedColumn:
                    case visuals.ColumnChartType.hundredPercentStackedColumn:
                        // if the series isn't last or the label doesn't fit where specified, then it should be inside 
                        if (!d.lastSeries || outsidePosition <= 0 || d.chartType === visuals.ColumnChartType.hundredPercentStackedColumn) {
                            shapeWidth = columnWidth;
                            shapeHeight = visuals.StackedUtil.getSize(yScale, d.valueAbsolute);
                            inside = true;
                        }
                        break;
                    case visuals.ColumnChartType.clusteredColumn:
                        // if the label doesn't fit where specified, then it should be inside 
                        if (outsidePosition <= 0) {
                            shapeWidth = columnWidth;
                            shapeHeight = Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value));
                            inside = true;
                        }
                        break;
                    default:
                        return true;
                }
                //checking that labels aren't greater than shape
                if (inside && ((textWidth > shapeWidth) || textHeight > shapeHeight))
                    return false;
                return true;
            }
            function getColumnChartLabelFilter(d, hasSelection, hasHighlights, axisOptions, visualWidth) {
                //labels of dimmed are hidden
                var shapesOpacity = hasSelection ? visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, !d.highlight && hasSelection, !d.selected && hasHighlights) :
                    visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights);
                return (d != null && d.value != null && validateLabelsSize(d, axisOptions, visualWidth) && shapesOpacity === 1);
            }
            dataLabelUtils.getColumnChartLabelFilter = getColumnChartLabelFilter;
            function getScatterChartLabelLayout(xScale, yScale, labelSettings, viewport, sizeRange) {
                return {
                    labelText: function (d) {
                        return getLabelFormattedText({
                            label: d.formattedCategory.getValue(),
                            maxWidth: dataLabelUtils.maxLabelWidth * 2.0
                        });
                    },
                    labelLayout: {
                        x: function (d) { return xScale(d.x); },
                        y: function (d) {
                            var margin = visuals.ScatterChart.getBubbleRadius(d.radius, sizeRange, viewport) + dataLabelUtils.labelMargin;
                            return labelSettings.position === 0 /* Above */ ? yScale(d.y) - margin : yScale(d.y) + margin;
                        },
                    },
                    filter: function (d) {
                        return (d != null && d.formattedCategory.getValue() != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                    },
                };
            }
            dataLabelUtils.getScatterChartLabelLayout = getScatterChartLabelLayout;
            function getLineChartLabelLayout(xScale, yScale, labelSettings, isScalar, axisFormatter) {
                var formattersCache = createColumnFormatterCacheManager();
                return {
                    labelText: function (d) {
                        var value2 = getDisplayUnitValueFromAxisFormatter(axisFormatter, d.labelSettings);
                        var formatter = formattersCache.getOrCreate(d.labelFormatString, d.labelSettings, value2);
                        return getLabelFormattedText({ label: formatter.format(d.value) });
                    },
                    labelLayout: {
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex); },
                        y: function (d) { return labelSettings.position === 0 /* Above */ ? yScale(d.value) - dataLabelUtils.labelMargin : yScale(d.value) + dataLabelUtils.labelMargin; },
                    },
                    filter: function (d) {
                        return (d != null && d.value != null);
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'font-size': function (d) { return PixelConverter.fromPoint(d.labelSettings.fontSize); },
                    },
                };
            }
            dataLabelUtils.getLineChartLabelLayout = getLineChartLabelLayout;
            function getFunnelChartLabelLayout(data, axisOptions, textMinimumPadding, labelSettings, currentViewport) {
                var yScale = axisOptions.yScale;
                var xScale = axisOptions.xScale;
                var marginLeft = axisOptions.margin.left;
                var innerTextHeightRate = 0.7;
                var rangeBand = axisOptions.xScale.rangeBand();
                //the bars are tranform, verticalRange mean horizontal range, xScale is y, yscale is x
                var pixelSpan = axisOptions.verticalRange / 2;
                var formatString = visuals.valueFormatter.getFormatString(data.valuesMetadata[0], visuals.funnelChartProps.general.formatString);
                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
                var value2 = null;
                if (labelSettings.displayUnits === 0) {
                    var minY = d3.min(data.slices, function (d) { return d.value; });
                    var maxY = d3.max(data.slices, function (d) { return d.value; });
                    value2 = Math.max(Math.abs(minY), Math.abs(maxY));
                }
                var formattersCache = createColumnFormatterCacheManager();
                return {
                    labelText: function (d) {
                        var barWidth = Math.abs(yScale(d.value) - yScale(0));
                        var insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - (textMinimumPadding * 2);
                        var outsideAvailableSpace = pixelSpan - (barWidth / 2) - textMinimumPadding;
                        var labelFormatString = (formatString != null) ? formatString : d.labelFormatString;
                        var maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace);
                        var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings, value2);
                        var labelText = formatter.format(visuals.FunnelChart.getFunnelSliceValue(d, true /* asOriginal */));
                        return getLabelFormattedText({
                            label: labelText,
                            maxWidth: maximumTextSize,
                            fontSize: labelSettings.fontSize
                        });
                    },
                    labelLayout: {
                        y: function (d, i) {
                            var properties = {
                                text: d.labeltext,
                                fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                                fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            //in order to make it center aligned we should 'correct' the height to not calculate text margin
                            var labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                            return xScale(i) + (rangeBand / 2) + (labelHeight / 2);
                        },
                        x: function (d) {
                            var barWidth = Math.abs(yScale(d.value) - yScale(0));
                            var insideAvailableSpace = Math.abs(yScale(d.value) - yScale(0)) - (textMinimumPadding * 2);
                            var outsideAvailableSpace = pixelSpan - (barWidth / 2) - textMinimumPadding;
                            var maximumTextSize = Math.max(insideAvailableSpace, outsideAvailableSpace);
                            var labelFormatString = (formatString != null) ? formatString : d.labelFormatString;
                            var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings, value2);
                            var labelText = formatter.format(visuals.FunnelChart.getFunnelSliceValue(d, true /* asOriginal */));
                            var properties = {
                                text: getLabelFormattedText({
                                    label: labelText,
                                    maxWidth: maximumTextSize
                                }),
                                fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                                fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            var textLength = textMeasurer(properties);
                            // Try to honor the position, but if the label doesn't fit where specified, then swap the position.
                            var labelPositionValue = labelSettings.position;
                            if ((labelPositionValue === visuals.labelPosition.outsideEnd && outsideAvailableSpace < textLength) || d.value === 0)
                                labelPositionValue = visuals.labelPosition.insideCenter;
                            else if (labelPositionValue === visuals.labelPosition.insideCenter && insideAvailableSpace < textLength) {
                                labelPositionValue = visuals.labelPosition.outsideEnd;
                            }
                            switch (labelPositionValue) {
                                case visuals.labelPosition.outsideEnd:
                                    return marginLeft + pixelSpan + (barWidth / 2) + textMinimumPadding + (textLength / 2);
                                default:
                                    // Inside position, change color to white unless value is 0
                                    d.labelFill = d.value !== 0 ? dataLabelUtils.defaultInsideLabelColor : d.labelFill;
                                    return marginLeft + pixelSpan;
                            }
                        },
                        dy: '-0.15em',
                    },
                    filter: function (d) {
                        if (!(d != null && d.value != null && data.hasHighlights === !!d.highlight))
                            return false;
                        var properties = {
                            text: d.labeltext,
                            fontFamily: dataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                            fontWeight: dataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var labelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties) * innerTextHeightRate;
                        return labelHeight < rangeBand;
                    },
                    style: {
                        'fill': function (d) { return d.labelFill; },
                        'fill-opacity': function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, false, false); },
                        'font-size': function (d) { return PixelConverter.fromPoint(labelSettings.fontSize); },
                    },
                };
            }
            dataLabelUtils.getFunnelChartLabelLayout = getFunnelChartLabelLayout;
            function enumerateDataLabels(options) {
                debug.assertValue(options, 'options');
                debug.assertValue(options.enumeration, 'enumeration');
                if (!options.dataLabelsSettings)
                    return;
                var instance = {
                    objectName: 'labels',
                    selector: options.selector,
                    properties: {},
                };
                if (options.show && options.selector) {
                    instance.properties['showSeries'] = options.dataLabelsSettings.show;
                }
                else if (options.show) {
                    instance.properties['show'] = options.dataLabelsSettings.show;
                }
                instance.properties['color'] = options.dataLabelsSettings.labelColor || dataLabelUtils.defaultLabelColor;
                if (options.displayUnits) {
                    instance.properties['labelDisplayUnits'] = options.dataLabelsSettings.displayUnits;
                }
                if (options.precision) {
                    var precision = options.dataLabelsSettings.precision;
                    instance.properties['labelPrecision'] = precision === dataLabelUtils.defaultLabelPrecision ? null : precision;
                }
                if (options.position) {
                    instance.properties['labelPosition'] = options.dataLabelsSettings.position;
                    if (options.positionObject) {
                        debug.assert(!instance.validValues, '!instance.validValues');
                        instance.validValues = { 'labelPosition': options.positionObject };
                    }
                }
                if (options.labelStyle)
                    instance.properties['labelStyle'] = options.dataLabelsSettings.labelStyle;
                if (options.fontSize)
                    instance.properties['fontSize'] = options.dataLabelsSettings.fontSize;
                if (options.labelDensity) {
                    var lineChartSettings = options.dataLabelsSettings;
                    if (lineChartSettings)
                        instance.properties['labelDensity'] = lineChartSettings.labelDensity;
                }
                //Keep show all as the last property of the instance.
                if (options.showAll)
                    instance.properties['showAll'] = options.dataLabelsSettings.showLabelPerSeries;
                return options.enumeration.pushInstance(instance);
            }
            dataLabelUtils.enumerateDataLabels = enumerateDataLabels;
            function enumerateCategoryLabels(enumeration, dataLabelsSettings, withFill, isShowCategory, fontSize) {
                if (isShowCategory === void 0) { isShowCategory = false; }
                var labelSettings = (dataLabelsSettings)
                    ? dataLabelsSettings
                    : getDefaultPointLabelSettings();
                var instance = {
                    objectName: 'categoryLabels',
                    selector: null,
                    properties: {
                        show: isShowCategory
                            ? labelSettings.showCategory
                            : labelSettings.show,
                        fontSize: dataLabelsSettings ? dataLabelsSettings.fontSize : dataLabelUtils.DefaultFontSizeInPt,
                    },
                };
                if (withFill) {
                    instance.properties['color'] = labelSettings.categoryLabelColor
                        ? labelSettings.categoryLabelColor
                        : labelSettings.labelColor;
                }
                if (fontSize) {
                    instance.properties['fontSize'] = fontSize;
                }
                enumeration.pushInstance(instance);
            }
            dataLabelUtils.enumerateCategoryLabels = enumerateCategoryLabels;
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                if (axisFormatter && axisFormatter.displayUnit && labelSettings.displayUnits === 0)
                    return axisFormatter.displayUnit.value;
                return null;
            }
            function createColumnFormatterCacheManager() {
                return {
                    cache: { defaultFormatter: null, },
                    getOrCreate: function (formatString, labelSetting, value2) {
                        if (formatString) {
                            var cacheKeyObject = {
                                formatString: formatString,
                                displayUnits: labelSetting.displayUnits,
                                precision: getLabelPrecision(labelSetting.precision, formatString),
                                value2: value2
                            };
                            var cacheKey = JSON.stringify(cacheKeyObject);
                            if (!this.cache[cacheKey])
                                this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
                            return this.cache[cacheKey];
                        }
                        if (!this.cache.defaultFormatter) {
                            this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision));
                        }
                        return this.cache.defaultFormatter;
                    }
                };
            }
            dataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: true,
                };
            }
            dataLabelUtils.getOptionsForLabelFormatter = getOptionsForLabelFormatter;
            function isTextWidthOverflows(textWidth, maxTextWidth) {
                return textWidth > maxTextWidth;
            }
            dataLabelUtils.isTextWidthOverflows = isTextWidthOverflows;
            ;
            function isTextHeightOverflows(textHeight, innerChordLength) {
                return textHeight > innerChordLength;
            }
            dataLabelUtils.isTextHeightOverflows = isTextHeightOverflows;
            ;
        })(dataLabelUtils = visuals.dataLabelUtils || (visuals.dataLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DonutLabelUtils;
        (function (DonutLabelUtils) {
            DonutLabelUtils.LineStrokeWidth = 1;
            DonutLabelUtils.DiagonalLineIndex = 0;
            DonutLabelUtils.HorizontalLineIndex = 1;
            function getLabelLeaderLineForDonutChart(donutArcDescriptor, donutProperties, parentPoint, sliceArc) {
                if (sliceArc === void 0) { sliceArc = 0; }
                var innerLinePointMultiplier = 2.05;
                var textPoint;
                var midPoint;
                var chartPoint;
                // Label position has changed
                if (sliceArc) {
                    var arc = sliceArc;
                    var outerRadius = donutProperties.radius * donutProperties.outerArcRadiusRatio;
                    var innerRadius = (donutProperties.radius / 2) * donutProperties.innerArcRadiusRatio;
                    midPoint = [Math.cos(arc) * outerRadius, Math.sin(arc) * outerRadius];
                    chartPoint = [Math.cos(arc) * innerRadius, Math.sin(arc) * innerRadius];
                }
                else {
                    midPoint = donutProperties.outerArc.centroid(donutArcDescriptor);
                    chartPoint = donutProperties.arc.centroid(donutArcDescriptor);
                }
                var textPointX = parentPoint.x;
                var lineMargin = visuals.NewDataLabelUtils.maxLabelOffset / 2;
                textPointX += textPointX < 0 ? -lineMargin : lineMargin;
                textPoint = [textPointX, parentPoint.y];
                chartPoint[0] *= innerLinePointMultiplier;
                chartPoint[1] *= innerLinePointMultiplier;
                return [chartPoint, midPoint, textPoint];
            }
            DonutLabelUtils.getLabelLeaderLineForDonutChart = getLabelLeaderLineForDonutChart;
            /** We calculate the rectangles of the leader lines for collision detection
              *width: x2 - x1; height: y2 - y1 */
            function getLabelLeaderLinesSizeForDonutChart(leaderLinePoints) {
                if (leaderLinePoints && leaderLinePoints.length > 2) {
                    var diagonalLineSize = {
                        width: Math.abs(leaderLinePoints[1][0] - leaderLinePoints[0][0]),
                        height: Math.abs(leaderLinePoints[1][1] - leaderLinePoints[0][1]),
                    };
                    // For horizontal line we set 1 in the height
                    var horizontalLineSize = {
                        width: Math.abs(leaderLinePoints[2][0] - leaderLinePoints[1][0]),
                        height: DonutLabelUtils.LineStrokeWidth,
                    };
                    return [diagonalLineSize, horizontalLineSize];
                }
                return null;
            }
            DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart = getLabelLeaderLinesSizeForDonutChart;
            function getXPositionForDonutLabel(textPointX) {
                var margin = textPointX < 0 ? -visuals.NewDataLabelUtils.maxLabelOffset : visuals.NewDataLabelUtils.maxLabelOffset;
                return textPointX += margin;
            }
            DonutLabelUtils.getXPositionForDonutLabel = getXPositionForDonutLabel;
            function getSpaceAvailableForDonutLabels(labelXPos, viewport) {
                return viewport.width / 2 - Math.abs(labelXPos) - visuals.NewDataLabelUtils.maxLabelOffset;
            }
            DonutLabelUtils.getSpaceAvailableForDonutLabels = getSpaceAvailableForDonutLabels;
        })(DonutLabelUtils = visuals.DonutLabelUtils || (visuals.DonutLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var NewDataLabelUtils;
        (function (NewDataLabelUtils) {
            NewDataLabelUtils.DefaultLabelFontSizeInPt = 9;
            NewDataLabelUtils.MapPolylineOpacity = 0.5;
            NewDataLabelUtils.LabelDensityBufferFactor = 3;
            NewDataLabelUtils.LabelDensityPadding = 6;
            NewDataLabelUtils.LabelDensityMin = 0;
            NewDataLabelUtils.LabelDensityMax = 6;
            NewDataLabelUtils.startingLabelOffset = 8;
            NewDataLabelUtils.maxLabelOffset = 8;
            NewDataLabelUtils.maxLabelWidth = 50;
            NewDataLabelUtils.hundredPercentFormat = '0.00 %;-0.00 %;0.00 %';
            NewDataLabelUtils.LabelTextProperties = {
                fontFamily: 'wf_standard-font',
                fontSize: PixelConverter.fromPoint(NewDataLabelUtils.DefaultLabelFontSizeInPt),
                fontWeight: 'normal',
            };
            NewDataLabelUtils.defaultLabelColor = "#777777";
            NewDataLabelUtils.defaultInsideLabelColor = "#ffffff"; //white
            NewDataLabelUtils.horizontalLabelBackgroundPadding = 4;
            NewDataLabelUtils.verticalLabelBackgroundPadding = 2;
            var labelBackgroundRounding = 4;
            var defaultLabelPrecision = undefined;
            var defaultCountLabelPrecision = 0;
            NewDataLabelUtils.labelGraphicsContextClass = createClassAndSelector('labelGraphicsContext');
            NewDataLabelUtils.labelBackgroundGraphicsContextClass = createClassAndSelector('labelBackgroundGraphicsContext');
            var labelsClass = createClassAndSelector('label');
            var secondLineLabelClass = createClassAndSelector('label-second-line');
            var linesGraphicsContextClass = createClassAndSelector('leader-lines');
            var lineClass = createClassAndSelector('line-label');
            function drawDefaultLabels(context, dataLabels, numeric, twoRows, hasTooltip) {
                if (numeric === void 0) { numeric = false; }
                if (twoRows === void 0) { twoRows = false; }
                if (hasTooltip === void 0) { hasTooltip = false; }
                var filteredDataLabels = _.filter(dataLabels, function (d) { return d.isVisible; });
                var labels = context.selectAll(labelsClass.selector)
                    .data(filteredDataLabels, labelKeyFunction);
                labels.enter()
                    .append("text")
                    .classed(labelsClass.class, true);
                var labelAttr = {
                    x: function (d) {
                        return (d.boundingBox.left + (d.boundingBox.width / 2));
                    },
                    y: function (d) {
                        if (d.hasBackground)
                            return d.boundingBox.top + d.boundingBox.height - NewDataLabelUtils.verticalLabelBackgroundPadding;
                        else
                            return d.boundingBox.top + d.boundingBox.height;
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                labels
                    .text(function (d) { return d.text; })
                    .attr(labelAttr)
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                    'text-anchor': function (d) { return d.textAnchor; },
                });
                labels.exit()
                    .remove();
                var filteredCategoryLabels = _.filter(twoRows ? dataLabels : [], function (d) { return d.isVisible && !_.isEmpty(d.secondRowText); });
                var secondLineLabels = context.selectAll(secondLineLabelClass.selector)
                    .data(filteredCategoryLabels, function (d, index) { return d.identity ? d.identity.getKeyWithoutHighlight() : index; });
                secondLineLabels.enter()
                    .append("text")
                    .classed(secondLineLabelClass.class, true);
                labelAttr = {
                    x: function (d) {
                        return (d.boundingBox.left + (d.boundingBox.width / 2));
                    },
                    y: function (d) {
                        var boundingBoxHeight = (d.text !== undefined) ? d.boundingBox.height / 2 : d.boundingBox.height;
                        if (d.hasBackground)
                            return d.boundingBox.top + boundingBoxHeight - NewDataLabelUtils.verticalLabelBackgroundPadding;
                        else
                            return d.boundingBox.top + boundingBoxHeight;
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                secondLineLabels
                    .text(function (d) { return d.secondRowText; })
                    .attr(labelAttr)
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                    'text-anchor': function (d) { return d.textAnchor; },
                });
                secondLineLabels.exit()
                    .remove();
                if (hasTooltip) {
                    labels.append('title').text(function (d) { return d.tooltip; });
                    secondLineLabels.append('title').text(function (d) { return d.tooltip; });
                    labels.style("pointer-events", "all");
                    secondLineLabels.style("pointer-events", "all");
                }
                return labels;
            }
            NewDataLabelUtils.drawDefaultLabels = drawDefaultLabels;
            function animateDefaultLabels(context, dataLabels, duration, numeric, easeType) {
                if (numeric === void 0) { numeric = false; }
                if (easeType === void 0) { easeType = 'cubic-in-out'; }
                var labels = context.selectAll(labelsClass.selector)
                    .data(_.filter(dataLabels, function (d) { return d.isVisible; }), labelKeyFunction);
                labels.enter()
                    .append("text")
                    .classed(labelsClass.class, true)
                    .style('opacity', 0);
                var labelAttr = {
                    x: function (d) {
                        return (d.boundingBox.left + (d.boundingBox.width / 2));
                    },
                    y: function (d) {
                        return d.boundingBox.top + d.boundingBox.height;
                    },
                    dy: "-0.15em",
                };
                if (numeric) {
                    labelAttr.dy = undefined;
                }
                labels.text(function (d) { return d.text; })
                    .style({
                    'fill': function (d) { return d.fill; },
                    'font-size': function (d) { return PixelConverter.fromPoint(d.fontSize || NewDataLabelUtils.DefaultLabelFontSizeInPt); },
                })
                    .transition()
                    .ease(easeType)
                    .duration(duration)
                    .attr(labelAttr)
                    .style('opacity', 1);
                labels.exit()
                    .transition()
                    .duration(duration)
                    .style('opacity', 0)
                    .remove();
                return labels;
            }
            NewDataLabelUtils.animateDefaultLabels = animateDefaultLabels;
            /** Draws black rectangles based on the bounding bx of labels, to be used in debugging */
            function drawLabelBackground(context, dataLabels, fill, fillOpacity) {
                var labelRects = context.selectAll("rect")
                    .data(_.filter(dataLabels, function (d) { return d.isVisible; }), labelKeyFunction);
                labelRects.enter()
                    .append("rect");
                labelRects
                    .attr({
                    x: function (d) {
                        return d.boundingBox.left - NewDataLabelUtils.horizontalLabelBackgroundPadding;
                    },
                    y: function (d) {
                        return d.boundingBox.top - NewDataLabelUtils.verticalLabelBackgroundPadding;
                    },
                    rx: labelBackgroundRounding,
                    ry: labelBackgroundRounding,
                    width: function (d) {
                        return d.boundingBox.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding;
                    },
                    height: function (d) {
                        if (d.text === undefined && d.secondRowText === undefined) {
                            return 0;
                        }
                        return d.boundingBox.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding;
                    },
                })
                    .style("fill", fill ? fill : "#000000")
                    .style("fill-opacity", fillOpacity != null ? fillOpacity : 1);
                labelRects.exit()
                    .remove();
                return labelRects;
            }
            NewDataLabelUtils.drawLabelBackground = drawLabelBackground;
            function drawLabelLeaderLines(context, filteredDataLabels, key, leaderLineColor) {
                if (context.select(linesGraphicsContextClass.selector).empty())
                    context.append('g').classed(linesGraphicsContextClass.class, true);
                var lines = context.select(linesGraphicsContextClass.selector).selectAll('polyline')
                    .data(filteredDataLabels, key);
                lines.enter()
                    .append('polyline')
                    .classed(lineClass.class, true);
                lines
                    .attr('points', function (d) {
                    return d.leaderLinePoints;
                }).
                    style({
                    'stroke': function (d) { return leaderLineColor ? leaderLineColor : d.fill; },
                    'stroke-width': visuals.DonutLabelUtils.LineStrokeWidth,
                });
                lines
                    .exit()
                    .remove();
            }
            NewDataLabelUtils.drawLabelLeaderLines = drawLabelLeaderLines;
            function getLabelFormattedText(label, format, formatter) {
                return formatter ? formatter.format(label) : powerbi.formattingService.formatValue(label, format);
            }
            NewDataLabelUtils.getLabelFormattedText = getLabelFormattedText;
            function getDisplayUnitValueFromAxisFormatter(axisFormatter, labelSettings) {
                if (axisFormatter && axisFormatter.displayUnit && labelSettings.displayUnits === 0)
                    return axisFormatter.displayUnit.value;
                return null;
            }
            NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter = getDisplayUnitValueFromAxisFormatter;
            function getLabelPrecision(precision, format) {
                debug.assertAnyValue(format, 'format');
                if (precision !== defaultLabelPrecision)
                    return precision;
                if (format) {
                    // Calculate precision from positive format by default
                    var positiveFormat = format.split(";")[0];
                    var formatMetadata = powerbi.NumberFormat.getCustomFormatMetadata(positiveFormat, true /*calculatePrecision*/);
                    if (formatMetadata.hasDots) {
                        return formatMetadata.precision;
                    }
                }
                // For count fields we do not want a precision by default
                return defaultCountLabelPrecision;
            }
            function createColumnFormatterCacheManager() {
                return {
                    cache: { defaultFormatter: null, },
                    getOrCreate: function (formatString, labelSetting, value2) {
                        if (formatString) {
                            var cacheKeyObject = {
                                formatString: formatString,
                                displayUnits: labelSetting.displayUnits,
                                precision: getLabelPrecision(labelSetting.precision, formatString),
                                value2: value2
                            };
                            var cacheKey = JSON.stringify(cacheKeyObject);
                            if (!this.cache[cacheKey])
                                this.cache[cacheKey] = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, cacheKeyObject.precision));
                            return this.cache[cacheKey];
                        }
                        if (!this.cache.defaultFormatter) {
                            this.cache.defaultFormatter = visuals.valueFormatter.create(getOptionsForLabelFormatter(labelSetting, formatString, value2, labelSetting.precision));
                        }
                        return this.cache.defaultFormatter;
                    }
                };
            }
            NewDataLabelUtils.createColumnFormatterCacheManager = createColumnFormatterCacheManager;
            function getOptionsForLabelFormatter(labelSetting, formatString, value2, precision) {
                return {
                    displayUnitSystemType: powerbi.DisplayUnitSystemType.DataLabels,
                    format: formatString,
                    precision: precision,
                    value: labelSetting.displayUnits,
                    value2: value2,
                    allowFormatBeautification: true,
                };
            }
            function removeDuplicates(labelDataPoints) {
                var uniqueLabelDataPoints = [];
                var labelDataPointMap = {};
                var sameParentIsInArray = function (newValue, array, parentIsRect) {
                    return array.some(function (arrayValue) {
                        if (parentIsRect) {
                            return visuals.shapes.Rect.equals(newValue.parentShape.rect, arrayValue.rect);
                        }
                        else {
                            return visuals.shapes.Point.equals(newValue.parentShape.point, arrayValue.point);
                        }
                    });
                };
                for (var _i = 0, labelDataPoints_1 = labelDataPoints; _i < labelDataPoints_1.length; _i++) {
                    var dataPoint = labelDataPoints_1[_i];
                    var parentIsRect = dataPoint.parentType === 1 /* Rectangle */;
                    var resultsFromMap = labelDataPointMap[dataPoint.text];
                    if (!resultsFromMap) {
                        uniqueLabelDataPoints.push(dataPoint);
                        labelDataPointMap[dataPoint.text] = [dataPoint.parentShape];
                    }
                    else {
                        if (!sameParentIsInArray(dataPoint, resultsFromMap, parentIsRect)) {
                            uniqueLabelDataPoints.push(dataPoint);
                            resultsFromMap.push(dataPoint.parentShape);
                        }
                    }
                }
                return uniqueLabelDataPoints;
            }
            NewDataLabelUtils.removeDuplicates = removeDuplicates;
            function getDataLabelLayoutOptions(type) {
                switch (type) {
                    case 9 /* Scatter */:
                        return {
                            maximumOffset: visuals.ScatterChart.dataLabelLayoutMaximumOffset,
                            startingOffset: visuals.ScatterChart.dataLabelLayoutStartingOffset,
                            offsetIterationDelta: visuals.ScatterChart.dataLabelLayoutOffsetIterationDelta,
                            allowLeaderLines: true,
                            attemptToMoveLabelsIntoViewport: true,
                        };
                    default:
                        return {
                            maximumOffset: NewDataLabelUtils.maxLabelOffset,
                            startingOffset: NewDataLabelUtils.startingLabelOffset,
                            attemptToMoveLabelsIntoViewport: true,
                        };
                }
            }
            NewDataLabelUtils.getDataLabelLayoutOptions = getDataLabelLayoutOptions;
            function getTextSize(text, fontSize) {
                var labelTextProperties = NewDataLabelUtils.LabelTextProperties;
                var properties = {
                    text: text,
                    fontFamily: labelTextProperties.fontFamily,
                    fontSize: jsCommon.PixelConverter.fromPoint(fontSize),
                    fontWeight: labelTextProperties.fontWeight,
                };
                return {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties),
                };
            }
            NewDataLabelUtils.getTextSize = getTextSize;
            /**
             * Obtains the key from the label.  Index is required to use as a backup in cases
             * where labels have no key or identity.
             */
            function labelKeyFunction(label, index) {
                if (label.key) {
                    return label.key;
                }
                if (label.identity) {
                    return label.identity.getKeyWithoutHighlight();
                }
                return index;
            }
        })(NewDataLabelUtils = visuals.NewDataLabelUtils || (visuals.NewDataLabelUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var KpiUtil;
        (function (KpiUtil) {
            var KPIImageClassName = 'powervisuals-glyph';
            var BigImageClassName = 'big-kpi';
            var RYGStatusIconClassNames = ['kpi-red', 'kpi-yellow', 'kpi-green'];
            var threeLights = {
                kpiIconClass: 'circle',
                statusValues: RYGStatusIconClassNames,
            };
            var roadSigns = {
                kpiIconClass: '',
                statusValues: ['circle-x kpi-red', 'circle-exclamation kpi-yellow', 'circle-checkmark kpi-green'],
            };
            var trafficLight = {
                kpiIconClass: 'traffic-light',
                statusValues: RYGStatusIconClassNames,
            };
            var shapes = {
                kpiIconClass: '',
                statusValues: ['rhombus kpi-red', 'triangle kpi-yellow', 'circle kpi-green'],
            };
            var gauge = {
                kpiIconClass: '',
                statusValues: ['circle-empty', 'circle-one-quarter', 'circle-half', 'circle-three-quarters', 'circle-full'],
            };
            var statusGraphicFormatStrings = {
                'THREE CIRCLES COLORED': threeLights,
                'TRAFFIC LIGHT - SINGLE': threeLights,
                'THREE FLAGS COLORED': {
                    kpiIconClass: 'flag',
                    statusValues: RYGStatusIconClassNames,
                },
                'ROAD SIGNS': roadSigns,
                'THREE SYMBOLS CIRCLED COLORED': roadSigns,
                'TRAFFIC LIGHT': trafficLight,
                'THREE TRAFFIC LIGHTS RIMMED COLORED': trafficLight,
                'THREE SYMBOLS UNCIRCLED COLORED': {
                    kpiIconClass: '',
                    statusValues: ['x kpi-red', 'exclamation kpi-yellow', 'checkmark kpi-green'],
                },
                'SHAPES': shapes,
                'SMILEY FACE': shapes,
                'THERMOMETER': shapes,
                'CYLINDER': shapes,
                'THREE SIGNS COLORED': shapes,
                'THREE STARS COLORED': {
                    kpiIconClass: 'star-stacked',
                    statusValues: ['star-empty', 'star-half-full', 'star-full'],
                },
                'FIVE BARS COLORED': {
                    kpiIconClass: 'bars-stacked',
                    statusValues: ['bars-zero', 'bars-one', 'bars-two', 'bars-three', 'bars-four'],
                },
                'FIVE BOXES COLORED': {
                    kpiIconClass: 'boxes-stacked',
                    statusValues: ['boxes-zero', 'boxes-one', 'boxes-two', 'boxes-three', 'boxes-four'],
                },
                'FIVE QUARTERS COLORED': gauge,
                'GAUGE - ASCENDING': gauge,
                'GAUGE - DESCENDING': {
                    kpiIconClass: '',
                    statusValues: ['circle-full', 'circle-three-quarters', 'circle-half', 'circle-one-quarter', 'circle-empty'],
                },
                'STANDARD ARROW': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down', 'arrow-right-down', 'arrow-right', 'arrow-right-up', 'arrow-up'],
                },
                'VARIANCE ARROW': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down kpi-red', 'arrow-right kpi-yellow', 'arrow-up kpi-green'],
                },
                'STATUS ARROW - ASCENDING': {
                    kpiIconClass: '',
                    statusValues: ['arrow-down kpi-red', 'arrow-right-down kpi-yellow', 'arrow-right kpi-yellow', 'arrow-right-up kpi-yellow', 'arrow-up kpi-green'],
                },
                'STATUS ARROW - DESCENDING': {
                    kpiIconClass: '',
                    statusValues: ['arrow-up kpi-green', 'arrow-right-up kpi-yellow', 'arrow-right kpi-yellow', 'arrow-right-down kpi-yellow', 'arrow-down kpi-red'],
                },
            };
            function getKpiIcon(kpi, value) {
                var numValue = parseFloat(value);
                if (!kpi)
                    return;
                var statusGraphicFormat = statusGraphicFormatStrings[kpi.graphic.toUpperCase()];
                if (!statusGraphicFormat || isNaN(numValue))
                    return undefined;
                var statusValues = statusGraphicFormat.statusValues;
                // Normalize range of (-1, -0.5, 0, 0.5, 1) to (-2, -1, 0, 1, 2)
                if (kpi.normalizedFiveStateKpiRange && statusValues.length === 5)
                    numValue = numValue * 2;
                // Convert values from the range of (-n/2, ..., 0, ..., n/2) to (0, 1, ..., n-1)
                var num = numValue + Math.floor(statusValues.length / 2);
                return [statusGraphicFormat.kpiIconClass, statusValues[num]].join(' ').trim();
            }
            function getKpiIconClassName(kpiIcon, kpiImageSize) {
                if (!kpiIcon)
                    return undefined;
                if (kpiImageSize === 1 /* Big */)
                    return [KPIImageClassName, BigImageClassName, kpiIcon].join(' ');
                else
                    return [KPIImageClassName, kpiIcon].join(' ');
            }
            function getClassForKpi(kpi, value, kpiImageSize) {
                debug.assertValue(kpi, 'kpi');
                debug.assertValue(value, 'value');
                var kpiIcon = getKpiIcon(kpi, value);
                return getKpiIconClassName(kpiIcon, kpiImageSize);
            }
            KpiUtil.getClassForKpi = getClassForKpi;
            function getKpiImageMetadata(metaDataColumn, value, kpiImageSize) {
                var kpi = metaDataColumn && metaDataColumn.kpi;
                if (kpi) {
                    var kpiIcon = getKpiIcon(kpi, value);
                    if (kpiIcon) {
                        return {
                            caption: kpiIcon,
                            statusGraphic: kpi.graphic,
                            class: getKpiIconClassName(kpiIcon, kpiImageSize),
                        };
                    }
                }
            }
            KpiUtil.getKpiImageMetadata = getKpiImageMetadata;
        })(KpiUtil = visuals.KpiUtil || (visuals.KpiUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ReferenceLineHelper;
        (function (ReferenceLineHelper) {
            ReferenceLineHelper.referenceLineProps = {
                show: 'show',
                lineColor: 'lineColor',
                transparency: 'transparency',
                value: 'value',
                style: 'style',
                position: 'position',
                dataLabelShow: 'dataLabelShow',
                dataLabelColor: 'dataLabelColor',
                dataLabelDecimalPoints: 'dataLabelDecimalPoints',
                dataLabelHorizontalPosition: 'dataLabelHorizontalPosition',
                dataLabelVerticalPosition: 'dataLabelVerticalPosition',
                dataLabelDisplayUnits: 'dataLabelDisplayUnits',
            };
            function enumerateObjectInstances(enumeration, referenceLines, defaultColor, objectName) {
                debug.assertValue(enumeration, 'enumeration');
                if (_.isEmpty(referenceLines)) {
                    // NOTE: We do not currently have support for object maps in the property pane. For now we will generate a single reference line 
                    // object that the format pane can handle.In the future we will need property pane support for multiple reference lines. Also, we're
                    // assuming that the user-defined IDs will be numeric strings, this may change in the future and will likley be controlled by the property pane.
                    var instance = {
                        selector: {
                            id: '0'
                        },
                        properties: {
                            show: false,
                            value: '',
                            lineColor: { solid: { color: defaultColor } },
                            transparency: 50,
                            style: visuals.lineStyle.dashed,
                            position: visuals.referenceLinePosition.back,
                            dataLabelShow: false,
                        },
                        objectName: objectName
                    };
                    enumeration.pushInstance(instance);
                    return;
                }
                for (var _i = 0, referenceLines_1 = referenceLines; _i < referenceLines_1.length; _i++) {
                    var referenceLine = referenceLines_1[_i];
                    var referenceLineProperties = referenceLine.object;
                    var show = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, false);
                    var value = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value);
                    var lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, { solid: { color: defaultColor } });
                    var transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency, 50);
                    var style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed);
                    var position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back);
                    var dataLabelShow = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelShow, false);
                    var instance = {
                        selector: {
                            id: referenceLine.id
                        },
                        properties: {
                            show: show,
                            value: value,
                            lineColor: lineColor,
                            transparency: transparency,
                            style: style,
                            position: position,
                            dataLabelShow: dataLabelShow,
                        },
                        objectName: objectName
                    };
                    // Show the data label properties only if the user chose to show the data label
                    if (dataLabelShow) {
                        var dataLabelColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, { solid: { color: defaultColor } });
                        var dataLabelHorizontalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition, visuals.referenceLineDataLabelHorizontalPosition.left);
                        var dataLabelVerticalPosition = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition, visuals.referenceLineDataLabelVerticalPosition.above);
                        var dataLabelDecimalPoints = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, undefined) < 0
                            ? undefined
                            : powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints, undefined);
                        var dataLabelDisplayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0);
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelColor] = dataLabelColor;
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] = dataLabelHorizontalPosition;
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] = dataLabelVerticalPosition;
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] = dataLabelDecimalPoints;
                        instance.properties[ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits] = dataLabelDisplayUnits;
                    }
                    enumeration.pushInstance(instance);
                }
            }
            ReferenceLineHelper.enumerateObjectInstances = enumerateObjectInstances;
            function render(options) {
                var graphicContext = options.graphicContext;
                var axes = options.axes;
                var referenceLineProperties = options.referenceLineProperties;
                var isHorizontal = options.isHorizontal;
                var viewport = options.viewport;
                var classAndSelector = options.classAndSelector;
                var xScale = axes.x.scale;
                var yScale = axes.y1.scale;
                var refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0);
                var lineColor = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.lineColor, { solid: { color: options.defaultColor } });
                var transparency = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.transparency);
                var style = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.style, visuals.lineStyle.dashed);
                var position = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.position, visuals.referenceLinePosition.back);
                var refLine = graphicContext.select(classAndSelector.selector);
                var index = $(refLine[0]).index();
                var currentPosition = index > 1 ? visuals.referenceLinePosition.front : visuals.referenceLinePosition.back;
                var isRefLineExists = index !== -1;
                var isPositionChanged = currentPosition !== position;
                if (isRefLineExists && isPositionChanged)
                    refLine.remove();
                if (!isRefLineExists || isPositionChanged)
                    refLine = (position === visuals.referenceLinePosition.back) ? graphicContext.insert('line', ":first-child") : graphicContext.append('line');
                var refLineX1 = isHorizontal ? 0 : xScale(refValue);
                var refLineY1 = isHorizontal ? yScale(refValue) : 0;
                var refLineX2 = isHorizontal ? viewport.width : xScale(refValue);
                var refLineY2 = isHorizontal ? yScale(refValue) : viewport.height;
                refLine.attr({
                    'class': classAndSelector.class,
                    x1: refLineX1,
                    y1: refLineY1,
                    x2: refLineX2,
                    y2: refLineY2,
                })
                    .style({
                    'stroke': lineColor.solid.color,
                });
                if (transparency != null)
                    refLine.style('stroke-opacity', ((100 - transparency) / 100));
                if (style === visuals.lineStyle.dashed) {
                    refLine.style('stroke-dasharray', ("5, 5"));
                }
                else if (style === visuals.lineStyle.dotted) {
                    refLine.style({
                        'stroke-dasharray': ("1, 5"),
                        'stroke-linecap': "round"
                    });
                }
                else if (style === visuals.lineStyle.solid) {
                    refLine.style({
                        'stroke-dasharray': null,
                        'stroke-linecap': null
                    });
                }
            }
            ReferenceLineHelper.render = render;
            function createLabelDataPoint(options) {
                var offsetRefLine = 5;
                var axes = options.axes;
                var referenceLineProperties = options.referenceLineProperties;
                var isHorizontal = options.isHorizontal;
                var viewport = options.viewport;
                var xScale = axes.x.scale;
                var yScale = axes.y1.scale;
                // Get the data label properties                
                var refValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, 0);
                var color = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelColor, { solid: { color: options.defaultColor } });
                var decimalPoints = (referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints] < 0 ? undefined : referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelDecimalPoints]);
                var horizontalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelHorizontalPosition] || visuals.referenceLineDataLabelHorizontalPosition.left;
                var verticalPosition = referenceLineProperties[ReferenceLineHelper.referenceLineProps.dataLabelVerticalPosition] || visuals.referenceLineDataLabelVerticalPosition.above;
                var displayUnits = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.dataLabelDisplayUnits, 0);
                // Format the reference line data label text according to the matching axis formatter
                // When options is null default formatter is used either boolean, numeric, or text
                var axisFormatter = isHorizontal ? axes.y1.formatter : axes.x.formatter;
                var formatterForReferenceLineDataLabel = axisFormatter;
                if (axisFormatter.options != null) {
                    var formatterOptions = powerbi.Prototype.inherit(axisFormatter.options);
                    formatterOptions.precision = decimalPoints;
                    formatterOptions.value = displayUnits;
                    formatterForReferenceLineDataLabel = visuals.valueFormatter.create(formatterOptions);
                }
                var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatterForReferenceLineDataLabel.format(refValue));
                var properties = {
                    text: text,
                    fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                    fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                    fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight,
                };
                // Get the height and with of the text element that will be created in order to place it correctly
                var rectWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var rectHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                var dataLabelX;
                var dataLabelY;
                var x1 = isHorizontal ? 0 : xScale(refValue);
                var y1 = isHorizontal ? yScale(refValue) : 0;
                var x2 = isHorizontal ? viewport.width : xScale(refValue);
                var y2 = isHorizontal ? yScale(refValue) : viewport.height;
                var validPositions = [1 /* Above */];
                if (isHorizontal) {
                    // Horizontal line. y1 = y2
                    dataLabelX = (horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left) ? x1 + offsetRefLine : x2 - (rectWidth / 2) - offsetRefLine;
                    dataLabelY = y1;
                    validPositions = (verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above) ? [1 /* Above */] : [2 /* Below */];
                }
                else {
                    // Vertical line. x1 = x2 
                    dataLabelX = x1;
                    dataLabelY = (verticalPosition === visuals.referenceLineDataLabelVerticalPosition.above) ? y1 + (rectHeight / 2) + offsetRefLine : y2 - (rectHeight / 2) - offsetRefLine;
                    validPositions = (horizontalPosition === visuals.referenceLineDataLabelHorizontalPosition.left) ? [4 /* Left */] : [8 /* Right */];
                }
                var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                var parentShape;
                parentShape = {
                    point: {
                        x: dataLabelX,
                        y: dataLabelY,
                    },
                    radius: 0,
                    validPositions: validPositions,
                };
                return {
                    isPreferred: true,
                    text: text,
                    textSize: {
                        width: textWidth,
                        height: textHeight,
                    },
                    outsideFill: color.solid.color,
                    insideFill: null,
                    parentShape: parentShape,
                    parentType: 0 /* Point */,
                    fontSize: 9,
                    identity: null,
                    secondRowText: null,
                    key: options.key,
                };
            }
            ReferenceLineHelper.createLabelDataPoint = createLabelDataPoint;
            function extractReferenceLineValue(referenceLineProperties) {
                var referenceLineValue = null;
                if (referenceLineProperties && powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.show, false))
                    referenceLineValue = powerbi.DataViewObject.getValue(referenceLineProperties, ReferenceLineHelper.referenceLineProps.value, null);
                return referenceLineValue;
            }
            ReferenceLineHelper.extractReferenceLineValue = extractReferenceLineValue;
        })(ReferenceLineHelper = visuals.ReferenceLineHelper || (visuals.ReferenceLineHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var InteractivityUtils;
        (function (InteractivityUtils) {
            function getPositionOfLastInputEvent() {
                return {
                    x: d3.event.clientX,
                    y: d3.event.clientY
                };
            }
            InteractivityUtils.getPositionOfLastInputEvent = getPositionOfLastInputEvent;
            function registerStandardInteractivityHandlers(selection, selectionHandler) {
                registerStandardSelectionHandler(selection, selectionHandler);
                registerStandardContextMenuHandler(selection, selectionHandler);
            }
            InteractivityUtils.registerStandardInteractivityHandlers = registerStandardInteractivityHandlers;
            function registerStandardSelectionHandler(selection, selectionHandler) {
                selection.on('click', function (d) { return handleSelection(d, selectionHandler); });
            }
            InteractivityUtils.registerStandardSelectionHandler = registerStandardSelectionHandler;
            function registerStandardContextMenuHandler(selection, selectionHandler) {
                selection.on('contextmenu', function (d) { return handleContextMenu(d, selectionHandler); });
            }
            InteractivityUtils.registerStandardContextMenuHandler = registerStandardContextMenuHandler;
            function registerGroupInteractivityHandlers(group, selectionHandler) {
                registerGroupSelectionHandler(group, selectionHandler);
                registerGroupContextMenuHandler(group, selectionHandler);
            }
            InteractivityUtils.registerGroupInteractivityHandlers = registerGroupInteractivityHandlers;
            function registerGroupSelectionHandler(group, selectionHandler) {
                group.on('click', function () {
                    var target = d3.event.target;
                    var d = d3.select(target).datum();
                    handleSelection(d, selectionHandler);
                });
            }
            InteractivityUtils.registerGroupSelectionHandler = registerGroupSelectionHandler;
            function registerGroupContextMenuHandler(group, selectionHandler) {
                group.on('contextmenu', function () {
                    var target = d3.event.target;
                    var d = d3.select(target).datum();
                    handleContextMenu(d, selectionHandler);
                });
            }
            InteractivityUtils.registerGroupContextMenuHandler = registerGroupContextMenuHandler;
            function handleContextMenu(d, selectionHandler) {
                if (d3.event.ctrlKey)
                    return;
                d3.event.preventDefault();
                var position = InteractivityUtils.getPositionOfLastInputEvent();
                selectionHandler.handleContextMenu(d, position);
            }
            function handleSelection(d, selectionHandler) {
                selectionHandler.handleSelection(d, d3.event.ctrlKey);
            }
        })(InteractivityUtils = visuals.InteractivityUtils || (visuals.InteractivityUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function getInvalidValueWarnings(dataViews, supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
            var checker = new InvalidDataValuesChecker(supportsNaN /*supportsNaN*/, supportsNegativeInfinity /*supportsNegativeInfinity*/, supportsPositiveInfinity /*supportsPositiveInfinity*/);
            // Show a warning if necessary.
            return checker.getWarningMessages(dataViews);
        }
        visuals.getInvalidValueWarnings = getInvalidValueWarnings;
        var InvalidDataValuesChecker = (function () {
            function InvalidDataValuesChecker(supportsNaN, supportsNegativeInfinity, supportsPositiveInfinity) {
                this.supportsNaN = supportsNaN;
                this.supportsNegativeInfinity = supportsNegativeInfinity;
                this.supportsPositiveInfinity = supportsPositiveInfinity;
            }
            InvalidDataValuesChecker.prototype.getWarningMessages = function (dataViews) {
                this.loadWarningStatus(dataViews);
                var warnings = [];
                if (this.hasNaN && !this.supportsNaN) {
                    warnings.push(new visuals.NaNNotSupportedWarning());
                }
                if ((this.hasNegativeInfinity && !this.supportsNegativeInfinity)
                    || (this.hasPositiveInfinity && !this.supportsPositiveInfinity)) {
                    warnings.push(new visuals.InfinityValuesNotSupportedWarning());
                }
                if (this.hasOutOfRange) {
                    warnings.push(new visuals.ValuesOutOfRangeWarning());
                }
                return warnings;
            };
            InvalidDataValuesChecker.prototype.loadWarningStatus = function (dataViews) {
                this.hasNaN = false;
                this.hasNegativeInfinity = false;
                this.hasOutOfRange = false;
                this.hasPositiveInfinity = false;
                for (var k = 0; k < dataViews.length; k++) {
                    var dataView = dataViews[k];
                    var values = dataView && dataView.categorical && dataView.categorical.values
                        ? dataView.categorical.values
                        : null;
                    if (!values)
                        return;
                    var valueLength = values.length;
                    for (var i = 0; i < valueLength; i++) {
                        var value = values[i];
                        if (value.values) {
                            var valueValueLength = value.values.length;
                            for (var j = 0; j < valueValueLength; j++) {
                                var v = value.values[j];
                                if (isNaN(v))
                                    this.hasNaN = true;
                                else if (v === Number.POSITIVE_INFINITY)
                                    this.hasPositiveInfinity = true;
                                else if (v === Number.NEGATIVE_INFINITY)
                                    this.hasNegativeInfinity = true;
                                else if (v < -1e300 || v > 1e300)
                                    this.hasOutOfRange = true;
                            }
                        }
                    }
                }
            };
            return InvalidDataValuesChecker;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ListViewFactory;
        (function (ListViewFactory) {
            function createListView(options) {
                return new ListView(options);
            }
            ListViewFactory.createListView = createListView;
        })(ListViewFactory = visuals.ListViewFactory || (visuals.ListViewFactory = {}));
        /**
         * A UI Virtualized List, that uses the D3 Enter, Update & Exit pattern to update rows.
         * It can create lists containing either HTML or SVG elements.
         */
        var ListView = (function () {
            function ListView(options) {
                var _this = this;
                // make a copy of options so that it is not modified later by caller
                this.options = $.extend(true, {}, options);
                this.scrollbarInner = options.baseContainer
                    .append('div')
                    .classed('scrollbar-inner', true)
                    .on('scroll', function () { return _this.renderImpl(_this.options.rowHeight); });
                this.scrollContainer = this.scrollbarInner
                    .append('div')
                    .classed('scrollRegion', true)
                    .on('touchstart', function () { return _this.stopTouchPropagation(); })
                    .on('touchmove', function () { return _this.stopTouchPropagation(); });
                this.visibleGroupContainer = this.scrollContainer
                    .append('div')
                    .classed('visibleGroup', true);
                $(options.baseContainer.node()).find('.scroll-element').attr('drag-resize-disabled', 'true');
                ListView.SetDefaultOptions(options);
            }
            ListView.SetDefaultOptions = function (options) {
                options.rowHeight = options.rowHeight || ListView.defaultRowHeight;
            };
            ListView.prototype.rowHeight = function (rowHeight) {
                this.options.rowHeight = Math.ceil(rowHeight);
                return this;
            };
            ListView.prototype.data = function (data, getDatumIndex, dataReset) {
                if (dataReset === void 0) { dataReset = false; }
                this._data = data;
                this.getDatumIndex = getDatumIndex;
                this.setTotalRows();
                if (dataReset)
                    $(this.scrollbarInner.node()).scrollTop(0);
                this.render();
                return this;
            };
            ListView.prototype.viewport = function (viewport) {
                this.options.viewport = viewport;
                this.render();
                return this;
            };
            ListView.prototype.empty = function () {
                this._data = [];
                this.render();
            };
            ListView.prototype.render = function () {
                var _this = this;
                if (this.renderTimeoutId)
                    window.clearTimeout(this.renderTimeoutId);
                this.renderTimeoutId = window.setTimeout(function () {
                    _this.getRowHeight().then(function (rowHeight) {
                        _this.renderImpl(rowHeight);
                    });
                    _this.renderTimeoutId = undefined;
                }, 0);
            };
            ListView.prototype.renderImpl = function (rowHeight) {
                var totalHeight = this.options.scrollEnabled ? Math.max(0, (this._totalRows * rowHeight)) : this.options.viewport.height;
                this.scrollContainer
                    .style('height', totalHeight + "px")
                    .attr('height', totalHeight);
                this.scrollToFrame(true /*loadMoreData*/);
            };
            /*
             *  This method is called in order to prevent a bug found in the Interact.js.
             *  The bug is caused when finishing a scroll outside the scroll area.
             *  In that case the Interact doesn't process a touchcancel event and thinks a touch point still exists.
             *  since the Interact listens on the visualContainer, by stoping the propagation we prevent the bug from taking place.
             */
            ListView.prototype.stopTouchPropagation = function () {
                //Stop the propagation only in read mode so the drag won't be affected.
                if (this.options.isReadMode()) {
                    if (d3.event.type === "touchstart") {
                        var event_1 = d3.event;
                        //If there is another touch point outside this visual than the event should be propagated.
                        //This way the pinch to zoom will not be affected.
                        if (event_1.touches && event_1.touches.length === 1) {
                            d3.event.stopPropagation();
                        }
                    }
                    if (d3.event.type === "touchmove") {
                        d3.event.stopPropagation();
                    }
                }
            };
            ListView.prototype.scrollToFrame = function (loadMoreData) {
                var options = this.options;
                var visibleGroupContainer = this.visibleGroupContainer;
                var totalRows = this._totalRows;
                var rowHeight = options.rowHeight || ListView.defaultRowHeight;
                var visibleRows = this.getVisibleRows() || 1;
                var scrollTop = this.scrollbarInner.node().scrollTop;
                var scrollPosition = (scrollTop === 0) ? 0 : Math.floor(scrollTop / rowHeight);
                var transformAttr = visuals.SVGUtil.translateWithPixels(0, scrollPosition * rowHeight);
                visibleGroupContainer.style({
                    //order matters for proper overriding
                    'transform': function (d) { return transformAttr; },
                    '-webkit-transform': transformAttr
                });
                var position0 = Math.max(0, Math.min(scrollPosition, totalRows - visibleRows + 1)), position1 = position0 + visibleRows;
                if (this.options.scrollEnabled) {
                    // Subtract the amount of height of the top row that's hidden when it's partially visible.
                    var topRowHiddenHeight = scrollTop - (scrollPosition * rowHeight);
                    var halfRowHeight = rowHeight * 0.5;
                    // If more than half the top row is hidden, we'll need to render an extra item at the bottom
                    if (topRowHiddenHeight > halfRowHeight) {
                        position1++; // Add 1 to handle when rows are partially visible (when scrolling)
                    }
                }
                var rowSelection = visibleGroupContainer.selectAll(".row")
                    .data(this._data.slice(position0, Math.min(position1, totalRows)), this.getDatumIndex);
                rowSelection
                    .enter()
                    .append('div')
                    .classed('row', true)
                    .call(function (d) { return options.enter(d); });
                rowSelection.order();
                var rowUpdateSelection = visibleGroupContainer.selectAll('.row:not(.transitioning)');
                rowUpdateSelection.call(function (d) { return options.update(d); });
                rowSelection
                    .exit()
                    .call(function (d) { return options.exit(d); })
                    .remove();
                if (loadMoreData && visibleRows !== totalRows && position1 >= totalRows * ListView.loadMoreDataThreshold)
                    options.loadMoreData();
            };
            ListView.prototype.setTotalRows = function () {
                var data = this._data;
                this._totalRows = data ? data.length : 0;
            };
            ListView.prototype.getVisibleRows = function () {
                var minimumVisibleRows = 1;
                var rowHeight = this.options.rowHeight;
                var viewportHeight = this.options.viewport.height;
                if (!rowHeight || rowHeight < 1)
                    return minimumVisibleRows;
                if (this.options.scrollEnabled)
                    return Math.min(Math.ceil(viewportHeight / rowHeight), this._totalRows) || minimumVisibleRows;
                return Math.min(Math.floor(viewportHeight / rowHeight), this._totalRows) || minimumVisibleRows;
            };
            ListView.prototype.getRowHeight = function () {
                var deferred = $.Deferred();
                var listView = this;
                var options = listView.options;
                if (this.cancelMeasurePass)
                    this.cancelMeasurePass();
                // if there is no data, resolve and return
                if (!(this._data && this._data.length && options)) {
                    listView.rowHeight(ListView.defaultRowHeight);
                    return deferred.resolve(options.rowHeight).promise();
                }
                //render the first item to calculate the row height
                this.scrollToFrame(false /*loadMoreData*/);
                var requestAnimationFrameId = window.requestAnimationFrame(function () {
                    //measure row height
                    var rows = listView.visibleGroupContainer.select(".row");
                    if (!rows.empty()) {
                        var firstRow = rows.node();
                        // If the container (child) has margins amd the row (parent) doesn't, the child's margins will collapse into the parent.
                        // outerHeight doesn't report the correct height for the parent in this case, but it does measure the child properly.
                        // Fix for #7497261 Measures both and take the max to work around this issue.
                        var rowHeight = Math.max($(firstRow).outerHeight(true), $(firstRow).children().first().outerHeight(true));
                        listView.rowHeight(rowHeight);
                        deferred.resolve(rowHeight);
                    }
                    listView.cancelMeasurePass = undefined;
                    window.cancelAnimationFrame(requestAnimationFrameId);
                });
                this.cancelMeasurePass = function () {
                    window.cancelAnimationFrame(requestAnimationFrameId);
                    deferred.reject();
                };
                return deferred.promise();
            };
            /**
             * The value indicates the percentage of data already shown
             * in the list view that triggers a loadMoreData call.
             */
            ListView.loadMoreDataThreshold = 0.8;
            ListView.defaultRowHeight = 1;
            return ListView;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var defaultLevelOfDetail = 11;
        var MapUtil;
        (function (MapUtil) {
            MapUtil.Settings = {
                /** Maximum Bing requests at once. The Bing have limit how many request at once you can do per socket. */
                MaxBingRequest: 6,
                /** Maximum cache size of cached geocode data. */
                MaxCacheSize: 3000,
                /** Maximum cache overflow of cached geocode data to kick the cache reducing. */
                MaxCacheSizeOverflow: 100,
                // Bing Keys and URL
                BingKey: "insert your key",
                BingUrl: "https://dev.virtualearth.net/REST/v1/Locations",
                BingUrlGeodata: "https://platform.bing.com/geo/spatial/v1/public/Geodata?",
                /** Switch the data result for geodata polygons to by double array instead locations array */
                UseDoubleArrayGeodataResult: true,
                UseDoubleArrayDequeueTimeout: 0,
            };
            // Bing map min/max boundaries
            MapUtil.MinAllowedLatitude = -85.05112878;
            MapUtil.MaxAllowedLatitude = 85.05112878;
            MapUtil.MinAllowedLongitude = -180;
            MapUtil.MaxAllowedLongitude = 180;
            MapUtil.TileSize = 256;
            MapUtil.MaxLevelOfDetail = 23;
            MapUtil.MinLevelOfDetail = 1;
            MapUtil.MaxAutoZoomLevel = 5;
            MapUtil.DefaultLevelOfDetail = 11;
            MapUtil.WorkerErrorName = "___error___";
            MapUtil.CategoryTypes = {
                Address: "Address",
                City: "City",
                Continent: "Continent",
                CountryRegion: "Country",
                County: "County",
                Longitude: "Longitude",
                Latitude: "Latitude",
                Place: "Place",
                PostalCode: "PostalCode",
                StateOrProvince: "StateOrProvince"
            };
            var safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
            function clip(n, minValue, maxValue) {
                return Math.min(Math.max(n, minValue), maxValue);
            }
            MapUtil.clip = clip;
            function getMapSize(levelOfDetail) {
                if (levelOfDetail === 23)
                    return 2147483648; //256 << 23 overflow the integer and return a negative value
                if (Math.floor(levelOfDetail) === levelOfDetail)
                    return 256 << levelOfDetail;
                return 256 * Math.pow(2, levelOfDetail);
            }
            MapUtil.getMapSize = getMapSize;
            /**
             * pointArrayChunkLength Motivation:
             * When the number is too small (e.g. less than 1000) the tile is rendering but VERY SLOW,
             * when it's too high there is a risk to get "stack overflow" error on mobile (while joining).
             * this is the lowest number I managed to get without any noticeable slowness.
             */
            var pointArrayChunkLength = 15000;
            /**
             * @param latLongArray - is a Float64Array as [lt0, lon0, lat1, long1, lat2, long2,....]
             * @param buildString - optional, if true returns also a string as "x0 y0 x1 y1 x2 y2 ...."
             * @returns IPixelArrayResult with Float64Array as [x0, y0, x1, y1, x2, y2,....]
             */
            function latLongToPixelXYArray(latLongArray, levelOfDetail, buildString) {
                if (buildString === void 0) { buildString = false; }
                var helperArray = [];
                var result = {
                    array: new Float64Array(latLongArray.length),
                    arrayString: ""
                };
                for (var i = 0; i < latLongArray.length; i += 2) {
                    var latitude = clip(latLongArray[i], MapUtil.MinAllowedLatitude, MapUtil.MaxAllowedLatitude);
                    var longitude = clip(latLongArray[i + 1], MapUtil.MinAllowedLongitude, MapUtil.MaxAllowedLongitude);
                    var x = (longitude + 180) / 360;
                    var sinLatitude = Math.sin(latitude * Math.PI / 180);
                    var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
                    var mapSize = getMapSize(levelOfDetail);
                    result.array[i] = clip(x * mapSize + 0.5, 0.0, mapSize - 1);
                    result.array[i + 1] = clip(y * mapSize + 0.5, 0.0, mapSize - 1);
                    if (buildString) {
                        helperArray.push(result.array[i], result.array[i + 1]);
                        if (helperArray.length >= pointArrayChunkLength) {
                            result.arrayString += helperArray.join(" ") + " ";
                            helperArray = [];
                        }
                    }
                }
                if (buildString) {
                    result.arrayString += helperArray.join(" ") + " ";
                }
                return result;
            }
            MapUtil.latLongToPixelXYArray = latLongToPixelXYArray;
            function getLocationBoundaries(latLongArray) {
                var northWest = {
                    latitude: -90, longitude: 180
                };
                var southEast = {
                    latitude: 90, longitude: -180
                };
                for (var i = 0; i < latLongArray.length; i += 2) {
                    northWest.latitude = Math.max(latLongArray[i], northWest.latitude);
                    northWest.longitude = Math.min(latLongArray[i + 1], northWest.longitude);
                    southEast.latitude = Math.min(latLongArray[i], southEast.latitude);
                    southEast.longitude = Math.max(latLongArray[i + 1], southEast.longitude);
                }
                northWest.longitude = clip(northWest.longitude, -180, 180);
                southEast.longitude = clip(southEast.longitude, -180, 180);
                return Microsoft.Maps.LocationRect.fromCorners(new Microsoft.Maps.Location(northWest.latitude, northWest.longitude), new Microsoft.Maps.Location(southEast.latitude, southEast.longitude));
            }
            MapUtil.getLocationBoundaries = getLocationBoundaries;
            /**
             * Note: this code is taken from Bing.
             *  see Point Compression Algorithm http://msdn.microsoft.com/en-us/library/jj158958.aspx
             *  see Decompression Algorithm in http://msdn.microsoft.com/en-us/library/dn306801.aspx
             */
            function parseEncodedSpatialValueArray(value) {
                var list = [];
                var index = 0;
                var xsum = 0;
                var ysum = 0;
                var max = 4294967296;
                while (index < value.length) {
                    var n = 0;
                    var k = 0;
                    while (1) {
                        if (index >= value.length) {
                            return null;
                        }
                        var b = safeCharacters.indexOf(value.charAt(index++));
                        if (b === -1) {
                            return null;
                        }
                        var tmp = ((b & 31) * (Math.pow(2, k)));
                        var ht = tmp / max;
                        var lt = tmp % max;
                        var hn = n / max;
                        var ln = n % max;
                        var nl = (lt | ln) >>> 0;
                        n = (ht | hn) * max + nl;
                        k += 5;
                        if (b < 32)
                            break;
                    }
                    var diagonal = Math.floor((Math.sqrt(8 * n + 5) - 1) / 2);
                    n -= diagonal * (diagonal + 1) / 2;
                    var ny = Math.floor(n);
                    var nx = diagonal - ny;
                    nx = (nx >> 1) ^ -(nx & 1);
                    ny = (ny >> 1) ^ -(ny & 1);
                    xsum += nx;
                    ysum += ny;
                    var lat = ysum * 0.00001;
                    var lon = xsum * 0.00001;
                    list.push(lat);
                    list.push(lon);
                }
                return new Float64Array(list);
            }
            MapUtil.parseEncodedSpatialValueArray = parseEncodedSpatialValueArray;
            function calcGeoData(data) {
                var locations = data.locations;
                for (var i = 0; i < locations.length; i++) {
                    var location_1 = locations[i];
                    if (!location_1.geographic) {
                        location_1.geographic = MapUtil.parseEncodedSpatialValueArray(location_1.nativeBing);
                    }
                    var polygon = location_1.geographic;
                    if (polygon) {
                        if (!location_1.absolute) {
                            var result = MapUtil.latLongToPixelXYArray(polygon, MapUtil.DefaultLevelOfDetail, true);
                            location_1.absolute = result.array;
                            location_1.absoluteString = result.arrayString;
                            var geographicBounds = MapUtil.getLocationBoundaries(polygon);
                            location_1.absoluteBounds = MapUtil.locationRectToRectXY(geographicBounds, MapUtil.DefaultLevelOfDetail);
                        }
                    }
                }
            }
            MapUtil.calcGeoData = calcGeoData;
            function locationToPixelXY(location, levelOfDetail) {
                return latLongToPixelXY(location.latitude, location.longitude, levelOfDetail);
            }
            MapUtil.locationToPixelXY = locationToPixelXY;
            function locationRectToRectXY(locationRect, levelOfDetail) {
                var topleft = locationToPixelXY(locationRect.getNorthwest(), levelOfDetail);
                var bottomRight = locationToPixelXY(locationRect.getSoutheast(), levelOfDetail);
                return new powerbi.visuals.Rect(topleft.x, topleft.y, bottomRight.x - topleft.x, bottomRight.y - topleft.y);
            }
            MapUtil.locationRectToRectXY = locationRectToRectXY;
            function latLongToPixelXY(latitude, longitude, levelOfDetail) {
                var array = latLongToPixelXYArray(new Float64Array([latitude, longitude]), levelOfDetail).array;
                return new powerbi.visuals.Point(array[0], array[1]);
            }
            MapUtil.latLongToPixelXY = latLongToPixelXY;
            function pixelXYToLocation(pixelX, pixelY, levelOfDetail) {
                var mapSize = getMapSize(levelOfDetail);
                var x = (clip(pixelX, 0, mapSize - 1) / mapSize) - 0.5;
                var y = 0.5 - (clip(pixelY, 0, mapSize - 1) / mapSize);
                var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
                var longitude = 360 * x;
                return new Microsoft.Maps.Location(latitude, longitude);
            }
            MapUtil.pixelXYToLocation = pixelXYToLocation;
            var CurrentLocation;
            (function (CurrentLocation) {
                function createPushpin(location) {
                    var template = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">'
                        + '<circle fill="#FF5F00" cx="12" cy="12" r="6"/>'
                        + '<circle fill="none" stroke="#FF5F00" stroke-width="2" cx="12" cy="12" r="10"/>'
                        + '</svg>';
                    var options = {
                        draggable: false,
                        htmlContent: template,
                        height: 24,
                        width: 24
                    };
                    return new Microsoft.Maps.Pushpin(location, options);
                }
                CurrentLocation.createPushpin = createPushpin;
            })(CurrentLocation = MapUtil.CurrentLocation || (MapUtil.CurrentLocation = {}));
        })(MapUtil = visuals.MapUtil || (visuals.MapUtil = {}));
        var MapPolygonInfo = (function () {
            function MapPolygonInfo() {
                this._locationRect = new Microsoft.Maps.LocationRect(new Microsoft.Maps.Location(30, -30), 60, 60);
            }
            MapPolygonInfo.prototype.reCalc = function (mapControl, width, height) {
                var baseLocations = [this._locationRect.getNorthwest(), this._locationRect.getSoutheast()];
                width = width / 2.00;
                height = height / 2.00;
                if (!this._baseRect) {
                    var l0 = MapUtil.locationToPixelXY(this._locationRect.getNorthwest(), defaultLevelOfDetail);
                    var l1 = MapUtil.locationToPixelXY(this._locationRect.getSoutheast(), defaultLevelOfDetail);
                    this._baseRect = new visuals.Rect(l0.x, l0.y, l1.x - l0.x, l1.y - l0.y);
                }
                var l = mapControl.tryLocationToPixel(baseLocations);
                this._currentRect = new visuals.Rect(l[0].x + width, l[0].y + height, l[1].x - l[0].x, l[1].y - l[0].y);
            };
            Object.defineProperty(MapPolygonInfo.prototype, "scale", {
                get: function () {
                    if (this._baseRect) {
                        return this._currentRect.width / this._baseRect.width;
                    }
                    return 1.0;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "transform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    transform.translate(current.left, current.top);
                    transform.scale((current.width / base.width), (current.height / base.height));
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MapPolygonInfo.prototype, "outherTransform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    transform.translate(current.left, current.top);
                    var scale = Math.sqrt(current.width / base.width);
                    transform.scale(scale, scale);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.setViewBox = function (svg) {
                var rect = svg.getBoundingClientRect();
                var current = this._currentRect;
                svg.setAttribute("viewBox", [-current.left, -current.top, rect.width, rect.height].join(" "));
            };
            Object.defineProperty(MapPolygonInfo.prototype, "innerTransform", {
                get: function () {
                    var base = this._baseRect;
                    var current = this._currentRect;
                    var transform = new visuals.Transform();
                    var scale = current.width / base.width;
                    transform.scale(scale, scale);
                    transform.translate(-base.left, -base.top);
                    return transform;
                },
                enumerable: true,
                configurable: true
            });
            MapPolygonInfo.prototype.transformToString = function (transform) {
                var m = transform.matrix;
                return "matrix(" + m.m00 + " " + m.m10 + " " + m.m01 + " " + m.m11 + " " + m.m02 + " " + m.m12 + ")";
            };
            return MapPolygonInfo;
        }());
        visuals.MapPolygonInfo = MapPolygonInfo;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var utility;
        (function (utility) {
            ;
            var SelectionManager = (function () {
                function SelectionManager(options) {
                    this.hostServices = options.hostServices;
                    this.selectedIds = [];
                }
                SelectionManager.prototype.select = function (selectionId, multiSelect) {
                    if (multiSelect === void 0) { multiSelect = false; }
                    var deferred = $.Deferred();
                    if (this.hostServices.shouldRetainSelection()) {
                        this.sendSelectionToHost([selectionId]);
                    }
                    else {
                        this.selectInternal(selectionId, multiSelect);
                        this.sendSelectionToHost(this.selectedIds);
                    }
                    deferred.resolve(this.selectedIds);
                    return deferred;
                };
                SelectionManager.prototype.showContextMenu = function (selectionId, position) {
                    var deferred = $.Deferred();
                    position = position || visuals.InteractivityUtils.getPositionOfLastInputEvent();
                    this.sendContextMenuToHost(selectionId, position);
                    deferred.resolve();
                    return deferred;
                };
                SelectionManager.prototype.hasSelection = function () {
                    return this.selectedIds.length > 0;
                };
                SelectionManager.prototype.clear = function () {
                    var deferred = $.Deferred();
                    this.selectedIds = [];
                    this.sendSelectionToHost([]);
                    deferred.resolve();
                    return deferred;
                };
                SelectionManager.prototype.getSelectionIds = function () {
                    return this.selectedIds;
                };
                SelectionManager.prototype.sendSelectionToHost = function (ids) {
                    var selectArgs = {
                        data: ids
                            .filter(function (value) { return value.hasIdentity(); })
                            .map(function (value) { return value.getSelector(); })
                    };
                    var data2 = this.getSelectorsByColumn(ids);
                    if (!_.isEmpty(data2))
                        selectArgs.data2 = data2;
                    this.hostServices.onSelect(selectArgs);
                };
                SelectionManager.prototype.sendContextMenuToHost = function (selectionId, position) {
                    var selectors = this.getSelectorsByColumn([selectionId]);
                    if (_.isEmpty(selectors))
                        return;
                    var args = {
                        data: selectors,
                        position: position
                    };
                    this.hostServices.onContextMenu(args);
                };
                SelectionManager.prototype.getSelectorsByColumn = function (selectionIds) {
                    return _(selectionIds)
                        .filter(function (value) { return value.hasIdentity; })
                        .map(function (value) { return value.getSelectorsByColumn(); })
                        .compact()
                        .value();
                };
                SelectionManager.prototype.selectInternal = function (selectionId, multiSelect) {
                    if (SelectionManager.containsSelection(this.selectedIds, selectionId)) {
                        this.selectedIds = multiSelect
                            ? this.selectedIds.filter(function (d) { return !powerbi.data.Selector.equals(d, selectionId); })
                            : this.selectedIds.length > 1
                                ? [selectionId] : [];
                    }
                    else {
                        if (multiSelect)
                            this.selectedIds.push(selectionId);
                        else
                            this.selectedIds = [selectionId];
                    }
                };
                SelectionManager.containsSelection = function (list, id) {
                    return list.some(function (d) { return powerbi.data.Selector.equals(d.getSelector(), id.getSelector()); });
                };
                return SelectionManager;
            }());
            utility.SelectionManager = SelectionManager;
        })(utility = visuals.utility || (visuals.utility = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        "use strict";
        var shapes;
        (function (shapes) {
            var Utility = jsCommon.Utility;
            var Polygon = (function () {
                function Polygon(absolutePoints) {
                    this.polygonPoints = this.convertArrayPathToPoints(absolutePoints);
                }
                Polygon.prototype.absoluteCentroid = function () {
                    if (this._absoluteCentroid == null) {
                        this._absoluteCentroid = this.calculatePolygonCentroid();
                    }
                    return this._absoluteCentroid;
                };
                Polygon.prototype.absoluteBoundingRect = function () {
                    if (this._absoluteBoundingRect == null) {
                        this._absoluteBoundingRect = this.calculateBoundingRect();
                    }
                    return this._absoluteBoundingRect;
                };
                /**
                 * Check if label text contain in polygon shape.
                 *
                 * @return true/false is the label fit in polygon.
                 * measure if rects points are inside the polygon shape
                 * return true if there is at least 3 point inside the polygon
                 */
                Polygon.prototype.contains = function (rect) {
                    var topLeft = { x: rect.left, y: rect.top };
                    var topRight = { x: rect.left + rect.width, y: rect.top };
                    var bottomLeft = { x: rect.left, y: rect.top + rect.height };
                    var bottomRight = { x: rect.left + rect.width, y: rect.top + rect.height };
                    return (this.inside(topLeft)
                        && this.inside(topRight)
                        && this.inside(bottomLeft)
                        && this.inside(bottomRight));
                };
                /**
                * Check if label text is outside of polygon shape.
                * It checks 8 points in the label. TopLeft, TopCenter, TopRight, MiddleLeft, MiddleRight, BottomLeft, BottomMiddle, BottomRight
                * @return true/false is there is any conflict (at least one point inside the shape).
                */
                Polygon.prototype.conflicts = function (rect) {
                    if (!this.isConflictWithBoundingBox(rect)) {
                        return false;
                    }
                    var topLeft = { x: rect.left, y: rect.top };
                    var topCenter = { x: rect.left + rect.width / 2, y: rect.top };
                    var topRight = { x: rect.left + rect.width, y: rect.top };
                    var bottomLeft = { x: rect.left, y: rect.top + rect.height };
                    var bottomCenter = { x: rect.left + rect.width / 2, y: rect.top + rect.height };
                    var bottomRight = { x: rect.left + rect.width, y: rect.top + rect.height };
                    var middleLeft = { x: rect.left, y: rect.top + rect.height / 2 };
                    var middleRight = { x: rect.left + rect.width, y: rect.top + rect.height / 2 };
                    return (this.inside(topLeft)
                        || this.inside(topCenter)
                        || this.inside(topRight)
                        || this.inside(bottomLeft)
                        || this.inside(bottomCenter)
                        || this.inside(bottomRight)
                        || this.inside(middleLeft)
                        || this.inside(middleRight));
                };
                /**
                * returns intersection point of a line (depicted by two points) and a polygon.
                *
                * @return the point of intersection or null if there is no intersection.
                */
                Polygon.prototype.lineIntersectionPoint = function (p0, p1) {
                    for (var i = 0; i < this.polygonPoints.length; i++) {
                        var p2 = this.polygonPoints[i];
                        var p3 = (i === this.polygonPoints.length - 1 ? this.polygonPoints[0] : this.polygonPoints[i + 1]);
                        var intersection = this.getLineIntersection(p0, p1, p2, p3);
                        if (intersection !== null) {
                            return intersection;
                        }
                    }
                    return null;
                };
                /**
                 * calculate Polygon Area.
                 *
                 * @return the area of the polygon (as number).
                 */
                Polygon.calculateAbsolutePolygonArea = function (polygonPoints) {
                    var i, j = 1;
                    var area = 0.0;
                    for (i = 0; i < polygonPoints.length; i++) {
                        area += polygonPoints[i].x * polygonPoints[j].y - polygonPoints[j].x * polygonPoints[i].y;
                        j = (j + 1) % polygonPoints.length;
                    }
                    area *= 0.5;
                    return area;
                };
                /**
                * Check if label text is outside of polygon bounding box.
                *
                * @return true/false is there is any conflict (at least one point inside the shape).
                */
                Polygon.prototype.isConflictWithBoundingBox = function (rect) {
                    return Rect.isIntersecting(this.absoluteBoundingRect(), rect);
                };
                /**
                 * Calculate Polygon Centroid.
                 *
                 * @return 'center' point of the polygon.
                 * calculate the polygon area
                 * calculate the average points of the polygon by x & y axis.
                 * divided the average point by the area
                 */
                Polygon.prototype.calculatePolygonCentroid = function () {
                    var area, tempPoint, cx, cy, i, j;
                    /* First calculate the polygon's signed area A */
                    area = Polygon.calculateAbsolutePolygonArea(this.polygonPoints);
                    /* Now calculate the centroid coordinates Cx and Cy */
                    cx = cy = 0.0;
                    j = 1;
                    for (i = 0; i < this.polygonPoints.length; i++) {
                        tempPoint = this.polygonPoints[i].x * this.polygonPoints[j].y - this.polygonPoints[j].x * this.polygonPoints[i].y;
                        cx += (this.polygonPoints[i].x + this.polygonPoints[j].x) * tempPoint;
                        cy += (this.polygonPoints[i].y + this.polygonPoints[j].y) * tempPoint;
                        j = (j + 1) % this.polygonPoints.length;
                    }
                    cx = cx / (6.0 * area);
                    cy = cy / (6.0 * area);
                    return {
                        x: cx,
                        y: cy,
                    };
                };
                Polygon.prototype.calculateBoundingRect = function () {
                    var minX = Number.POSITIVE_INFINITY;
                    var minY = Number.POSITIVE_INFINITY;
                    var maxX = Number.NEGATIVE_INFINITY;
                    var maxY = Number.NEGATIVE_INFINITY;
                    for (var i = 0; i < this.polygonPoints.length; i++) {
                        if (this.polygonPoints[i].x < minX) {
                            minX = this.polygonPoints[i].x;
                        }
                        else if (this.polygonPoints[i].x > maxX) {
                            maxX = this.polygonPoints[i].x;
                        }
                        if (this.polygonPoints[i].y < minY) {
                            minY = this.polygonPoints[i].y;
                        }
                        else if (this.polygonPoints[i].y > maxY) {
                            maxY = this.polygonPoints[i].y;
                        }
                    }
                    return {
                        left: minX,
                        top: minY,
                        width: maxX - minX,
                        height: maxY - minY
                    };
                };
                /**
                 * Check if point exist inside polygon shape.
                 *
                 * @return true/false if point exist inside shape.
                 * ray-casting algorithm based on:
                 * http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
                 */
                Polygon.prototype.inside = function (point) {
                    var x = point.x, y = point.y;
                    var insideVar = false;
                    for (var i = 0, j = this.polygonPoints.length - 1; i < this.polygonPoints.length; j = i++) {
                        var xi = this.polygonPoints[i].x, yi = this.polygonPoints[i].y;
                        var xj = this.polygonPoints[j].x, yj = this.polygonPoints[j].y;
                        var intersect = ((yi > y) !== (yj > y))
                            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                        if (intersect) {
                            insideVar = !insideVar;
                        }
                    }
                    return insideVar;
                };
                ;
                /**
                 * Checks if a line (presented as two points) intersects with a another line
                 */
                Polygon.prototype.getLineIntersection = function (line0p1, line0p2, line1p1, line1p2) {
                    var p0_x = line0p1.x;
                    var p0_y = line0p1.y;
                    var p1_x = line0p2.x;
                    var p1_y = line0p2.y;
                    var p2_x = line1p1.x;
                    var p2_y = line1p1.y;
                    var p3_x = line1p2.x;
                    var p3_y = line1p2.y;
                    var s1_x = p1_x - p0_x;
                    var s1_y = p1_y - p0_y;
                    var s2_x = p3_x - p2_x;
                    var s2_y = p3_y - p2_y;
                    //Calculating collisions using cross products
                    var s = (-s1_y * (p0_x - p2_x) + s1_x * (p0_y - p2_y)) / (-s2_x * s1_y + s1_x * s2_y);
                    var t = (s2_x * (p0_y - p2_y) - s2_y * (p0_x - p2_x)) / (-s2_x * s1_y + s1_x * s2_y);
                    // 0<=s<=1 and 0<=t<=1 ensures that the collision is part of the original line
                    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
                        // Collision detected
                        return { x: (p0_x + (t * s1_x)), y: (p0_y + (t * s1_y)) };
                    }
                    return null; // No collision
                };
                Polygon.prototype.convertArrayPathToPoints = function (path) {
                    var pointsRes = [];
                    for (var i = 0; i < path.length; i += 2) {
                        var x = path[i];
                        var y = path[i + 1];
                        var newPoint = {
                            x: x,
                            y: y,
                        };
                        pointsRes.push(newPoint);
                    }
                    return pointsRes;
                };
                return Polygon;
            }());
            shapes.Polygon = Polygon;
            var Point;
            (function (Point) {
                function offset(point, offsetX, offsetY) {
                    var newPointX = ((point.x + offsetX) >= 0) ? (point.x + offsetX) : 0;
                    var newPointY = ((point.y + offsetY) >= 0) ? (point.y + offsetY) : 0;
                    return { x: newPointX, y: newPointY };
                }
                Point.offset = offset;
                function equals(point, other) {
                    return point !== undefined && point !== null && other !== undefined && other !== null && point.x === other.x && point.y === other.y;
                }
                Point.equals = equals;
                function clone(point) {
                    return (point !== null) ? { x: point.x, y: point.y } : null;
                }
                Point.clone = clone;
                function toString(point) {
                    return "{x:" + point.x + ", y:" + point.y + "}";
                }
                Point.toString = toString;
                function serialize(point) {
                    return point.x + "," + point.y;
                }
                Point.serialize = serialize;
                function getDistance(point, other) {
                    if ((point === null) || (other) === null) {
                        return null;
                    }
                    var diffX = other.x - point.x;
                    var diffY = other.y - point.y;
                    return Math.sqrt(diffX * diffX + diffY * diffY);
                }
                Point.getDistance = getDistance;
                function equalWithPrecision(point1, point2) {
                    return point1 === point2 ||
                        (point1 !== undefined && point2 !== undefined && powerbi.Double.equalWithPrecision(point1.x, point2.x) && powerbi.Double.equalWithPrecision(point1.y, point2.y));
                }
                Point.equalWithPrecision = equalWithPrecision;
                function parsePoint(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 2) {
                            return { x: Utility.parseNumber(value[0]), y: Utility.parseNumber(value[1]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { x: Utility.parseNumber(parts[0]), y: Utility.parseNumber(parts[1]) };
                        }
                        else if ((value.length !== 2) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { x: Utility.parseNumber(value.x), y: Utility.parseNumber(value.y) };
                        }
                    }
                }
                Point.parsePoint = parsePoint;
            })(Point = shapes.Point || (shapes.Point = {}));
            var Size;
            (function (Size) {
                function isEmpty(size) {
                    return size.width === 0 && size.height === 0;
                }
                Size.isEmpty = isEmpty;
                function equals(size, other) {
                    return size !== undefined && size !== null && other !== undefined && other !== null && size.width === other.width && size.height === other.height;
                }
                Size.equals = equals;
                function clone(size) {
                    return (size !== null) ? { width: size.width, height: size.height } : null;
                }
                Size.clone = clone;
                function inflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Size.inflate = inflate;
                function deflate(size, padding) {
                    var result = clone(size);
                    if (padding) {
                        result.width = result.width - padding.left - padding.right;
                        if (result.width < 0) {
                            result.width = 0;
                        }
                        result.height = result.height - padding.top - padding.bottom;
                        if (result.height < 0) {
                            result.height = 0;
                        }
                    }
                    return result;
                }
                Size.deflate = deflate;
                function combine(size, other) {
                    if (other) {
                        size.width = Math.max(size.width, other.width);
                        size.height = Math.max(size.height, other.height);
                    }
                    return size;
                }
                Size.combine = combine;
                function toRect(size) {
                    return { left: 0, top: 0, width: size.width, height: size.height };
                }
                Size.toRect = toRect;
                function toString(size) {
                    return "{width:" + size.width + ", height:" + size.height + "}";
                }
                Size.toString = toString;
                function equal(size1, size2) {
                    return size1 === size2 ||
                        (size1 !== undefined && size2 !== undefined && size1.width === size2.width && size1.height === size2.height);
                }
                Size.equal = equal;
                function equalWithPrecision(size1, size2) {
                    return size1 === size2 ||
                        (size1 !== undefined && size2 !== undefined && powerbi.Double.equalWithPrecision(size1.width, size2.width) && powerbi.Double.equalWithPrecision(size1.height, size2.height));
                }
                Size.equalWithPrecision = equalWithPrecision;
                function parseSize(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 2) {
                            return { width: Utility.parseNumber(value[0]), height: Utility.parseNumber(value[1]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 2) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { width: Utility.parseNumber(parts[0]), height: Utility.parseNumber(parts[1]) };
                        }
                        else if ((value.length !== 2) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
                        }
                    }
                }
                Size.parseSize = parseSize;
            })(Size = shapes.Size || (shapes.Size = {}));
            var Rect;
            (function (Rect) {
                function getOffset(rect) {
                    return { x: rect.left, y: rect.top };
                }
                Rect.getOffset = getOffset;
                function getSize(rect) {
                    return { width: rect.width, height: rect.height };
                }
                Rect.getSize = getSize;
                function setSize(rect, value) {
                    rect.width = value.width;
                    rect.height = value.height;
                }
                Rect.setSize = setSize;
                function right(rect) {
                    return rect.left + rect.width;
                }
                Rect.right = right;
                function bottom(rect) {
                    return rect.top + rect.height;
                }
                Rect.bottom = bottom;
                function topLeft(rect) {
                    return { x: rect.left, y: rect.top };
                }
                Rect.topLeft = topLeft;
                function topRight(rect) {
                    return { x: rect.left + rect.width, y: rect.top };
                }
                Rect.topRight = topRight;
                function bottomLeft(rect) {
                    return { x: rect.left, y: rect.top + rect.height };
                }
                Rect.bottomLeft = bottomLeft;
                function bottomRight(rect) {
                    return { x: rect.left + rect.width, y: rect.top + rect.height };
                }
                Rect.bottomRight = bottomRight;
                function equals(rect, other) {
                    return other !== undefined && other !== null &&
                        rect.left === other.left && rect.top === other.top && rect.width === other.width && rect.height === other.height;
                }
                Rect.equals = equals;
                function clone(rect) {
                    return (rect !== null) ? { left: rect.left, top: rect.top, width: rect.width, height: rect.height } : null;
                }
                Rect.clone = clone;
                function toString(rect) {
                    return "{left:" + rect.left + ", top:" + rect.top + ", width:" + rect.width + ", height:" + rect.height + "}";
                }
                Rect.toString = toString;
                function offset(rect, offsetX, offsetY) {
                    var newLeft = ((rect.left + offsetX) >= 0) ? rect.left + offsetX : 0;
                    var newTop = ((rect.top + offsetY) >= 0) ? rect.top + offsetY : 0;
                    return { left: newLeft, top: newTop, width: rect.width, height: rect.height };
                }
                Rect.offset = offset;
                function inflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left -= padding.left;
                        result.top -= padding.top;
                        result.width += padding.left + padding.right;
                        result.height += padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.inflate = inflate;
                function deflate(rect, padding) {
                    var result = clone(rect);
                    if (padding) {
                        result.left += padding.left;
                        result.top += padding.top;
                        result.width -= padding.left + padding.right;
                        result.height -= padding.top + padding.bottom;
                    }
                    return result;
                }
                Rect.deflate = deflate;
                function inflateBy(rect, padding) {
                    return { left: rect.left - padding, top: rect.top - padding, width: rect.width + padding + padding, height: rect.height + padding + padding };
                }
                Rect.inflateBy = inflateBy;
                function deflateBy(rect, padding) {
                    return { left: rect.left + padding, top: rect.top + padding, width: rect.width - padding - padding, height: rect.height - padding - padding };
                }
                Rect.deflateBy = deflateBy;
                /**
                 * Get closest point.
                 *
                 * @return the closest point on the rect to the (x,y) point given.
                 * In case the (x,y) given is inside the rect, (x,y) will be returned.
                 * Otherwise, a point on a border will be returned.
                 */
                function getClosestPoint(rect, x, y) {
                    return {
                        x: Math.min(Math.max(rect.left, x), rect.left + rect.width),
                        y: Math.min(Math.max(rect.top, y), rect.top + rect.height)
                    };
                }
                Rect.getClosestPoint = getClosestPoint;
                function equal(rect1, rect2) {
                    return rect1 === rect2 ||
                        (rect1 !== undefined && rect2 !== undefined && rect1.left === rect2.left && rect1.top === rect2.top && rect1.width === rect2.width && rect1.height === rect2.height);
                }
                Rect.equal = equal;
                function equalWithPrecision(rect1, rect2) {
                    return rect1 === rect2 ||
                        (rect1 !== undefined && rect2 !== undefined &&
                            powerbi.Double.equalWithPrecision(rect1.left, rect2.left) && powerbi.Double.equalWithPrecision(rect1.top, rect2.top) &&
                            powerbi.Double.equalWithPrecision(rect1.width, rect2.width) && powerbi.Double.equalWithPrecision(rect1.height, rect2.height));
                }
                Rect.equalWithPrecision = equalWithPrecision;
                function isEmpty(rect) {
                    return rect === undefined || rect === null || (rect.width === 0 && rect.height === 0);
                }
                Rect.isEmpty = isEmpty;
                function containsPoint(rect, point) {
                    if ((rect === null) || (point === null)) {
                        return false;
                    }
                    return powerbi.Double.lessOrEqualWithPrecision(rect.left, point.x) &&
                        powerbi.Double.lessOrEqualWithPrecision(point.x, rect.left + rect.width) &&
                        powerbi.Double.lessOrEqualWithPrecision(rect.top, point.y) &&
                        powerbi.Double.lessOrEqualWithPrecision(point.y, rect.top + rect.height);
                }
                Rect.containsPoint = containsPoint;
                function isIntersecting(rect1, rect2) {
                    if (!rect1 || !rect2) {
                        return false;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    if (left > right) {
                        return false;
                    }
                    var top = Math.max(rect1.top, rect2.top);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    return top <= bottom;
                }
                Rect.isIntersecting = isIntersecting;
                function intersect(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.max(rect1.left, rect2.left);
                    var top = Math.max(rect1.top, rect2.top);
                    var right = Math.min(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.min(rect1.top + rect1.height, rect2.top + rect2.height);
                    if (left <= right && top <= bottom) {
                        return { left: left, top: top, width: right - left, height: bottom - top };
                    }
                    else {
                        return { left: 0, top: 0, width: 0, height: 0 };
                    }
                }
                Rect.intersect = intersect;
                function combine(rect1, rect2) {
                    if (!rect1) {
                        return rect2;
                    }
                    if (!rect2) {
                        return rect1;
                    }
                    var left = Math.min(rect1.left, rect2.left);
                    var top = Math.min(rect1.top, rect2.top);
                    var right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width);
                    var bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);
                    return { left: left, top: top, width: right - left, height: bottom - top };
                }
                Rect.combine = combine;
                function parseRect(value, defaultValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 4) {
                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), width: Utility.parseNumber(value[2]), height: Utility.parseNumber(value[3]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return {
                                left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), width: Utility.parseNumber(parts[2]), height: Utility.parseNumber(parts[3])
                            };
                        }
                        else if ((value.length !== 4) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), width: Utility.parseNumber(value.width), height: Utility.parseNumber(value.height) };
                        }
                    }
                }
                Rect.parseRect = parseRect;
            })(Rect = shapes.Rect || (shapes.Rect = {}));
            var Thickness;
            (function (Thickness) {
                function inflate(thickness, other) {
                    var result = clone(thickness);
                    if (other) {
                        result.left = thickness.left + other.left;
                        result.right = thickness.right + other.right;
                        result.bottom = thickness.bottom + other.bottom;
                        result.top = thickness.top + other.top;
                    }
                    return result;
                }
                Thickness.inflate = inflate;
                function getWidth(thickness) {
                    return thickness.left + thickness.right;
                }
                Thickness.getWidth = getWidth;
                function getHeight(thickness) {
                    return thickness.top + thickness.bottom;
                }
                Thickness.getHeight = getHeight;
                function clone(thickness) {
                    return (thickness !== null) ? { left: thickness.left, top: thickness.top, right: thickness.right, bottom: thickness.bottom } : null;
                }
                Thickness.clone = clone;
                function equals(thickness, other) {
                    return thickness !== undefined && thickness !== null && other !== undefined && other !== null && thickness.left === other.left && thickness.bottom === other.bottom && thickness.right === other.right && thickness.top === other.top;
                }
                Thickness.equals = equals;
                function flipHorizontal(thickness) {
                    var temp = thickness.right;
                    thickness.right = thickness.left;
                    thickness.left = temp;
                }
                Thickness.flipHorizontal = flipHorizontal;
                function flipVertical(thickness) {
                    var top = thickness.top;
                    thickness.top = thickness.bottom;
                    thickness.bottom = top;
                }
                Thickness.flipVertical = flipVertical;
                function toString(thickness) {
                    return "{top:" + thickness.top + ", left:" + thickness.left + ", right:" + thickness.right + ", bottom:" + thickness.bottom + "}";
                }
                Thickness.toString = toString;
                function toCssString(thickness) {
                    return thickness.top + "px " + thickness.right + "px " + thickness.bottom + "px " + thickness.left + "px";
                }
                Thickness.toCssString = toCssString;
                function isEmpty(thickness) {
                    return thickness.left === 0 && thickness.top === 0 && thickness.right === 0 && thickness.bottom === 0;
                }
                Thickness.isEmpty = isEmpty;
                function equal(thickness1, thickness2) {
                    return thickness1 === thickness2 ||
                        (thickness1 !== undefined && thickness2 !== undefined && thickness1.left === thickness2.left && thickness1.top === thickness2.top && thickness1.right === thickness2.right && thickness1.bottom === thickness2.bottom);
                }
                Thickness.equal = equal;
                function equalWithPrecision(thickness1, thickness2) {
                    return thickness1 === thickness2 ||
                        (thickness1 !== undefined && thickness2 !== undefined &&
                            powerbi.Double.equalWithPrecision(thickness1.left, thickness2.left) && powerbi.Double.equalWithPrecision(thickness1.top, thickness2.top) &&
                            powerbi.Double.equalWithPrecision(thickness1.right, thickness2.right) && powerbi.Double.equalWithPrecision(thickness1.bottom, thickness2.bottom));
                }
                Thickness.equalWithPrecision = equalWithPrecision;
                function parseThickness(value, defaultValue, resetValue) {
                    if (value === null) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else if (value === undefined) {
                        return (defaultValue === undefined) ? null : defaultValue;
                    }
                    else {
                        if (value.length === 4) {
                            return { left: Utility.parseNumber(value[0]), top: Utility.parseNumber(value[1]), right: Utility.parseNumber(value[2]), bottom: Utility.parseNumber(value[3]) };
                        }
                        else if (typeof value === "string") {
                            var parts = value.split(",");
                            if (parts.length !== 4) {
                                return (defaultValue === undefined) ? null : defaultValue;
                            }
                            return { left: Utility.parseNumber(parts[0]), top: Utility.parseNumber(parts[1]), right: Utility.parseNumber(parts[2]), bottom: Utility.parseNumber(parts[3]) };
                        }
                        else if ((value.length !== 4) && (typeof value !== "string")) {
                            return (defaultValue === undefined) ? null : defaultValue;
                        }
                        else {
                            return { left: Utility.parseNumber(value.left), top: Utility.parseNumber(value.top), right: Utility.parseNumber(value.right), bottom: Utility.parseNumber(value.bottom) };
                        }
                    }
                }
                Thickness.parseThickness = parseThickness;
            })(Thickness = shapes.Thickness || (shapes.Thickness = {}));
            var Vector;
            (function (Vector) {
                function isEmpty(vector) {
                    return vector.x === 0 && vector.y === 0;
                }
                Vector.isEmpty = isEmpty;
                function equals(vector, other) {
                    return vector !== undefined && vector !== null && other !== undefined && other !== null && vector.x === other.x && vector.y === other.y;
                }
                Vector.equals = equals;
                function clone(vector) {
                    return (vector !== null) ? { x: vector.x, y: vector.y } : null;
                }
                Vector.clone = clone;
                function toString(vector) {
                    return "{x:" + vector.x + ", y:" + vector.y + "}";
                }
                Vector.toString = toString;
                function getLength(vector) {
                    return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
                }
                Vector.getLength = getLength;
                function getLengthSqr(vector) {
                    return vector.x * vector.x + vector.y * vector.y;
                }
                Vector.getLengthSqr = getLengthSqr;
                function scale(vector, scalar) {
                    return { x: vector.x * scalar, y: vector.y * scalar };
                }
                Vector.scale = scale;
                function normalize(vector) {
                    return !isEmpty(vector) ? scale(vector, 1 / getLength(vector)) : vector;
                }
                Vector.normalize = normalize;
                function rotate90DegCW(vector) {
                    return { x: vector.y, y: -vector.x };
                }
                Vector.rotate90DegCW = rotate90DegCW;
                function rotate90DegCCW(vector) {
                    return { x: -vector.y, y: vector.x };
                }
                Vector.rotate90DegCCW = rotate90DegCCW;
                function rotate(vector, angle) {
                    var newX = vector.x * Math.cos(angle) - vector.y * Math.sin(angle);
                    var newY = vector.x * Math.sin(angle) + vector.y * Math.cos(angle);
                    return { x: newX, y: newY };
                }
                Vector.rotate = rotate;
                function equal(vector1, vector2) {
                    return vector1 === vector2 ||
                        (vector1 !== undefined && vector2 !== undefined && vector1.x === vector2.x && vector1.y === vector2.y);
                }
                Vector.equal = equal;
                function equalWithPrecision(vector1, vector2) {
                    return vector1 === vector2 ||
                        (vector1 !== undefined && vector2 !== undefined && powerbi.Double.equalWithPrecision(vector1.x, vector2.x) && powerbi.Double.equalWithPrecision(vector1.y, vector2.y));
                }
                Vector.equalWithPrecision = equalWithPrecision;
                function add(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return { x: vect1.x + vect2.x, y: vect1.y + vect2.y };
                }
                Vector.add = add;
                function subtract(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return { x: vect1.x - vect2.x, y: vect1.y - vect2.y };
                }
                Vector.subtract = subtract;
                function dotProduct(vect1, vect2) {
                    if (!vect1 || !vect2) {
                        return undefined;
                    }
                    return vect1.x * vect2.x + vect1.y * vect2.y;
                }
                Vector.dotProduct = dotProduct;
                function getDeltaVector(p0, p1) {
                    if (!p0 || !p1) {
                        return undefined;
                    }
                    return { x: p1.x - p0.x, y: p1.y - p0.y };
                }
                Vector.getDeltaVector = getDeltaVector;
            })(Vector = shapes.Vector || (shapes.Vector = {}));
        })(shapes = visuals.shapes || (visuals.shapes = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        /** Utility class for slicer*/
        var SlicerUtil;
        (function (SlicerUtil) {
            /** CSS selectors for slicer elements. */
            var Selectors;
            (function (Selectors) {
                var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
                Selectors.HeaderContainer = createClassAndSelector('headerContainer');
                Selectors.Header = createClassAndSelector('slicerHeader');
                Selectors.HeaderText = createClassAndSelector('headerText');
                Selectors.Body = createClassAndSelector('slicerBody');
                Selectors.Label = createClassAndSelector('slicerLabel');
                Selectors.LabelText = createClassAndSelector('slicerText');
                Selectors.LabelImage = createClassAndSelector('slicerImage');
                Selectors.CountText = createClassAndSelector('slicerCountText');
                Selectors.Clear = createClassAndSelector('clear');
                Selectors.MultiSelectEnabled = createClassAndSelector('isMultiSelectEnabled');
            })(Selectors = SlicerUtil.Selectors || (SlicerUtil.Selectors = {}));
            /** Const declarations*/
            var DisplayNameKeys;
            (function (DisplayNameKeys) {
                DisplayNameKeys.Clear = 'Slicer_Clear';
                DisplayNameKeys.SelectAll = 'Slicer_SelectAll';
            })(DisplayNameKeys = SlicerUtil.DisplayNameKeys || (SlicerUtil.DisplayNameKeys = {}));
            /** Helper class for slicer settings  */
            var SettingsHelper;
            (function (SettingsHelper) {
                function areSettingsDefined(data) {
                    return data != null && data.slicerSettings != null;
                }
                SettingsHelper.areSettingsDefined = areSettingsDefined;
            })(SettingsHelper = SlicerUtil.SettingsHelper || (SlicerUtil.SettingsHelper = {}));
            /** Helper class for handling slicer default value  */
            var DefaultValueHandler;
            (function (DefaultValueHandler) {
                function getIdentityFields(dataView) {
                    if (!dataView)
                        return;
                    var dataViewCategorical = dataView.categorical;
                    if (!dataViewCategorical || _.isEmpty(dataViewCategorical.categories))
                        return;
                    return dataViewCategorical.categories[0].identityFields;
                }
                DefaultValueHandler.getIdentityFields = getIdentityFields;
            })(DefaultValueHandler = SlicerUtil.DefaultValueHandler || (SlicerUtil.DefaultValueHandler = {}));
            // Compare the sqExpr of the scopeId with sqExprs of the retained values. 
            // If match found, remove the item from the retainedValues list, and return true, 
            // otherwise return false.
            function tryRemoveValueFromRetainedList(value, selectedScopeIds, caseInsensitive) {
                if (!value || _.isEmpty(selectedScopeIds))
                    return false;
                for (var i = 0, len = selectedScopeIds.length; i < len; i++) {
                    var retainedValueScopeId = selectedScopeIds[i];
                    if (powerbi.DataViewScopeIdentity.equals(value, retainedValueScopeId, caseInsensitive)) {
                        selectedScopeIds.splice(i, 1);
                        return true;
                    }
                }
                return false;
            }
            SlicerUtil.tryRemoveValueFromRetainedList = tryRemoveValueFromRetainedList;
            /** Helper class for creating and measuring slicer DOM elements  */
            var DOMHelper = (function () {
                function DOMHelper() {
                }
                DOMHelper.prototype.createSlicerHeader = function (hostServices) {
                    var slicerHeaderDiv = document.createElement('div');
                    slicerHeaderDiv.className = Selectors.Header.class;
                    var slicerHeader = d3.select(slicerHeaderDiv);
                    slicerHeader.append('span')
                        .classed(Selectors.Clear.class, true)
                        .attr('title', hostServices.getLocalizedString(DisplayNameKeys.Clear));
                    slicerHeader.append('div').classed(Selectors.HeaderText.class, true);
                    return slicerHeaderDiv;
                };
                DOMHelper.prototype.getHeaderTextProperties = function (settings) {
                    var headerTextProperties = {
                        fontFamily: 'wf_segoe-ui_normal',
                        fontSize: '10px'
                    };
                    if (settings.header.show) {
                        headerTextProperties.fontSize = PixelConverter.fromPoint(settings.header.textSize);
                    }
                    return headerTextProperties;
                };
                DOMHelper.prototype.getSlicerBodyViewport = function (currentViewport, settings, headerTextProperties) {
                    var headerHeight = (settings.header.show) ? this.getHeaderHeight(settings, headerTextProperties) : 0;
                    var slicerBodyHeight = currentViewport.height - (headerHeight + settings.header.borderBottomWidth);
                    return {
                        height: slicerBodyHeight,
                        width: currentViewport.width
                    };
                };
                DOMHelper.prototype.updateSlicerBodyDimensions = function (currentViewport, slicerBody, settings) {
                    var slicerViewport = this.getSlicerBodyViewport(currentViewport, settings, this.getHeaderTextProperties(settings));
                    slicerBody.style({
                        'height': PixelConverter.toString(slicerViewport.height),
                        'width': PixelConverter.toString(slicerViewport.width),
                    });
                };
                DOMHelper.prototype.getHeaderHeight = function (settings, textProperties) {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.header.textSize, textProperties)) + settings.general.outlineWeight;
                };
                DOMHelper.prototype.getRowHeight = function (settings, textProperties) {
                    return powerbi.TextMeasurementService.estimateSvgTextHeight(this.getTextProperties(settings.slicerText.textSize, textProperties)) + this.getRowsOutlineWidth(settings.slicerText.outline, settings.general.outlineWeight);
                };
                DOMHelper.prototype.styleSlicerHeader = function (slicerHeader, settings, headerText) {
                    if (settings.header.show) {
                        slicerHeader.style('display', 'block');
                        var headerTextElement = slicerHeader.select(Selectors.HeaderText.selector)
                            .text(headerText);
                        this.setSlicerHeaderTextStyle(headerTextElement, settings);
                    }
                    else {
                        slicerHeader.style('display', 'none');
                    }
                };
                DOMHelper.prototype.setSlicerTextStyle = function (slicerText, settings) {
                    slicerText
                        .style({
                        'color': settings.slicerText.color,
                        'background-color': settings.slicerText.background,
                        'border-style': 'solid',
                        'border-color': settings.general.outlineColor,
                        'border-width': visuals.VisualBorderUtil.getBorderWidth(settings.slicerText.outline, settings.general.outlineWeight),
                        'font-size': PixelConverter.fromPoint(settings.slicerText.textSize),
                    });
                };
                DOMHelper.prototype.getRowsOutlineWidth = function (outlineElement, outlineWeight) {
                    switch (outlineElement) {
                        case visuals.outline.none:
                        case visuals.outline.leftRight:
                            return 0;
                        case visuals.outline.bottomOnly:
                        case visuals.outline.topOnly:
                            return outlineWeight;
                        case visuals.outline.topBottom:
                        case visuals.outline.frame:
                            return outlineWeight * 2;
                        default:
                            return 0;
                    }
                };
                DOMHelper.prototype.setSlicerHeaderTextStyle = function (slicerHeader, settings) {
                    slicerHeader
                        .style({
                        'border-style': 'solid',
                        'border-color': settings.general.outlineColor,
                        'border-width': visuals.VisualBorderUtil.getBorderWidth(settings.header.outline, settings.general.outlineWeight),
                        'color': settings.header.fontColor,
                        'background-color': settings.header.background,
                        'font-size': PixelConverter.fromPoint(settings.header.textSize),
                    });
                };
                DOMHelper.prototype.getTextProperties = function (textSize, textProperties) {
                    textProperties.fontSize = PixelConverter.fromPoint(textSize);
                    return textProperties;
                };
                return DOMHelper;
            }());
            SlicerUtil.DOMHelper = DOMHelper;
        })(SlicerUtil = visuals.SlicerUtil || (visuals.SlicerUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in adding tooltips.
         */
        var tooltipUtils;
        (function (tooltipUtils) {
            function tooltipUpdate(selection, tooltips) {
                if (tooltips.length === 0)
                    return;
                debug.assert(selection.length === tooltips.length || selection[0].length === tooltips.length, 'data length should match dom element count');
                var titles = selection.selectAll('title');
                var titlesUpdate = titles.data(function (d, i) { return [tooltips[i]]; });
                titlesUpdate.enter().append('title');
                titlesUpdate.exit().remove();
                titlesUpdate.text(function (d) { return d; });
            }
            tooltipUtils.tooltipUpdate = tooltipUpdate;
        })(tooltipUtils = visuals.tooltipUtils || (visuals.tooltipUtils = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in SVG manupilation.
         */
        var SVGUtil;
        (function (SVGUtil) {
            /**
             * Very small values, when stringified, may be converted to scientific notation and cause a temporarily
             * invalid attribute or style property value.
             * For example, the number 0.0000001 is converted to the string "1e-7".
             * This is particularly noticeable when interpolating opacity values.
             * To avoid scientific notation, start or end the transition at 1e-6,
             * which is the smallest value that is not stringified in exponential notation.
             */
            SVGUtil.AlmostZero = 1e-6;
            /**
             * Creates a translate string for use with the SVG transform call.
             */
            function translate(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return 'translate(' + x + ',' + y + ')';
            }
            SVGUtil.translate = translate;
            /**
             * Creates a translateX string for use with the SVG transform call.
             */
            function translateXWithPixels(x) {
                debug.assertValue(x, 'x');
                return 'translateX(' + x + 'px)';
            }
            SVGUtil.translateXWithPixels = translateXWithPixels;
            function translateWithPixels(x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return 'translate(' + x + 'px,' + y + 'px)';
            }
            SVGUtil.translateWithPixels = translateWithPixels;
            /**
             * Creates a translate + rotate string for use with the SVG transform call.
             */
            function translateAndRotate(x, y, px, py, angle) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                debug.assertValue(px, 'px');
                debug.assertValue(py, 'py');
                debug.assertValue(angle, 'angle');
                return 'transform', "translate("
                    + x + "," + y + ")"
                    + " rotate(" + angle + "," + px + "," + py + ")";
            }
            SVGUtil.translateAndRotate = translateAndRotate;
            /**
             * Creates a scale string for use in a CSS transform property.
             */
            function scale(scale) {
                debug.assertValue(scale, 'scale');
                return "scale(" + scale + ")";
            }
            SVGUtil.scale = scale;
            /**
             * Creates a translate + scale string for use with the SVG transform call.
             */
            function translateAndScale(x, y, ratio) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                debug.assertValue(ratio, 'ratio');
                return 'transform', "translate("
                    + x + "," + y + ")"
                    + " scale(" + ratio + ")";
            }
            SVGUtil.translateAndScale = translateAndScale;
            /**
             * Creates a transform origin string for use in a CSS transform-origin property.
             */
            function transformOrigin(xOffset, yOffset) {
                debug.assertValue(xOffset, 'xOffset');
                debug.assertValue(yOffset, 'yOffset');
                return xOffset + " " + yOffset;
            }
            SVGUtil.transformOrigin = transformOrigin;
            /**
             * Forces all D3 transitions to complete.
             * Normally, zero-delay transitions are executed after an instantaneous delay (<10ms).
             * This can cause a brief flicker if the browser renders the page twice: once at the end of the first event loop,
             * then again immediately on the first timer callback. By flushing the timer queue at the end of the first event loop,
             * you can run any zero-delay transitions immediately and avoid the flicker.
             *
             * These flickers are noticable on IE, and with a large number of webviews(not recommend you ever do this) on iOS.
             */
            function flushAllD3Transitions() {
                var now = Date.now;
                Date.now = function () { return Infinity; };
                d3.timer.flush();
                Date.now = now;
            }
            SVGUtil.flushAllD3Transitions = flushAllD3Transitions;
            /**
             * Wrapper for flushAllD3Transitions.
             */
            function flushAllD3TransitionsIfNeeded(options) {
                if (!options)
                    return;
                var animationOptions = options;
                var asVisualInitOptions = options;
                if (asVisualInitOptions.animation)
                    animationOptions = asVisualInitOptions.animation;
                if (animationOptions && animationOptions.transitionImmediate) {
                    flushAllD3Transitions();
                }
            }
            SVGUtil.flushAllD3TransitionsIfNeeded = flushAllD3TransitionsIfNeeded;
            /**
             * There is a known bug in IE10 that causes cryptic crashes for SVG elements with a null 'd' attribute:
             * https://github.com/mbostock/d3/issues/1737
             */
            function ensureDAttribute(pathElement) {
                if (!pathElement.getAttribute('d')) {
                    pathElement.setAttribute('d', '');
                }
            }
            SVGUtil.ensureDAttribute = ensureDAttribute;
            /**
             * In IE10, it is possible to return SVGPoints with NaN members.
             */
            function ensureValidSVGPoint(point) {
                if (isNaN(point.x)) {
                    point.x = 0;
                }
                if (isNaN(point.y)) {
                    point.y = 0;
                }
            }
            SVGUtil.ensureValidSVGPoint = ensureValidSVGPoint;
            /**
             * Parse the Transform string with value 'translate(x,y)'.
             * In Chrome for the translate(position) string the delimiter
             * is a comma and in IE it is a spaceso checking for both.
             */
            function parseTranslateTransform(input) {
                if (!input || input.length === 0) {
                    return {
                        x: "0",
                        y: "0",
                    };
                }
                var translateCoordinates = input.split(/[\s,]+/);
                debug.assertValue(translateCoordinates, 'translateCoordinates');
                debug.assert(translateCoordinates.length > 0, 'translate array must atleast have one value');
                var yValue = '0';
                var xValue;
                var xCoord = translateCoordinates[0];
                // Y coordinate is ommited in I.E if it is 0, so need to check against that
                if (translateCoordinates.length === 1) {
                    // 10 refers to the length of 'translate('
                    xValue = xCoord.substring(10, xCoord.length - 1);
                }
                else {
                    var yCoord = translateCoordinates[1];
                    yValue = yCoord.substring(0, yCoord.length - 1);
                    // 10 refers to the length of 'translate('
                    xValue = xCoord.substring(10, xCoord.length);
                }
                return {
                    x: xValue,
                    y: yValue
                };
            }
            SVGUtil.parseTranslateTransform = parseTranslateTransform;
            /**
             * Create an arrow.
             */
            function createArrow(width, height, rotate) {
                var transform = "rotate(" + rotate + " " + width / 2 + " " + height / 2 + ")";
                var path = "M0 0";
                path += "L0 " + height;
                path += "L" + width + " " + height / 2 + " Z";
                return {
                    path: path,
                    transform: transform
                };
            }
            SVGUtil.createArrow = createArrow;
            /**
             * Use the ratio of the scaled bounding rect and the SVG DOM bounding box to get the x and y transform scale values
             */
            function getTransformScaleRatios(svgElement) {
                if (svgElement != null) {
                    var scaledRect = svgElement.getBoundingClientRect();
                    var domRect = svgElement.getBBox();
                    if (domRect.height > 0 && domRect.width > 0) {
                        return {
                            x: scaledRect.width / domRect.width,
                            y: scaledRect.height / domRect.height
                        };
                    }
                }
                return { x: 1, y: 1 };
            }
            SVGUtil.getTransformScaleRatios = getTransformScaleRatios;
        })(SVGUtil = visuals.SVGUtil || (visuals.SVGUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Contains functions/constants to aid in text manupilation.
         */
        var TextUtil;
        (function (TextUtil) {
            /**
             * Remove breaking spaces from given string and replace by none breaking space (&nbsp).
             */
            function removeBreakingSpaces(str) {
                return str.toString().replace(new RegExp(' ', 'g'), '&nbsp');
            }
            TextUtil.removeBreakingSpaces = removeBreakingSpaces;
            /**
             * Remove ellipses from a given string
             */
            function removeEllipses(str) {
                return str.replace(/…/g, '');
            }
            TextUtil.removeEllipses = removeEllipses;
            /**
            * Replace every whitespace (0x20) with Non-Breaking Space (0xA0)
             * @param {string} txt String to replace White spaces
             * @returns Text after replcing white spaces
             */
            function replaceSpaceWithNBSP(txt) {
                if (txt != null)
                    return txt.replace(/ /g, "\xA0");
            }
            TextUtil.replaceSpaceWithNBSP = replaceSpaceWithNBSP;
        })(TextUtil = visuals.TextUtil || (visuals.TextUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        ;
        var GradientUtils;
        (function (GradientUtils) {
            var SQExprBuilder = powerbi.data.SQExprBuilder;
            var DefaultMidColor = "#ffffff";
            var DataPointPropertyIdentifier = "dataPoint";
            var FillRulePropertyIdentifier = "fillRule";
            function getFillRuleRole(objectDescs) {
                if (!objectDescs)
                    return;
                for (var objectName in objectDescs) {
                    var objectDesc = objectDescs[objectName];
                    for (var propertyName in objectDesc.properties) {
                        var propertyDesc = objectDesc.properties[propertyName];
                        if (propertyDesc.type && propertyDesc.type[FillRulePropertyIdentifier]) {
                            return propertyDesc.rule.inputRole;
                        }
                    }
                }
            }
            GradientUtils.getFillRuleRole = getFillRuleRole;
            function shouldShowGradient(visualConfig) {
                var isShowGradienCard = visualConfig && visualConfig.query && visualConfig.query.projections && visualConfig.query.projections['Gradient'] ? true : false;
                return isShowGradienCard;
            }
            GradientUtils.shouldShowGradient = shouldShowGradient;
            function getUpdatedGradientSettings(gradientObject) {
                var gradientSettings;
                if (gradientObject && !$.isEmptyObject(gradientObject)) {
                    gradientSettings = getDefaultGradientSettings();
                    for (var propertyName in gradientSettings) {
                        var hasProperty = gradientObject.hasOwnProperty(propertyName);
                        if (hasProperty) {
                            var value = gradientObject[propertyName];
                            if (value && value.solid && value.solid.color) {
                                value = value.solid.color;
                            }
                            gradientSettings[propertyName] = value;
                        }
                    }
                }
                return gradientSettings;
            }
            GradientUtils.getUpdatedGradientSettings = getUpdatedGradientSettings;
            function getGradientMeasureIndex(dataViewCategorical) {
                if (dataViewCategorical && dataViewCategorical.values && dataViewCategorical.values.grouped) {
                    var grouped = dataViewCategorical.values.grouped();
                    return DataRoleHelper.getMeasureIndexOfRole(grouped, 'Gradient');
                }
                return -1;
            }
            GradientUtils.getGradientMeasureIndex = getGradientMeasureIndex;
            function getGradientValueColumn(dataViewCategorical) {
                if (dataViewCategorical == null)
                    return null;
                // check for gradient measure index 
                var gradientMeasureIndex = GradientUtils.getGradientMeasureIndex(dataViewCategorical);
                var gradientValueColumn = gradientMeasureIndex === -1 ? null : dataViewCategorical.values[gradientMeasureIndex];
                return gradientValueColumn;
            }
            GradientUtils.getGradientValueColumn = getGradientValueColumn;
            function hasGradientRole(dataViewCategorical) {
                var gradientMeasureIndex = getGradientMeasureIndex(dataViewCategorical);
                return gradientMeasureIndex >= 0;
            }
            GradientUtils.hasGradientRole = hasGradientRole;
            function getDefaultGradientSettings() {
                var colors = getDefaultColors();
                var gradientSettings = {
                    diverging: false,
                    minColor: colors.minColor,
                    midColor: DefaultMidColor,
                    maxColor: colors.maxColor,
                    minValue: undefined,
                    midValue: undefined,
                    maxValue: undefined,
                };
                return gradientSettings;
            }
            GradientUtils.getDefaultGradientSettings = getDefaultGradientSettings;
            function getDefaultFillRuleDefinition() {
                return getLinearGradien2FillRuleDefinition();
            }
            GradientUtils.getDefaultFillRuleDefinition = getDefaultFillRuleDefinition;
            function updateFillRule(propertyName, propertyValue, definitions) {
                var dataPointObjectDefinition = powerbi.data.DataViewObjectDefinitions.ensure(definitions, DataPointPropertyIdentifier, null);
                var fillRule = getFillRule(definitions);
                var numericValueExpr;
                var colorValueExpr;
                if (!fillRule) {
                    return;
                }
                if ($.isNumeric(propertyValue)) {
                    numericValueExpr = propertyValue !== undefined ? SQExprBuilder.double(+propertyValue) : undefined;
                    ;
                }
                if (propertyName === "minColor" || propertyName === "midColor" || propertyName === "maxColor") {
                    colorValueExpr = getColorExpressionValue(fillRule, propertyName, propertyValue);
                }
                if (propertyName === "minColor") {
                    updateMinColor(fillRule, colorValueExpr);
                }
                else if (propertyName === "midColor") {
                    updateMidColor(fillRule, colorValueExpr);
                }
                else if (propertyName === "maxColor") {
                    updateMaxColor(fillRule, colorValueExpr);
                }
                else if (propertyName === "minValue") {
                    updateMinValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "midValue") {
                    updateMidValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "maxValue") {
                    updateMaxValue(fillRule, numericValueExpr);
                }
                else if (propertyName === "diverging") {
                    if (propertyValue) {
                        fillRule = getLinearGradien3FillRuleDefinition(fillRule);
                    }
                    else {
                        fillRule = getLinearGradien2FillRuleDefinition(fillRule);
                    }
                    dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule;
                }
                else if (propertyName === "revertToDefault") {
                    fillRule = this.getDefaultFillRuleDefinition();
                    dataPointObjectDefinition.properties[FillRulePropertyIdentifier] = fillRule;
                }
            }
            GradientUtils.updateFillRule = updateFillRule;
            function getGradientSettings(baseFillRule) {
                if (baseFillRule) {
                    return getGradientSettingsFromRule(baseFillRule);
                }
                else {
                    return getDefaultGradientSettings();
                }
            }
            GradientUtils.getGradientSettings = getGradientSettings;
            function getFillRule(objectDefinitions) {
                var fillRuleDefinition = powerbi.data.DataViewObjectDefinitions.getValue(objectDefinitions, { objectName: DataPointPropertyIdentifier, propertyName: FillRulePropertyIdentifier }, null);
                return fillRuleDefinition;
            }
            GradientUtils.getFillRule = getFillRule;
            function getDefaultColors() {
                var dataColors = new powerbi.visuals.DataColorPalette();
                var maxColorInfo = dataColors.getColorByIndex(0);
                var colors = d3.scale.linear()
                    .domain([0, 100])
                    .range(["#ffffff", maxColorInfo.value]);
                var maxColor = maxColorInfo.value;
                var minColor = colors(20);
                var midColor = DefaultMidColor;
                return {
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                };
            }
            function getGradientSettingsFromRule(fillRule) {
                var maxColor;
                var minColor;
                var midColor = DefaultMidColor;
                var maxValue;
                var midValue;
                var minValue;
                var diverging = fillRule.linearGradient3 !== undefined;
                if (fillRule.linearGradient2) {
                    var maxColorExpr = fillRule.linearGradient2.max.color;
                    var minColorExpr = fillRule.linearGradient2.min.color;
                    var maxValueExpr = fillRule.linearGradient2.max.value;
                    var minValueExpr = fillRule.linearGradient2.min.value;
                    maxColor = maxColorExpr.value;
                    minColor = minColorExpr.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                }
                else if (fillRule.linearGradient3) {
                    var maxColorExpr = fillRule.linearGradient3.max.color;
                    var midColorExpr = fillRule.linearGradient3.mid.color;
                    var minColorExpr = fillRule.linearGradient3.min.color;
                    var maxValueExpr = fillRule.linearGradient3.max.value;
                    var midValueExpr = fillRule.linearGradient3.mid.value;
                    var minValueExpr = fillRule.linearGradient3.min.value;
                    maxColor = maxColorExpr.value;
                    midColor = midColorExpr.value;
                    minColor = minColorExpr.value;
                    if (maxValueExpr) {
                        maxValue = maxValueExpr.value;
                    }
                    if (midValueExpr) {
                        midValue = midValueExpr.value;
                    }
                    if (minValueExpr) {
                        minValue = minValueExpr.value;
                    }
                }
                return {
                    diverging: diverging,
                    minColor: minColor,
                    midColor: midColor,
                    maxColor: maxColor,
                    minValue: minValue,
                    midValue: midValue,
                    maxValue: maxValue,
                };
            }
            GradientUtils.getGradientSettingsFromRule = getGradientSettingsFromRule;
            function getLinearGradien2FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient2: {
                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
                    }
                };
                return fillRuleDefinition;
            }
            function getLinearGradien3FillRuleDefinition(baseFillRule) {
                var gradientSettings = getGradientSettings(baseFillRule);
                var fillRuleDefinition = {
                    linearGradient3: {
                        max: { color: SQExprBuilder.text(gradientSettings.maxColor) },
                        mid: { color: SQExprBuilder.text(gradientSettings.midColor) },
                        min: { color: SQExprBuilder.text(gradientSettings.minColor) },
                    }
                };
                return fillRuleDefinition;
            }
            function getDefaultColorExpression(fillRule, propertyName) {
                var defaultColor;
                var defaultFillRule;
                if (fillRule.linearGradient3) {
                    defaultFillRule = getLinearGradien3FillRuleDefinition();
                    if (propertyName === "minColor") {
                        defaultColor = defaultFillRule.linearGradient3.min.color;
                    }
                    else if (propertyName === "midColor") {
                        defaultColor = defaultFillRule.linearGradient3.mid.color;
                    }
                    else if (propertyName === "maxColor") {
                        defaultColor = defaultFillRule.linearGradient3.max.color;
                    }
                }
                else if (fillRule.linearGradient2) {
                    defaultFillRule = getLinearGradien2FillRuleDefinition();
                    if (propertyName === "minColor") {
                        defaultColor = defaultFillRule.linearGradient2.min.color;
                    }
                    else if (propertyName === "maxColor") {
                        defaultColor = defaultFillRule.linearGradient2.max.color;
                    }
                }
                return defaultColor;
            }
            function getColorExpressionValue(fillRule, propertyName, propertyValue) {
                var colorExpressionValue;
                if (propertyValue) {
                    colorExpressionValue = SQExprBuilder.text(propertyValue);
                }
                else {
                    colorExpressionValue = getDefaultColorExpression(fillRule, propertyName);
                }
                return colorExpressionValue;
            }
            function updateMinColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.color = colorExpressionValue;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.color = colorExpressionValue;
                }
            }
            function updateMidColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.color = colorExpressionValue;
                }
            }
            function updateMaxColor(fillRule, colorExpressionValue) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.color = colorExpressionValue;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.color = colorExpressionValue;
                }
            }
            function updateMinValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.min.value = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.min.value = value;
                }
            }
            function updateMidValue(fillRule, value) {
                if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.mid.value = value;
                }
            }
            function updateMaxValue(fillRule, value) {
                if (fillRule.linearGradient2) {
                    fillRule.linearGradient2.max.value = value;
                }
                else if (fillRule.linearGradient3) {
                    fillRule.linearGradient3.max.value = value;
                }
            }
        })(GradientUtils = visuals.GradientUtils || (visuals.GradientUtils = {}));
        ;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualBackgroundHelper;
        (function (visualBackgroundHelper) {
            function getDefaultColor() {
                return '#FFF';
            }
            visualBackgroundHelper.getDefaultColor = getDefaultColor;
            function getDefaultTransparency() {
                return 50;
            }
            visualBackgroundHelper.getDefaultTransparency = getDefaultTransparency;
            function getDefaultShow() {
                return false;
            }
            visualBackgroundHelper.getDefaultShow = getDefaultShow;
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                    transparency: getDefaultTransparency(),
                    show: getDefaultShow()
                };
            }
            visualBackgroundHelper.getDefaultValues = getDefaultValues;
            function enumeratePlot(enumeration, background) {
                var transparency = (background && background.transparency);
                if (transparency == null)
                    transparency = getDefaultTransparency();
                var backgroundObject = {
                    selector: null,
                    properties: {
                        transparency: transparency,
                        image: (background && background.image)
                    },
                    objectName: 'plotArea',
                };
                enumeration.pushInstance(backgroundObject);
            }
            visualBackgroundHelper.enumeratePlot = enumeratePlot;
            function renderBackgroundImage(background, visualElement, layout) {
                var image = background && background.image;
                var imageUrl = image && image.url;
                var imageFit = image && image.scaling;
                var imageTransparency = background && background.transparency;
                var backgroundImage = visualElement.children('.background-image');
                // If there were image and it was removed
                if (!imageUrl) {
                    if (backgroundImage.length !== 0)
                        backgroundImage.remove();
                    return;
                }
                // If this is the first edit of the image
                if (backgroundImage.length === 0) {
                    // Place the div only if the image exists in order to keep the html as clean as possible
                    visualElement.prepend('<div class="background-image"></div>');
                    backgroundImage = visualElement.children('.background-image');
                    // the div should be positioned absolute in order to get on top of the sibling svg
                    backgroundImage.css('position', 'absolute');
                }
                // Get the size and margins from the visual for the div will placed inside the plot area
                backgroundImage.css({
                    'width': layout.width,
                    'height': layout.height,
                    'margin-left': layout.left,
                    'margin-top': layout.top,
                });
                // Background properties
                backgroundImage.css({
                    'background-image': 'url(' + imageUrl + ')',
                    'background-repeat': 'no-repeat',
                    'opacity': (100 - imageTransparency) / 100,
                });
                switch (imageFit) {
                    // The image will be centered in its initial size
                    case visuals.imageScalingType.normal: {
                        backgroundImage.css({
                            'background-size': '',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                    // The image will be streched all over the background
                    case visuals.imageScalingType.fit: {
                        backgroundImage.css({
                            'background-size': '100% 100%',
                            'background-position': '',
                        });
                        break;
                    }
                    // The image will stretch on the width and the height will scale accordingly
                    case visuals.imageScalingType.fill: {
                        backgroundImage.css({
                            'background-size': '100%',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                    default: {
                        backgroundImage.css({
                            'background-size': '',
                            'background-position': '50% 50%',
                        });
                        break;
                    }
                }
            }
            visualBackgroundHelper.renderBackgroundImage = renderBackgroundImage;
        })(visualBackgroundHelper = visuals.visualBackgroundHelper || (visuals.visualBackgroundHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Selector = powerbi.data.Selector;
        /**
         * A helper class for building a VisualObjectInstanceEnumerationObject:
         * - Allows call chaining (e.g., builder.pushInstance({...}).pushInstance({...})
         * - Allows creating of containers (via pushContainer/popContainer)
         */
        var ObjectEnumerationBuilder = (function () {
            function ObjectEnumerationBuilder() {
            }
            ObjectEnumerationBuilder.prototype.pushInstance = function (instance) {
                debug.assertValue(instance, 'instance');
                var instances = this.instances;
                if (!instances) {
                    instances = this.instances = [];
                }
                var containerIdx = this.containerIdx;
                if (containerIdx != null) {
                    instance.containerIdx = containerIdx;
                }
                // Attempt to merge with an existing item if possible.
                for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
                    var existingInstance = instances_1[_i];
                    if (this.canMerge(existingInstance, instance)) {
                        this.extend(existingInstance, instance, 'properties');
                        this.extend(existingInstance, instance, 'validValues');
                        return this;
                    }
                }
                instances.push(instance);
                return this;
            };
            ObjectEnumerationBuilder.prototype.pushContainer = function (container) {
                debug.assertValue(container, 'container');
                var containers = this.containers;
                if (!containers) {
                    containers = this.containers = [];
                }
                var updatedLen = containers.push(container);
                this.containerIdx = updatedLen - 1;
                return this;
            };
            ObjectEnumerationBuilder.prototype.popContainer = function () {
                this.containerIdx = undefined;
                return this;
            };
            ObjectEnumerationBuilder.prototype.complete = function () {
                if (!this.instances)
                    return;
                var result = {
                    instances: this.instances,
                };
                var containers = this.containers;
                if (containers) {
                    result.containers = containers;
                }
                return result;
            };
            ObjectEnumerationBuilder.prototype.canMerge = function (x, y) {
                debug.assertValue(x, 'x');
                debug.assertValue(y, 'y');
                return x.objectName === y.objectName &&
                    x.containerIdx === y.containerIdx &&
                    Selector.equals(x.selector, y.selector);
            };
            ObjectEnumerationBuilder.prototype.extend = function (target, source, propertyName) {
                debug.assertValue(target, 'target');
                debug.assertValue(source, 'source');
                debug.assertValue(propertyName, 'propertyName');
                var sourceValues = source[propertyName];
                if (!sourceValues)
                    return;
                var targetValues = target[propertyName];
                if (!targetValues)
                    targetValues = target[propertyName] = {};
                for (var valuePropertyName in sourceValues) {
                    if (targetValues[valuePropertyName]) {
                        // Properties have first-writer-wins semantics.
                        continue;
                    }
                    targetValues[valuePropertyName] = sourceValues[valuePropertyName];
                }
            };
            ObjectEnumerationBuilder.merge = function (x, y) {
                var xNormalized = ObjectEnumerationBuilder.normalize(x);
                var yNormalized = ObjectEnumerationBuilder.normalize(y);
                if (!xNormalized || !yNormalized)
                    return xNormalized || yNormalized;
                debug.assertValue(xNormalized, 'xNormalized');
                debug.assertValue(yNormalized, 'yNormalized');
                var xCategoryCount = xNormalized.containers ? xNormalized.containers.length : 0;
                for (var _i = 0, _a = yNormalized.instances; _i < _a.length; _i++) {
                    var yInstance = _a[_i];
                    xNormalized.instances.push(yInstance);
                    if (yInstance.containerIdx != null)
                        yInstance.containerIdx += xCategoryCount;
                }
                var yContainers = yNormalized.containers;
                if (!_.isEmpty(yContainers)) {
                    if (xNormalized.containers)
                        Array.prototype.push.apply(xNormalized.containers, yContainers);
                    else
                        xNormalized.containers = yContainers;
                }
                return xNormalized;
            };
            ObjectEnumerationBuilder.normalize = function (x) {
                debug.assertAnyValue(x, 'x');
                if (_.isArray(x)) {
                    return { instances: x };
                }
                return x;
            };
            ObjectEnumerationBuilder.getContainerForInstance = function (enumeration, instance) {
                debug.assertValue(enumeration, "enumeration");
                debug.assertValue(instance, "instance");
                debug.assertValue(enumeration.containers, "containers");
                debug.assert(enumeration.containers.length > instance.containerIdx, "no container found in containers collection");
                return enumeration.containers[instance.containerIdx];
            };
            return ObjectEnumerationBuilder;
        }());
        visuals.ObjectEnumerationBuilder = ObjectEnumerationBuilder;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Helper class for Visual border styles */
        var VisualBorderUtil;
        (function (VisualBorderUtil) {
            /**
             * Gets The Boder Width string (e.g. 0px 1px 2px 3px)
             * @param {OutlineType} string Type of the Outline, one of Visuals.outline.<XX> const strings
             * @param {number} outlineWeight Weight of the outline in pixels
             * @returns String representing the Border Width
             */
            function getBorderWidth(outlineType, outlineWeight) {
                switch (outlineType) {
                    case visuals.outline.none:
                        return '0px';
                    case visuals.outline.bottomOnly:
                        return '0px 0px ' + outlineWeight + 'px 0px';
                    case visuals.outline.topOnly:
                        return outlineWeight + 'px 0px 0px 0px';
                    case visuals.outline.leftOnly:
                        return '0px 0px 0px ' + outlineWeight + 'px';
                    case visuals.outline.rightOnly:
                        return '0px ' + outlineWeight + 'px 0px 0px';
                    case visuals.outline.topBottom:
                        return outlineWeight + 'px 0px';
                    case visuals.outline.leftRight:
                        return '0px ' + outlineWeight + 'px';
                    case visuals.outline.frame:
                        return outlineWeight + 'px';
                    default:
                        debug.assertFail('Unexpected OutlineType value: ' + outlineType);
                        return '0px';
                }
            }
            VisualBorderUtil.getBorderWidth = getBorderWidth;
        })(VisualBorderUtil = visuals.VisualBorderUtil || (visuals.VisualBorderUtil = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /** Transformation matrix math wrapper */
        var Transform = (function () {
            // Constructor
            function Transform(m) {
                this.matrix = m || {
                    m00: 1, m01: 0, m02: 0,
                    m10: 0, m11: 1, m12: 0,
                };
            }
            // Methods
            Transform.prototype.applyToPoint = function (point) {
                if (!point) {
                    return point;
                }
                var m = this.matrix;
                return {
                    x: m.m00 * point.x + m.m01 * point.y + m.m02,
                    y: m.m10 * point.x + m.m11 * point.y + m.m12,
                };
            };
            Transform.prototype.applyToRect = function (rect) {
                if (!rect) {
                    return rect;
                }
                var x0 = rect.left;
                var y0 = rect.top;
                var m = this.matrix;
                var isScaled = m.m00 !== 1 || m.m11 !== 1;
                var isRotated = m.m01 !== 0 || m.m10 !== 0;
                if (!isRotated && !isScaled) {
                    // Optimize for the translation only case
                    return { left: x0 + m.m02, top: y0 + m.m12, width: rect.width, height: rect.height };
                }
                var x1 = rect.left + rect.width;
                var y1 = rect.top + rect.height;
                var minX;
                var maxX;
                var minY;
                var maxY;
                if (isRotated) {
                    var p0x = m.m00 * x0 + m.m01 * y0 + m.m02;
                    var p0y = m.m10 * x0 + m.m11 * y0 + m.m12;
                    var p1x = m.m00 * x0 + m.m01 * y1 + m.m02;
                    var p1y = m.m10 * x0 + m.m11 * y1 + m.m12;
                    var p2x = m.m00 * x1 + m.m01 * y0 + m.m02;
                    var p2y = m.m10 * x1 + m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m01 * y1 + m.m02;
                    var p3y = m.m10 * x1 + m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p1x, p2x, p3x);
                    maxX = Math.max(p0x, p1x, p2x, p3x);
                    minY = Math.min(p0y, p1y, p2y, p3y);
                    maxY = Math.max(p0y, p1y, p2y, p3y);
                }
                else {
                    var p0x = m.m00 * x0 + m.m02;
                    var p0y = m.m11 * y0 + m.m12;
                    var p3x = m.m00 * x1 + m.m02;
                    var p3y = m.m11 * y1 + m.m12;
                    minX = Math.min(p0x, p3x);
                    maxX = Math.max(p0x, p3x);
                    minY = Math.min(p0y, p3y);
                    maxY = Math.max(p0y, p3y);
                }
                return { left: minX, top: minY, width: maxX - minX, height: maxY - minY };
            };
            Transform.prototype.translate = function (xOffset, yOffset) {
                if (xOffset !== 0 || yOffset !== 0) {
                    var m = createTranslateMatrix(xOffset, yOffset);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.scale = function (xScale, yScale) {
                if (xScale !== 1 || yScale !== 1) {
                    var m = createScaleMatrix(xScale, yScale);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.rotate = function (angleInRadians) {
                if (angleInRadians !== 0) {
                    var m = createRotationMatrix(angleInRadians);
                    this.matrix = multiplyMatrices(this.matrix, m);
                    this._inverse = null;
                }
            };
            Transform.prototype.add = function (other) {
                if (other) {
                    this.matrix = multiplyMatrices(this.matrix, other.matrix);
                    this._inverse = null;
                }
            };
            Transform.prototype.getInverse = function () {
                if (!this._inverse) {
                    this._inverse = new Transform(createInverseMatrix(this.matrix));
                }
                return this._inverse;
            };
            return Transform;
        }());
        visuals.Transform = Transform;
        function createTranslateMatrix(xOffset, yOffset) {
            return {
                m00: 1, m01: 0, m02: xOffset,
                m10: 0, m11: 1, m12: yOffset,
            };
        }
        visuals.createTranslateMatrix = createTranslateMatrix;
        function createScaleMatrix(xScale, yScale) {
            return {
                m00: xScale, m01: 0, m02: 0,
                m10: 0, m11: yScale, m12: 0
            };
        }
        visuals.createScaleMatrix = createScaleMatrix;
        function createRotationMatrix(angleInRads) {
            var a = angleInRads;
            var sinA = Math.sin(a);
            var cosA = Math.cos(a);
            return {
                m00: cosA, m01: -sinA, m02: 0,
                m10: sinA, m11: cosA, m12: 0,
            };
        }
        visuals.createRotationMatrix = createRotationMatrix;
        function createInverseMatrix(m) {
            var determinant = m.m00 * m.m11 - m.m01 * m.m10;
            var invdet = 1 / determinant;
            return {
                m00: m.m11 * invdet,
                m01: -m.m01 * invdet,
                m02: (m.m01 * m.m12 - m.m02 * m.m11) * invdet,
                m10: -m.m10 * invdet,
                m11: m.m00 * invdet,
                m12: -(m.m00 * m.m12 - m.m10 * m.m02) * invdet
            };
        }
        visuals.createInverseMatrix = createInverseMatrix;
        function multiplyMatrices(a, b) {
            return {
                m00: a.m00 * b.m00 + a.m01 * b.m10,
                m01: a.m00 * b.m01 + a.m01 * b.m11,
                m02: a.m00 * b.m02 + a.m01 * b.m12 + a.m02,
                m10: a.m10 * b.m00 + a.m11 * b.m10,
                m11: a.m10 * b.m01 + a.m11 * b.m11,
                m12: a.m10 * b.m02 + a.m11 * b.m12 + a.m12,
            };
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Color = jsCommon.Color;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var TrendLineHelper;
        (function (TrendLineHelper) {
            var trendLinePropertyNames = {
                show: 'show',
                lineColor: 'lineColor',
                transparency: 'transparency',
                style: 'style',
                combineSeries: 'combineSeries',
                useHighlightValues: 'useHighlightValues',
            };
            var trendObjectName = 'trend';
            TrendLineHelper.defaults = {
                lineColor: { solid: { color: '#000' } },
                lineStyle: visuals.lineStyle.dashed,
                transparency: 0,
                combineSeries: true,
                useHighlightValues: true,
            };
            var TrendLineClassSelector = jsCommon.CssConstants.createClassAndSelector('trend-line');
            var TrendLineLayerClassSelector = jsCommon.CssConstants.createClassAndSelector('trend-line-layer');
            function enumerateObjectInstances(enumeration, trendLines) {
                debug.assertValue(enumeration, 'enumeration');
                if (_.isEmpty(trendLines)) {
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: false,
                            lineColor: TrendLineHelper.defaults.lineColor,
                            transparency: TrendLineHelper.defaults.transparency,
                            style: TrendLineHelper.defaults.lineStyle,
                            combineSeries: TrendLineHelper.defaults.combineSeries,
                        },
                        objectName: trendObjectName,
                    });
                    return;
                }
                var trendLine = trendLines[0];
                var properties = {};
                properties['show'] = trendLine.show;
                if (trendLine.combineSeries)
                    properties['lineColor'] = trendLine.lineColor;
                properties['transparency'] = trendLine.transparency;
                properties['style'] = trendLine.style;
                properties['combineSeries'] = trendLine.combineSeries;
                properties['useHighlightValues'] = trendLine.useHighlightValues;
                enumeration.pushInstance({
                    selector: null,
                    properties: properties,
                    objectName: trendObjectName,
                });
            }
            TrendLineHelper.enumerateObjectInstances = enumerateObjectInstances;
            function isDataViewForRegression(dataView) {
                return DataRoleHelper.hasRoleInDataView(dataView, 'regression.X');
            }
            TrendLineHelper.isDataViewForRegression = isDataViewForRegression;
            function readDataView(dataView, sourceDataView, y2, colors) {
                if (!dataView || !dataView.categorical)
                    return;
                var categorical = dataView.categorical;
                if (_.isEmpty(categorical.categories) || _.isEmpty(categorical.values))
                    return;
                var categories = categorical.categories[0].values;
                var groups = categorical.values.grouped();
                if (!categories || !groups)
                    return;
                var trendProperties = powerbi.DataViewObjects.getObject(dataView.metadata.objects, trendObjectName, {});
                var show = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.show, false);
                var lineColor = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.lineColor);
                var transparency = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.transparency, TrendLineHelper.defaults.transparency);
                var style = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.style, TrendLineHelper.defaults.lineStyle);
                var combineSeries = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.combineSeries, TrendLineHelper.defaults.combineSeries);
                var useHighlightValues = powerbi.DataViewObject.getValue(trendProperties, trendLinePropertyNames.useHighlightValues, TrendLineHelper.defaults.useHighlightValues);
                // Trend lines generated by Insights will be putting line color here, we should convert the Insights code to create
                // "trend" objects like above and write the upgrade code to handle pinned tiles with trend lines before removing any feature switch.
                var legacyColor = powerbi.DataViewObjects.getValue(categorical.values[0].source.objects, visuals.lineChartProps.dataPoint.fill);
                if (legacyColor)
                    lineColor = legacyColor;
                var objects = sourceDataView.metadata.objects;
                var defaultColor = powerbi.DataViewObjects.getFillColor(objects, { objectName: 'dataPoint', propertyName: 'defaultColor' });
                var colorHelper = new visuals.ColorHelper(colors, { objectName: 'dataPoint', propertyName: 'fill' }, defaultColor);
                var trendLines = [];
                for (var groupIndex = 0; groupIndex < groups.length; groupIndex++) {
                    var group = groups[groupIndex];
                    var points = [];
                    for (var i = 0; i < categories.length; i++) {
                        var x = visuals.AxisHelper.normalizeNonFiniteNumber(categories[i]);
                        // There is a assumption here that the group only has 1 set of values in it. Once we add more things like confidence bands,
                        // this assumption will not be true. This assumption comes from the way dataViewRegresion generates the dataView
                        var valueColumn = group.values[0];
                        var values = void 0;
                        if (useHighlightValues && valueColumn.highlights) {
                            values = valueColumn.highlights;
                        }
                        else {
                            values = valueColumn.values;
                        }
                        var y = visuals.AxisHelper.normalizeNonFiniteNumber(values[i]);
                        if (x != null && y != null) {
                            points.push({
                                x: x,
                                y: y,
                            });
                        }
                    }
                    var seriesLineColor = void 0;
                    if (combineSeries) {
                        seriesLineColor = lineColor || TrendLineHelper.defaults.lineColor;
                    }
                    else {
                        // TODO: This should likely be delegated to the layer which knows how to choose the correct color for any given situation.
                        if (sourceDataView.categorical.values.source) {
                            // Dynamic series
                            var sourceGroups = sourceDataView.categorical.values.grouped();
                            var color = colorHelper.getColorForSeriesValue(sourceGroups[groupIndex].objects, sourceDataView.categorical.values.identityFields, group.name);
                            color = darkenTrendLineColor(color);
                            seriesLineColor = { solid: { color: color } };
                        }
                        else {
                            // Static series
                            var matchingMeasure = sourceDataView.categorical.values[groupIndex];
                            var color = colorHelper.getColorForMeasure(matchingMeasure.source.objects, group.name);
                            color = darkenTrendLineColor(color);
                            seriesLineColor = { solid: { color: color } };
                        }
                    }
                    trendLines.push({
                        points: points,
                        show: show,
                        lineColor: seriesLineColor,
                        transparency: transparency,
                        style: style,
                        combineSeries: combineSeries,
                        useHighlightValues: useHighlightValues,
                        y2Axis: y2,
                    });
                }
                return trendLines;
            }
            TrendLineHelper.readDataView = readDataView;
            function darkenTrendLineColor(color) {
                var rgb = Color.parseColorString(color);
                rgb = Color.darken(rgb, 20);
                return Color.rgbString(rgb);
            }
            TrendLineHelper.darkenTrendLineColor = darkenTrendLineColor;
            function render(trendLines, graphicsContext, axes, viewport) {
                var layer = graphicsContext.select(TrendLineLayerClassSelector.selector);
                if (layer.empty()) {
                    layer = graphicsContext.append('svg').classed(TrendLineLayerClassSelector.class, true);
                }
                layer.attr({
                    height: viewport.height,
                    width: viewport.width
                });
                var lines = layer.selectAll(TrendLineClassSelector.selector).data(trendLines || []);
                lines.enter().append('path').classed(TrendLineClassSelector.class, true);
                lines
                    .attr('d', function (d) {
                    var xScale = axes.x.scale;
                    var yScale = (d.y2Axis && axes.y2) ? axes.y2.scale : axes.y1.scale;
                    var pathGen = d3.svg.line()
                        .x(function (point) { return xScale(point.x); })
                        .y(function (point) { return yScale(point.y); });
                    return pathGen(_.filter(d.points, function (point) { return point.x != null && point.y != null; }));
                });
                lines.each(function (d) {
                    var line = d3.select(this);
                    var style = {};
                    style.stroke = d.lineColor.solid.color;
                    if (d.transparency != null) {
                        style['stroke-opacity'] = (100 - d.transparency) / 100;
                    }
                    if (d.style === visuals.lineStyle.dashed) {
                        style['stroke-dasharray'] = "5, 5";
                    }
                    else if (d.style === visuals.lineStyle.dotted) {
                        style['stroke-dasharray'] = "1, 5";
                        style['stroke-linecap'] = "round";
                    }
                    else if (d.style === visuals.lineStyle.solid) {
                        style['stroke-dasharray'] = null;
                        style['stroke-linecap'] = null;
                    }
                    line.style(style);
                });
                lines.exit().remove();
            }
            TrendLineHelper.render = render;
        })(TrendLineHelper = visuals.TrendLineHelper || (visuals.TrendLineHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visibilityHelper;
        (function (visibilityHelper) {
            /**  Helper method that uses jQuery :visible selector to determine if visual is visible.
                Elements are considered visible if they consume space in the document. Visible elements have a width or height that is greater than zero.
                Elements with visibility: hidden or opacity: 0 are considered visible, since they still consume space in the layout.
            */
            function partiallyVisible(element) {
                return element.is(":visible");
            }
            visibilityHelper.partiallyVisible = partiallyVisible;
        })(visibilityHelper = visuals.visibilityHelper || (visuals.visibilityHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SemanticFilter = powerbi.data.SemanticFilter;
        var UrlUtils = jsCommon.UrlUtils;
        /** Helper module for converting a DataView into SlicerData. */
        var DataConversion;
        (function (DataConversion) {
            function convert(dataView, localizedSelectAllText, interactivityService, hostServices) {
                debug.assertValue(hostServices, 'hostServices');
                if (!dataView || !dataView.categorical || _.isEmpty(dataView.categorical.categories))
                    return;
                var identityFields = dataView.categorical.categories[0].identityFields;
                if (!identityFields)
                    return;
                var filter = (dataView.metadata &&
                    dataView.metadata.objects &&
                    powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.slicerProps.filterPropertyIdentifier));
                var analyzer = hostServices.analyzeFilter({
                    dataView: dataView,
                    defaultValuePropertyId: visuals.slicerProps.defaultValue,
                    filter: filter,
                    fieldSQExprs: identityFields
                });
                if (!analyzer)
                    return;
                var analyzedSemanticFilter = analyzer.filter;
                if (analyzedSemanticFilter && !SemanticFilter.isSameFilter(analyzedSemanticFilter, filter)) {
                    interactivityService.handleClearSelection();
                    var filterPropertyIdentifier = visuals.slicerProps.filterPropertyIdentifier;
                    var properties = {};
                    properties[filterPropertyIdentifier.propertyName] = analyzer.filter;
                    var instance = {
                        objectName: filterPropertyIdentifier.objectName,
                        selector: undefined,
                        properties: properties
                    };
                    var changes = {
                        merge: [instance]
                    };
                    hostServices.persistProperties(changes);
                }
                var slicerData = getSlicerData(analyzer, dataView.metadata, dataView.categorical, localizedSelectAllText, interactivityService, hostServices);
                return slicerData;
            }
            DataConversion.convert = convert;
            function getSlicerData(analyzer, dataViewMetadata, categorical, localizedSelectAllText, interactivityService, hostServices) {
                var isInvertedSelectionMode = interactivityService && interactivityService.isSelectionModeInverted();
                var selectedScopeIds = analyzer.selectedIdentities;
                var hasSelectionOverride = !_.isEmpty(selectedScopeIds) || isInvertedSelectionMode === true;
                if (!isInvertedSelectionMode && analyzer.filter)
                    isInvertedSelectionMode = analyzer.isNotFilter;
                if (interactivityService) {
                    // To indicate whether the selection is Not selected items
                    interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
                    // defaultValueMode will be used when determine show/hide clear button.
                    interactivityService.setDefaultValueMode(SemanticFilter.isDefaultFilter(analyzer.filter));
                }
                var category = categorical.categories[0];
                var categoryValuesLen = category && category.values ? category.values.length : 0;
                var slicerDataPoints = [];
                var formatString = visuals.valueFormatter.getFormatString(category.source, visuals.slicerProps.formatString);
                var numOfSelected = 0;
                var valueCounts = categorical.values && categorical.values[0] && categorical.values[0].values;
                if (valueCounts && _.isEmpty(valueCounts))
                    valueCounts = undefined;
                debug.assert(!valueCounts || valueCounts.length === categoryValuesLen, "valueCounts doesn't match values");
                var isImageData = dataViewMetadata &&
                    !_.isEmpty(dataViewMetadata.columns) && visuals.converterHelper.isImageUrlColumn(dataViewMetadata.columns[0]);
                var displayNameIdentityPairs = [];
                for (var i = 0; i < categoryValuesLen; i++) {
                    var scopeId = category.identity && category.identity[i];
                    var value = category.values && category.values[i];
                    var count = valueCounts && valueCounts[i];
                    var isRetained = hasSelectionOverride ? visuals.SlicerUtil.tryRemoveValueFromRetainedList(scopeId, selectedScopeIds) : false;
                    var label = visuals.valueFormatter.format(value, formatString);
                    var isImage = isImageData === true && UrlUtils.isValidImageUrl(label);
                    var slicerData_1 = {
                        value: label,
                        tooltip: label,
                        identity: visuals.SelectionId.createWithId(scopeId),
                        selected: isRetained,
                        count: count,
                        isImage: isImage,
                    };
                    if (isRetained) {
                        var displayNameIdentityPair = {
                            displayName: label,
                            identity: scopeId
                        };
                        displayNameIdentityPairs.push(displayNameIdentityPair);
                    }
                    slicerDataPoints.push(slicerData_1);
                    if (slicerData_1.selected)
                        numOfSelected++;
                }
                if (!_.isEmpty(displayNameIdentityPairs))
                    hostServices.setIdentityDisplayNames(displayNameIdentityPairs);
                // Add retained values that are not in the returned dataview to the value list.
                if (hasSelectionOverride && !_.isEmpty(selectedScopeIds)) {
                    var displayNamesIdentityPairs = hostServices.getIdentityDisplayNames(selectedScopeIds);
                    if (!_.isEmpty(displayNamesIdentityPairs)) {
                        for (var _i = 0, displayNamesIdentityPairs_1 = displayNamesIdentityPairs; _i < displayNamesIdentityPairs_1.length; _i++) {
                            var pair = displayNamesIdentityPairs_1[_i];
                            // When there is no valueCounts, set count to be undefined, otherwise use 0 as the count for retained values
                            var slicerData_2 = {
                                value: pair.displayName,
                                tooltip: pair.displayName,
                                identity: visuals.SelectionId.createWithId(pair.identity),
                                selected: true,
                                count: valueCounts != null ? 0 : undefined,
                            };
                            slicerDataPoints.push(slicerData_2);
                            numOfSelected++;
                        }
                    }
                }
                var defaultSettings = createDefaultSettings(dataViewMetadata);
                if (defaultSettings.selection.selectAllCheckboxEnabled) {
                    //If selectAllCheckboxEnabled, and all the items are selected and there is no more data to request, then unselect all and toggle the invertedSelectionMode
                    if (numOfSelected > 0 && !dataViewMetadata.segment && numOfSelected === slicerDataPoints.length) {
                        isInvertedSelectionMode = !isInvertedSelectionMode;
                        interactivityService.setSelectionModeInverted(isInvertedSelectionMode);
                        for (var _a = 0, slicerDataPoints_1 = slicerDataPoints; _a < slicerDataPoints_1.length; _a++) {
                            var item = slicerDataPoints_1[_a];
                            item.selected = false;
                        }
                        hasSelectionOverride = false;
                        numOfSelected = 0;
                    }
                    slicerDataPoints.unshift({
                        value: localizedSelectAllText,
                        tooltip: localizedSelectAllText,
                        identity: visuals.SelectionId.createWithMeasure(localizedSelectAllText),
                        selected: !!isInvertedSelectionMode && numOfSelected === 0,
                        isSelectAllDataPoint: true,
                        count: undefined,
                    });
                }
                var slicerData = {
                    categorySourceName: category.source.displayName,
                    slicerSettings: defaultSettings,
                    slicerDataPoints: slicerDataPoints,
                    hasSelectionOverride: hasSelectionOverride,
                    defaultValue: analyzer.defaultValue,
                };
                return slicerData;
            }
            function createDefaultSettings(dataViewMetadata) {
                var defaultSettings = visuals.Slicer.DefaultStyleProperties();
                var objects = dataViewMetadata.objects;
                var forceSingleSelect = dataViewMetadata.columns && _.some(dataViewMetadata.columns, function (column) { return column.discourageAggregationAcrossGroups; });
                if (objects) {
                    defaultSettings.general.outlineColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.general.outlineColor, defaultSettings.general.outlineColor);
                    defaultSettings.general.outlineWeight = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.outlineWeight, defaultSettings.general.outlineWeight);
                    defaultSettings.general.orientation = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.general.orientation, defaultSettings.general.orientation);
                    defaultSettings.header.show = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.show, defaultSettings.header.show);
                    defaultSettings.header.fontColor = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.fontColor, defaultSettings.header.fontColor);
                    var headerBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.header.background);
                    if (headerBackground)
                        defaultSettings.header.background = headerBackground;
                    defaultSettings.header.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.outline, defaultSettings.header.outline);
                    defaultSettings.header.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.header.textSize, defaultSettings.header.textSize);
                    defaultSettings.slicerText.color = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.fontColor, defaultSettings.slicerText.color);
                    var textBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.slicerProps.items.background);
                    if (textBackground)
                        defaultSettings.slicerText.background = textBackground;
                    defaultSettings.slicerText.outline = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.outline, defaultSettings.slicerText.outline);
                    defaultSettings.slicerText.textSize = powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.items.textSize, defaultSettings.slicerText.textSize);
                    defaultSettings.selection.selectAllCheckboxEnabled = !forceSingleSelect && powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.selectAllCheckboxEnabled, defaultSettings.selection.selectAllCheckboxEnabled);
                    defaultSettings.selection.singleSelect = forceSingleSelect || powerbi.DataViewObjects.getValue(objects, visuals.slicerProps.selection.singleSelect, defaultSettings.selection.singleSelect);
                }
                return defaultSettings;
            }
        })(DataConversion = visuals.DataConversion || (visuals.DataConversion = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var shapes = powerbi.visuals.shapes;
    /**
    * Rectangle orientation. Rectangle orientation is used to define vertical or horizontal orientation
    * and starting/ending side of the rectangle.
    */
    (function (RectOrientation) {
        /** Rectangle with no specific orientation. */
        RectOrientation[RectOrientation["None"] = 0] = "None";
        /** Vertical rectangle with base at the bottom. */
        RectOrientation[RectOrientation["VerticalBottomTop"] = 1] = "VerticalBottomTop";
        /** Vertical rectangle with base at the top. */
        RectOrientation[RectOrientation["VerticalTopBottom"] = 2] = "VerticalTopBottom";
        /** Horizontal rectangle with base at the left. */
        RectOrientation[RectOrientation["HorizontalLeftRight"] = 3] = "HorizontalLeftRight";
        /** Horizontal rectangle with base at the right. */
        RectOrientation[RectOrientation["HorizontalRightLeft"] = 4] = "HorizontalRightLeft";
    })(powerbi.RectOrientation || (powerbi.RectOrientation = {}));
    var RectOrientation = powerbi.RectOrientation;
    /**
    * Defines if panel elements are allowed to be positioned
    * outside of the panel boundaries.
    */
    (function (OutsidePlacement) {
        /** Elements can be positioned outside of the panel. */
        OutsidePlacement[OutsidePlacement["Allowed"] = 0] = "Allowed";
        /** Elements can not be positioned outside of the panel. */
        OutsidePlacement[OutsidePlacement["Disallowed"] = 1] = "Disallowed";
        /** Elements can be partially outside of the panel. */
        OutsidePlacement[OutsidePlacement["Partial"] = 2] = "Partial";
    })(powerbi.OutsidePlacement || (powerbi.OutsidePlacement = {}));
    var OutsidePlacement = powerbi.OutsidePlacement;
    /**
    * Arranges label elements using the anchor point or rectangle. Collisions
    * between elements can be automatically detected and as a result elements
    * can be repositioned or get hidden.
    */
    var DataLabelManager = (function () {
        function DataLabelManager() {
            this.movingStep = 3;
            this.hideOverlapped = true;
            // The global settings for all labels. 
            // They can be oweridden by each label we add into the panel, because contains same properties.
            this.defaultDataLabelSettings = {
                anchorMargin: DataLabelManager.DefaultAnchorMargin,
                anchorRectOrientation: RectOrientation.None,
                contentPosition: 128 /* BottomCenter */,
                outsidePlacement: OutsidePlacement.Disallowed,
                maximumMovingDistance: DataLabelManager.DefaultMaximumMovingDistance,
                minimumMovingDistance: DataLabelManager.DefaultMinimumMovingDistance,
                validContentPositions: 128 /* BottomCenter */,
                opacity: 1
            };
        }
        Object.defineProperty(DataLabelManager.prototype, "defaultSettings", {
            get: function () {
                return this.defaultDataLabelSettings;
            },
            enumerable: true,
            configurable: true
        });
        /** Arranges the lables position and visibility*/
        DataLabelManager.prototype.hideCollidedLabels = function (viewport, data, layout, addTransform) {
            if (addTransform === void 0) { addTransform = false; }
            // Split size into a grid
            var arrangeGrid = new DataLabelArrangeGrid(viewport, data, layout);
            var filteredData = [];
            var transform = { x: 0, y: 0 };
            if (addTransform) {
                transform.x = viewport.width / 2;
                transform.y = viewport.height / 2;
            }
            for (var i = 0, len = data.length; i < len; i++) {
                // Filter unwanted data points
                if (!layout.filter(data[i]))
                    continue;
                // Set default values where properties values are undefined
                var info = this.getLabelInfo(data[i]);
                info.anchorPoint = {
                    x: layout.labelLayout.x(data[i]) + transform.x,
                    y: layout.labelLayout.y(data[i]) + transform.y,
                };
                var position = this.calculateContentPosition(info, info.contentPosition, data[i].size, info.anchorMargin);
                if (DataLabelManager.isValid(position) && !this.hasCollisions(arrangeGrid, info, position, viewport)) {
                    data[i].labelX = position.left - transform.x;
                    data[i].labelY = position.top - transform.y;
                    // Keep track of all panel elements positions.
                    arrangeGrid.add(info, position);
                    // Save all data points to display
                    filteredData.push(data[i]);
                }
            }
            return filteredData;
        };
        /**
         * Merges the label element info with the panel element info and returns correct label info.
         * @param source The label info.
         */
        DataLabelManager.prototype.getLabelInfo = function (source) {
            var settings = this.defaultDataLabelSettings;
            source.anchorMargin = source.anchorMargin !== undefined ? source.anchorMargin : settings.anchorMargin;
            source.anchorRectOrientation = source.anchorRectOrientation !== undefined ? source.anchorRectOrientation : settings.anchorRectOrientation;
            source.contentPosition = source.contentPosition !== undefined ? source.contentPosition : settings.contentPosition;
            source.maximumMovingDistance = source.maximumMovingDistance !== undefined ? source.maximumMovingDistance : settings.maximumMovingDistance;
            source.minimumMovingDistance = source.minimumMovingDistance !== undefined ? source.minimumMovingDistance : settings.minimumMovingDistance;
            source.outsidePlacement = source.outsidePlacement !== undefined ? source.outsidePlacement : settings.outsidePlacement;
            source.validContentPositions = source.validContentPositions !== undefined ? source.validContentPositions : settings.validContentPositions;
            source.opacity = source.opacity !== undefined ? source.opacity : settings.opacity;
            source.maximumMovingDistance += source.anchorMargin;
            return source;
        };
        /**
        * (Private) Calculates element position using anchor point..
        */
        DataLabelManager.prototype.calculateContentPositionFromPoint = function (anchorPoint, contentPosition, contentSize, offset) {
            var position = { x: 0, y: 0 };
            if (anchorPoint) {
                if (anchorPoint.x !== undefined && isFinite(anchorPoint.x)) {
                    position.x = anchorPoint.x;
                    switch (contentPosition) {
                        // D3 positions the label in the middle by default.
                        // The algorithem asumed the label was positioned in right so this is why we add/substract half width
                        case 1 /* TopLeft */:
                        case 8 /* MiddleLeft */:
                        case 64 /* BottomLeft */:
                            position.x -= contentSize.width / 2.0;
                            break;
                        case 4 /* TopRight */:
                        case 32 /* MiddleRight */:
                        case 256 /* BottomRight */:
                            position.x += contentSize.width / 2.0;
                            break;
                    }
                }
                if (anchorPoint.y !== undefined && isFinite(anchorPoint.y)) {
                    position.y = anchorPoint.y;
                    switch (contentPosition) {
                        case 8 /* MiddleLeft */:
                        case 16 /* MiddleCenter */:
                        case 32 /* MiddleRight */:
                            position.y -= contentSize.height / 2.0;
                            break;
                        case 4 /* TopRight */:
                        case 1 /* TopLeft */:
                        case 2 /* TopCenter */:
                            position.y -= contentSize.height;
                            break;
                    }
                }
                if (offset !== undefined && isFinite(offset)) {
                    switch (contentPosition) {
                        case 1 /* TopLeft */:
                            position.x -= offset;
                            position.y -= offset;
                            break;
                        case 8 /* MiddleLeft */:
                            position.x -= offset;
                            break;
                        case 64 /* BottomLeft */:
                            position.x -= offset;
                            position.y += offset;
                            break;
                        case 2 /* TopCenter */:
                            position.y -= offset;
                            break;
                        case 16 /* MiddleCenter */:
                            // Offset is not applied
                            break;
                        case 128 /* BottomCenter */:
                            position.y += offset;
                            break;
                        case 4 /* TopRight */:
                            position.x += offset;
                            position.y -= offset;
                            break;
                        case 32 /* MiddleRight */:
                            position.x += offset;
                            break;
                        case 256 /* BottomRight */:
                            position.x += offset;
                            position.y += offset;
                            break;
                        default:
                            debug.assertFail("Unsupported content position.");
                            break;
                    }
                }
            }
            return { left: position.x, top: position.y, width: contentSize.width, height: contentSize.height };
        };
        /** (Private) Calculates element position using anchor rect. */
        DataLabelManager.prototype.calculateContentPositionFromRect = function (anchorRect, anchorRectOrientation, contentPosition, contentSize, offset) {
            switch (contentPosition) {
                case 512 /* InsideCenter */:
                    return this.handleInsideCenterPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 2048 /* InsideEnd */:
                    return this.handleInsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 1024 /* InsideBase */:
                    return this.handleInsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 8192 /* OutsideEnd */:
                    return this.handleOutsideEndPosition(anchorRectOrientation, contentSize, anchorRect, offset);
                case 4096 /* OutsideBase */:
                    return this.handleOutsideBasePosition(anchorRectOrientation, contentSize, anchorRect, offset);
                default:
                    debug.assertFail("Unsupported ContentPosition.");
            }
            return { left: 0, top: 0, width: -1, height: -1 };
        };
        /** (Private) Calculates element inside center position using anchor rect. */
        DataLabelManager.prototype.handleInsideCenterPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.middleVertical(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                case RectOrientation.HorizontalRightLeft:
                default:
                    return LocationConverter.middleHorizontal(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element inside end position using anchor rect. */
        DataLabelManager.prototype.handleInsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element inside base position using anchor rect. */
        DataLabelManager.prototype.handleInsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.bottomInside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.topInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.rightInside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.leftInside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element outside end position using anchor rect. */
        DataLabelManager.prototype.handleOutsideEndPosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
            }
        };
        /** (Private) Calculates element outside base position using anchor rect. */
        DataLabelManager.prototype.handleOutsideBasePosition = function (anchorRectOrientation, contentSize, anchorRect, offset) {
            switch (anchorRectOrientation) {
                case RectOrientation.VerticalBottomTop:
                    return LocationConverter.bottomOutside(contentSize, anchorRect, offset);
                case RectOrientation.VerticalTopBottom:
                    return LocationConverter.topOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalRightLeft:
                    return LocationConverter.rightOutside(contentSize, anchorRect, offset);
                case RectOrientation.HorizontalLeftRight:
                default:
                    return LocationConverter.leftOutside(contentSize, anchorRect, offset);
            }
        };
        /**  (Private) Calculates element position. */
        DataLabelManager.prototype.calculateContentPosition = function (anchoredElementInfo, contentPosition, contentSize, offset) {
            if (contentPosition !== 2048 /* InsideEnd */ &&
                contentPosition !== 512 /* InsideCenter */ &&
                contentPosition !== 1024 /* InsideBase */ &&
                contentPosition !== 4096 /* OutsideBase */ &&
                contentPosition !== 8192 /* OutsideEnd */) {
                // Determine position using anchor point.
                return this.calculateContentPositionFromPoint(anchoredElementInfo.anchorPoint, contentPosition, contentSize, offset);
            }
            // Determine position using anchor rectangle.
            return this.calculateContentPositionFromRect(anchoredElementInfo.anchorRect, anchoredElementInfo.anchorRectOrientation, contentPosition, contentSize, offset);
        };
        /** (Private) Check for collisions. */
        DataLabelManager.prototype.hasCollisions = function (arrangeGrid, info, position, size) {
            var rect = shapes.Rect;
            if (arrangeGrid.hasConflict(position)) {
                return true;
            }
            // Since we divide the height by 2 we add it back to the top of the view port so labels won't be cut off
            var intersection = { left: 0, top: position.height / 2, width: size.width, height: size.height };
            intersection = rect.inflate(intersection, { left: DataLabelManager.InflateAmount, top: 0, right: DataLabelManager.InflateAmount, bottom: 0 });
            intersection = rect.intersect(intersection, position);
            if (rect.isEmpty(intersection))
                // Empty rectangle means there is a collision
                return true;
            var lessWithPrecision = powerbi.Double.lessWithPrecision;
            switch (info.outsidePlacement) {
                // D3 positions the label in the middle by default.
                // The algorithem asumed the label was positioned in right so this is why we devide by 2 or 4
                case OutsidePlacement.Disallowed:
                    return lessWithPrecision(intersection.width, position.width) ||
                        lessWithPrecision(intersection.height, position.height / 2);
                case OutsidePlacement.Partial:
                    return lessWithPrecision(intersection.width, position.width / 2) ||
                        lessWithPrecision(intersection.height, position.height / 4);
            }
            return false;
        };
        DataLabelManager.isValid = function (rect) {
            return !shapes.Rect.isEmpty(rect) && (rect.width > 0 && rect.height > 0);
        };
        DataLabelManager.DefaultAnchorMargin = 0; // For future use
        DataLabelManager.DefaultMaximumMovingDistance = 12;
        DataLabelManager.DefaultMinimumMovingDistance = 3;
        DataLabelManager.InflateAmount = 5;
        return DataLabelManager;
    }());
    powerbi.DataLabelManager = DataLabelManager;
    /**
    * Utility class to speed up the conflict detection by collecting the arranged items in the DataLabelsPanel.
    */
    var DataLabelArrangeGrid = (function () {
        /**
         * Creates new ArrangeGrid.
         * @param size The available size
         */
        function DataLabelArrangeGrid(size, elements, layout) {
            this.grid = [];
            if (size.width === 0 || size.height === 0) {
                this.cellSize = size;
                this.rowCount = this.colCount = 0;
            }
            var baseProperties = {
                fontFamily: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                fontSize: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize,
                fontWeight: powerbi.visuals.dataLabelUtils.LabelTextProperties.fontWeight,
            };
            //sets the cell size to be twice of the Max with and Max height of the elements 
            this.cellSize = { width: 0, height: 0 };
            for (var i = 0, len = elements.length; i < len; i++) {
                var child = elements[i];
                // Fill label field
                child.labeltext = layout.labelText(child);
                var properties = powerbi.Prototype.inherit(baseProperties);
                properties.text = child.labeltext;
                properties.fontSize = (child.data) ? child.data.labelFontSize :
                    child.labelFontSize ? child.labelFontSize : powerbi.visuals.dataLabelUtils.LabelTextProperties.fontSize;
                child.size = {
                    width: powerbi.TextMeasurementService.measureSvgTextWidth(properties),
                    height: powerbi.TextMeasurementService.estimateSvgTextHeight(properties),
                };
                var w = child.size.width * 2;
                var h = child.size.height * 2;
                if (w > this.cellSize.width)
                    this.cellSize.width = w;
                if (h > this.cellSize.height)
                    this.cellSize.height = h;
            }
            if (this.cellSize.width === 0)
                this.cellSize.width = size.width;
            if (this.cellSize.height === 0)
                this.cellSize.height = size.height;
            this.colCount = this.getGridRowColCount(this.cellSize.width, size.width, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this.rowCount = this.getGridRowColCount(this.cellSize.height, size.height, DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT, DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT);
            this.cellSize.width = size.width / this.colCount;
            this.cellSize.height = size.height / this.rowCount;
            var grid = this.grid;
            for (var x = 0; x < this.colCount; x++) {
                grid[x] = [];
                for (var y = 0; y < this.rowCount; y++) {
                    grid[x][y] = [];
                }
            }
        }
        /**
         * Register a new label element.
         * @param element The label element to register.
         * @param rect The label element position rectangle.
         */
        DataLabelArrangeGrid.prototype.add = function (element, rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this.grid;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    grid[x][y].push({ element: element, rect: rect });
                }
            }
        };
        /**
         * Checks for conflict of given rectangle in registered elements.
         * @param rect The rectengle to check.
         * @return True if conflict is detected.
         */
        DataLabelArrangeGrid.prototype.hasConflict = function (rect) {
            var indexRect = this.getGridIndexRect(rect);
            var grid = this.grid;
            var isIntersecting = shapes.Rect.isIntersecting;
            for (var x = indexRect.left; x < indexRect.right; x++) {
                for (var y = indexRect.top; y < indexRect.bottom; y++) {
                    for (var z = 0; z < grid[x][y].length; z++) {
                        var item = grid[x][y][z];
                        if (isIntersecting(item.rect, rect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        /**
         * Calculates the number of rows or columns in a grid
         * @param step is the largest label size (width or height)
         * @param length is the grid size (width or height)
         * @param minCount is the minimum allowed size
         * @param maxCount is the maximum allowed size
         * @return the number of grid rows or columns
         */
        DataLabelArrangeGrid.prototype.getGridRowColCount = function (step, length, minCount, maxCount) {
            return Math.min(Math.max(Math.ceil(length / step), minCount), maxCount);
        };
        /**
         * Returns the grid index of a given recangle
         * @param rect The rectengle to check.
         * @return grid index as a thickness object.
         */
        DataLabelArrangeGrid.prototype.getGridIndexRect = function (rect) {
            var restrict = function (n, min, max) { return Math.min(Math.max(n, min), max); };
            return {
                left: restrict(Math.floor(rect.left / this.cellSize.width), 0, this.colCount),
                top: restrict(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                right: restrict(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.colCount),
                bottom: restrict(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount)
            };
        };
        DataLabelArrangeGrid.ARRANGEGRID_MIN_COUNT = 1;
        DataLabelArrangeGrid.ARRANGEGRID_MAX_COUNT = 100;
        return DataLabelArrangeGrid;
    }());
    powerbi.DataLabelArrangeGrid = DataLabelArrangeGrid;
    /**
    * (Private) Contains methods for calculating the top-left coordinate of rectangle based on content size and anchor rect.
    */
    var LocationConverter;
    (function (LocationConverter) {
        function topInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topInside = topInside;
        function bottomInside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: (rect.top + rect.height) - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomInside = bottomInside;
        function rightInside(size, rect, offset) {
            return {
                left: (rect.left + rect.width) - size.width - offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightInside = rightInside;
        function leftInside(size, rect, offset) {
            return {
                left: rect.left + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftInside = leftInside;
        function topOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top - size.height - offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.topOutside = topOutside;
        function bottomOutside(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: (rect.top + rect.height) + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.bottomOutside = bottomOutside;
        function rightOutside(size, rect, offset) {
            return {
                left: (rect.left + rect.width) + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.rightOutside = rightOutside;
        function leftOutside(size, rect, offset) {
            return {
                left: rect.left - size.width - offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.leftOutside = leftOutside;
        function middleHorizontal(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0 + offset,
                top: rect.top + rect.height / 2.0 - size.height / 2.0,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleHorizontal = middleHorizontal;
        function middleVertical(size, rect, offset) {
            return {
                left: rect.left + rect.width / 2.0 - size.width / 2.0,
                top: rect.top + rect.height / 2.0 - size.height / 2.0 + offset,
                width: size.width,
                height: size.height
            };
        }
        LocationConverter.middleVertical = middleVertical;
    })(LocationConverter || (LocationConverter = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var shapes = powerbi.visuals.shapes;
    var Rect = powerbi.visuals.shapes.Rect;
    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
    var LabelArrangeGrid = (function () {
        function LabelArrangeGrid(labelDataPointsGroups, viewport) {
            this.viewport = viewport;
            var maxLabelWidth = 0;
            var maxLabelHeight = 0;
            for (var _i = 0, labelDataPointsGroups_1 = labelDataPointsGroups; _i < labelDataPointsGroups_1.length; _i++) {
                var labelDataPointsGroup = labelDataPointsGroups_1[_i];
                for (var _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                    var labelDataPoint = _b[_a];
                    if (labelDataPoint.isPreferred) {
                        var dataLabelSize = labelDataPoint.labelSize;
                        if (dataLabelSize.width > maxLabelWidth) {
                            maxLabelWidth = dataLabelSize.width;
                        }
                        if (dataLabelSize.height > maxLabelHeight) {
                            maxLabelHeight = dataLabelSize.height;
                        }
                    }
                }
            }
            if (maxLabelWidth === 0) {
                maxLabelWidth = viewport.width;
            }
            if (maxLabelHeight === 0) {
                maxLabelHeight = viewport.height;
            }
            var cellSize = this.cellSize = { width: maxLabelWidth * LabelArrangeGrid.cellSizeMultiplier, height: maxLabelHeight * LabelArrangeGrid.cellSizeMultiplier };
            this.columnCount = LabelArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
            this.rowCount = LabelArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
            var grid = [];
            for (var i = 0, ilen = this.columnCount; i < ilen; i++) {
                grid[i] = [];
                for (var j = 0, jlen = this.rowCount; j < jlen; j++) {
                    grid[i][j] = [];
                }
            }
            this.grid = grid;
        }
        /**
         * Add a rectangle to check collision against
         */
        LabelArrangeGrid.prototype.add = function (rect) {
            var containingIndexRect = this.getContainingGridSubsection(rect);
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    this.grid[x][y].push(rect);
                }
            }
        };
        /**
         * Check whether the rect conflicts with the grid, either bleeding outside the
         * viewport or colliding with another rect added to the grid.
         */
        LabelArrangeGrid.prototype.hasConflict = function (rect) {
            if (!this.isWithinGridViewport(rect)) {
                return true;
            }
            return this.hasCollision(rect);
        };
        /**
         * Attempt to position the given rect within the viewport.  Returns
         * the adjusted rectangle or null if the rectangle couldn't fit,
         * conflicts with the viewport, or is too far outside the viewport
         */
        LabelArrangeGrid.prototype.tryPositionInViewport = function (rect) {
            // If it's too far outside the viewport, return null
            if (!this.isCloseToGridViewport(rect)) {
                return;
            }
            if (!this.isWithinGridViewport(rect)) {
                rect = this.tryMoveInsideViewport(rect);
            }
            if (rect && !this.hasCollision(rect)) {
                return rect;
            }
        };
        /**
         * Checks for a collision between the given rect and others in the grid.
         * Returns true if there is a collision.
         */
        LabelArrangeGrid.prototype.hasCollision = function (rect) {
            var containingIndexRect = this.getContainingGridSubsection(rect);
            var grid = this.grid;
            var isIntersecting = shapes.Rect.isIntersecting;
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                        var currentGridRect = _a[_i];
                        if (isIntersecting(currentGridRect, rect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        /**
         * Check to see if the given rect is inside the grid's viewport
         */
        LabelArrangeGrid.prototype.isWithinGridViewport = function (rect) {
            return rect.left >= 0 &&
                rect.top >= 0 &&
                rect.left + rect.width <= this.viewport.width &&
                rect.top + rect.height <= this.viewport.height;
        };
        /**
         * Checks to see if the rect is close enough to the viewport to be moved inside.
         * "Close" here is determined by the distance between the edge of the viewport
         * and the closest edge of the rect; if that distance is less than the appropriate
         * dimension of the rect, we will reposition the rect.
         */
        LabelArrangeGrid.prototype.isCloseToGridViewport = function (rect) {
            return rect.left + rect.width >= 0 - rect.width &&
                rect.top + rect.height >= -rect.height &&
                rect.left <= this.viewport.width + rect.width &&
                rect.top <= this.viewport.height + rect.height;
        };
        /**
         * Attempt to move the rect inside the grid's viewport.  Returns the resulting
         * rectangle with the same width/height adjusted to be inside the viewport or
         * null if it couldn't fit regardless.
         */
        LabelArrangeGrid.prototype.tryMoveInsideViewport = function (rect) {
            var result = Rect.clone(rect);
            var viewport = this.viewport;
            // Return null if it's too big to fit regardless of positioning
            if (rect.width > viewport.width || rect.height > viewport.height) {
                return;
            }
            // Only one movement should be made in each direction, because we are only moving it inside enough for it to fit; there should be no overshooting.
            // Outside to the left
            if (rect.left < 0) {
                result.left = 0;
            }
            else if (rect.left + rect.width > viewport.width) {
                result.left -= (rect.left + rect.width) - viewport.width;
            }
            // Outside above
            if (rect.top < 0) {
                result.top = 0;
            }
            else if (rect.top + rect.height > viewport.height) {
                result.top -= (rect.top + rect.height) - viewport.height;
            }
            return result;
        };
        LabelArrangeGrid.prototype.getContainingGridSubsection = function (rect) {
            return {
                xMin: LabelArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                xMax: LabelArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                yMin: LabelArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                yMax: LabelArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
            };
        };
        LabelArrangeGrid.getCellCount = function (step, length, minCount, maxCount) {
            return LabelArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
        };
        LabelArrangeGrid.bound = function (value, min, max) {
            return Math.max(Math.min(value, max), min);
        };
        /**
         * A multiplier applied to the largest width height to attempt to balance # of
         * labels in each cell and number of cells each label belongs to
         */
        LabelArrangeGrid.cellSizeMultiplier = 2;
        return LabelArrangeGrid;
    }());
    powerbi.LabelArrangeGrid = LabelArrangeGrid;
    var LabelLayout = (function () {
        function LabelLayout(options) {
            this.startingOffset = options.startingOffset;
            this.maximumOffset = options.maximumOffset;
            if (options.offsetIterationDelta != null) {
                debug.assert(options.offsetIterationDelta > 0, "label offset delta must be greater than 0");
                this.offsetIterationDelta = options.offsetIterationDelta;
            }
            else {
                this.offsetIterationDelta = LabelLayout.defaultOffsetIterationDelta;
            }
            if (options.horizontalPadding != null) {
                this.horizontalPadding = options.horizontalPadding;
            }
            else {
                this.horizontalPadding = LabelLayout.defaultHorizontalPadding;
            }
            if (options.verticalPadding != null) {
                this.verticalPadding = options.verticalPadding;
            }
            else {
                this.verticalPadding = LabelLayout.defaultVerticalPadding;
            }
            this.allowLeaderLines = !!options.allowLeaderLines;
            this.attemptToMoveLabelsIntoViewport = !!options.attemptToMoveLabelsIntoViewport;
        }
        /**
         * Arrange takes a set of data labels and lays them out in order, assuming that
         * the given array has already been sorted with the most preferred labels at the
         * front, taking into considiration a maximum number of labels that are alowed
         * to display.
         *
         * Details:
         * - We iterate over offsets from the target position, increasing from 0 while
         *      verifiying the maximum number of labels to display hasn't been reached
         * - For each offset, we iterate over each data label
         * - For each data label, we iterate over each position that is valid for
         *     both the specific label and this layout
         * - When a valid position is found, we position the label there and no longer
         *     reposition it.
         * - This prioritizes the earlier labels to be positioned closer to their
         *     target points in the position they prefer.
         * - This prioritizes putting data labels close to a valid position over
         *     placing them at their preferred position (it will place it at a less
         *     preferred position if it will be a smaller offset)
         */
        LabelLayout.prototype.layout = function (labelDataPointsGroups, viewport) {
            // Clear data labels for a new layout
            for (var _i = 0, labelDataPointsGroups_2 = labelDataPointsGroups; _i < labelDataPointsGroups_2.length; _i++) {
                var labelDataPointsGroup = labelDataPointsGroups_2[_i];
                for (var _a = 0, _b = labelDataPointsGroup.labelDataPoints; _a < _b.length; _a++) {
                    var labelPoint = _b[_a];
                    labelPoint.hasBeenRendered = false;
                    if (labelPoint.hasBackground) {
                        labelPoint.labelSize = {
                            width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
                            height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding,
                        };
                    }
                    else {
                        labelPoint.labelSize = labelPoint.textSize;
                    }
                }
            }
            var resultingDataLabels = [];
            var grid = new LabelArrangeGrid(labelDataPointsGroups, viewport);
            // Iterates on every series
            for (var _c = 0, labelDataPointsGroups_3 = labelDataPointsGroups; _c < labelDataPointsGroups_3.length; _c++) {
                var labelDataPointsGroup = labelDataPointsGroups_3[_c];
                var maxLabelsToRender = labelDataPointsGroup.maxNumberOfLabels;
                // NOTE: we create a copy and modify the copy to keep track of preferred vs. non-preferred labels.
                var labelDataPoints = _.clone(labelDataPointsGroup.labelDataPoints);
                var preferredLabels = [];
                // Exclude preferred labels
                for (var j = labelDataPoints.length - 1, localMax = maxLabelsToRender; j >= 0 && localMax > 0; j--) {
                    var labelPoint = labelDataPoints[j];
                    if (labelPoint.isPreferred) {
                        preferredLabels.unshift(labelDataPoints.splice(j, 1)[0]);
                        localMax--;
                    }
                }
                // First iterate all the preferred labels
                if (preferredLabels.length > 0) {
                    var positionedLabels = this.positionDataLabels(preferredLabels, viewport, grid, maxLabelsToRender);
                    maxLabelsToRender -= positionedLabels.length;
                    resultingDataLabels = resultingDataLabels.concat(positionedLabels);
                }
                // While there are invisible not preferred labels and label distance is less than the max
                // allowed distance
                if (labelDataPoints.length > 0) {
                    var labels = this.positionDataLabels(labelDataPoints, viewport, grid, maxLabelsToRender);
                    resultingDataLabels = resultingDataLabels.concat(labels);
                }
            }
            return resultingDataLabels;
        };
        LabelLayout.prototype.positionDataLabels = function (labelDataPoints, viewport, grid, maxLabelsToRender) {
            var resultingDataLabels = [];
            var offsetDelta = this.offsetIterationDelta;
            var currentOffset = this.startingOffset;
            var currentCenteredOffset = 0;
            var drawLeaderLinesOnIteration;
            while (currentOffset <= this.maximumOffset && maxLabelsToRender > 0) {
                drawLeaderLinesOnIteration = this.allowLeaderLines && currentOffset > this.startingOffset;
                for (var _i = 0, labelDataPoints_2 = labelDataPoints; _i < labelDataPoints_2.length; _i++) {
                    var labelPoint = labelDataPoints_2[_i];
                    // Check if maximum number of labels to display has been reached
                    if (maxLabelsToRender === 0)
                        break;
                    if (labelPoint.hasBeenRendered) {
                        continue;
                    }
                    var dataLabel = void 0;
                    if (labelPoint.parentType === 1 /* Rectangle */) {
                        dataLabel = this.tryPositionForRectPositions(labelPoint, grid, currentOffset, currentCenteredOffset);
                    }
                    else {
                        dataLabel = this.tryPositionForPointPositions(labelPoint, grid, currentOffset, drawLeaderLinesOnIteration);
                    }
                    if (dataLabel) {
                        resultingDataLabels.push(dataLabel);
                        maxLabelsToRender--;
                    }
                }
                currentOffset += offsetDelta;
                currentCenteredOffset += offsetDelta;
            }
            return resultingDataLabels;
        };
        LabelLayout.prototype.tryPositionForRectPositions = function (labelPoint, grid, currentLabelOffset, currentCenteredLabelOffset) {
            var _this = this;
            // Function declared and reused to reduce code duplication
            var tryPosition = function (position, adjustForViewport) {
                var isPositionInside = position & 7 /* InsideAll */;
                if (isPositionInside && !DataLabelRectPositioner.canFitWithinParent(labelPoint, _this.horizontalPadding, _this.verticalPadding)) {
                    return;
                }
                var resultingBoundingBox = LabelLayout.tryPositionRect(grid, position, labelPoint, currentLabelOffset, currentCenteredLabelOffset, adjustForViewport);
                if (resultingBoundingBox) {
                    if (isPositionInside && !DataLabelRectPositioner.isLabelWithinParent(resultingBoundingBox, labelPoint, _this.horizontalPadding, _this.verticalPadding)) {
                        return;
                    }
                    grid.add(resultingBoundingBox);
                    labelPoint.hasBeenRendered = true;
                    return {
                        boundingBox: resultingBoundingBox,
                        text: labelPoint.text,
                        tooltip: labelPoint.tooltip,
                        isVisible: true,
                        fill: isPositionInside ? labelPoint.insideFill : labelPoint.outsideFill,
                        identity: labelPoint.identity,
                        key: labelPoint.key,
                        fontSize: labelPoint.fontSize,
                        selected: false,
                        hasBackground: !!labelPoint.hasBackground,
                    };
                }
            };
            // Iterate over all positions that are valid for the data point
            for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                var position = _a[_i];
                var label = tryPosition(position, false /* adjustForViewport */);
                if (label)
                    return label;
            }
            // If no position has been found and the option is enabled, try any outside positions while moving the label inside the viewport
            if (this.attemptToMoveLabelsIntoViewport) {
                for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                    var position = _c[_b];
                    var label = tryPosition(position, true /* adjustForViewport */);
                    if (label)
                        return label;
                }
            }
            return null;
        };
        /**
         * Tests a particular position/offset combination for the given data label.
         * If the label can be placed, returns the resulting bounding box for the data
         * label.  If not, returns null.
         */
        LabelLayout.tryPositionRect = function (grid, position, labelDataPoint, offset, centerOffset, adjustForViewport) {
            var offsetForPosition = offset;
            if (position & 1 /* InsideCenter */) {
                offsetForPosition = centerOffset;
            }
            var labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, offsetForPosition);
            if (position !== 1 /* InsideCenter */ || labelDataPoint.parentShape.orientation === 0 /* None */) {
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
                if (adjustForViewport) {
                    return grid.tryPositionInViewport(labelRect);
                }
            }
            else {
                // If the position is centered, attempt to offset in both a positive and negative direction
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
                labelRect = DataLabelRectPositioner.getLabelRect(labelDataPoint, position, -offsetForPosition);
                if (!grid.hasConflict(labelRect)) {
                    return labelRect;
                }
            }
            return null;
        };
        LabelLayout.prototype.tryPositionForPointPositions = function (labelPoint, grid, currentLabelOffset, drawLeaderLines) {
            // Function declared and reused to reduce code duplication
            var tryPosition = function (position, parentShape, adjustForViewport) {
                var resultingBoundingBox = LabelLayout.tryPositionPoint(grid, position, labelPoint, currentLabelOffset, adjustForViewport);
                if (resultingBoundingBox) {
                    grid.add(resultingBoundingBox);
                    labelPoint.hasBeenRendered = true;
                    return {
                        boundingBox: resultingBoundingBox,
                        text: labelPoint.text,
                        tooltip: labelPoint.tooltip,
                        isVisible: true,
                        fill: position === 256 /* Center */ ? labelPoint.insideFill : labelPoint.outsideFill,
                        isInsideParent: position === 256 /* Center */,
                        identity: labelPoint.identity,
                        key: labelPoint.key,
                        fontSize: labelPoint.fontSize,
                        selected: false,
                        leaderLinePoints: drawLeaderLines ? DataLabelPointPositioner.getLabelLeaderLineEndingPoint(resultingBoundingBox, position, parentShape) : null,
                        hasBackground: !!labelPoint.hasBackground,
                    };
                }
            };
            // Iterate over all positions that are valid for the data point
            var parentShape = labelPoint.parentShape;
            var validPositions = parentShape.validPositions;
            for (var _i = 0, validPositions_1 = validPositions; _i < validPositions_1.length; _i++) {
                var position = validPositions_1[_i];
                var label = tryPosition(position, parentShape, false /* adjustForViewport */);
                if (label)
                    return label;
            }
            // Attempt to position at the most preferred position by simply moving it inside the viewport
            if (this.attemptToMoveLabelsIntoViewport && !_.isEmpty(validPositions)) {
                var label = tryPosition(validPositions[0], parentShape, true /* adjustForViewport */);
                if (label)
                    return label;
            }
            return null;
        };
        LabelLayout.tryPositionPoint = function (grid, position, labelDataPoint, offset, adjustForViewport) {
            var labelRect = DataLabelPointPositioner.getLabelRect(labelDataPoint.labelSize, labelDataPoint.parentShape, position, offset);
            if (!grid.hasConflict(labelRect)) {
                return labelRect;
            }
            if (adjustForViewport) {
                return grid.tryPositionInViewport(labelRect);
            }
            return null;
        };
        // Default values
        LabelLayout.defaultOffsetIterationDelta = 2;
        LabelLayout.defaultHorizontalPadding = 2;
        LabelLayout.defaultVerticalPadding = 2;
        return LabelLayout;
    }());
    powerbi.LabelLayout = LabelLayout;
    /**
     * (Private) Contains methods for calculating the bounding box of a data label
     */
    var DataLabelRectPositioner;
    (function (DataLabelRectPositioner) {
        function getLabelRect(labelDataPoint, position, offset) {
            var parentRect = labelDataPoint.parentShape;
            if (parentRect != null) {
                // Each combination of position and orientation results in a different actual positioning, which is then called.
                switch (position) {
                    case 1 /* InsideCenter */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.middleVertical(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.middleHorizontal(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 2 /* InsideBase */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 4 /* InsideEnd */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.topInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.bottomInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.rightInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.leftInside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 8 /* OutsideBase */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    case 16 /* OutsideEnd */:
                        switch (parentRect.orientation) {
                            case 1 /* VerticalBottomBased */:
                                return DataLabelRectPositioner.topOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 2 /* VerticalTopBased */:
                                return DataLabelRectPositioner.bottomOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 3 /* HorizontalLeftBased */:
                                return DataLabelRectPositioner.rightOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 4 /* HorizontalRightBased */:
                                return DataLabelRectPositioner.leftOutside(labelDataPoint.labelSize, parentRect.rect, offset);
                            case 0 /* None */:
                        }
                    default:
                        debug.assertFail("Unsupported label position");
                }
            }
            else {
            }
            return null;
        }
        DataLabelRectPositioner.getLabelRect = getLabelRect;
        function canFitWithinParent(labelDataPoint, horizontalPadding, verticalPadding) {
            return (labelDataPoint.labelSize.width + 2 * horizontalPadding < labelDataPoint.parentShape.rect.width) ||
                (labelDataPoint.labelSize.height + 2 * verticalPadding < labelDataPoint.parentShape.rect.height);
        }
        DataLabelRectPositioner.canFitWithinParent = canFitWithinParent;
        function isLabelWithinParent(labelRect, labelPoint, horizontalPadding, verticalPadding) {
            var parentRect = labelPoint.parentShape.rect;
            var labelRectWithPadding = shapes.Rect.inflate(labelRect, { left: horizontalPadding, right: horizontalPadding, top: verticalPadding, bottom: verticalPadding });
            return shapes.Rect.containsPoint(parentRect, {
                x: labelRectWithPadding.left,
                y: labelRectWithPadding.top,
            }) && shapes.Rect.containsPoint(parentRect, {
                x: labelRectWithPadding.left + labelRectWithPadding.width,
                y: labelRectWithPadding.top + labelRectWithPadding.height,
            });
        }
        DataLabelRectPositioner.isLabelWithinParent = isLabelWithinParent;
        function topInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.topInside = topInside;
        function bottomInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: (parentRect.top + parentRect.height) - offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.bottomInside = bottomInside;
        function rightInside(labelSize, parentRect, offset) {
            return {
                left: (parentRect.left + parentRect.width) - labelSize.width - offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.rightInside = rightInside;
        function leftInside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.leftInside = leftInside;
        function topOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top - labelSize.height - offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.topOutside = topOutside;
        function bottomOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: (parentRect.top + parentRect.height) + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.bottomOutside = bottomOutside;
        function rightOutside(labelSize, parentRect, offset) {
            return {
                left: (parentRect.left + parentRect.width) + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.rightOutside = rightOutside;
        function leftOutside(labelSize, parentRect, offset) {
            return {
                left: parentRect.left - labelSize.width - offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.leftOutside = leftOutside;
        function middleHorizontal(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0 + offset,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.middleHorizontal = middleHorizontal;
        function middleVertical(labelSize, parentRect, offset) {
            return {
                left: parentRect.left + parentRect.width / 2.0 - labelSize.width / 2.0,
                top: parentRect.top + parentRect.height / 2.0 - labelSize.height / 2.0 + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelRectPositioner.middleVertical = middleVertical;
    })(DataLabelRectPositioner = powerbi.DataLabelRectPositioner || (powerbi.DataLabelRectPositioner = {}));
    var DataLabelPointPositioner;
    (function (DataLabelPointPositioner) {
        DataLabelPointPositioner.cos45 = Math.cos(45);
        DataLabelPointPositioner.sin45 = Math.sin(45);
        function getLabelRect(labelSize, parentPoint, position, offset) {
            switch (position) {
                case 1 /* Above */: {
                    return DataLabelPointPositioner.above(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 2 /* Below */: {
                    return DataLabelPointPositioner.below(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 4 /* Left */: {
                    return DataLabelPointPositioner.left(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 8 /* Right */: {
                    return DataLabelPointPositioner.right(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 32 /* BelowLeft */: {
                    return DataLabelPointPositioner.belowLeft(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 16 /* BelowRight */: {
                    return DataLabelPointPositioner.belowRight(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 128 /* AboveLeft */: {
                    return DataLabelPointPositioner.aboveLeft(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 64 /* AboveRight */: {
                    return DataLabelPointPositioner.aboveRight(labelSize, parentPoint.point, parentPoint.radius + offset);
                }
                case 256 /* Center */: {
                    return DataLabelPointPositioner.center(labelSize, parentPoint.point);
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return null;
        }
        DataLabelPointPositioner.getLabelRect = getLabelRect;
        function above(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y - offset - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.above = above;
        function below(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y + offset,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.below = below;
        function left(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - offset - labelSize.width,
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.left = left;
        function right(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + offset,
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.right = right;
        function belowLeft(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (DataLabelPointPositioner.sin45 * offset) - labelSize.width,
                top: parentPoint.y + (DataLabelPointPositioner.cos45 * offset),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.belowLeft = belowLeft;
        function belowRight(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + (DataLabelPointPositioner.sin45 * offset),
                top: parentPoint.y + (DataLabelPointPositioner.cos45 * offset),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.belowRight = belowRight;
        function aboveLeft(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x - (DataLabelPointPositioner.sin45 * offset) - labelSize.width,
                top: parentPoint.y - (DataLabelPointPositioner.cos45 * offset) - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.aboveLeft = aboveLeft;
        function aboveRight(labelSize, parentPoint, offset) {
            return {
                left: parentPoint.x + (DataLabelPointPositioner.sin45 * offset),
                top: parentPoint.y - (DataLabelPointPositioner.cos45 * offset) - labelSize.height,
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.aboveRight = aboveRight;
        function center(labelSize, parentPoint) {
            return {
                left: parentPoint.x - (labelSize.width / 2),
                top: parentPoint.y - (labelSize.height / 2),
                width: labelSize.width,
                height: labelSize.height
            };
        }
        DataLabelPointPositioner.center = center;
        function getLabelLeaderLineEndingPoint(boundingBox, position, parentShape) {
            var x = boundingBox.left;
            var y = boundingBox.top;
            switch (position) {
                case 1 /* Above */:
                    x += (boundingBox.width / 2);
                    y += boundingBox.height;
                    break;
                case 2 /* Below */:
                    x += (boundingBox.width / 2);
                    break;
                case 4 /* Left */:
                    x += boundingBox.width;
                    y += ((boundingBox.height * 2) / 3);
                    break;
                case 8 /* Right */:
                    y += ((boundingBox.height * 2) / 3);
                    break;
                case 32 /* BelowLeft */:
                    x += boundingBox.width;
                    y += (boundingBox.height / 2);
                    break;
                case 16 /* BelowRight */:
                    y += (boundingBox.height / 2);
                    break;
                case 128 /* AboveLeft */:
                    x += boundingBox.width;
                    y += boundingBox.height;
                    break;
                case 64 /* AboveRight */:
                    y += boundingBox.height;
                    break;
            }
            return [[parentShape.point.x, parentShape.point.y], [x, y]];
        }
        DataLabelPointPositioner.getLabelLeaderLineEndingPoint = getLabelLeaderLineEndingPoint;
    })(DataLabelPointPositioner = powerbi.DataLabelPointPositioner || (powerbi.DataLabelPointPositioner = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
    var labelStyle = powerbi.visuals.labelStyle;
    var DonutLabelUtils = powerbi.visuals.DonutLabelUtils;
    var DonutLabelLayout = (function () {
        function DonutLabelLayout(options, donutChartProperties) {
            this.startingOffset = options.startingOffset;
            this.maximumOffset = options.maximumOffset;
            if (options.offsetIterationDelta != null) {
                debug.assert(options.offsetIterationDelta > 0, "label offset delta must be greater than 0");
                this.offsetIterationDelta = options.offsetIterationDelta;
            }
            this.donutChartProperties = donutChartProperties;
            this.center = {
                x: donutChartProperties.viewport.width / 2,
                y: donutChartProperties.viewport.height / 2,
            };
            this.outerRadius = this.donutChartProperties.radius * this.donutChartProperties.outerArcRadiusRatio;
            this.innerRadius = (this.donutChartProperties.radius / 2) * this.donutChartProperties.innerArcRadiusRatio;
            this.additionalCharsWidth = powerbi.TextMeasurementService.measureSvgTextWidth({
                text: " ()",
                fontFamily: NewDataLabelUtils.LabelTextProperties.fontFamily,
                fontSize: jsCommon.PixelConverter.fromPoint(donutChartProperties.dataLabelsSettings.fontSize),
                fontWeight: NewDataLabelUtils.LabelTextProperties.fontWeight,
            });
        }
        /**
         * Arrange takes a set of data labels and lays them out them in order, assuming that
         * the given array has already been sorted with the most preferred labels at the
         * front.
         *
         * Details:
         * - We iterate over offsets from the target position, increasing from 0
         * - For each offset, we iterate over each data label
         * - For each data label, we iterate over each position that is valid for
         *     both the specific label and this layout
         * - When a valid position is found, we position the label there and no longer
         *     reposition it.
         * - This prioritizes the earlier labels to be positioned closer to their
         *     target points in the position they prefer.
         * - This prioritizes putting data labels close to a valid position over
         *     placing them at their preferred position (it will place it at a less
         *     preferred position if it will be a smaller offset)
         */
        DonutLabelLayout.prototype.layout = function (labelDataPoints) {
            // Clear data labels for a new layout
            for (var _i = 0, labelDataPoints_3 = labelDataPoints; _i < labelDataPoints_3.length; _i++) {
                var donutLabel = labelDataPoints_3[_i];
                donutLabel.hasBeenRendered = false;
                donutLabel.labelSize = donutLabel.textSize;
            }
            var resultingLabels = [];
            var preferredLabels = [];
            var viewport = this.donutChartProperties.viewport;
            var labelDataPointsGroup = {
                labelDataPoints: labelDataPoints,
                maxNumberOfLabels: labelDataPoints.length
            };
            var grid = new powerbi.LabelArrangeGrid([labelDataPointsGroup], viewport);
            for (var i = labelDataPoints.length - 1; i >= 0; i--) {
                var labelPoint = labelDataPoints[i];
                if (labelPoint.isPreferred) {
                    var label = labelDataPoints.splice(i, 1);
                    preferredLabels = label.concat(preferredLabels);
                }
            }
            // first iterate all the preferred labels
            if (preferredLabels.length > 0)
                resultingLabels = this.positionLabels(preferredLabels, grid);
            // While there are invisible not preferred labels and label distance is less than the max
            // allowed distance
            if (labelDataPoints.length > 0) {
                var labels = this.positionLabels(labelDataPoints, grid);
                resultingLabels = resultingLabels.concat(labels);
            }
            return resultingLabels;
        };
        DonutLabelLayout.prototype.positionLabels = function (labelDataPoints, grid) {
            var resultingLabels = [];
            var offsetDelta = this.offsetIterationDelta;
            var currentOffset = this.startingOffset;
            var currentCenteredOffset = 0;
            while (currentOffset <= this.maximumOffset) {
                for (var _i = 0, labelDataPoints_4 = labelDataPoints; _i < labelDataPoints_4.length; _i++) {
                    var labelPoint = labelDataPoints_4[_i];
                    if (labelPoint.hasBeenRendered)
                        continue;
                    var label = this.tryPositionForDonut(labelPoint, grid, currentOffset);
                    if (label)
                        resultingLabels.push(label);
                }
                currentOffset += offsetDelta;
                currentCenteredOffset += offsetDelta;
            }
            return resultingLabels;
        };
        /**
         * We try to move the label 25% up/down if the label is truncated or it collides with other labels.
         * after we moved it once we check that the new position doesn't failed (collides with other labels).
         */
        DonutLabelLayout.prototype.tryPositionForDonut = function (labelPoint, grid, currentLabelOffset) {
            var parentShape = labelPoint.parentShape;
            if (_.isEmpty(parentShape.validPositions) || parentShape.validPositions[0] === 0 /* None */)
                return;
            var defaultPosition = parentShape.validPositions[0];
            var bestCandidate = this.tryAllPositions(labelPoint, grid, defaultPosition, currentLabelOffset);
            if (bestCandidate && bestCandidate.score === 0) {
                return this.buildLabel(bestCandidate, grid);
            }
            // If we haven't found a non-truncated label, try to split into 2 lines.
            if (this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both) {
                // Try to split the label to two lines if both data and category label are on
                var splitLabelDataPoint = this.splitDonutDataPoint(labelPoint);
                var bestSplitCandidate = this.tryAllPositions(splitLabelDataPoint, grid, defaultPosition, currentLabelOffset);
                // If the best candidate with a split line is better than the best candidate with a single line, return the former.
                if (bestSplitCandidate && (!bestCandidate || (bestSplitCandidate.score < bestCandidate.score))) {
                    return this.buildLabel(bestSplitCandidate, grid);
                }
            }
            // We didn't find a better candidate by splitting the label lines, so return our best single-line candidate.
            if (bestCandidate) {
                return this.buildLabel(bestCandidate, grid);
            }
        };
        DonutLabelLayout.prototype.generateCandidate = function (labelDataPoint, candidatePosition, grid, currentLabelOffset) {
            var angle = this.generateCandidateAngleForPosition(labelDataPoint.donutArcDescriptor, candidatePosition);
            var parentShape = this.getPointPositionForAngle(angle);
            var parentPoint = parentShape.point;
            var score = this.score(labelDataPoint, parentPoint);
            var leaderLinePoints = DonutLabelUtils.getLabelLeaderLineForDonutChart(labelDataPoint.donutArcDescriptor, this.donutChartProperties, parentPoint, angle);
            var leaderLinesSize = DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
            var newLabelDataPoint = _.clone(labelDataPoint);
            newLabelDataPoint.angle = angle;
            newLabelDataPoint.parentShape = parentShape;
            newLabelDataPoint.leaderLinePoints = leaderLinePoints;
            newLabelDataPoint.linesSize = leaderLinesSize;
            var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, parentShape.validPositions[0], newLabelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport);
            return {
                angle: angle,
                point: parentShape,
                score: score,
                labelRects: boundingBoxs,
                labelDataPoint: newLabelDataPoint,
            };
        };
        DonutLabelLayout.prototype.tryAllPositions = function (labelDataPoint, grid, defaultPosition, currentLabelOffset) {
            var boundingBoxs = DonutLabelLayout.tryPositionPoint(grid, defaultPosition, labelDataPoint, currentLabelOffset, this.center, this.donutChartProperties.viewport);
            var originalPoint = labelDataPoint.parentShape;
            var originalCandidate = {
                point: originalPoint,
                angle: labelDataPoint.angle,
                score: this.score(labelDataPoint, originalPoint.point),
                labelRects: boundingBoxs,
                labelDataPoint: labelDataPoint,
            };
            if (boundingBoxs && boundingBoxs.textRect && originalCandidate.score === 0) {
                return originalCandidate;
            }
            var positions = [];
            var bestCandidate;
            if (boundingBoxs && boundingBoxs.textRect) {
                // We have a truncated label here, otherwised we would have returned already
                positions = this.getLabelPointPositions(labelDataPoint, /* isTruncated */ true);
                bestCandidate = originalCandidate;
            }
            else {
                positions = this.getLabelPointPositions(labelDataPoint, /* isTruncated */ false);
            }
            // Try to reposition the label if necessary
            for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
                var position = positions_1[_i];
                var candidate = this.generateCandidate(labelDataPoint, position, grid, currentLabelOffset);
                if (candidate.labelRects && candidate.labelRects.textRect) {
                    if (bestCandidate == null || candidate.score < bestCandidate.score) {
                        bestCandidate = candidate;
                        if (bestCandidate.score === 0)
                            return bestCandidate;
                    }
                }
            }
            return bestCandidate;
        };
        DonutLabelLayout.prototype.buildLabel = function (labelLayout, grid) {
            var resultingBoundingBox = labelLayout.labelRects.textRect;
            var labelPoint = labelLayout.labelDataPoint;
            grid.add(resultingBoundingBox);
            grid.add(labelLayout.labelRects.horizontalLineRect);
            grid.add(labelLayout.labelRects.diagonalLineRect);
            labelPoint.hasBeenRendered = true;
            var left = resultingBoundingBox.left - this.center.x;
            //We need to add or subtract half resultingBoundingBox.width because Donut chart labels get text anchor start/end
            if (left < 0)
                left += resultingBoundingBox.width / 2;
            else
                left -= resultingBoundingBox.width / 2;
            var textAnchor = labelPoint.parentShape.validPositions[0] === 8 /* Right */ ? 'start' : 'end';
            var boundingBox = {
                left: left,
                top: resultingBoundingBox.top - this.center.y,
                height: resultingBoundingBox.height,
                width: resultingBoundingBox.width,
            };
            // After repositioning the label we need to recalculate its size and format it according to the current available space
            var labelSettingsStyle = this.donutChartProperties.dataLabelsSettings.labelStyle;
            var spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(labelPoint.parentShape.point.x, this.donutChartProperties.viewport);
            var formattedDataLabel;
            var formattedCategoryLabel;
            var text;
            var getLabelFormattedText = powerbi.visuals.dataLabelUtils.getLabelFormattedText;
            var fontSize = labelPoint.fontSize;
            var hasOneLabelRow = labelSettingsStyle === labelStyle.both && labelPoint.secondRowText == null;
            // Giving 50/50 space when both category and measure are on
            if (hasOneLabelRow) {
                labelPoint.dataLabel = " (" + labelPoint.dataLabel + ")";
                spaceAvailableForLabels /= 2;
            }
            if (labelSettingsStyle === labelStyle.both || labelSettingsStyle === labelStyle.data) {
                formattedDataLabel = getLabelFormattedText({
                    label: labelPoint.dataLabel,
                    maxWidth: spaceAvailableForLabels,
                    fontSize: fontSize
                });
            }
            if (labelSettingsStyle === labelStyle.both || labelSettingsStyle === labelStyle.category) {
                formattedCategoryLabel = getLabelFormattedText({
                    label: labelPoint.categoryLabel,
                    maxWidth: spaceAvailableForLabels,
                    fontSize: fontSize
                });
            }
            switch (labelSettingsStyle) {
                case labelStyle.both:
                    if (labelPoint.secondRowText == null) {
                        text = formattedCategoryLabel + formattedDataLabel;
                    }
                    else {
                        text = formattedDataLabel;
                        labelPoint.secondRowText = formattedCategoryLabel;
                    }
                    break;
                case labelStyle.data:
                    text = formattedDataLabel;
                    break;
                case labelStyle.category:
                    text = formattedCategoryLabel;
                    break;
            }
            // Limit text size width for correct leader line calculation
            labelPoint.textSize.width = Math.min(labelPoint.textSize.width, hasOneLabelRow ? spaceAvailableForLabels * 2 : spaceAvailableForLabels);
            return {
                boundingBox: boundingBox,
                text: text,
                tooltip: labelPoint.tooltip,
                isVisible: true,
                fill: labelPoint.outsideFill,
                identity: labelPoint.identity,
                fontSize: fontSize,
                selected: false,
                textAnchor: textAnchor,
                leaderLinePoints: labelPoint.leaderLinePoints,
                hasBackground: false,
                secondRowText: labelPoint.secondRowText,
            };
        };
        DonutLabelLayout.tryPositionPoint = function (grid, position, labelDataPoint, offset, center, viewport) {
            var parentPoint = labelDataPoint.parentShape;
            // Limit label width to fit the availabe space for labels
            var textSize = _.clone(labelDataPoint.textSize);
            textSize.width = Math.min(textSize.width, DonutLabelUtils.getSpaceAvailableForDonutLabels(parentPoint.point.x, viewport));
            // Create label rectangle
            var labelRect = powerbi.DataLabelPointPositioner.getLabelRect(textSize, parentPoint, position, offset);
            // Create label diagonal line rectangle
            var diagonalLineParentPoint = {
                point: {
                    x: labelDataPoint.leaderLinePoints[0][0],
                    y: labelDataPoint.leaderLinePoints[0][1] < 0 ? labelDataPoint.leaderLinePoints[1][1] : labelDataPoint.leaderLinePoints[0][1]
                },
                radius: 0,
                validPositions: null
            };
            var diagonalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.DiagonalLineIndex], diagonalLineParentPoint, position, offset);
            // Create label horizontal line rectangle
            var horizontalLineParentPoint = {
                point: {
                    x: labelDataPoint.leaderLinePoints[1][0],
                    y: labelDataPoint.leaderLinePoints[1][1]
                },
                radius: 0,
                validPositions: null
            };
            var horizontalLineRect = powerbi.DataLabelPointPositioner.getLabelRect(labelDataPoint.linesSize[DonutLabelUtils.HorizontalLineIndex], horizontalLineParentPoint, position, offset);
            if (!labelRect || !diagonalLineRect || !horizontalLineRect)
                return;
            labelRect.left += center.x;
            labelRect.top += center.y;
            var centerForLinesWidth = center.x - labelRect.width / 2;
            diagonalLineRect.left += centerForLinesWidth;
            diagonalLineRect.top += center.y;
            horizontalLineRect.left += centerForLinesWidth;
            horizontalLineRect.top += center.y;
            if (!grid.hasConflict(labelRect) && !grid.hasConflict(diagonalLineRect) && !grid.hasConflict(horizontalLineRect))
                return { textRect: labelRect, diagonalLineRect: diagonalLineRect, horizontalLineRect: horizontalLineRect };
        };
        /**
         * Returns an array of valid positions for hidden and truncated labels.
         * For truncated labels will return positions with more available space.
         * For hidden labels will return all possible positions by the order we draw labels (clockwise)
         */
        DonutLabelLayout.prototype.getLabelPointPositions = function (labelPoint, isTruncated) {
            var parentShape = labelPoint.parentShape;
            var position = parentShape.validPositions[0];
            if (!isTruncated) {
                return position === 4 /* Left */
                    ? [128 /* AboveLeft */, 32 /* BelowLeft */]
                    : [16 /* BelowRight */, 64 /* AboveRight */];
            }
            if (parentShape.point.y < 0) {
                return position === 8 /* Right */
                    ? [64 /* AboveRight */]
                    : [128 /* AboveLeft */];
            }
            else {
                return position === 8 /* Right */
                    ? [16 /* BelowRight */]
                    : [32 /* BelowLeft */];
            }
        };
        /**
         * Returns a new DonutLabelDataPoint after splitting it into two lines
         */
        DonutLabelLayout.prototype.splitDonutDataPoint = function (labelPoint) {
            var textSize = {
                width: Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width),
                height: labelPoint.dataLabelSize.height * 2,
            };
            var newLabelPoint = _.clone(labelPoint);
            newLabelPoint.textSize = textSize;
            newLabelPoint.secondRowText = labelPoint.categoryLabel;
            return newLabelPoint;
        };
        DonutLabelLayout.prototype.generateCandidateAngleForPosition = function (d, position) {
            var midAngle = d.startAngle + ((d.endAngle - d.startAngle) / 2);
            switch (position) {
                case 64 /* AboveRight */:
                case 32 /* BelowLeft */:
                    return ((d.startAngle + midAngle) - Math.PI) / 2;
                case 128 /* AboveLeft */:
                case 16 /* BelowRight */:
                    return ((midAngle + d.endAngle) - Math.PI) / 2;
                default:
                    debug.assertFail("Unsupported label position");
            }
        };
        DonutLabelLayout.prototype.getPointPositionForAngle = function (angle) {
            // Calculate the new label coordinates
            var labelX = DonutLabelUtils.getXPositionForDonutLabel(Math.cos(angle) * this.outerRadius);
            var labelY = Math.sin(angle) * this.outerRadius;
            var newPosition = labelX < 0 ? 4 /* Left */ : 8 /* Right */;
            var pointPosition = {
                point: {
                    x: labelX,
                    y: labelY,
                },
                validPositions: [newPosition],
                radius: 0,
            };
            return pointPosition;
        };
        DonutLabelLayout.prototype.score = function (labelPoint, point) {
            var spaceAvailableForLabels = DonutLabelUtils.getSpaceAvailableForDonutLabels(point.x, this.donutChartProperties.viewport);
            var textWidth;
            // Check if we show category and data labels in one row
            if (this.donutChartProperties.dataLabelsSettings.labelStyle === labelStyle.both && labelPoint.secondRowText == null) {
                // Each of the labels gets half of the available space for labels so we take this into consideration in the score
                textWidth = Math.max(labelPoint.categoryLabelSize.width, labelPoint.dataLabelSize.width + this.additionalCharsWidth);
                spaceAvailableForLabels /= 2;
            }
            else {
                textWidth = labelPoint.textSize.width;
            }
            return Math.max(textWidth - spaceAvailableForLabels, 0);
        };
        return DonutLabelLayout;
    }());
    powerbi.DonutLabelLayout = DonutLabelLayout;
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var NewDataLabelUtils = powerbi.visuals.NewDataLabelUtils;
    var DefaultCentroidOffset = 5;
    var OffsetDelta = 10;
    var MaximumOffset = 60;
    var stemExtension = 5;
    var FilledMapLabelLayout = (function () {
        function FilledMapLabelLayout() {
        }
        FilledMapLabelLayout.prototype.layout = function (labelDataPoints, viewport, polygonInfoTransform, redrawDataLabels) {
            if (redrawDataLabels || this.labels === undefined) {
                var labelDataPointsGroup = {
                    labelDataPoints: labelDataPoints,
                    maxNumberOfLabels: labelDataPoints.length
                };
                for (var _i = 0, labelDataPoints_5 = labelDataPoints; _i < labelDataPoints_5.length; _i++) {
                    var labelPoint = labelDataPoints_5[_i];
                    labelPoint.labelSize = {
                        width: labelPoint.textSize.width + 2 * NewDataLabelUtils.horizontalLabelBackgroundPadding,
                        height: labelPoint.textSize.height + 2 * NewDataLabelUtils.verticalLabelBackgroundPadding,
                    };
                }
                var grid = new powerbi.LabelArrangeGrid([labelDataPointsGroup], viewport);
                var resultingDataLabels = [];
                var allPolygons = [];
                for (var _a = 0, labelDataPoints_6 = labelDataPoints; _a < labelDataPoints_6.length; _a++) {
                    var labelPoint = labelDataPoints_6[_a];
                    var polygon = labelPoint.parentShape.polygon;
                    allPolygons.push(polygon);
                    polygon.pixelBoundingRect = polygonInfoTransform.applyToRect(polygon.absoluteBoundingRect());
                }
                var shapesgrid = new LabelPolygonArrangeGrid(allPolygons, viewport);
                for (var _b = 0, labelDataPoints_7 = labelDataPoints; _b < labelDataPoints_7.length; _b++) {
                    var labelPoint = labelDataPoints_7[_b];
                    var dataLabel = this.getLabelByPolygonPositions(labelPoint, polygonInfoTransform, grid, shapesgrid);
                    if (dataLabel != null) {
                        resultingDataLabels.push(dataLabel);
                    }
                }
                this.labels = resultingDataLabels;
            }
            else {
                this.updateLabelOffsets(polygonInfoTransform);
            }
            return this.labels;
        };
        FilledMapLabelLayout.prototype.getLabelPolygon = function (mapDataPoint, position, pointPosition, offset) {
            var dataPointSize = {
                width: mapDataPoint.textSize.width,
                height: (mapDataPoint.textSize.height)
            };
            return this.getLabelBoundingBox(dataPointSize, position, pointPosition, offset);
        };
        FilledMapLabelLayout.prototype.getLabelBoundingBox = function (dataPointSize, position, pointPosition, offset) {
            switch (position) {
                case 1 /* Above */: {
                    return powerbi.DataLabelPointPositioner.above(dataPointSize, pointPosition, offset);
                }
                case 2 /* Below */: {
                    return powerbi.DataLabelPointPositioner.below(dataPointSize, pointPosition, offset);
                }
                case 4 /* Left */: {
                    return powerbi.DataLabelPointPositioner.left(dataPointSize, pointPosition, offset);
                }
                case 8 /* Right */: {
                    return powerbi.DataLabelPointPositioner.right(dataPointSize, pointPosition, offset);
                }
                case 128 /* AboveLeft */: {
                    return powerbi.DataLabelPointPositioner.aboveLeft(dataPointSize, pointPosition, offset);
                }
                case 64 /* AboveRight */: {
                    return powerbi.DataLabelPointPositioner.aboveRight(dataPointSize, pointPosition, offset);
                }
                case 32 /* BelowLeft */: {
                    return powerbi.DataLabelPointPositioner.belowLeft(dataPointSize, pointPosition, offset);
                }
                case 16 /* BelowRight */: {
                    return powerbi.DataLabelPointPositioner.belowRight(dataPointSize, pointPosition, offset);
                }
                case 256 /* Center */: {
                    return powerbi.DataLabelPointPositioner.center(dataPointSize, pointPosition);
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return null;
        };
        FilledMapLabelLayout.prototype.getLabelByPolygonPositions = function (labelPoint, polygonInfoTransform, grid, shapesGrid) {
            var offset = 0;
            var inverseTransorm = polygonInfoTransform.getInverse();
            for (var i = 0; i < 2; i++) {
                if (i === 1) {
                    offset = DefaultCentroidOffset;
                }
                for (var _i = 0, _a = labelPoint.parentShape.validPositions; _i < _a.length; _i++) {
                    var position = _a[_i];
                    var resultingAbsoluteBoundingBox = this.tryPositionForPolygonPosition(position, labelPoint, polygonInfoTransform, offset, inverseTransorm);
                    if (position === 256 /* Center */ && i !== 0) {
                        continue;
                    }
                    if (resultingAbsoluteBoundingBox) {
                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsoluteBoundingBox);
                        var dataLabel = {
                            text: labelPoint.text,
                            secondRowText: labelPoint.secondRowText,
                            boundingBox: resultingBoundingBox,
                            isVisible: true,
                            fill: labelPoint.insideFill,
                            identity: null,
                            selected: false,
                            hasBackground: true,
                            textAnchor: "middle",
                            originalPixelOffset: offset,
                            isPlacedInsidePolygon: true,
                            absoluteBoundingBoxCenter: {
                                x: resultingAbsoluteBoundingBox.left + resultingAbsoluteBoundingBox.width / 2,
                                y: resultingAbsoluteBoundingBox.top + resultingAbsoluteBoundingBox.height / 2
                            }
                        };
                        return dataLabel;
                    }
                }
            }
            var currentOffset = 6;
            while (currentOffset <= MaximumOffset) {
                for (var _b = 0, _c = labelPoint.parentShape.validPositions; _b < _c.length; _b++) {
                    var position = _c[_b];
                    if (position === 256 /* Center */) {
                        continue;
                    }
                    var polygon = labelPoint.parentShape.polygon;
                    var pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid());
                    var resultingAbsolutBoundingBox = this.tryPlaceLabelOutsidePolygon(grid, position, labelPoint, currentOffset, pixelCentroid, shapesGrid, inverseTransorm);
                    if (resultingAbsolutBoundingBox) {
                        var resultingBoundingBox = polygonInfoTransform.applyToRect(resultingAbsolutBoundingBox);
                        var dataLabel = {
                            text: labelPoint.text,
                            secondRowText: labelPoint.secondRowText,
                            boundingBox: resultingBoundingBox,
                            isVisible: true,
                            fill: labelPoint.insideFill,
                            identity: null,
                            selected: false,
                            hasBackground: true,
                            isPlacedInsidePolygon: false,
                            textAnchor: "middle",
                            originalPixelOffset: currentOffset,
                            originalPosition: position,
                            originalAbsoluteCentroid: polygon.absoluteCentroid(),
                            absoluteBoundingBoxCenter: {
                                x: resultingAbsolutBoundingBox.left + resultingAbsolutBoundingBox.width / 2,
                                y: resultingAbsolutBoundingBox.top + resultingAbsolutBoundingBox.height / 2
                            }
                        };
                        var pixelStemSource = this.calculateStemSource(polygonInfoTransform, inverseTransorm, polygon, resultingBoundingBox, position, pixelCentroid);
                        dataLabel.leaderLinePoints = this.setLeaderLinePoints(pixelStemSource, this.calculateStemDestination(resultingBoundingBox, position));
                        dataLabel.absoluteStemSource = inverseTransorm.applyToPoint(pixelStemSource);
                        grid.add(resultingBoundingBox);
                        return dataLabel;
                    }
                }
                currentOffset += OffsetDelta;
            }
            return null;
        };
        FilledMapLabelLayout.prototype.setLeaderLinePoints = function (stemSource, stemDestination) {
            return [[stemSource.x, stemSource.y], [stemDestination.x, stemDestination.y]];
        };
        FilledMapLabelLayout.prototype.calculateStemSource = function (polygonInfoTransform, inverseTransorm, polygon, labelBoundingBox, position, pixelCentroid) {
            var absoluteStemSource = polygon.lineIntersectionPoint(polygon.absoluteCentroid(), inverseTransorm.applyToPoint({ x: labelBoundingBox.left + labelBoundingBox.width / 2, y: labelBoundingBox.top + labelBoundingBox.height / 2 }));
            if (absoluteStemSource == null) {
                return pixelCentroid;
            }
            var stemSource = polygonInfoTransform.applyToPoint(absoluteStemSource);
            switch (position) {
                case 1 /* Above */: {
                    stemSource.y += stemExtension;
                    break;
                }
                case 2 /* Below */: {
                    stemSource.y -= stemExtension;
                    break;
                }
                case 4 /* Left */: {
                    stemSource.x += stemExtension;
                    break;
                }
                case 8 /* Right */: {
                    stemSource.x -= stemExtension;
                    break;
                }
                case 128 /* AboveLeft */: {
                    stemSource.x += (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y += (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 64 /* AboveRight */: {
                    stemSource.x -= (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y += (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 32 /* BelowLeft */: {
                    stemSource.x += (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y -= (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 16 /* BelowRight */: {
                    stemSource.x -= (stemExtension / powerbi.DataLabelPointPositioner.cos45);
                    stemSource.y -= (stemExtension / powerbi.DataLabelPointPositioner.sin45);
                    break;
                }
                case 256 /* Center */: {
                    break;
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return stemSource;
        };
        FilledMapLabelLayout.prototype.calculateStemDestination = function (labelBoundingBox, position) {
            var x;
            var y;
            switch (position) {
                case 1 /* Above */: {
                    x = labelBoundingBox.left + labelBoundingBox.width / 2;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 2 /* Below */: {
                    x = labelBoundingBox.left + labelBoundingBox.width / 2;
                    y = labelBoundingBox.top;
                    break;
                }
                case 4 /* Left */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top + labelBoundingBox.height / 2;
                    break;
                }
                case 8 /* Right */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top + labelBoundingBox.height / 2;
                    break;
                }
                case 128 /* AboveLeft */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 64 /* AboveRight */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top + labelBoundingBox.height;
                    break;
                }
                case 32 /* BelowLeft */: {
                    x = labelBoundingBox.left + labelBoundingBox.width;
                    y = labelBoundingBox.top;
                    break;
                }
                case 16 /* BelowRight */: {
                    x = labelBoundingBox.left;
                    y = labelBoundingBox.top;
                    break;
                }
                case 256 /* Center */: {
                    break;
                }
                default: {
                    debug.assertFail("Unsupported label position");
                }
            }
            return { x: x, y: y };
        };
        FilledMapLabelLayout.prototype.tryPositionForPolygonPosition = function (position, labelDataPoint, polygonInfoTransform, offset, inverseTransorm) {
            var polygon = labelDataPoint.parentShape.polygon;
            var pixelCentroid = polygonInfoTransform.applyToPoint(polygon.absoluteCentroid());
            var labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offset);
            var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransorm, labelRect);
            return polygon.contains(absoluteLabelRect) ? absoluteLabelRect : null;
        };
        /**
        * Tests a particular position/offset combination for the given data label.
        * If the label can be placed, returns the resulting bounding box for the data
        * label.  If not, returns null.
        */
        FilledMapLabelLayout.prototype.tryPlaceLabelOutsidePolygon = function (grid, position, labelDataPoint, offset, pixelCentroid, shapesGrid, inverseTransform) {
            var offsetForPosition = offset;
            var labelRect = this.getLabelPolygon(labelDataPoint, position, pixelCentroid, offsetForPosition);
            var otherLabelsConflict = grid.hasConflict(labelRect);
            if (!otherLabelsConflict) {
                var absoluteLabelRect = this.getAbsoluteRectangle(inverseTransform, labelRect);
                if (!shapesGrid.hasConflict(absoluteLabelRect, labelRect))
                    return absoluteLabelRect;
            }
            return null;
        };
        FilledMapLabelLayout.prototype.updateLabelOffsets = function (polygonInfoTransform) {
            for (var _i = 0, _a = this.labels; _i < _a.length; _i++) {
                var label = _a[_i];
                if (!label.isVisible)
                    continue;
                if (label.isPlacedInsidePolygon) {
                    var newOffset = polygonInfoTransform.applyToPoint(label.absoluteBoundingBoxCenter);
                    var xDelta = (label.boundingBox.left + label.boundingBox.width / 2) - newOffset.x;
                    var yDelta = (label.boundingBox.top + label.boundingBox.height / 2) - newOffset.y;
                    label.boundingBox.top -= yDelta;
                    label.boundingBox.left -= xDelta;
                }
                else {
                    var stemSourcePoint = polygonInfoTransform.applyToPoint(label.absoluteStemSource);
                    var pixelCentroid = polygonInfoTransform.applyToPoint(label.originalAbsoluteCentroid);
                    label.boundingBox = this.getLabelBoundingBox({ width: label.boundingBox.width, height: label.boundingBox.height }, label.originalPosition, pixelCentroid, label.originalPixelOffset);
                    if (label.leaderLinePoints !== undefined)
                        label.leaderLinePoints = this.setLeaderLinePoints(stemSourcePoint, this.calculateStemDestination(label.boundingBox, label.originalPosition));
                }
            }
        };
        FilledMapLabelLayout.prototype.getAbsoluteRectangle = function (inverseTransorm, rect) {
            return inverseTransorm.applyToRect(rect);
        };
        return FilledMapLabelLayout;
    }());
    powerbi.FilledMapLabelLayout = FilledMapLabelLayout;
    var LabelPolygonArrangeGrid = (function () {
        function LabelPolygonArrangeGrid(polygons, viewport) {
            this.viewport = viewport;
            var maxPolygonWidth = 0;
            var maxPolygonHeight = 0;
            for (var _i = 0, polygons_1 = polygons; _i < polygons_1.length; _i++) {
                var polygon = polygons_1[_i];
                var polygonSize = polygon.pixelBoundingRect;
                if (polygonSize.width > maxPolygonWidth) {
                    maxPolygonWidth = polygonSize.width;
                }
                if (polygonSize.height > maxPolygonHeight) {
                    maxPolygonHeight = polygonSize.height;
                }
            }
            if (maxPolygonWidth === 0) {
                maxPolygonWidth = viewport.width;
            }
            if (maxPolygonHeight === 0) {
                maxPolygonHeight = viewport.height;
            }
            var cellSize = this.cellSize = { width: maxPolygonWidth * LabelPolygonArrangeGrid.cellSizeMultiplier, height: maxPolygonHeight * LabelPolygonArrangeGrid.cellSizeMultiplier };
            this.columnCount = LabelPolygonArrangeGrid.getCellCount(cellSize.width, viewport.width, 1, 100);
            this.rowCount = LabelPolygonArrangeGrid.getCellCount(cellSize.height, viewport.height, 1, 100);
            var grid = [];
            for (var i = 0, ilen = this.columnCount; i < ilen; i++) {
                grid[i] = [];
                for (var j = 0, jlen = this.rowCount; j < jlen; j++) {
                    grid[i][j] = [];
                }
            }
            this.grid = grid;
            for (var _a = 0, polygons_2 = polygons; _a < polygons_2.length; _a++) {
                var polygon = polygons_2[_a];
                this.add(polygon);
            }
        }
        LabelPolygonArrangeGrid.prototype.hasConflict = function (absolutLabelRect, pixelLabelRect) {
            var containingIndexRect = this.getContainingGridSubsection(pixelLabelRect);
            var grid = this.grid;
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    for (var _i = 0, _a = grid[x][y]; _i < _a.length; _i++) {
                        var currentPolygon = _a[_i];
                        if (currentPolygon.conflicts(absolutLabelRect)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        };
        LabelPolygonArrangeGrid.prototype.add = function (polygon) {
            var containingIndexRect = this.getContainingGridSubsection(polygon.pixelBoundingRect);
            for (var x = containingIndexRect.xMin; x < containingIndexRect.xMax; x++) {
                for (var y = containingIndexRect.yMin; y < containingIndexRect.yMax; y++) {
                    this.grid[x][y].push(polygon);
                }
            }
        };
        LabelPolygonArrangeGrid.prototype.getContainingGridSubsection = function (rect) {
            return {
                xMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.left / this.cellSize.width), 0, this.columnCount),
                xMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.left + rect.width) / this.cellSize.width), 0, this.columnCount),
                yMin: LabelPolygonArrangeGrid.bound(Math.floor(rect.top / this.cellSize.height), 0, this.rowCount),
                yMax: LabelPolygonArrangeGrid.bound(Math.ceil((rect.top + rect.height) / this.cellSize.height), 0, this.rowCount),
            };
        };
        LabelPolygonArrangeGrid.getCellCount = function (step, length, minCount, maxCount) {
            return LabelPolygonArrangeGrid.bound(Math.ceil(length / step), minCount, maxCount);
        };
        LabelPolygonArrangeGrid.bound = function (value, min, max) {
            return Math.max(Math.min(value, max), min);
        };
        /**
         * A multiplier applied to the largest width height to attempt to balance # of
         * polygons in each cell and number of cells each polygon belongs to
         */
        LabelPolygonArrangeGrid.cellSizeMultiplier = 2;
        return LabelPolygonArrangeGrid;
    }());
    powerbi.LabelPolygonArrangeGrid = LabelPolygonArrangeGrid;
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        function createColorAllocatorFactory() {
            return new ColorAllocatorFactory();
        }
        visuals.createColorAllocatorFactory = createColorAllocatorFactory;
        var ColorAllocatorFactory = (function () {
            function ColorAllocatorFactory() {
            }
            ColorAllocatorFactory.prototype.linearGradient2 = function (options) {
                return new LinearGradient2Allocator(options);
            };
            ColorAllocatorFactory.prototype.linearGradient3 = function (options, splitScales) {
                if (splitScales)
                    return new LinearGradient3AllocatorWithSplittedScales(options);
                return new LinearGradient3Allocator(options);
            };
            return ColorAllocatorFactory;
        }());
        var LinearGradient2Allocator = (function () {
            function LinearGradient2Allocator(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, max = options.max;
                this.scale = d3.scale.linear()
                    .domain([min.value, max.value])
                    .range([min.color, max.color])
                    .clamp(true); // process a value outside of the domain - set to extremum values
            }
            LinearGradient2Allocator.prototype.color = function (value) {
                var min = this.options.min, max = this.options.max;
                if (min.value === max.value) {
                    if (value >= max.value)
                        return max.color;
                    return min.color;
                }
                return this.scale(value);
            };
            return LinearGradient2Allocator;
        }());
        var LinearGradient3Allocator = (function () {
            function LinearGradient3Allocator(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, mid = options.mid, max = options.max;
                this.scale = d3.scale.linear()
                    .domain([min.value, mid.value, max.value])
                    .range([min.color, mid.color, max.color])
                    .clamp(true); // process a value outside of the domain- set to extremum values
            }
            LinearGradient3Allocator.prototype.color = function (value) {
                var min = this.options.min, mid = this.options.mid, max = this.options.max;
                if (max.value === mid.value || mid.value === min.value || (max.value === mid.value && max.value === min.value)) {
                    if (value >= max.value)
                        return max.color;
                    else if (value >= mid.value)
                        return mid.color;
                    return min.color;
                }
                return this.scale(value);
            };
            return LinearGradient3Allocator;
        }());
        var LinearGradient3AllocatorWithSplittedScales = (function () {
            function LinearGradient3AllocatorWithSplittedScales(options) {
                debug.assertValue(options, 'options');
                this.options = options;
                var min = options.min, mid = options.mid, max = options.max;
                /*
                If the center value is overridden, but the max and min remain automatic,
                colors are then assigned on a scale between the overridden center value and the max/min values in the data.
                Each side of the center value is assigned separately, independent of the relative scales.
                */
                this.scale1 = d3.scale.linear()
                    .domain([min.value, mid.value])
                    .range([min.color, mid.color])
                    .clamp(true); // process a value outside of the domain- set to extremum values
                this.scale2 = d3.scale.linear()
                    .domain([mid.value, max.value])
                    .range([mid.color, max.color])
                    .clamp(true); // process a value outside of the domain- set to extremum values
            }
            LinearGradient3AllocatorWithSplittedScales.prototype.color = function (value) {
                var min = this.options.min, mid = this.options.mid, max = this.options.max;
                if (max.value === mid.value || mid.value === min.value || (max.value === mid.value && max.value === min.value)) {
                    if (value >= max.value)
                        return max.color;
                    else if (value >= mid.value)
                        return mid.color;
                    return min.color;
                }
                else if (value <= mid.value) {
                    return this.scale1(value);
                }
                return this.scale2(value);
            };
            return LinearGradient3AllocatorWithSplittedScales;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BeautifiedFormat = {
            '0.00 %;-0.00 %;0.00 %': 'Percentage',
            '0.0 %;-0.0 %;0.0 %': 'Percentage1',
        };
        var defaultLocalizedStrings = {
            'NullValue': '(Blank)',
            'BooleanTrue': 'True',
            'BooleanFalse': 'False',
            'NaNValue': 'NaN',
            'InfinityValue': '+Infinity',
            'NegativeInfinityValue': '-Infinity',
            'Restatement_Comma': '{0}, {1}',
            'Restatement_CompoundAnd': '{0} and {1}',
            'DisplayUnitSystem_EAuto_Title': 'Auto',
            'DisplayUnitSystem_E0_Title': 'None',
            'DisplayUnitSystem_E3_LabelFormat': '{0}K',
            'DisplayUnitSystem_E3_Title': 'Thousands',
            'DisplayUnitSystem_E6_LabelFormat': '{0}M',
            'DisplayUnitSystem_E6_Title': 'Millions',
            'DisplayUnitSystem_E9_LabelFormat': '{0}bn',
            'DisplayUnitSystem_E9_Title': 'Billions',
            'DisplayUnitSystem_E12_LabelFormat': '{0}T',
            'DisplayUnitSystem_E12_Title': 'Trillions',
            'Percentage': '#,0.##%',
            'Percentage1': '#,0.#%',
            'RichTextbox_Link_DefaultText': 'Link',
            'TableTotalLabel': 'Total',
            'Tooltip_HighlightedValueDisplayName': 'Highlighted',
            'Funnel_PercentOfFirst': 'Percent of first',
            'Funnel_PercentOfPrevious': 'Percent of previous',
            'Funnel_PercentOfFirst_Highlight': 'Percent of first (highlight)',
            'Funnel_PercentOfPrevious_Highlight': 'Percent of previous (highlight)',
            // Geotagging strings
            'GeotaggingString_Continent': 'continent',
            'GeotaggingString_Continents': 'continents',
            'GeotaggingString_Country': 'country',
            'GeotaggingString_Countries': 'countries',
            'GeotaggingString_State': 'state',
            'GeotaggingString_States': 'states',
            'GeotaggingString_City': 'city',
            'GeotaggingString_Cities': 'cities',
            'GeotaggingString_Town': 'town',
            'GeotaggingString_Towns': 'towns',
            'GeotaggingString_Province': 'province',
            'GeotaggingString_Provinces': 'provinces',
            'GeotaggingString_County': 'county',
            'GeotaggingString_Counties': 'counties',
            'GeotaggingString_Village': 'village',
            'GeotaggingString_Villages': 'villages',
            'GeotaggingString_Post': 'post',
            'GeotaggingString_Zip': 'zip',
            'GeotaggingString_Code': 'code',
            'GeotaggingString_Place': 'place',
            'GeotaggingString_Places': 'places',
            'GeotaggingString_Address': 'address',
            'GeotaggingString_Addresses': 'addresses',
            'GeotaggingString_Street': 'street',
            'GeotaggingString_Streets': 'streets',
            'GeotaggingString_Longitude': 'longitude',
            'GeotaggingString_Longitude_Short': 'lon',
            'GeotaggingString_Latitude': 'latitude',
            'GeotaggingString_Latitude_Short': 'lat',
            'GeotaggingString_PostalCode': 'postal code',
            'GeotaggingString_PostalCodes': 'postal codes',
            'GeotaggingString_ZipCode': 'zip code',
            'GeotaggingString_ZipCodes': 'zip codes',
            'GeotaggingString_Territory': 'territory',
            'GeotaggingString_Territories': 'territories',
            'Waterfall_IncreaseLabel': 'Increase',
            'Waterfall_DecreaseLabel': 'Decrease',
            'Waterfall_TotalLabel': 'Total',
            'Slicer_SelectAll': 'Select All',
        };
        var DefaultVisualHostServices = (function () {
            function DefaultVisualHostServices() {
            }
            // TODO: Add locale-awareness to this host service. Currently default/english functionality only.
            DefaultVisualHostServices.initialize = function () {
                visuals.valueFormatter.setLocaleOptions(DefaultVisualHostServices.createLocaleOptions());
                visuals.TooltipManager.setLocalizedStrings(DefaultVisualHostServices.createTooltipLocaleOptions());
            };
            /**
             * Create locale options.
             *
             * Note: Public for testability.
             */
            DefaultVisualHostServices.createLocaleOptions = function () {
                return {
                    null: defaultLocalizedStrings['NullValue'],
                    true: defaultLocalizedStrings['BooleanTrue'],
                    false: defaultLocalizedStrings['BooleanFalse'],
                    NaN: defaultLocalizedStrings['NaNValue'],
                    infinity: defaultLocalizedStrings['InfinityValue'],
                    negativeInfinity: defaultLocalizedStrings['NegativeInfinityValue'],
                    beautify: function (format) { return DefaultVisualHostServices.beautify(format); },
                    describe: function (exponent) { return DefaultVisualHostServices.describeUnit(exponent); },
                    restatementComma: defaultLocalizedStrings['Restatement_Comma'],
                    restatementCompoundAnd: defaultLocalizedStrings['Restatement_CompoundAnd'],
                    restatementCompoundOr: defaultLocalizedStrings['Restatement_CompoundOr']
                };
            };
            DefaultVisualHostServices.createTooltipLocaleOptions = function () {
                return {
                    highlightedValueDisplayName: defaultLocalizedStrings['Tooltip_HighlightedValueDisplayName']
                };
            };
            DefaultVisualHostServices.prototype.getLocalizedString = function (stringId) {
                return defaultLocalizedStrings[stringId];
            };
            // NO-OP IHostServices methods
            DefaultVisualHostServices.prototype.onDragStart = function () { };
            DefaultVisualHostServices.prototype.canSelect = function () { return false; };
            DefaultVisualHostServices.prototype.onSelect = function () { };
            DefaultVisualHostServices.prototype.onContextMenu = function () { };
            DefaultVisualHostServices.prototype.loadMoreData = function () { };
            DefaultVisualHostServices.prototype.persistProperties = function (changes) { };
            DefaultVisualHostServices.prototype.onCustomSort = function (args) { };
            DefaultVisualHostServices.prototype.getViewMode = function () { return 0 /* View */; };
            DefaultVisualHostServices.prototype.setWarnings = function (warnings) { };
            DefaultVisualHostServices.prototype.setToolbar = function ($toolbar) { };
            DefaultVisualHostServices.prototype.shouldRetainSelection = function () { return false; };
            DefaultVisualHostServices.prototype.geocoder = function () { return visuals.services.createGeocoder(); };
            DefaultVisualHostServices.prototype.geolocation = function () { return visuals.services.createGeolocation(); };
            DefaultVisualHostServices.prototype.promiseFactory = function () { return powerbi.createJQueryPromiseFactory(); };
            DefaultVisualHostServices.prototype.analyzeFilter = function (options) {
                return {
                    isNotFilter: false,
                    selectedIdentities: [],
                    filter: undefined,
                    defaultValue: undefined,
                };
            };
            DefaultVisualHostServices.prototype.getIdentityDisplayNames = function (dentities) { return; };
            DefaultVisualHostServices.prototype.setIdentityDisplayNames = function (displayNamesIdentityPairs) { };
            DefaultVisualHostServices.beautify = function (format) {
                var key = BeautifiedFormat[format];
                if (key)
                    return defaultLocalizedStrings[key] || format;
                return format;
            };
            DefaultVisualHostServices.describeUnit = function (exponent) {
                var exponentLookup = (exponent === -1) ? 'Auto' : exponent.toString();
                var title = defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_Title"];
                var format = (exponent <= 0) ? '{0}' : defaultLocalizedStrings["DisplayUnitSystem_E" + exponentLookup + "_LabelFormat"];
                if (title || format)
                    return { title: title, format: format };
            };
            return DefaultVisualHostServices;
        }());
        visuals.DefaultVisualHostServices = DefaultVisualHostServices;
        visuals.defaultVisualHostServices = new DefaultVisualHostServices();
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        /**
         * Factory method to create an IInteractivityService instance.
         */
        function createInteractivityService(hostServices) {
            return new InteractivityService(hostServices);
        }
        visuals.createInteractivityService = createInteractivityService;
        /**
         * Creates a clear an svg rect to catch clear clicks.
         */
        function appendClearCatcher(selection) {
            return selection
                .append("rect")
                .classed("clearCatcher", true)
                .attr({ width: "100%", height: "100%" });
        }
        visuals.appendClearCatcher = appendClearCatcher;
        function isCategoryColumnSelected(propertyId, categories, idx) {
            return categories.objects != null
                && categories.objects[idx]
                && powerbi.DataViewObjects.getValue(categories.objects[idx], propertyId);
        }
        visuals.isCategoryColumnSelected = isCategoryColumnSelected;
        function dataHasSelection(data) {
            for (var i = 0, ilen = data.length; i < ilen; i++) {
                if (data[i].selected)
                    return true;
            }
            return false;
        }
        visuals.dataHasSelection = dataHasSelection;
        var InteractivityService = (function () {
            function InteractivityService(hostServices) {
                this.renderSelectionInVisual = _.noop;
                this.renderSelectionInLegend = _.noop;
                this.renderSelectionInLabels = _.noop;
                // Selection state
                this.selectedIds = [];
                this.isInvertedSelectionMode = false;
                debug.assertValue(hostServices, 'hostServices');
                this.hostService = hostServices;
            }
            // IInteractivityService Implementation
            /** Binds the vsiual to the interactivityService */
            InteractivityService.prototype.bind = function (dataPoints, behavior, behaviorOptions, options) {
                var _this = this;
                // Bind the data
                if (options && options.overrideSelectionFromData) {
                    // Override selection state from data points if needed
                    this.takeSelectionStateFromDataPoints(dataPoints);
                }
                if (options) {
                    if (options.isLegend) {
                        // Bind to legend data instead of normal data if isLegend
                        this.selectableLegendDataPoints = dataPoints;
                        this.renderSelectionInLegend = function () { return behavior.renderSelection(_this.legendHasSelection()); };
                    }
                    else if (options.isLabels) {
                        //Bind to label data instead of normal data if isLabels
                        this.selectableLabelsDataPoints = dataPoints;
                        this.renderSelectionInLabels = function () { return behavior.renderSelection(_this.labelsHasSelection()); };
                    }
                    else {
                        this.selectableDataPoints = dataPoints;
                        this.renderSelectionInVisual = function () { return behavior.renderSelection(_this.hasSelection()); };
                    }
                    if (options.hasSelectionOverride != null) {
                        this.hasSelectionOverride = options.hasSelectionOverride;
                    }
                    if (options.slicerDefaultValueHandler) {
                        this.slicerDefaultValueHandler = options.slicerDefaultValueHandler;
                    }
                }
                else {
                    this.selectableDataPoints = dataPoints;
                    this.renderSelectionInVisual = function () { return behavior.renderSelection(_this.hasSelection()); };
                }
                // Bind to the behavior
                this.behavior = behavior;
                behavior.bindEvents(behaviorOptions, this);
                // Sync data points with current selection state
                this.syncSelectionState();
            };
            /**
             * Sets the selected state of all selectable data points to false and invokes the behavior's select command.
             */
            InteractivityService.prototype.clearSelection = function () {
                // if default value is already applied, don't clear the default selection
                if (this.slicerDefaultValueHandler && this.slicerDefaultValueHandler.getDefaultValue() && this.useDefaultValue) {
                    this.isInvertedSelectionMode = false;
                    return;
                }
                this.hasSelectionOverride = undefined;
                ArrayExtensions.clear(this.selectedIds);
                this.isInvertedSelectionMode = false;
                this.applyToAllSelectableDataPoints(function (dataPoint) { return dataPoint.selected = false; });
                this.renderAll();
            };
            InteractivityService.prototype.applySelectionStateToData = function (dataPoints) {
                for (var _i = 0, dataPoints_1 = dataPoints; _i < dataPoints_1.length; _i++) {
                    var dataPoint = dataPoints_1[_i];
                    dataPoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(dataPoint, this.selectedIds);
                }
                return this.hasSelection();
            };
            /**
             * Checks whether there is at least one item selected.
             */
            InteractivityService.prototype.hasSelection = function () {
                return this.selectedIds.length > 0;
            };
            InteractivityService.prototype.legendHasSelection = function () {
                return this.selectableLegendDataPoints ? dataHasSelection(this.selectableLegendDataPoints) : false;
            };
            InteractivityService.prototype.labelsHasSelection = function () {
                return this.selectableLabelsDataPoints ? dataHasSelection(this.selectableLabelsDataPoints) : false;
            };
            InteractivityService.prototype.isSelectionModeInverted = function () {
                return this.isInvertedSelectionMode;
            };
            InteractivityService.prototype.setSelectionModeInverted = function (inverted) {
                this.isInvertedSelectionMode = inverted;
            };
            // ISelectionHandler Implementation
            InteractivityService.prototype.handleSelection = function (dataPoint, multiSelect) {
                // defect 7067397: should not happen so assert but also don't continue as it's
                // causing a lot of error telemetry in desktop.
                debug.assertValue(dataPoint, 'dataPoint');
                if (!dataPoint)
                    return;
                this.useDefaultValue = false;
                this.select(dataPoint, multiSelect);
                this.sendSelectionToHost();
                this.renderAll();
            };
            InteractivityService.prototype.handleContextMenu = function (dataPoint, point) {
                this.sendContextMenuToHost(dataPoint, point);
            };
            InteractivityService.prototype.handleClearSelection = function () {
                this.useDefaultValue = true;
                this.clearSelection();
                this.sendSelectionToHost();
            };
            InteractivityService.prototype.toggleSelectionModeInversion = function () {
                this.useDefaultValue = false;
                this.isInvertedSelectionMode = !this.isInvertedSelectionMode;
                ArrayExtensions.clear(this.selectedIds);
                this.applyToAllSelectableDataPoints(function (dataPoint) { return dataPoint.selected = false; });
                this.sendSelectionToHost();
                this.isInvertedSelectionMode ? this.syncSelectionStateInverted() : this.syncSelectionState();
                this.renderAll();
                return this.isInvertedSelectionMode;
            };
            InteractivityService.prototype.persistSelectionFilter = function (filterPropertyIdentifier) {
                this.hostService.persistProperties(this.createChangeForFilterProperty(filterPropertyIdentifier));
            };
            InteractivityService.prototype.setDefaultValueMode = function (useDefaultValue) {
                this.useDefaultValue = useDefaultValue;
            };
            InteractivityService.prototype.isDefaultValueEnabled = function () {
                return this.useDefaultValue;
            };
            // Private utility methods
            InteractivityService.prototype.renderAll = function () {
                this.renderSelectionInVisual();
                this.renderSelectionInLegend();
                this.renderSelectionInLabels();
            };
            /** Marks a data point as selected and syncs selection with the host. */
            InteractivityService.prototype.select = function (d, multiSelect) {
                // If we're in inverted mode, use the invertedSelect instead
                if (this.isInvertedSelectionMode) {
                    return this.selectInverted(d, multiSelect);
                }
                // For highlight data points we actually want to select the non-highlight data point
                if (d.identity.highlight) {
                    d = _.find(this.selectableDataPoints, function (dp) { return !dp.identity.highlight && d.identity.includes(dp.identity, /* ignoreHighlight */ true); });
                    debug.assertValue(d, 'Expected to find a non-highlight data point');
                }
                var id = d.identity;
                if (!id)
                    return;
                var selected = !d.selected || (!multiSelect && this.selectedIds.length > 1);
                // If we have a multiselect flag, we attempt a multiselect
                if (multiSelect) {
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    }
                    else {
                        d.selected = false;
                        this.removeId(id);
                    }
                }
                // We do a single select if we didn't do a multiselect or if we find out that the multiselect is invalid.
                if (!multiSelect || !this.hostService.canSelect({ data: this.selectedIds.map(function (value) { return value.getSelector(); }) })) {
                    this.clearSelection();
                    if (selected) {
                        d.selected = true;
                        this.selectedIds.push(id);
                    }
                }
                this.syncSelectionState();
            };
            InteractivityService.prototype.selectInverted = function (d, multiSelect) {
                var wasSelected = d.selected;
                var id = d.identity;
                debug.assert(!!multiSelect, "inverted selections are only supported in multiselect mode");
                // the current datapoint state has to be inverted
                d.selected = !wasSelected;
                if (wasSelected)
                    this.removeId(id);
                else
                    this.selectedIds.push(id);
                this.syncSelectionStateInverted();
            };
            InteractivityService.prototype.removeId = function (toRemove) {
                var selectedIds = this.selectedIds;
                for (var i = selectedIds.length - 1; i > -1; i--) {
                    var currentId = selectedIds[i];
                    if (toRemove.includes(currentId))
                        selectedIds.splice(i, 1);
                }
            };
            /** Note: Public for UnitTesting */
            InteractivityService.prototype.createChangeForFilterProperty = function (filterPropertyIdentifier) {
                var properties = {};
                var selectors = [];
                if (this.selectedIds.length > 0) {
                    selectors = _.chain(this.selectedIds)
                        .filter(function (value) { return value.hasIdentity(); })
                        .map(function (value) { return value.getSelector(); })
                        .value();
                }
                var instance = {
                    objectName: filterPropertyIdentifier.objectName,
                    selector: undefined,
                    properties: properties
                };
                var filter = powerbi.data.Selector.filterFromSelector(selectors, this.isInvertedSelectionMode);
                if (this.slicerDefaultValueHandler && this.slicerDefaultValueHandler.getDefaultValue()) {
                    // we explicitly check for true/false because undefine means no default value
                    if (this.useDefaultValue === true)
                        filter = powerbi.data.SemanticFilter.getDefaultValueFilter(this.slicerDefaultValueHandler.getIdentityFields());
                    else if (_.isEmpty(selectors))
                        filter = powerbi.data.SemanticFilter.getAnyValueFilter(this.slicerDefaultValueHandler.getIdentityFields());
                }
                if (filter == null) {
                    properties[filterPropertyIdentifier.propertyName] = {};
                    return {
                        remove: [instance]
                    };
                }
                else {
                    properties[filterPropertyIdentifier.propertyName] = filter;
                    return {
                        merge: [instance]
                    };
                }
            };
            InteractivityService.prototype.sendContextMenuToHost = function (dataPoint, position) {
                var host = this.hostService;
                if (!host.onContextMenu)
                    return;
                var selectors = this.getSelectorsByColumn([dataPoint.identity]);
                if (_.isEmpty(selectors))
                    return;
                var args = {
                    data: selectors,
                    position: position
                };
                host.onContextMenu(args);
            };
            InteractivityService.prototype.sendSelectionToHost = function () {
                var host = this.hostService;
                if (host.onSelect) {
                    var selectArgs = {
                        data: this.selectedIds.filter(function (value) { return value.hasIdentity(); }).map(function (value) { return value.getSelector(); })
                    };
                    var data2 = this.getSelectorsByColumn(this.selectedIds);
                    if (!_.isEmpty(data2))
                        selectArgs.data2 = data2;
                    host.onSelect(selectArgs);
                }
            };
            InteractivityService.prototype.getSelectorsByColumn = function (selectionIds) {
                return _(selectionIds)
                    .filter(function (value) { return value.hasIdentity; })
                    .map(function (value) { return value.getSelectorsByColumn(); })
                    .compact()
                    .value();
            };
            InteractivityService.prototype.takeSelectionStateFromDataPoints = function (dataPoints) {
                debug.assertValue(dataPoints, "dataPoints");
                var selectedIds = this.selectedIds;
                // Replace the existing selectedIds rather than merging.
                ArrayExtensions.clear(selectedIds);
                for (var _i = 0, dataPoints_2 = dataPoints; _i < dataPoints_2.length; _i++) {
                    var dataPoint = dataPoints_2[_i];
                    if (dataPoint.selected)
                        selectedIds.push(dataPoint.identity);
                }
            };
            /**
             * Syncs the selection state for all data points that have the same category. Returns
             * true if the selection state was out of sync and corrections were made; false if
             * the data is already in sync with the service.
             *
             * If the data is not compatible with the current service's current selection state,
             * the state is cleared and the cleared selection is sent to the host.
             *
             * Ignores series for now, since we don't support series selection at the moment.
             */
            InteractivityService.prototype.syncSelectionState = function () {
                if (this.isInvertedSelectionMode) {
                    return this.syncSelectionStateInverted();
                }
                var selectedIds = this.selectedIds;
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var selectableLabelsDataPoints = this.selectableLabelsDataPoints;
                var foundMatchingId = false; // Checked only against the visual's data points; it's possible to have stuff selected in the visual that's not in the legend, but not vice-verse
                if (!selectableDataPoints && !selectableLegendDataPoints)
                    return;
                if (selectableDataPoints) {
                    if (InteractivityService.updateSelectableDataPointsBySelectedIds(selectableDataPoints, selectedIds))
                        foundMatchingId = true;
                }
                if (selectableLegendDataPoints) {
                    if (InteractivityService.updateSelectableDataPointsBySelectedIds(selectableLegendDataPoints, selectedIds))
                        foundMatchingId = true;
                }
                if (selectableLabelsDataPoints) {
                    var labelsDataPoint_1;
                    for (var i = 0, ilen = selectableLabelsDataPoints.length; i < ilen; i++) {
                        labelsDataPoint_1 = selectableLabelsDataPoints[i];
                        if (selectedIds.some(function (value) { return value.includes(labelsDataPoint_1.identity); }))
                            labelsDataPoint_1.selected = true;
                        else
                            labelsDataPoint_1.selected = false;
                    }
                }
                if (!foundMatchingId && selectedIds.length > 0) {
                    this.clearSelection();
                    this.sendSelectionToHost();
                }
            };
            InteractivityService.prototype.syncSelectionStateInverted = function () {
                var selectedIds = this.selectedIds;
                var selectableDataPoints = this.selectableDataPoints;
                if (!selectableDataPoints)
                    return;
                if (selectedIds.length === 0) {
                    for (var _i = 0, selectableDataPoints_1 = selectableDataPoints; _i < selectableDataPoints_1.length; _i++) {
                        var dataPoint_1 = selectableDataPoints_1[_i];
                        dataPoint_1.selected = false;
                    }
                }
                else {
                    for (var _a = 0, selectableDataPoints_2 = selectableDataPoints; _a < selectableDataPoints_2.length; _a++) {
                        var dataPoint = selectableDataPoints_2[_a];
                        if (selectedIds.some(function (value) { return value.includes(dataPoint.identity); }))
                            dataPoint.selected = true;
                        else if (dataPoint.selected)
                            dataPoint.selected = false;
                    }
                }
            };
            InteractivityService.prototype.applyToAllSelectableDataPoints = function (action) {
                var selectableDataPoints = this.selectableDataPoints;
                var selectableLegendDataPoints = this.selectableLegendDataPoints;
                var selectableLabelsDataPoints = this.selectableLabelsDataPoints;
                if (selectableDataPoints) {
                    for (var _i = 0, selectableDataPoints_3 = selectableDataPoints; _i < selectableDataPoints_3.length; _i++) {
                        var dataPoint = selectableDataPoints_3[_i];
                        action(dataPoint);
                    }
                }
                if (selectableLegendDataPoints) {
                    for (var _a = 0, selectableLegendDataPoints_1 = selectableLegendDataPoints; _a < selectableLegendDataPoints_1.length; _a++) {
                        var dataPoint = selectableLegendDataPoints_1[_a];
                        action(dataPoint);
                    }
                }
                if (selectableLabelsDataPoints) {
                    for (var _b = 0, selectableLabelsDataPoints_1 = selectableLabelsDataPoints; _b < selectableLabelsDataPoints_1.length; _b++) {
                        var dataPoint = selectableLabelsDataPoints_1[_b];
                        action(dataPoint);
                    }
                }
            };
            InteractivityService.updateSelectableDataPointsBySelectedIds = function (selectableDataPoints, selectedIds) {
                var foundMatchingId = false;
                for (var _i = 0, selectableDataPoints_4 = selectableDataPoints; _i < selectableDataPoints_4.length; _i++) {
                    var datapoint = selectableDataPoints_4[_i];
                    datapoint.selected = InteractivityService.checkDatapointAgainstSelectedIds(datapoint, selectedIds);
                    if (datapoint.selected)
                        foundMatchingId = true;
                }
                return foundMatchingId;
            };
            InteractivityService.checkDatapointAgainstSelectedIds = function (datapoint, selectedIds) {
                return selectedIds.some(function (value) { return value.includes(datapoint.identity); });
            };
            return InteractivityService;
        }());
        visuals.InteractivityService = InteractivityService;
        ;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            var CategoryTypes = visuals.MapUtil.CategoryTypes;
            var Settings = visuals.MapUtil.Settings;
            function createGeocoder() {
                return {
                    geocode: geocode,
                    geocodeBoundary: geocodeBoundary,
                    geocodePoint: geocodePoint,
                };
            }
            services.createGeocoder = createGeocoder;
            services.safeCharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
            /** Note: Used for test mockup */
            services.BingAjaxCall = $.ajax;
            services.CategoryTypeArray = [
                "Address",
                "City",
                "Continent",
                "Country",
                "County",
                "Longitude",
                "Latitude",
                "Place",
                "PostalCode",
                "StateOrProvince"
            ];
            function isCategoryType(value) {
                return services.CategoryTypeArray.indexOf(value) > -1;
            }
            services.isCategoryType = isCategoryType;
            services.BingEntities = {
                Continent: "Continent",
                Sovereign: "Sovereign",
                CountryRegion: "CountryRegion",
                AdminDivision1: "AdminDivision1",
                AdminDivision2: "AdminDivision2",
                PopulatedPlace: "PopulatedPlace",
                Postcode: "Postcode",
                Postcode1: "Postcode1",
                Neighborhood: "Neighborhood",
                Address: "Address",
            };
            // Static variables for caching, maps, etc.
            var geocodeQueue;
            var activeRequests;
            var categoryToBingEntity;
            var categoryToBingEntityGeodata;
            var geocodingCache;
            var GeocodeQuery = (function () {
                function GeocodeQuery(query, category) {
                    this.query = query != null ? query : "";
                    this.category = category != null ? category : "";
                    this.key = (this.query + "/" + this.category).toLowerCase();
                    this.cacheHits = 0;
                    if (!geocodingCache) {
                        geocodingCache = services.createGeocodingCache(Settings.MaxCacheSize, Settings.MaxCacheSizeOverflow);
                    }
                }
                GeocodeQuery.prototype.incrementCacheHit = function () {
                    this.cacheHits++;
                };
                GeocodeQuery.prototype.getCacheHits = function () {
                    return this.cacheHits;
                };
                GeocodeQuery.prototype.getBingEntity = function () {
                    var category = this.category.toLowerCase();
                    if (!categoryToBingEntity) {
                        categoryToBingEntity = {};
                        categoryToBingEntity[CategoryTypes.Continent.toLowerCase()] = services.BingEntities.Continent;
                        categoryToBingEntity[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.Sovereign;
                        categoryToBingEntity[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1;
                        categoryToBingEntity[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2;
                        categoryToBingEntity[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace;
                        categoryToBingEntity[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode;
                        categoryToBingEntity[CategoryTypes.Address.toLowerCase()] = services.BingEntities.Address;
                    }
                    return categoryToBingEntity[category] || "";
                };
                GeocodeQuery.prototype.getUrl = function () {
                    var url = Settings.BingUrl + "?key=" + Settings.BingKey;
                    var entityType = this.getBingEntity();
                    var queryAdded = false;
                    if (entityType) {
                        if (entityType === services.BingEntities.Postcode) {
                            url += "&includeEntityTypes=Postcode,Postcode1,Postcode2,Postcode3,Postcode4";
                        }
                        else if (this.query.indexOf(",") === -1 && (entityType === services.BingEntities.AdminDivision1 || entityType === services.BingEntities.AdminDivision2)) {
                            queryAdded = true;
                            try {
                                url += "&adminDistrict=" + decodeURIComponent(this.query);
                            }
                            catch (e) {
                                return null;
                            }
                        }
                        else {
                            url += "&includeEntityTypes=" + entityType;
                        }
                    }
                    if (!queryAdded) {
                        try {
                            url += "&q=" + decodeURIComponent(this.query);
                        }
                        catch (e) {
                            return null;
                        }
                    }
                    var cultureName = navigator.userLanguage || navigator["language"];
                    cultureName = mapLocalesForBing(cultureName);
                    if (cultureName) {
                        url += "&c=" + cultureName;
                    }
                    url += "&maxRes=20";
                    // If the query is of length 2, request the ISO 2-letter country code to be returned with the result to be compared against the query so that such results can be preferred.
                    if (this.query.length === 2 && this.category === CategoryTypes.CountryRegion) {
                        url += "&include=ciso2";
                    }
                    return url;
                };
                return GeocodeQuery;
            }());
            services.GeocodeQuery = GeocodeQuery;
            var GeocodePointQuery = (function (_super) {
                __extends(GeocodePointQuery, _super);
                function GeocodePointQuery(latitude, longitude) {
                    _super.call(this, [latitude, longitude].join(), "Point");
                    this.latitude = latitude;
                    this.longitude = longitude;
                }
                GeocodePointQuery.prototype.getUrl = function () {
                    var url = Settings.BingUrl + "/" +
                        [this.latitude, this.longitude].join() + "?" +
                        "key=" + Settings.BingKey +
                        "&includeEntityTypes=" + [
                        services.BingEntities.Address,
                        services.BingEntities.Neighborhood,
                        services.BingEntities.PopulatedPlace,
                        services.BingEntities.Postcode1,
                        services.BingEntities.AdminDivision1,
                        services.BingEntities.AdminDivision2,
                        services.BingEntities.CountryRegion].join() +
                        "&include=ciso2";
                    return url;
                };
                return GeocodePointQuery;
            }(GeocodeQuery));
            services.GeocodePointQuery = GeocodePointQuery;
            var GeocodeBoundaryQuery = (function (_super) {
                __extends(GeocodeBoundaryQuery, _super);
                function GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData) {
                    if (maxGeoData === void 0) { maxGeoData = 3; }
                    _super.call(this, [latitude, longitude, levelOfDetail, maxGeoData].join(","), category);
                    this.latitude = latitude;
                    this.longitude = longitude;
                    this.levelOfDetail = levelOfDetail;
                    this.maxGeoData = maxGeoData;
                }
                GeocodeBoundaryQuery.prototype.getBingEntity = function () {
                    var category = this.category.toLowerCase();
                    if (!categoryToBingEntityGeodata) {
                        categoryToBingEntityGeodata = {};
                        categoryToBingEntityGeodata[CategoryTypes.CountryRegion.toLowerCase()] = services.BingEntities.CountryRegion;
                        categoryToBingEntityGeodata[CategoryTypes.StateOrProvince.toLowerCase()] = services.BingEntities.AdminDivision1;
                        categoryToBingEntityGeodata[CategoryTypes.County.toLowerCase()] = services.BingEntities.AdminDivision2;
                        categoryToBingEntityGeodata[CategoryTypes.City.toLowerCase()] = services.BingEntities.PopulatedPlace;
                        categoryToBingEntityGeodata[CategoryTypes.PostalCode.toLowerCase()] = services.BingEntities.Postcode1;
                    }
                    return categoryToBingEntityGeodata[category] || "";
                };
                GeocodeBoundaryQuery.prototype.getUrl = function () {
                    var url = Settings.BingUrlGeodata + "key=" + Settings.BingKey + "&$format=json";
                    var entityType = this.getBingEntity();
                    if (!entityType) {
                        return null;
                    }
                    var cultureName = navigator.userLanguage || navigator["language"];
                    cultureName = mapLocalesForBing(cultureName);
                    var cultures = cultureName.split("-");
                    var data = [this.latitude, this.longitude, this.levelOfDetail, "'" + entityType + "'", 1, 0, "'" + cultureName + "'"];
                    if (cultures.length > 1) {
                        data.push("'" + cultures[1] + "'");
                    }
                    return url + "&SpatialFilter=GetBoundary(" + data.join(", ") + ")";
                };
                return GeocodeBoundaryQuery;
            }(GeocodeQuery));
            services.GeocodeBoundaryQuery = GeocodeBoundaryQuery;
            /**
             * Map locales that cause failures to similar locales that work
             */
            function mapLocalesForBing(locale) {
                switch (locale.toLowerCase()) {
                    case 'fr':
                        return 'fr-FR';
                    default:
                        return locale;
                }
            }
            function geocodeCore(geocodeQuery) {
                var result = geocodingCache ? geocodingCache.getCoordinates(geocodeQuery) : undefined;
                var deferred = $.Deferred();
                if (result) {
                    deferred.resolve(result);
                }
                else {
                    geocodeQueue.push({ query: geocodeQuery, deferred: deferred });
                    dequeue();
                }
                return deferred;
            }
            services.geocodeCore = geocodeCore;
            function geocode(query, category) {
                if (category === void 0) { category = ""; }
                return geocodeCore(new GeocodeQuery(query, category));
            }
            services.geocode = geocode;
            function geocodeBoundary(latitude, longitude, category, levelOfDetail, maxGeoData) {
                if (category === void 0) { category = ""; }
                if (levelOfDetail === void 0) { levelOfDetail = 2; }
                if (maxGeoData === void 0) { maxGeoData = 3; }
                return geocodeCore(new GeocodeBoundaryQuery(latitude, longitude, category, levelOfDetail, maxGeoData));
            }
            services.geocodeBoundary = geocodeBoundary;
            function geocodePoint(latitude, longitude) {
                return geocodeCore(new GeocodePointQuery(latitude, longitude));
            }
            services.geocodePoint = geocodePoint;
            function dequeue(decrement) {
                if (decrement === void 0) { decrement = 0; }
                activeRequests -= decrement;
                while (activeRequests < Settings.MaxBingRequest) {
                    if (geocodeQueue.length === 0) {
                        break;
                    }
                    activeRequests++;
                    makeRequest(geocodeQueue.shift());
                }
            }
            function makeRequest(item) {
                // Check again if we already got the coordinate;
                var result = geocodingCache ? geocodingCache.getCoordinates(item.query) : undefined;
                if (result) {
                    setTimeout(function () { return dequeue(1); });
                    item.deferred.resolve(result);
                    return;
                }
                // Unfortunately the Bing service doesn't support CORS, only jsonp. This issue must be raised and revised.
                // VSTS: 1396088 - Tracking: Ask: Bing geocoding to support CORS
                var config = {
                    type: "GET",
                    dataType: "jsonp",
                    jsonp: "jsonp"
                };
                var url = item.query.getUrl();
                if (!url) {
                    completeRequest(item, new Error("Unsupported query. " + item.query.query));
                }
                services.BingAjaxCall(url, config).then(function (data) {
                    try {
                        if (item.query instanceof GeocodeBoundaryQuery) {
                            var result_1 = data;
                            if (result_1 && result_1.d && Array.isArray(result_1.d.results) && result_1.d.results.length > 0) {
                                var entity = result_1.d.results[0];
                                var primitives = entity.Primitives;
                                if (primitives && primitives.length > 0) {
                                    var coordinates = {
                                        latitude: item.query.latitude,
                                        longitude: item.query.longitude,
                                        locations: []
                                    };
                                    primitives.sort(function (a, b) {
                                        if (a.Shape.length < b.Shape.length) {
                                            return 1;
                                        }
                                        if (a.Shape.length > b.Shape.length) {
                                            return -1;
                                        }
                                        return 0;
                                    });
                                    var maxGeoData = Math.min(primitives.length, item.query.maxGeoData);
                                    for (var i = 0; i < maxGeoData; i++) {
                                        var ringStr = primitives[i].Shape;
                                        var ringArray = ringStr.split(",");
                                        for (var j = 1; j < ringArray.length; j++) {
                                            coordinates.locations.push({ nativeBing: ringArray[j] });
                                        }
                                    }
                                    completeRequest(item, null, coordinates);
                                }
                                else {
                                    completeRequest(item, new Error("Geocode result is empty."));
                                }
                            }
                            else {
                                completeRequest(item, new Error("Geocode result is empty."));
                            }
                        }
                        else if (item.query instanceof GeocodePointQuery) {
                            var resources = data.resourceSets[0].resources;
                            if (Array.isArray(resources) && resources.length > 0) {
                                var index = getBestResultIndex(resources, item.query);
                                var pointData = resources[index].point.coordinates;
                                var addressData = resources[index].address;
                                var coordinates = {
                                    latitude: parseFloat(pointData[0]),
                                    longitude: parseFloat(pointData[1]),
                                    addressLine: addressData.addressLine,
                                    locality: addressData.locality,
                                    neighborhood: addressData.neighborhood,
                                    adminDistrict: addressData.adminDistrict,
                                    adminDistrict2: addressData.adminDistrict2,
                                    formattedAddress: addressData.formattedAddress,
                                    postalCode: addressData.postalCode,
                                    countryRegionIso2: addressData.countryRegionIso2,
                                    countryRegion: addressData.countryRegion,
                                    landmark: addressData.landmark,
                                };
                                completeRequest(item, null, coordinates);
                            }
                            else {
                                completeRequest(item, new Error("Geocode result is empty."));
                            }
                        }
                        else {
                            var resources = data.resourceSets[0].resources;
                            if (Array.isArray(resources) && resources.length > 0) {
                                var index = getBestResultIndex(resources, item.query);
                                var pointData = resources[index].point.coordinates;
                                var coordinates = {
                                    latitude: parseFloat(pointData[0]),
                                    longitude: parseFloat(pointData[1])
                                };
                                completeRequest(item, null, coordinates);
                            }
                            else {
                                completeRequest(item, new Error("Geocode result is empty."));
                            }
                        }
                    }
                    catch (error) {
                        completeRequest(item, error);
                    }
                }, function (error) {
                    completeRequest(item, error);
                });
            }
            var dequeueTimeoutId;
            function completeRequest(item, error, coordinate) {
                if (coordinate === void 0) { coordinate = null; }
                dequeueTimeoutId = setTimeout(function () { return dequeue(1); }, Settings.UseDoubleArrayGeodataResult ? Settings.UseDoubleArrayDequeueTimeout : 0);
                if (error) {
                    item.deferred.reject(error);
                }
                else {
                    if (geocodingCache && !(item.query instanceof GeocodePointQuery))
                        geocodingCache.registerCoordinates(item.query, coordinate);
                    item.deferred.resolve(coordinate);
                }
            }
            function getBestResultIndex(resources, query) {
                var queryString = query.query.toLowerCase();
                // If string is of length 2 and is a country, check against the ISO country code of results, prefering exact matches
                if (queryString.length === 2 && query.category === CategoryTypes.CountryRegion) {
                    for (var index = 0; index < resources.length; index++) {
                        var iso2 = resources[index].address && resources[index].address.countryRegionIso2;
                        if (iso2 && queryString === iso2.toLowerCase()) {
                            return index;
                        }
                    }
                }
                // Prefer results that match the targetEntity (geotagged category) on the query
                var targetEntity = query.getBingEntity().toLowerCase();
                for (var index = 0; index < resources.length; index++) {
                    var resultEntity = (resources[index].entityType || "").toLowerCase();
                    if (resultEntity === targetEntity) {
                        return index;
                    }
                }
                return 0;
            }
            function reset() {
                geocodeQueue = [];
                activeRequests = 0;
                categoryToBingEntity = null;
                clearTimeout(dequeueTimeoutId);
            }
            services.reset = reset;
            reset();
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            function createGeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                return new GeocodingCache(maxCacheSize, maxCacheSizeOverflow);
            }
            services.createGeocodingCache = createGeocodingCache;
            var GeocodingCache = (function () {
                function GeocodingCache(maxCacheSize, maxCacheSizeOverflow) {
                    this.geocodeCache = {};
                    this.maxCacheSize = maxCacheSize;
                    this.maxCacheSizeOverflow = maxCacheSizeOverflow;
                }
                /**
                 * Retrieves the coordinate for the key from the cache, returning undefined on a cache miss.
                 */
                GeocodingCache.prototype.getCoordinates = function (query) {
                    // Check in-memory cache
                    var pair = this.geocodeCache[query.key];
                    if (pair) {
                        pair.query.incrementCacheHit();
                        return pair.coordinate;
                    }
                    // Check local storage cache
                    pair = powerbi.localStorageService.getData(query.key);
                    if (pair) {
                        this.registerInMemory(query, pair.coordinate);
                        return pair.coordinate;
                    }
                    return undefined;
                };
                /**
                 * Registers the query and coordinate to the cache.
                 */
                GeocodingCache.prototype.registerCoordinates = function (query, coordinate) {
                    this.registerInMemory(query, coordinate);
                    this.registerInStorage(query, coordinate);
                };
                GeocodingCache.prototype.registerInMemory = function (query, coordinate) {
                    var geocodeCache = this.geocodeCache;
                    var keys = Object.keys(geocodeCache);
                    var cacheSize = keys.length;
                    var maxCacheSize = this.maxCacheSize;
                    if (keys.length > (maxCacheSize + this.maxCacheSizeOverflow)) {
                        var sortedKeys = keys.sort(function (a, b) {
                            var cachedA = geocodeCache[a];
                            var cachedB = geocodeCache[b];
                            var ca = cachedA ? cachedA.query.getCacheHits() : 0;
                            var cb = cachedB ? cachedB.query.getCacheHits() : 0;
                            return ca < cb ? -1 : (ca > cb ? 1 : 0);
                        });
                        for (var i = 0; i < (cacheSize - maxCacheSize); i++) {
                            geocodeCache[sortedKeys[i]] = undefined;
                        }
                    }
                    geocodeCache[query.key] = { query: query, coordinate: coordinate };
                };
                GeocodingCache.prototype.registerInStorage = function (query, coordinate) {
                    powerbi.localStorageService.setData(query.key, { query: query, coordinate: coordinate });
                };
                return GeocodingCache;
            }());
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var services;
        (function (services) {
            function createGeolocation() {
                return new GeolocationService();
            }
            services.createGeolocation = createGeolocation;
            /**
             * HTML5 Implementation of IGeolocation
             */
            var GeolocationService = (function () {
                function GeolocationService() {
                    this.webGeolocation = navigator.geolocation;
                }
                GeolocationService.prototype.watchPosition = function (successCallback, errorCallback) {
                    return this.webGeolocation.watchPosition(function (position) {
                        successCallback(position);
                    }, function (error) {
                        if (errorCallback != null) {
                            errorCallback(error);
                        }
                    });
                };
                GeolocationService.prototype.clearWatch = function (watchId) {
                    this.webGeolocation.clearWatch(watchId);
                };
                GeolocationService.prototype.getCurrentPosition = function (successCallback, errorCallback) {
                    this.webGeolocation.getCurrentPosition(function (position) {
                        successCallback(position);
                    }, function (error) {
                        if (errorCallback != null) {
                            errorCallback(error);
                        }
                    });
                };
                return GeolocationService;
            }());
        })(services = visuals.services || (visuals.services = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var unsupportedVisuals = ['play', 'subview', 'smallMultiple'];
        var visualPluginFactory;
        (function (visualPluginFactory) {
            var VisualPluginService = (function () {
                function VisualPluginService(featureSwitches) {
                    this.plugins = powerbi.visuals.plugins;
                    this.featureSwitches = featureSwitches;
                }
                /**
                 * Gets metadata for all registered.
                 */
                VisualPluginService.prototype.getVisuals = function () {
                    var registry = this.plugins, names = Object.keys(registry);
                    return names.map(function (name) { return registry[name]; });
                };
                VisualPluginService.prototype.getPlugin = function (type) {
                    if (!type) {
                        return;
                    }
                    var plugin = this.plugins[type];
                    if (!plugin) {
                        return;
                    }
                    return plugin;
                };
                VisualPluginService.prototype.capabilities = function (type) {
                    var plugin = this.getPlugin(type);
                    if (plugin)
                        return plugin.capabilities;
                };
                VisualPluginService.prototype.requireSandbox = function (plugin) {
                    return plugin && plugin.custom;
                };
                VisualPluginService.prototype.removeAnyCustomVisuals = function () {
                    var plugins = powerbi.visuals.plugins;
                    for (var key in plugins) {
                        var p = plugins[key];
                        if (p.custom) {
                            delete plugins[key];
                        }
                    }
                };
                VisualPluginService.prototype.isCustomVisual = function (visual) {
                    if (visual) {
                        if (this.plugins[visual]) {
                            return this.plugins[visual].custom === true;
                        }
                        else if (_.include(unsupportedVisuals, visual)) {
                            /*use the hardcoded unsupported visual list to distinguish unsupported visual with custom visual when the plugin object is not in memory*/
                            return false;
                        }
                        else {
                            return true;
                        }
                    }
                    return false;
                };
                VisualPluginService.prototype.shouldDisableVisual = function (type, mapDisabled) {
                    return (type === visuals.plugins.map.name || type === visuals.plugins.filledMap.name) && mapDisabled;
                };
                VisualPluginService.prototype.isScriptVisualQueryable = function () {
                    // Feature switch determines if Script visuals are query visuals - currently non-query in PBI site
                    return (this.featureSwitches !== undefined && this.featureSwitches.scriptVisualEnabled);
                };
                VisualPluginService.prototype.getInteractivityOptions = function (visualType) {
                    var interactivityOptions = {
                        overflow: 'hidden',
                    };
                    return interactivityOptions;
                };
                return VisualPluginService;
            }());
            visualPluginFactory.VisualPluginService = VisualPluginService;
            function createPlugin(visualPlugins, base, create, modifyPluginFn) {
                var visualPlugin = powerbi.Prototype.inherit(base);
                visualPlugin.create = create;
                if (modifyPluginFn) {
                    modifyPluginFn(visualPlugin);
                }
                visualPlugins[base.name] = visualPlugin;
            }
            visualPluginFactory.createPlugin = createPlugin;
            function createDashboardPlugins(plugins, options, featureSwitches) {
                var tooltipsOnDashboard = options.tooltipsEnabled;
                var lineChartLabelDensityEnabled = featureSwitches && featureSwitches.lineChartLabelDensityEnabled;
                // Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.barChart, function () { return new visuals.CartesianChart({
                    chartType: 6 /* StackedBar */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Clustered Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({
                    chartType: 5 /* ClusteredBar */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Clustered Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.clusteredColumnChart, function () { return new visuals.CartesianChart({
                    chartType: 3 /* ClusteredColumn */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({
                    chartType: 4 /* StackedColumn */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Data Dot Clustered Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 15 /* DataDotClusteredColumnCombo */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Data Dot Stacked Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 16 /* DataDotStackedColumnCombo */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Donut Chart
                createPlugin(plugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Funnel Chart
                createPlugin(plugins, powerbi.visuals.plugins.funnel, function () { return new visuals.FunnelChart({
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Gauge
                createPlugin(plugins, powerbi.visuals.plugins.gauge, function () { return new visuals.Gauge({
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Hundred Percent Stacked Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({
                    chartType: 7 /* HundredPercentStackedBar */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Hundred Percent Stacked Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({
                    chartType: 8 /* HundredPercentStackedColumn */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Line Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({
                    chartType: 0 /* Line */,
                    tooltipsEnabled: tooltipsOnDashboard,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Area Chart
                createPlugin(plugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({
                    chartType: 1 /* Area */,
                    tooltipsEnabled: tooltipsOnDashboard,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Stacked Area Chart
                createPlugin(plugins, powerbi.visuals.plugins.stackedAreaChart, function () { return new visuals.CartesianChart({
                    chartType: 2 /* StackedArea */,
                    tooltipsEnabled: tooltipsOnDashboard,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Line Clustered Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 13 /* LineClusteredColumnCombo */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Line Stacked Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 14 /* LineStackedColumnCombo */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Pie Chart
                createPlugin(plugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({
                    sliceWidthRatio: 0,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Scatter Chart
                createPlugin(plugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({
                    chartType: 9 /* Scatter */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Treemap
                createPlugin(plugins, powerbi.visuals.plugins.treemap, function () { return new visuals.Treemap({
                    isScrollable: false,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Waterfall Chart
                createPlugin(plugins, powerbi.visuals.plugins.waterfallChart, function () { return new visuals.CartesianChart({
                    chartType: 12 /* Waterfall */,
                    tooltipsEnabled: tooltipsOnDashboard,
                }); });
                // Map
                createPlugin(plugins, powerbi.visuals.plugins.map, function () { return new visuals.Map({
                    tooltipsEnabled: tooltipsOnDashboard,
                    disableZooming: true,
                    disablePanning: true,
                }); });
                // Filled Map
                createPlugin(plugins, powerbi.visuals.plugins.filledMap, function () { return new visuals.Map({
                    filledMap: true,
                    tooltipsEnabled: tooltipsOnDashboard,
                    disableZooming: true,
                    disablePanning: true,
                }); });
                // Matrix
                createPlugin(plugins, powerbi.visuals.plugins.matrix, function () { return new visuals.Matrix({}); });
                // Table
                createPlugin(plugins, powerbi.visuals.plugins.table, function () { return new visuals.Table({
                    isConditionalFormattingEnabled: false,
                }); });
            }
            function createMinervaPlugins(plugins, featureSwitches) {
                var scriptVisualEnabled = featureSwitches ? featureSwitches.scriptVisualEnabled : false;
                var scriptVisualAuthoringEnabled = featureSwitches ? featureSwitches.scriptVisualAuthoringEnabled : false;
                var isLabelInteractivityEnabled = featureSwitches ? featureSwitches.isLabelInteractivityEnabled : false;
                var conditionalFormattingEnabled = featureSwitches ? featureSwitches.conditionalFormattingEnabled : false;
                var fillMapDataLabelsEnabled = featureSwitches ? featureSwitches.filledMapDataLabelsEnabled : false;
                var lineChartLabelDensityEnabled = featureSwitches ? featureSwitches.lineChartLabelDensityEnabled : false;
                // Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.barChart, function () { return new visuals.CartesianChart({
                    chartType: 6 /* StackedBar */,
                    isScrollable: true, animator: new visuals.WebColumnChartAnimator(),
                    tooltipsEnabled: true,
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Card
                createPlugin(plugins, powerbi.visuals.plugins.card, function () { return new visuals.Card({
                    isScrollable: true,
                    animator: new visuals.BaseAnimator(),
                }); });
                // Clustered Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({
                    chartType: 5 /* ClusteredBar */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Clustered Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.clusteredColumnChart, function () { return new visuals.CartesianChart({
                    chartType: 3 /* ClusteredColumn */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({
                    chartType: 4 /* StackedColumn */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Data Dot Clustered Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 15 /* DataDotClusteredColumnCombo */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior(), new visuals.DataDotChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Data Dot Stacked Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 16 /* DataDotStackedColumnCombo */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior(), new visuals.DataDotChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Donut Chart
                createPlugin(plugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({
                    animator: new visuals.WebDonutChartAnimator(),
                    isScrollable: true,
                    tooltipsEnabled: true,
                    behavior: new visuals.DonutChartWebBehavior(),
                }); });
                // Funnel Chart
                createPlugin(plugins, powerbi.visuals.plugins.funnel, function () { return new visuals.FunnelChart({
                    animator: new visuals.WebFunnelAnimator(),
                    behavior: new visuals.FunnelWebBehavior(),
                    tooltipsEnabled: true,
                }); });
                // Gauge
                createPlugin(plugins, powerbi.visuals.plugins.gauge, function () { return new visuals.Gauge({
                    animator: new visuals.BaseAnimator(),
                    tooltipsEnabled: true,
                }); });
                // Hundred Percent Stacked Bar Chart
                createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({
                    chartType: 7 /* HundredPercentStackedBar */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Hundred Percent Stacked Column Chart
                createPlugin(plugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({
                    chartType: 8 /* HundredPercentStackedColumn */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Line Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({
                    chartType: 0 /* Line */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.BaseAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.LineChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Area Chart
                createPlugin(plugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({
                    chartType: 1 /* Area */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.BaseAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.LineChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Stacked Area Chart
                createPlugin(plugins, powerbi.visuals.plugins.stackedAreaChart, function () { return new visuals.CartesianChart({
                    chartType: 2 /* StackedArea */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.BaseAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.LineChartWebBehavior()]),
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                }); });
                // Line Clustered Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 13 /* LineClusteredColumnCombo */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior(), new visuals.LineChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Line Stacked Combo Chart
                createPlugin(plugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function () { return new visuals.CartesianChart({
                    chartType: 14 /* LineStackedColumnCombo */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.WebColumnChartAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ColumnChartWebBehavior(), new visuals.LineChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Pie Chart
                createPlugin(plugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({
                    sliceWidthRatio: 0,
                    animator: new visuals.WebDonutChartAnimator(),
                    isScrollable: true,
                    tooltipsEnabled: true,
                    behavior: new visuals.DonutChartWebBehavior(),
                }); });
                // Scatter Chart
                createPlugin(plugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({
                    chartType: 9 /* Scatter */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    animator: new visuals.BaseAnimator(),
                    behavior: new visuals.CartesianChartBehavior([new visuals.ScatterChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Treemap
                createPlugin(plugins, powerbi.visuals.plugins.treemap, function () { return new visuals.Treemap({
                    animator: new visuals.WebTreemapAnimator,
                    isScrollable: true,
                    behavior: new visuals.TreemapWebBehavior(),
                    tooltipsEnabled: true,
                }); });
                // Waterfall Chart
                createPlugin(plugins, powerbi.visuals.plugins.waterfallChart, function () { return new visuals.CartesianChart({
                    chartType: 12 /* Waterfall */,
                    isScrollable: true,
                    tooltipsEnabled: true,
                    behavior: new visuals.CartesianChartBehavior([new visuals.WaterfallChartWebBehavior()]),
                    isLabelInteractivityEnabled: isLabelInteractivityEnabled,
                }); });
                // Map
                createPlugin(plugins, powerbi.visuals.plugins.map, function () { return new visuals.Map({
                    behavior: new visuals.MapBehavior(),
                    tooltipsEnabled: true,
                    isLegendScrollable: true,
                }); });
                // Filled Map
                createPlugin(plugins, powerbi.visuals.plugins.filledMap, function () { return new visuals.Map({
                    filledMap: true,
                    behavior: new visuals.MapBehavior,
                    tooltipsEnabled: true,
                    filledMapDataLabelsEnabled: fillMapDataLabelsEnabled,
                    isLegendScrollable: true,
                }); });
                // Slicer
                createPlugin(plugins, powerbi.visuals.plugins.slicer, function () { return new visuals.Slicer({
                    behavior: new visuals.SlicerWebBehavior(),
                }); });
                // Matrix
                createPlugin(plugins, powerbi.visuals.plugins.matrix, function () { return new visuals.Matrix({}); });
                // Table
                createPlugin(plugins, powerbi.visuals.plugins.table, function () { return new visuals.Table({
                    isConditionalFormattingEnabled: conditionalFormattingEnabled,
                }); });
                ;
                if (scriptVisualEnabled && scriptVisualAuthoringEnabled) {
                    // R visual
                    createPlugin(plugins, powerbi.visuals.plugins.scriptVisual, function () { return new visuals.ScriptVisual({ canRefresh: true }); });
                }
            }
            var MinervaVisualPluginService = (function (_super) {
                __extends(MinervaVisualPluginService, _super);
                function MinervaVisualPluginService(featureSwitches) {
                    _super.call(this, featureSwitches);
                    debug.assertValue(featureSwitches, 'featureSwitches');
                    this.visualPlugins = {};
                    this.addCustomVisualizations([]);
                    createMinervaPlugins(this.visualPlugins, this.featureSwitches);
                }
                MinervaVisualPluginService.prototype.getVisuals = function () {
                    // Current visual types that supports visual conversion. Please don't change the orders
                    // CAUTION: If you are adding new visual types, please check if you need to update the height of
                    // the visual convertion pane in visualization pane as well.
                    var convertibleVisualTypes = [
                        powerbi.visuals.plugins.barChart,
                        powerbi.visuals.plugins.columnChart,
                        powerbi.visuals.plugins.clusteredBarChart,
                        powerbi.visuals.plugins.clusteredColumnChart,
                        powerbi.visuals.plugins.hundredPercentStackedBarChart,
                        powerbi.visuals.plugins.hundredPercentStackedColumnChart,
                        powerbi.visuals.plugins.lineChart,
                        powerbi.visuals.plugins.areaChart,
                        powerbi.visuals.plugins.stackedAreaChart,
                        powerbi.visuals.plugins.lineStackedColumnComboChart,
                        powerbi.visuals.plugins.lineClusteredColumnComboChart,
                        powerbi.visuals.plugins.waterfallChart,
                        powerbi.visuals.plugins.scatterChart,
                        powerbi.visuals.plugins.pieChart,
                        powerbi.visuals.plugins.treemap,
                        powerbi.visuals.plugins.map,
                        powerbi.visuals.plugins.table,
                        powerbi.visuals.plugins.matrix,
                        powerbi.visuals.plugins.filledMap,
                        powerbi.visuals.plugins.funnel,
                        powerbi.visuals.plugins.gauge,
                        powerbi.visuals.plugins.multiRowCard,
                        powerbi.visuals.plugins.card,
                        powerbi.visuals.plugins.kpi,
                        powerbi.visuals.plugins.slicer,
                        powerbi.visuals.plugins.donutChart
                    ];
                    if (this.featureSwitches.scriptVisualEnabled && this.featureSwitches.scriptVisualAuthoringEnabled) {
                        convertibleVisualTypes.push(powerbi.visuals.plugins.scriptVisual);
                    }
                    // Add any visuals compiled in the developer tools
                    // Additionally add custom visuals.
                    for (var p in visuals.plugins) {
                        var plugin = visuals.plugins[p];
                        if (plugin.custom) {
                            this.pushPluginIntoConvertibleTypes(convertibleVisualTypes, plugin);
                        }
                    }
                    this.addCustomVisualizations(convertibleVisualTypes);
                    if (this.featureSwitches.dataDotChartEnabled) {
                        convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotClusteredColumnComboChart);
                        convertibleVisualTypes.push(powerbi.visuals.plugins.dataDotStackedColumnComboChart);
                    }
                    return convertibleVisualTypes;
                };
                MinervaVisualPluginService.prototype.pushPluginIntoConvertibleTypes = function (convertibleVisualTypes, plugin) {
                    if (!convertibleVisualTypes.some(function (pl) { return pl.name === plugin.name; })) {
                        convertibleVisualTypes.push(plugin);
                    }
                };
                MinervaVisualPluginService.prototype.addCustomVisualizations = function (convertibleVisualTypes) {
                    // Read new visual from localstorage
                    var customVisualizationDict = powerbi.localStorageService.getData('customVisualMetaData');
                    for (var visualName in customVisualizationDict) {
                        var customVisualMetaData = customVisualizationDict[visualName];
                        if (!customVisualMetaData) {
                            continue;
                        }
                        var pluginName = customVisualMetaData.pluginName;
                        // Uncompiled new visuals should not be loaded into the report
                        if (!pluginName || !customVisualMetaData.sourceCode || !customVisualMetaData.sourceCode.javascriptCode) {
                            continue;
                        }
                        var plugin = this.getPlugin(pluginName);
                        // If the browser session got restarted or its a new window the plugin wont be available, so we need to add it
                        if (!plugin) {
                            var jsCode = customVisualMetaData.sourceCode.javascriptCode;
                            var script = $("<script/>", {
                                html: jsCode + '//# sourceURL=' + pluginName + '.js\n' + '//# sourceMappingURL=' + pluginName + '.js.map'
                            });
                            script.attr('pluginName', pluginName);
                            $('body').append(script);
                            var style = $("<style/>", {
                                html: customVisualMetaData.sourceCode.cssCode
                            });
                            style.attr('pluginName', pluginName);
                            $('head').append(style);
                            plugin = this.getPlugin(pluginName);
                            if (!plugin) {
                                continue;
                            }
                        }
                        this.pushPluginIntoConvertibleTypes(convertibleVisualTypes, plugin);
                    }
                };
                MinervaVisualPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type])
                        return this.visualPlugins[type];
                    return _super.prototype.getPlugin.call(this, type);
                };
                MinervaVisualPluginService.prototype.requireSandbox = function (plugin) {
                    return (this.featureSwitches.sandboxVisualsEnabled) && (!plugin || (plugin && plugin.custom));
                };
                return MinervaVisualPluginService;
            }(VisualPluginService));
            visualPluginFactory.MinervaVisualPluginService = MinervaVisualPluginService;
            var PlaygroundVisualPluginService = (function (_super) {
                __extends(PlaygroundVisualPluginService, _super);
                function PlaygroundVisualPluginService() {
                    _super.call(this, undefined);
                    this.visualPlugins = powerbi.visuals.plugins;
                    createMinervaPlugins(this.visualPlugins, null);
                }
                PlaygroundVisualPluginService.prototype.getVisuals = function () {
                    var registry = this.visualPlugins, names = Object.keys(registry);
                    return names.map(function (name) { return registry[name]; });
                };
                PlaygroundVisualPluginService.prototype.getPlugin = function (type) {
                    if (!type) {
                        return;
                    }
                    var plugin = this.visualPlugins[type];
                    if (!plugin) {
                        return;
                    }
                    return plugin;
                };
                PlaygroundVisualPluginService.prototype.capabilities = function (type) {
                    var plugin = this.getPlugin(type);
                    if (plugin) {
                        return plugin.capabilities;
                    }
                };
                return PlaygroundVisualPluginService;
            }(VisualPluginService));
            visualPluginFactory.PlaygroundVisualPluginService = PlaygroundVisualPluginService;
            /**
             * This plug-in service is used when displaying visuals on the dashboard.
             */
            var DashboardPluginService = (function (_super) {
                __extends(DashboardPluginService, _super);
                function DashboardPluginService(featureSwitches, options) {
                    _super.call(this, featureSwitches);
                    debug.assertValue(featureSwitches, 'featureSwitches');
                    this.visualPlugins = {};
                    createDashboardPlugins(this.visualPlugins, options, this.featureSwitches);
                }
                DashboardPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                DashboardPluginService.prototype.requireSandbox = function (plugin) {
                    return (this.featureSwitches.sandboxVisualsEnabled) && (!plugin || (plugin && plugin.custom));
                };
                return DashboardPluginService;
            }(VisualPluginService));
            visualPluginFactory.DashboardPluginService = DashboardPluginService;
            // This plug-in service is used when displaying visuals for insights.
            var InsightsPluginService = (function (_super) {
                __extends(InsightsPluginService, _super);
                function InsightsPluginService(featureSwitches) {
                    _super.call(this, featureSwitches);
                    debug.assertValue(featureSwitches, 'featureSwitches');
                    this.visualPlugins = {};
                    // Clustered Bar Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({
                        chartType: 5 /* ClusteredBar */,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: true
                    }); });
                    // Column Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({
                        chartType: 4 /* StackedColumn */,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: true
                    }); });
                    // Donut Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({
                        animator: new visuals.WebDonutChartAnimator(),
                        tooltipsEnabled: true,
                    }); });
                    // Hundred Percent Stacked Bar Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({
                        chartType: 7 /* HundredPercentStackedBar */,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: true
                    }); });
                    // Hundred Percent Stacked Column Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({
                        chartType: 8 /* HundredPercentStackedColumn */,
                        animator: new visuals.WebColumnChartAnimator(),
                        tooltipsEnabled: true
                    }); });
                    // Line Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({
                        chartType: 0 /* Line */,
                        animator: new visuals.BaseAnimator(),
                        tooltipsEnabled: true,
                    }); });
                    // Area Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({
                        chartType: 1 /* Area */,
                        animator: new visuals.BaseAnimator(),
                        tooltipsEnabled: true,
                    }); });
                    // Pie Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({
                        sliceWidthRatio: 0,
                        animator: new visuals.WebDonutChartAnimator(),
                        tooltipsEnabled: true,
                    }); });
                    // Scatter Chart
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({
                        chartType: 9 /* Scatter */,
                        animator: new visuals.BaseAnimator(),
                        tooltipsEnabled: true,
                    }); }, undefined);
                }
                InsightsPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type]) {
                        return this.visualPlugins[type];
                    }
                    return _super.prototype.getPlugin.call(this, type);
                };
                InsightsPluginService.prototype.requireSandbox = function (plugin) {
                    return (this.featureSwitches.sandboxVisualsEnabled) && (!plugin || (plugin && plugin.custom));
                };
                return InsightsPluginService;
            }(VisualPluginService));
            visualPluginFactory.InsightsPluginService = InsightsPluginService;
            var MobileVisualPluginService = (function (_super) {
                __extends(MobileVisualPluginService, _super);
                function MobileVisualPluginService(smallViewPortProperties, featureSwitches) {
                    var _this = this;
                    _super.call(this, featureSwitches);
                    this.smallViewPortProperties = smallViewPortProperties || {
                        CartesianSmallViewPortProperties: {
                            hideAxesOnSmallViewPort: true,
                            hideLegendOnSmallViewPort: true,
                            MinHeightLegendVisible: MobileVisualPluginService.MinHeightLegendVisible,
                            MinHeightAxesVisible: MobileVisualPluginService.MinHeightAxesVisible,
                        },
                        GaugeSmallViewPortProperties: {
                            hideGaugeSideNumbersOnSmallViewPort: true,
                            smallGaugeMarginsOnSmallViewPort: true,
                            MinHeightGaugeSideNumbersVisible: MobileVisualPluginService.MinHeightGaugeSideNumbersVisible,
                            GaugeMarginsOnSmallViewPort: MobileVisualPluginService.GaugeMarginsOnSmallViewPort,
                        },
                        FunnelSmallViewPortProperties: {
                            hideFunnelCategoryLabelsOnSmallViewPort: true,
                            minHeightFunnelCategoryLabelsVisible: MobileVisualPluginService.MinHeightFunnelCategoryLabelsVisible,
                        },
                        DonutSmallViewPortProperties: {
                            maxHeightToScaleDonutLegend: MobileVisualPluginService.MaxHeightToScaleDonutLegend,
                        },
                    };
                    // Disable tooltips for mobile
                    visuals.TooltipManager.ShowTooltips = false;
                    // Don't trim overflow data on mobile
                    var trimOrdinalDataOnOverflow = false;
                    var mapThrottleInterval = this.getMapThrottleInterval();
                    this.visualPlugins = {};
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.areaChart, function () { return new visuals.CartesianChart({
                        chartType: 1 /* Area */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.barChart, function () { return new visuals.CartesianChart({
                        chartType: 6 /* StackedBar */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredBarChart, function () { return new visuals.CartesianChart({
                        chartType: 5 /* ClusteredBar */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.clusteredColumnChart, function () { return new visuals.CartesianChart({
                        chartType: 3 /* ClusteredColumn */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.columnChart, function () { return new visuals.CartesianChart({
                        chartType: 4 /* StackedColumn */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.comboChart, function () { return new visuals.CartesianChart({
                        chartType: 10 /* ComboChart */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotChart, function () { return new visuals.CartesianChart({
                        chartType: 11 /* DataDot */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                        chartType: 15 /* DataDotClusteredColumnCombo */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.dataDotStackedColumnComboChart, function () { return new visuals.CartesianChart({
                        chartType: 16 /* DataDotStackedColumnCombo */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedBarChart, function () { return new visuals.CartesianChart({
                        chartType: 7 /* HundredPercentStackedBar */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.hundredPercentStackedColumnChart, function () { return new visuals.CartesianChart({
                        chartType: 8 /* HundredPercentStackedColumn */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.stackedAreaChart, function () { return new visuals.CartesianChart({
                        chartType: 2 /* StackedArea */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.waterfallChart, function () { return new visuals.CartesianChart({
                        chartType: 12 /* Waterfall */,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineChart, function () { return new visuals.CartesianChart({
                        chartType: 0 /* Line */,
                        cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineClusteredColumnComboChart, function () { return new visuals.CartesianChart({
                        chartType: 13 /* LineClusteredColumnCombo */,
                        cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.lineStackedColumnComboChart, function () { return new visuals.CartesianChart({
                        chartType: 14 /* LineStackedColumnCombo */,
                        cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                        trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.scatterChart, function () { return new visuals.CartesianChart({
                        chartType: 9 /* Scatter */,
                        cartesianSmallViewPortProperties: _this.smallViewPortProperties.CartesianSmallViewPortProperties,
                        behavior: new visuals.CartesianChartBehavior([new visuals.ScatterChartMobileBehavior()])
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.gauge, function () { return new visuals.Gauge({
                        gaugeSmallViewPortProperties: _this.smallViewPortProperties.GaugeSmallViewPortProperties
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.funnel, function () { return new visuals.FunnelChart({
                        animator: null,
                        funnelSmallViewPortProperties: _this.smallViewPortProperties.FunnelSmallViewPortProperties
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.donutChart, function () { return new visuals.DonutChart({
                        disableGeometricCulling: true,
                        smallViewPortProperties: _this.smallViewPortProperties.DonutSmallViewPortProperties
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.pieChart, function () { return new visuals.DonutChart({
                        sliceWidthRatio: 0,
                        disableGeometricCulling: true,
                        smallViewPortProperties: _this.smallViewPortProperties.DonutSmallViewPortProperties
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.matrix, function () { return new visuals.Matrix({
                        isTouchEnabled: true
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.table, function () { return new visuals.Table({
                        isTouchEnabled: true
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.map, function () { return new visuals.Map({
                        viewChangeThrottleInterval: mapThrottleInterval,
                        enableCurrentLocation: featureSwitches ? featureSwitches.mapCurrentLocationEnabled : false
                    }); });
                    createPlugin(this.visualPlugins, powerbi.visuals.plugins.filledMap, function () { return new visuals.Map({
                        filledMap: true,
                        viewChangeThrottleInterval: mapThrottleInterval
                    }); });
                }
                MobileVisualPluginService.prototype.getPlugin = function (type) {
                    if (this.visualPlugins[type])
                        return this.visualPlugins[type];
                    return _super.prototype.getPlugin.call(this, type);
                };
                MobileVisualPluginService.prototype.requireSandbox = function (plugin) {
                    if (this.featureSwitches)
                        return (this.featureSwitches.sandboxVisualsEnabled) && (!plugin || (plugin && plugin.custom));
                    else
                        return _super.prototype.requireSandbox.call(this, plugin);
                };
                // Windows phone webView chokes when zooming on heavy maps,
                // this is a workaround to allow a relatively smooth pinch to zoom experience.
                MobileVisualPluginService.prototype.getMapThrottleInterval = function () {
                    var windowsPhoneThrottleInterval = 100;
                    var userAgentLowerCase = navigator.userAgent.toLowerCase();
                    if (userAgentLowerCase.indexOf('windows phone') !== -1) {
                        return windowsPhoneThrottleInterval;
                    }
                    return undefined;
                };
                MobileVisualPluginService.prototype.getInteractivityOptions = function (visualType) {
                    var mobileOptions = {
                        overflow: this.getMobileOverflowString(visualType),
                        isInteractiveLegend: this.isChartSupportInteractivity(visualType),
                        selection: true,
                    };
                    return mobileOptions;
                };
                MobileVisualPluginService.prototype.getMobileOverflowString = function (visualType) {
                    switch (visualType) {
                        case 'multiRowCard':
                            return 'visible';
                        default:
                            return 'hidden';
                    }
                };
                MobileVisualPluginService.prototype.isChartSupportInteractivity = function (visualType) {
                    switch (visualType) {
                        case 'areaChart':
                        case 'barChart':
                        case 'clusteredBarChart':
                        case 'clusteredColumnChart':
                        case 'columnChart':
                        case 'donutChart':
                        case 'hundredPercentStackedBarChart':
                        case 'hundredPercentStackedColumnChart':
                        case 'lineChart':
                        case 'pieChart':
                        case 'scatterChart':
                        case 'table':
                        case 'matrix':
                        case 'multiRowCard':
                            return true;
                        default:
                            return false;
                    }
                };
                MobileVisualPluginService.MinHeightLegendVisible = 125;
                MobileVisualPluginService.MinHeightAxesVisible = 125;
                MobileVisualPluginService.MinHeightGaugeSideNumbersVisible = 80;
                MobileVisualPluginService.GaugeMarginsOnSmallViewPort = 10;
                MobileVisualPluginService.MinHeightFunnelCategoryLabelsVisible = 80;
                MobileVisualPluginService.MaxHeightToScaleDonutLegend = 300;
                return MobileVisualPluginService;
            }(VisualPluginService));
            visualPluginFactory.MobileVisualPluginService = MobileVisualPluginService;
            // this function is called by tests
            function create() {
                return new VisualPluginService(undefined);
            }
            visualPluginFactory.create = create;
            function createVisualPluginService(featureSwitch) {
                return new VisualPluginService(featureSwitch);
            }
            visualPluginFactory.createVisualPluginService = createVisualPluginService;
            function createMinerva(featureSwitches) {
                return new MinervaVisualPluginService(featureSwitches);
            }
            visualPluginFactory.createMinerva = createMinerva;
            function createDashboard(featureSwitches, options) {
                return new DashboardPluginService(featureSwitches, options);
            }
            visualPluginFactory.createDashboard = createDashboard;
            function createInsights(featureSwitches) {
                return new InsightsPluginService(featureSwitches);
            }
            visualPluginFactory.createInsights = createInsights;
            function createMobile(smallViewPortProperties, featureSwitches) {
                return new MobileVisualPluginService(smallViewPortProperties, featureSwitches);
            }
            visualPluginFactory.createMobile = createMobile;
        })(visualPluginFactory = visuals.visualPluginFactory || (visuals.visualPluginFactory = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var UNSELECTABLE_CLASS_NAME = "unselectable";
            function fire(eventHandlers, eventArgs) {
                if (eventHandlers) {
                    for (var i = 0; i < eventHandlers.length; i++) {
                        var h = eventHandlers[i];
                        h(eventArgs);
                    }
                }
            }
            controls.fire = fire;
            var ScrollbarButton = (function () {
                // Constructor
                function ScrollbarButton(owner, direction) {
                    this._owner = owner;
                    this._direction = direction;
                    this._timerHandle = undefined;
                    this.createView();
                    var that = this;
                    this._element.addEventListener("mousedown", function (e) { that.onMouseDown(e); });
                    $(this._element).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._svg).addClass(UNSELECTABLE_CLASS_NAME);
                    $(this._polygon).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Object.defineProperty(ScrollbarButton.prototype, "element", {
                    // Properties
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                // Methods
                ScrollbarButton.prototype.createView = function () {
                    var svgns = "http://www.w3.org/2000/svg";
                    this._polygon = document.createElementNS(svgns, "polygon");
                    this._polygon.setAttributeNS(null, "points", "3,3 6,3 13,8 6,13 3,13 10,8");
                    this._polygon.setAttributeNS(null, "fill", ScrollbarButton.ARROW_COLOR);
                    this._svg = document.createElementNS(svgns, "svg");
                    var svgStyle = this._svg.style;
                    svgStyle.position = "absolute";
                    svgStyle.left = "0px";
                    svgStyle.top = "0px";
                    this._svg.appendChild(this._polygon);
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.arrowClassName;
                    this._element.appendChild(this._svg);
                    this._owner.element.appendChild(this._element);
                };
                ScrollbarButton.prototype.onMouseDown = function (event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._mouseUpWrapper) {
                        event.cancelBubble = true;
                        var that_1 = this;
                        this._mouseUpWrapper = function (event) { that_1.onMouseUp(event); };
                        Scrollbar.addDocumentMouseUpEvent(this._mouseUpWrapper);
                    }
                    this._owner._scrollSmallIncrement(this._direction);
                    this._owner.refresh();
                    this._timerHandle = setTimeout(function () { that.onMouseDown(event); }, 100);
                    if (event.preventDefault) {
                        event.preventDefault(); // prevent dragging
                    }
                };
                ScrollbarButton.prototype.onMouseUp = function (event) {
                    clearTimeout(this._timerHandle);
                    Scrollbar.removeDocumentMouseUpEvent(this._mouseUpWrapper);
                    this._mouseUpWrapper = undefined;
                };
                ScrollbarButton.prototype.arrange = function (width, height, angle) {
                    var size = Math.min(width, height);
                    var scale = size / 16;
                    var x = (width - size) / 2;
                    var y = (height - size) / 2;
                    this._polygon.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ") scale(" + scale + ") rotate(" + angle + ",8,8)");
                    this._svg.setAttributeNS(null, "width", width + "px");
                    this._svg.setAttributeNS(null, "height", height + "px");
                    controls.HTMLElementUtils.setElementWidth(this._element, width);
                    controls.HTMLElementUtils.setElementHeight(this._element, height);
                };
                // Const
                // TODO: Move to style
                ScrollbarButton.MIN_WIDTH = 26;
                ScrollbarButton.ARROW_COLOR = "#404040";
                return ScrollbarButton;
            }());
            controls.ScrollbarButton = ScrollbarButton;
            /** Scrollbar base class */
            var Scrollbar = (function () {
                function Scrollbar(parentElement, layoutKind) {
                    this.MIN_BAR_SIZE = 10;
                    this.min = 0;
                    this.max = 10;
                    this.viewMin = 0;
                    this.viewSize = 2;
                    this.smallIncrement = 1;
                    this._onscroll = [];
                    this._screenToOffsetScale = 1.0;
                    this.createView(parentElement, layoutKind);
                    var that = this;
                    this._element.addEventListener("mousedown", function (e) { that.onBackgroundMouseDown(e); });
                    this._middleBar.addEventListener("mousedown", function (e) { that.onMiddleBarMouseDown(e); });
                    this._timerHandle = undefined;
                    this._visible = true;
                    this.element["winControl"] = this;
                    $(this._touchPanel).addClass(UNSELECTABLE_CLASS_NAME);
                }
                Scrollbar.prototype.scrollBy = function (delta) {
                    this.scrollTo(this.viewMin + delta);
                };
                Scrollbar.prototype.scrollUp = function () {
                    this.scrollBy(-this.smallIncrement);
                };
                Scrollbar.prototype.scrollDown = function () {
                    this.scrollBy(this.smallIncrement);
                };
                Scrollbar.prototype.scrollPageUp = function () {
                    this.scrollBy(-this.viewSize);
                };
                Scrollbar.prototype.scrollPageDown = function () {
                    this.scrollBy(this.viewSize);
                };
                Object.defineProperty(Scrollbar.prototype, "width", {
                    get: function () {
                        return this._width;
                    },
                    set: function (value) {
                        this._width = value;
                        this._element.style.width = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "height", {
                    get: function () {
                        return this._height;
                    },
                    set: function (value) {
                        this._height = value;
                        this._element.style.height = value;
                        this.invalidateArrange();
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.refresh = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar.refresh()");
                };
                Object.defineProperty(Scrollbar.prototype, "element", {
                    get: function () {
                        return this._element;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "maxButton", {
                    get: function () {
                        return this._maxButton;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "middleBar", {
                    get: function () {
                        return this._middleBar;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype._scrollSmallIncrement = function (direction) {
                    this.scrollBy(this.smallIncrement * direction);
                };
                Object.defineProperty(Scrollbar.prototype, "visible", {
                    get: function () {
                        return this._visible;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "isInMouseCapture", {
                    get: function () {
                        return this._timerHandle !== undefined;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.show = function (value) {
                    this._visible = value;
                    this.element.style.visibility = value ? "visible" : "hidden";
                    this.invalidateArrange();
                };
                Scrollbar.prototype._getMouseOffset = function (event) {
                    if (event.offsetX !== undefined)
                        return { x: event.offsetX, y: event.offsetY };
                    if (event.layerX !== undefined)
                        return { x: event.layerX, y: event.layerY };
                    return { x: event.screenX, y: event.screenY };
                };
                Scrollbar.prototype._getOffsetXDelta = function (event) {
                    return (event.screenX - this._screenPrevMousePos.x) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetYDelta = function (event) {
                    return (event.screenY - this._screenPrevMousePos.y) / this._screenToOffsetScale;
                };
                Scrollbar.prototype._getOffsetXTouchDelta = function (event) {
                    return this._getMouseOffset(event).x - this._offsetTouchPrevPos.x;
                };
                Scrollbar.prototype._getOffsetYTouchDelta = function (event) {
                    return this._getMouseOffset(event).y - this._offsetTouchPrevPos.y;
                };
                Scrollbar.prototype.initTouch = function (panel, allowMouseDrag) {
                    var _this = this;
                    this._touchPanel = panel;
                    this._allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                    if ("ontouchmove" in panel) {
                        panel.addEventListener("touchstart", function (e) { return _this.onTouchStart(e); });
                        panel.addEventListener("touchmove", function (e) { return _this.onTouchMove(e); });
                        panel.addEventListener("touchend", function (e) { return _this.onTouchEnd(e); });
                    }
                    else {
                        panel.addEventListener("mousedown", function (e) { return _this.onTouchMouseDown(e); });
                        panel.addEventListener("mousemove", function (e) { return _this.onTouchMouseMove(e); });
                        panel.addEventListener("mouseup", function (e) { return _this.onTouchMouseUp(e); });
                    }
                };
                Scrollbar.prototype.onTouchStart = function (e) {
                    if (e.touches.length === 1) {
                        this.onTouchMouseDown(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchMove = function (e) {
                    if (e.touches.length === 1) {
                        if (e.preventDefault)
                            e.preventDefault();
                        this.onTouchMouseMove(e.touches[0]);
                    }
                };
                Scrollbar.prototype.onTouchEnd = function (e) {
                    this.onTouchMouseUp(e.touches.length === 1 ? e.touches[0] : e, true);
                };
                Scrollbar.prototype.onTouchMouseDown = function (e) {
                    // except IE touch cancels mouse so not need for detection. For IE touch and mouse difference is detected by a flag.
                    if (!this._allowMouseDrag &&
                        e["pointerType"] === MSPointerEvent.MSPOINTER_TYPE_MOUSE) {
                        return;
                    }
                    if ("setCapture" in this._touchPanel) {
                        this._touchPanel.setCapture(true);
                    }
                    this._offsetTouchPrevPos = this._offsetTouchStartPos = null;
                    this._touchStarted = true;
                };
                Scrollbar.prototype._getOffsetTouchDelta = function (e) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetTouchDelta()");
                    return null;
                };
                Scrollbar.prototype.onTouchMouseMove = function (e) {
                    if (this._touchStarted) {
                        if (!this._offsetTouchStartPos) {
                            this._offsetTouchPrevPos = this._offsetTouchStartPos = this._getMouseOffset(e);
                        }
                        var delta = this._getOffsetTouchDelta(e);
                        if (delta !== 0) {
                            this.scrollBy(-delta / this._getRunningSize(false) * this.viewSize);
                            this._offsetTouchPrevPos = this._getMouseOffset(e);
                        }
                        if (e.preventDefault)
                            e.preventDefault();
                        e.cancelBubble = true;
                    }
                };
                Scrollbar.prototype.onTouchMouseUp = function (e, bubble) {
                    if (this._touchStarted) {
                        if (this._offsetTouchStartPos) {
                            var end = this._getMouseOffset(e);
                            if (!bubble && (Math.abs(this._offsetTouchStartPos.x - end.x) > 3 || Math.abs(this._offsetTouchStartPos.y - end.y) > 3)) {
                                if (e.preventDefault)
                                    e.preventDefault();
                                e.cancelBubble = true;
                            }
                        }
                    }
                    if ("releaseCapture" in this._touchPanel) {
                        this._touchPanel.releaseCapture();
                    }
                    this._touchStarted = false;
                };
                Scrollbar.prototype.registerElementForMouseWheelScrolling = function (element) {
                    var _this = this;
                    element.addEventListener("mousewheel", function (e) { _this.onMouseWheel(e); });
                    element.addEventListener("DOMMouseScroll", function (e) { _this.onFireFoxMouseWheel(e); });
                };
                Scrollbar.prototype.createView = function (parentElement, layoutKind) {
                    this._element = document.createElement("div");
                    this._element.className = Scrollbar.className;
                    this._element.setAttribute("drag-resize-disabled", "true");
                    if (layoutKind === 0 /* Canvas */)
                        parentElement.appendChild(this._element);
                    this._minButton = new ScrollbarButton(this, -1);
                    this._maxButton = new ScrollbarButton(this, 1);
                    this._middleBar = document.createElement("div");
                    this._middleBar.className = Scrollbar.barClassName;
                    this._element.appendChild(this._middleBar);
                };
                Scrollbar.prototype.scrollTo = function (pos) {
                    var viewMin = Math.min(this.max - this.viewSize, Math.max(this.min, pos));
                    if (viewMin !== this.viewMin) {
                        this.viewMin = viewMin;
                        fire(this._onscroll, null);
                    }
                };
                Scrollbar.prototype._scrollByPage = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._scrollByPage()");
                };
                Scrollbar.prototype._getRunningSize = function (net) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getRunningSize()");
                    return null;
                };
                Scrollbar.prototype._getOffsetDelta = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getOffsetDelta()");
                    return null;
                };
                Scrollbar.prototype.scroll = function (event) {
                    var delta = this._getOffsetDelta(event) / this._getRunningSize(true) * (this.max - this.min);
                    if (delta < 0) {
                        if (this._getScreenMousePos(event) >= this._screenMaxMousePos) {
                            return;
                        }
                    }
                    else if (delta > 0) {
                        if (this._getScreenMousePos(event) <= this._screenMinMousePos) {
                            return;
                        }
                    }
                    this.scrollBy(delta);
                };
                Object.defineProperty(Scrollbar.prototype, "actualWidth", {
                    get: function () {
                        if (this._actualWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualHeight", {
                    get: function () {
                        if (!this._actualHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonWidth", {
                    get: function () {
                        if (!this._actualButtonWidth === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonWidth;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(Scrollbar.prototype, "actualButtonHeight", {
                    get: function () {
                        if (!this._actualButtonHeight === undefined) {
                            this.arrange();
                        }
                        return this._actualButtonHeight;
                    },
                    enumerable: true,
                    configurable: true
                });
                Scrollbar.prototype.arrange = function () {
                    if (!this._actualWidth) {
                        this._actualWidth = this._element.offsetWidth;
                        this._actualHeight = this._element.offsetHeight;
                        this._actualButtonWidth = this._calculateButtonWidth();
                        this._actualButtonHeight = this._calculateButtonHeight();
                        this._minButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMinButtonAngle());
                        this._maxButton.arrange(this._actualButtonWidth, this._actualButtonHeight, this._getMaxButtonAngle());
                        this._setMaxButtonPosition();
                    }
                };
                Scrollbar.prototype._calculateButtonWidth = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonWidth()");
                    return null;
                };
                Scrollbar.prototype._calculateButtonHeight = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._calculateButtonHeight()");
                    return null;
                };
                Scrollbar.prototype._getMinButtonAngle = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMinButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._getMaxButtonAngle = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getMaxButtonAngle()");
                    return null;
                };
                Scrollbar.prototype._setMaxButtonPosition = function () {
                    debug.assertFail("PureVirtualMethod: Scrollbar._setMaxButtonPosition()");
                };
                Scrollbar.prototype.invalidateArrange = function () {
                    this._actualWidth = undefined;
                    this._actualHeight = undefined;
                    this._actualButtonWidth = undefined;
                    this._actualButtonHeight = undefined;
                };
                Scrollbar.prototype.onHoldBackgroundMouseDown = function (event) {
                    var _this = this;
                    var holdDelay = this._timerHandle ?
                        Scrollbar.ScrollbarBackgroundMousedownHoldDelay :
                        Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay;
                    this._timerHandle = setTimeout(function () {
                        _this.onBackgroundMouseDown(event);
                    }, holdDelay);
                };
                Scrollbar.prototype.onBackgroundMouseDown = function (event) {
                    var that = this;
                    clearTimeout(this._timerHandle);
                    if (!this._backgroundMouseUpWrapper) {
                        event.cancelBubble = true;
                        this._backgroundMouseUpWrapper = function (event) { that.onBackgroundMouseUp(event); };
                        Scrollbar.addDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    }
                    this._scrollByPage(event);
                    this.refresh();
                    this.onHoldBackgroundMouseDown(event);
                    if (event.preventDefault)
                        event.preventDefault(); // prevent dragging
                };
                Scrollbar.prototype.onBackgroundMouseUp = function (event) {
                    clearTimeout(this._timerHandle);
                    this._timerHandle = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._backgroundMouseUpWrapper);
                    this._backgroundMouseUpWrapper = undefined;
                };
                Scrollbar.prototype.getPinchZoomY = function () {
                    return document.documentElement.clientHeight / window.innerHeight;
                };
                Scrollbar.prototype.onMiddleBarMouseDown = function (event) {
                    event.cancelBubble = true;
                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
                    this._screenMinMousePos = this._getScreenMousePos(event) - (this._getScreenContextualLeft(this._middleBar) - this._getScreenContextualRight(this._minButton.element));
                    this._screenMaxMousePos = this._getScreenMousePos(event) + (this._getScreenContextualLeft(this._maxButton.element) - this._getScreenContextualRight(this._middleBar));
                    this._screenToOffsetScale = controls.HTMLElementUtils.getAccumulatedScale(this.element) * this.getPinchZoomY();
                    var that = this;
                    this._middleBarMouseMoveWrapper = function (e) { that.onMiddleBarMouseMove(e); };
                    Scrollbar.addDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseUpWrapper = function (e) { that.onMiddleBarMouseUp(e); };
                    Scrollbar.addDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    if (event.preventDefault)
                        event.preventDefault(); // prevent dragging
                };
                Scrollbar.prototype.onMiddleBarMouseMove = function (event) {
                    if (!this._screenPrevMousePos) {
                        return;
                    }
                    this.scroll(event);
                    this.refresh();
                    this._screenPrevMousePos = { x: event.screenX, y: event.screenY };
                };
                Scrollbar.prototype.onMiddleBarMouseUp = function (event) {
                    this._screenPrevMousePos = undefined;
                    Scrollbar.removeDocumentMouseMoveEvent(this._middleBarMouseMoveWrapper);
                    this._middleBarMouseMoveWrapper = undefined;
                    Scrollbar.removeDocumentMouseUpEvent(this._middleBarMouseUpWrapper);
                    this._middleBarMouseUpWrapper = undefined;
                    if (event.preventDefault)
                        event.preventDefault(); // prevent other events
                };
                Scrollbar.prototype._getScreenContextualLeft = function (element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualLeft()");
                    return null;
                };
                Scrollbar.prototype._getScreenContextualRight = function (element) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenContextualRight()");
                    return null;
                };
                Scrollbar.prototype.onMouseWheel = function (e) {
                    if (e.wheelDelta) {
                        this.mouseWheel(e.wheelDelta);
                    }
                    e.preventDefault();
                };
                Scrollbar.prototype.onFireFoxMouseWheel = function (e) {
                    if (e.detail) {
                        this.mouseWheel(-e.detail);
                    }
                    e.preventDefault();
                };
                Scrollbar.prototype.mouseWheel = function (delta) {
                    if (this.visible) {
                        if (delta < 0) {
                            delta = Math.min(-Scrollbar.MouseWheelRange, delta);
                        }
                        else if (delta > 0) {
                            delta = Math.max(Scrollbar.MouseWheelRange, delta);
                        }
                        this.scrollBy(-delta / Scrollbar.MouseWheelRange * this.smallIncrement);
                    }
                };
                Scrollbar.prototype._getScreenMousePos = function (event) {
                    debug.assertFail("PureVirtualMethod: Scrollbar._getScreenMousePos()");
                    return null;
                };
                Scrollbar.addDocumentMouseUpEvent = function (func) {
                    document.addEventListener("mouseup", func);
                };
                Scrollbar.removeDocumentMouseUpEvent = function (func) {
                    document.removeEventListener("mouseup", func);
                };
                Scrollbar.addDocumentMouseMoveEvent = function (func) {
                    document.addEventListener("mousemove", func);
                };
                Scrollbar.removeDocumentMouseMoveEvent = function (func) {
                    document.removeEventListener("mousemove", func);
                };
                Scrollbar.DefaultScrollbarWidth = "15px"; // protected
                Scrollbar.ScrollbarBackgroundFirstTimeMousedownHoldDelay = 500;
                Scrollbar.ScrollbarBackgroundMousedownHoldDelay = 50;
                Scrollbar.MouseWheelRange = 120;
                Scrollbar.className = "scroll-bar-div";
                Scrollbar.barClassName = "scroll-bar-part-bar";
                Scrollbar.arrowClassName = "scroll-bar-part-arrow";
                return Scrollbar;
            }());
            controls.Scrollbar = Scrollbar;
            /** Horizontal Scrollbar */
            var HorizontalScrollbar = (function (_super) {
                __extends(HorizontalScrollbar, _super);
                function HorizontalScrollbar(parentElement, layoutKind) {
                    _super.call(this, parentElement, layoutKind);
                    this.height = Scrollbar.DefaultScrollbarWidth;
                }
                HorizontalScrollbar.prototype._calculateButtonWidth = function () {
                    return Math.min(this.actualWidth / 2, Math.max(this.actualHeight, ScrollbarButton.MIN_WIDTH));
                };
                HorizontalScrollbar.prototype._calculateButtonHeight = function () {
                    return this.actualHeight;
                };
                HorizontalScrollbar.prototype._getMinButtonAngle = function () {
                    return -180;
                };
                HorizontalScrollbar.prototype._getMaxButtonAngle = function () {
                    return 0;
                };
                HorizontalScrollbar.prototype._setMaxButtonPosition = function () {
                    controls.HTMLElementUtils.setElementLeft(this.maxButton.element, this.actualWidth - this.actualButtonWidth);
                };
                HorizontalScrollbar.prototype.refresh = function () {
                    this.arrange();
                    var runningSize = this.actualWidth - this.actualButtonWidth * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    barSize = Math.min(barSize, runningSize);
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, this.actualHeight);
                    controls.HTMLElementUtils.setElementLeft(this.middleBar, this.actualButtonWidth + 1 + barPos);
                };
                HorizontalScrollbar.prototype.show = function (visible) {
                    if (visible === this.visible)
                        return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.height = this.height;
                    }
                    else {
                        controls.HTMLElementUtils.setElementHeight(this.element, 0);
                    }
                };
                HorizontalScrollbar.prototype._scrollByPage = function (event) {
                    var left = this.middleBar.offsetLeft;
                    var right = left + this.middleBar.offsetWidth;
                    var x = (event.offsetX === undefined) ? event.layerX : event.offsetX;
                    if (x > right) {
                        this.scrollPageDown();
                    }
                    else if (x < left) {
                        this.scrollPageUp();
                    }
                };
                HorizontalScrollbar.prototype._getRunningSize = function (net) {
                    var result = this.actualWidth;
                    if (net) {
                        var barMinPos = this.actualButtonWidth + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE)
                            result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                HorizontalScrollbar.prototype._getOffsetDelta = function (event) {
                    return this._getOffsetXDelta(event);
                };
                HorizontalScrollbar.prototype._getOffsetTouchDelta = function (e) {
                    return this._getOffsetXTouchDelta(e);
                };
                HorizontalScrollbar.prototype._getScreenContextualLeft = function (element) {
                    return element.getBoundingClientRect().left;
                };
                HorizontalScrollbar.prototype._getScreenContextualRight = function (element) {
                    return element.getBoundingClientRect().right;
                };
                HorizontalScrollbar.prototype._getScreenMousePos = function (event) {
                    return event.screenX;
                };
                return HorizontalScrollbar;
            }(Scrollbar));
            controls.HorizontalScrollbar = HorizontalScrollbar;
            /** Vertical Scrollbar */
            var VerticalScrollbar = (function (_super) {
                __extends(VerticalScrollbar, _super);
                function VerticalScrollbar(parentElement, layoutKind) {
                    _super.call(this, parentElement, layoutKind);
                    this.width = Scrollbar.DefaultScrollbarWidth;
                }
                VerticalScrollbar.prototype._calculateButtonWidth = function () {
                    return this.actualWidth;
                };
                VerticalScrollbar.prototype._calculateButtonHeight = function () {
                    return Math.min(this.actualHeight / 2, Math.max(this.actualWidth, ScrollbarButton.MIN_WIDTH));
                };
                VerticalScrollbar.prototype._getMinButtonAngle = function () {
                    return -90;
                };
                VerticalScrollbar.prototype._getMaxButtonAngle = function () {
                    return 90;
                };
                VerticalScrollbar.prototype._setMaxButtonPosition = function () {
                    controls.HTMLElementUtils.setElementTop(this.maxButton.element, this.actualHeight - this.actualButtonHeight);
                };
                VerticalScrollbar.prototype.refresh = function () {
                    this.arrange();
                    var runningSize = this.actualHeight - this.actualButtonHeight * 2 - 2;
                    var barSize = this.viewSize / (this.max - this.min) * runningSize;
                    if (barSize < this.MIN_BAR_SIZE) {
                        runningSize -= this.MIN_BAR_SIZE - barSize;
                        barSize = this.MIN_BAR_SIZE;
                    }
                    if (runningSize < 0) {
                        runningSize = 0;
                        barSize = 0;
                    }
                    var barPos = this.viewMin / (this.max - this.min) * runningSize;
                    controls.HTMLElementUtils.setElementWidth(this.middleBar, this.actualWidth);
                    controls.HTMLElementUtils.setElementHeight(this.middleBar, barSize);
                    controls.HTMLElementUtils.setElementTop(this.middleBar, this.actualButtonHeight + 1 + barPos);
                };
                VerticalScrollbar.prototype.show = function (visible) {
                    if (visible === this.visible)
                        return;
                    _super.prototype.show.call(this, visible);
                    if (visible) {
                        this.element.style.width = this.width;
                    }
                    else {
                        controls.HTMLElementUtils.setElementWidth(this.element, 0);
                    }
                };
                VerticalScrollbar.prototype._scrollByPage = function (event) {
                    var top = this.middleBar.offsetTop;
                    var bottom = top + this.middleBar.offsetHeight;
                    var y = (event.offsetY === undefined) ? event.layerY : event.offsetY;
                    if (y > bottom) {
                        this.scrollPageDown();
                    }
                    else if (y < top) {
                        this.scrollPageUp();
                    }
                };
                VerticalScrollbar.prototype._getRunningSize = function (net) {
                    var result = this.actualHeight;
                    if (net) {
                        var barMinPos = this.actualButtonHeight + 1;
                        result -= barMinPos * 2;
                        var barSize = result * (this.viewSize / (this.max - this.min));
                        if (barSize < this.MIN_BAR_SIZE)
                            result -= this.MIN_BAR_SIZE - barSize;
                    }
                    return result;
                };
                VerticalScrollbar.prototype._getOffsetDelta = function (event) {
                    return this._getOffsetYDelta(event);
                };
                VerticalScrollbar.prototype._getOffsetTouchDelta = function (e) {
                    return this._getOffsetYTouchDelta(e);
                };
                VerticalScrollbar.prototype._getScreenContextualLeft = function (element) {
                    return element.getBoundingClientRect().top;
                };
                VerticalScrollbar.prototype._getScreenContextualRight = function (element) {
                    return element.getBoundingClientRect().bottom;
                };
                VerticalScrollbar.prototype._getScreenMousePos = function (event) {
                    return event.screenY;
                };
                return VerticalScrollbar;
            }(Scrollbar));
            controls.VerticalScrollbar = VerticalScrollbar;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var UNSELECTABLE_CLASS_NAME = "unselectable";
                /** This class is responsible for tablix header resizing */
                var TablixResizer = (function () {
                    function TablixResizer(element, handler) {
                        this._element = element;
                        this._handler = handler;
                        this._elementMouseDownWrapper = null;
                        this._elementMouseMoveWrapper = null;
                        this._elementMouseOutWrapper = null;
                        this._documentMouseMoveWrapper = null;
                        this._documentMouseUpWrapper = null;
                        this._startMousePosition = null;
                        this._originalCursor = null;
                    }
                    TablixResizer.addDocumentMouseUpEvent = function (listener) {
                        document.addEventListener("mouseup", listener);
                    };
                    TablixResizer.removeDocumentMouseUpEvent = function (listener) {
                        document.removeEventListener("mouseup", listener);
                    };
                    TablixResizer.addDocumentMouseMoveEvent = function (listener) {
                        document.addEventListener("mousemove", listener);
                    };
                    TablixResizer.removeDocumentMouseMoveEvent = function (listener) {
                        document.removeEventListener("mousemove", listener);
                    };
                    TablixResizer.getMouseCoordinates = function (event) {
                        return { x: event.pageX, y: event.pageY };
                    };
                    TablixResizer.getMouseCoordinateDelta = function (previous, current) {
                        return { x: current.x - previous.x, y: current.y - previous.y };
                    };
                    TablixResizer.prototype.initialize = function () {
                        var _this = this;
                        this._elementMouseDownWrapper = function (e) { return _this.onElementMouseDown(e); };
                        this._element.addEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseMoveWrapper = function (e) { return _this.onElementMouseMove(e); };
                        this._element.addEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseOutWrapper = function (e) { return _this.onElementMouseOut(e); };
                        this._element.addEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = function (e) { return _this.onElementMouseDoubleClick(e); };
                        this._element.addEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                    };
                    TablixResizer.prototype.uninitialize = function () {
                        this._element.removeEventListener("mousedown", this._elementMouseDownWrapper);
                        this._elementMouseDownWrapper = null;
                        this._element.removeEventListener("mousemove", this._elementMouseMoveWrapper);
                        this._elementMouseMoveWrapper = null;
                        this._element.removeEventListener("mouseout", this._elementMouseOutWrapper);
                        this._elementMouseOutWrapper = null;
                        this._element.removeEventListener("dblclick", this._elementMouseDoubleClickOutWrapper);
                        this._elementMouseDoubleClickOutWrapper = null;
                    };
                    Object.defineProperty(TablixResizer.prototype, "cell", {
                        get: function () {
                            // abstract
                            debug.assertFail("PureVirtualMethod: TablixResizer.cell");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixResizer.prototype, "element", {
                        get: function () {
                            return this._element;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    // Protected
                    TablixResizer.prototype._hotSpot = function (position) {
                        // abstract
                        debug.assertFail("PureVirtualMethod: TablixResizer._hotSpot");
                        return false;
                    };
                    TablixResizer.prototype.onElementMouseDown = function (event) {
                        var _this = this;
                        var position = TablixResizer.getMouseCoordinates(event);
                        if (!this._hotSpot(position))
                            return;
                        if ("setCapture" in this._element) {
                            this._element.setCapture();
                        }
                        event.cancelBubble = true;
                        this._startMousePosition = position;
                        this._documentMouseMoveWrapper = function (e) { return _this.onDocumentMouseMove(e); };
                        TablixResizer.addDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseUpWrapper = function (e) { return _this.onDocumentMouseUp(e); };
                        TablixResizer.addDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        if (document.documentElement) {
                            this._originalCursor = document.documentElement.style.cursor;
                            document.documentElement.style.cursor = TablixResizer.resizeCursor;
                        }
                        this._handler.onStartResize(this.cell, this._startMousePosition.x, this._startMousePosition.y);
                    };
                    TablixResizer.prototype.onElementMouseMove = function (event) {
                        if (!this._startMousePosition) {
                            if (this._hotSpot(TablixResizer.getMouseCoordinates(event))) {
                                if (this._originalCursor === null) {
                                    this._originalCursor = this._element.style.cursor;
                                    this._element.style.cursor = TablixResizer.resizeCursor;
                                }
                            }
                            else {
                                if (this._originalCursor !== null) {
                                    this._element.style.cursor = this._originalCursor;
                                    this._originalCursor = null;
                                }
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseOut = function (event) {
                        if (!this._startMousePosition) {
                            if (this._originalCursor !== null) {
                                this._element.style.cursor = this._originalCursor;
                                this._originalCursor = null;
                            }
                        }
                    };
                    TablixResizer.prototype.onElementMouseDoubleClick = function (event) {
                        if (!this._hotSpot(TablixResizer.getMouseCoordinates(event)))
                            return;
                        this._handler.onReset(this.cell);
                    };
                    TablixResizer.prototype.onDocumentMouseMove = function (event) {
                        if (!this._startMousePosition)
                            return;
                        var delta = TablixResizer.getMouseCoordinateDelta(this._startMousePosition, TablixResizer.getMouseCoordinates(event));
                        this._handler.onResize(this.cell, delta.x, delta.y);
                        // Need to prevent default to prevent mouse move from triggering other effects (VSTS 6720639)
                        event.preventDefault();
                    };
                    TablixResizer.prototype.onDocumentMouseUp = function (event) {
                        this._startMousePosition = null;
                        if ("releaseCapture" in this._element) {
                            this._element.releaseCapture();
                        }
                        TablixResizer.removeDocumentMouseMoveEvent(this._documentMouseMoveWrapper);
                        this._documentMouseMoveWrapper = null;
                        TablixResizer.removeDocumentMouseUpEvent(this._documentMouseUpWrapper);
                        this._documentMouseUpWrapper = null;
                        if (document.documentElement)
                            document.documentElement.style.cursor = this._originalCursor;
                        if (event.preventDefault)
                            event.preventDefault(); // prevent other events
                        this._handler.onEndResize(this.cell);
                    };
                    TablixResizer.resizeHandleSize = 4;
                    TablixResizer.resizeCursor = "e-resize";
                    return TablixResizer;
                }());
                internal.TablixResizer = TablixResizer;
                var TablixDomResizer = (function (_super) {
                    __extends(TablixDomResizer, _super);
                    function TablixDomResizer(cell, element, handler) {
                        _super.call(this, element, handler);
                        this._cell = cell;
                    }
                    Object.defineProperty(TablixDomResizer.prototype, "cell", {
                        get: function () {
                            return this._cell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    // Protected
                    TablixDomResizer.prototype._hotSpot = function (position) {
                        return position.x >= this.element.getBoundingClientRect().right - TablixResizer.resizeHandleSize;
                    };
                    return TablixDomResizer;
                }(TablixResizer));
                internal.TablixDomResizer = TablixDomResizer;
                var TablixCellPresenter = (function () {
                    function TablixCellPresenter(fitProportionally, layoutKind) {
                        // Table cell will be created once needed
                        this._tableCell = null;
                        // Content element
                        this._contentElement = internal.TablixUtils.createDiv();
                        // Content Host
                        this._contentHost = internal.TablixUtils.createDiv();
                        this.layoutKind = layoutKind;
                        this._contentElement.appendChild(this._contentHost);
                        this._resizer = null;
                    }
                    TablixCellPresenter.prototype.initialize = function (owner) {
                        this._owner = owner;
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerTableCell = function (tableCell) {
                        this._tableCell = tableCell;
                        tableCell.appendChild(this._contentElement);
                    };
                    Object.defineProperty(TablixCellPresenter.prototype, "tableCell", {
                        get: function () {
                            return this._tableCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentElement", {
                        /**
                         * Outer DIV
                         */
                        get: function () {
                            return this._contentElement;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCellPresenter.prototype, "contentHost", {
                        /**
                        * Inner DIV
                        */
                        get: function () {
                            return this._contentHost;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCellPresenter.prototype.registerClickHandler = function (handler) {
                        this._contentElement.onclick = handler;
                    };
                    TablixCellPresenter.prototype.unregisterClickHandler = function () {
                        this._contentElement.onclick = null;
                    };
                    TablixCellPresenter.prototype.onContainerWidthChanged = function (value) {
                        controls.HTMLElementUtils.setElementWidth(this._contentElement, value);
                    };
                    TablixCellPresenter.prototype.onContinerHeightChanged = function (height) {
                        controls.HTMLElementUtils.setElementHeight(this._contentElement, height);
                    };
                    TablixCellPresenter.prototype.onColumnSpanChanged = function (value) {
                        this._tableCell.colSpan = value;
                    };
                    TablixCellPresenter.prototype.onRowSpanChanged = function (value) {
                        this._tableCell.rowSpan = value;
                    };
                    TablixCellPresenter.prototype.onTextAlignChanged = function (value) {
                        this._tableCell.style.textAlign = value;
                    };
                    TablixCellPresenter.prototype.onClear = function () {
                        this._contentHost.className = "";
                        this._tableCell.className = "";
                    };
                    TablixCellPresenter.prototype.onHorizontalScroll = function (width, offset) {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, width);
                    };
                    TablixCellPresenter.prototype.onVerticalScroll = function (height, offset) {
                        controls.HTMLElementUtils.setElementTop(this._contentHost, offset);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, height);
                    };
                    TablixCellPresenter.prototype.onInitializeScrolling = function () {
                        controls.HTMLElementUtils.setElementLeft(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementTop(this._contentHost, 0);
                        controls.HTMLElementUtils.setElementWidth(this._contentHost, -1);
                        controls.HTMLElementUtils.setElementHeight(this._contentHost, -1);
                    };
                    TablixCellPresenter.prototype.enableHorizontalResize = function (enable, handler) {
                        if (enable === (this._resizer !== null))
                            return;
                        if (enable) {
                            this._resizer = new TablixDomResizer(this._owner, this._tableCell, handler);
                            this._resizer.initialize();
                        }
                        else {
                            this._resizer.uninitialize();
                            this._resizer = null;
                        }
                    };
                    /**
                     * In order to allow dragging of the tableCell we need to
                     * disable dragging of the container of the cell in IE.
                     */
                    TablixCellPresenter.prototype.disableDragResize = function () {
                        this._tableCell.setAttribute(TablixCellPresenter._dragResizeDisabledAttributeName, "true");
                    };
                    // Attribute used to disable dragging in order to have cell resizing work.
                    TablixCellPresenter._dragResizeDisabledAttributeName = "drag-resize-disabled";
                    return TablixCellPresenter;
                }());
                internal.TablixCellPresenter = TablixCellPresenter;
                var TablixRowPresenter = (function () {
                    function TablixRowPresenter(fitProportionally) {
                        // Table row will be created once needed
                        this._tableRow = null;
                        this._fitProportionally = fitProportionally;
                    }
                    TablixRowPresenter.prototype.initialize = function (row) {
                        this._row = row;
                    };
                    TablixRowPresenter.prototype.createCellPresenter = function (layoutKind) {
                        return new TablixCellPresenter(this._fitProportionally, layoutKind);
                    };
                    TablixRowPresenter.prototype.registerRow = function (tableRow) {
                        this._tableRow = tableRow;
                    };
                    TablixRowPresenter.prototype.onAppendCell = function (cell) {
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            // For performance reason we use InsertCell() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableCell = this._tableRow.insertCell(-1);
                            presenter.registerTableCell(tableCell);
                        }
                        else {
                            this._tableRow.appendChild(presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onInsertCellBefore = function (cell, refCell) {
                        debug.assertValue(refCell._presenter.tableCell, 'refTableCell');
                        var presenter = cell._presenter;
                        if (presenter.tableCell === null) {
                            // For performance reasons we use InsertCell() to create new table cells instead of AppendChild()
                            var tableCell = this._tableRow.insertCell(Math.max(0, refCell._presenter.tableCell.cellIndex - 1));
                            presenter.registerTableCell(tableCell);
                        }
                        else {
                            this._tableRow.insertBefore(cell._presenter.tableCell, refCell._presenter.tableCell);
                        }
                    };
                    TablixRowPresenter.prototype.onRemoveCell = function (cell) {
                        this._tableRow.removeChild(cell._presenter.tableCell);
                    };
                    TablixRowPresenter.prototype.getHeight = function () {
                        return this.getCellHeight(this._row.getTablixCell());
                    };
                    TablixRowPresenter.prototype.getCellHeight = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    TablixRowPresenter.prototype.getCellContentHeight = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixRowPresenter.getCellHeight");
                        return -1;
                    };
                    Object.defineProperty(TablixRowPresenter.prototype, "tableRow", {
                        get: function () {
                            return this._tableRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TablixRowPresenter;
                }());
                internal.TablixRowPresenter = TablixRowPresenter;
                var DashboardRowPresenter = (function (_super) {
                    __extends(DashboardRowPresenter, _super);
                    function DashboardRowPresenter(gridPresenter, fitProportionally) {
                        _super.call(this, fitProportionally);
                        this._gridPresenter = gridPresenter;
                    }
                    DashboardRowPresenter.prototype.getCellHeight = function (cell) {
                        return cell.containerHeight;
                    };
                    DashboardRowPresenter.prototype.getCellContentHeight = function (cell) {
                        return cell.contentHeight;
                    };
                    return DashboardRowPresenter;
                }(TablixRowPresenter));
                internal.DashboardRowPresenter = DashboardRowPresenter;
                var CanvasRowPresenter = (function (_super) {
                    __extends(CanvasRowPresenter, _super);
                    function CanvasRowPresenter() {
                        _super.apply(this, arguments);
                    }
                    CanvasRowPresenter.prototype.getCellHeight = function (cell) {
                        return cell.containerHeight;
                    };
                    CanvasRowPresenter.prototype.getCellContentHeight = function (cell) {
                        return cell.contentHeight;
                    };
                    return CanvasRowPresenter;
                }(TablixRowPresenter));
                internal.CanvasRowPresenter = CanvasRowPresenter;
                var TablixColumnPresenter = (function () {
                    function TablixColumnPresenter() {
                    }
                    TablixColumnPresenter.prototype.initialize = function (column) {
                        this._column = column;
                    };
                    TablixColumnPresenter.prototype.getWidth = function () {
                        return this.getCellWidth(this._column.getTablixCell());
                    };
                    TablixColumnPresenter.prototype.getCellWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellWidth");
                        return -1;
                    };
                    TablixColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixColumnPresenter.getCellContentWidth");
                        return -1;
                    };
                    return TablixColumnPresenter;
                }());
                internal.TablixColumnPresenter = TablixColumnPresenter;
                var DashboardColumnPresenter = (function (_super) {
                    __extends(DashboardColumnPresenter, _super);
                    function DashboardColumnPresenter(gridPresenter) {
                        _super.call(this);
                        this._gridPresenter = gridPresenter;
                    }
                    DashboardColumnPresenter.prototype.getCellWidth = function (cell) {
                        return this._gridPresenter.sizeComputationManager.cellWidth;
                    };
                    DashboardColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        return this._gridPresenter.sizeComputationManager.contentWidth;
                    };
                    return DashboardColumnPresenter;
                }(TablixColumnPresenter));
                internal.DashboardColumnPresenter = DashboardColumnPresenter;
                var CanvasColumnPresenter = (function (_super) {
                    __extends(CanvasColumnPresenter, _super);
                    function CanvasColumnPresenter(gridPresenter, index) {
                        _super.call(this);
                        this._gridPresenter = gridPresenter;
                        this._columnIndex = index;
                    }
                    CanvasColumnPresenter.prototype.getCellWidth = function (cell) {
                        var persistedWidth = this._gridPresenter.getPersistedCellWidth(this._columnIndex);
                        // Because persistedWidth could be 0 check specifically for null or undefined 
                        if (_.isNumber(persistedWidth))
                            return persistedWidth;
                        if (!cell._presenter)
                            return 0;
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    };
                    CanvasColumnPresenter.prototype.getCellContentWidth = function (cell) {
                        var persistedWidth = this._gridPresenter.getPersistedCellWidth(this._columnIndex);
                        // Because persistedWidth could be 0 check specifically for null or undefined 
                        if (_.isNumber(persistedWidth))
                            return persistedWidth;
                        if (!cell._presenter)
                            return 0;
                        var requiredWidth = controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                        if (requiredWidth > 0 && cell.colSpan === 1)
                            requiredWidth += 1; // Adding 1px because offsetWidth returns floored number, may risk getting ellipsis
                        return requiredWidth;
                    };
                    return CanvasColumnPresenter;
                }(TablixColumnPresenter));
                internal.CanvasColumnPresenter = CanvasColumnPresenter;
                var TablixGridPresenter = (function () {
                    function TablixGridPresenter(columnWidthManager) {
                        // Main Table
                        this._table = internal.TablixUtils.createTable();
                        this._table.className = UNSELECTABLE_CLASS_NAME;
                        // Footer Table
                        this._footerTable = internal.TablixUtils.createTable();
                        this._footerTable.className = UNSELECTABLE_CLASS_NAME;
                        // ColumnWidthManager
                        this._columnWidthManager = columnWidthManager;
                    }
                    TablixGridPresenter.prototype.initialize = function (owner, gridHost, footerHost, control) {
                        this._owner = owner;
                        gridHost.appendChild(this._table);
                        footerHost.appendChild(this._footerTable);
                    };
                    TablixGridPresenter.prototype.getWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getWidth");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.getHeight");
                        return -1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioX = function () {
                        return 1;
                    };
                    TablixGridPresenter.prototype.getScreenToCssRatioY = function () {
                        return 1;
                    };
                    TablixGridPresenter.prototype.createRowPresenter = function () {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createRowPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        debug.assertFail("PureVirtualMethod: TablixGridPresenter.createColumnPresenter");
                        return null;
                    };
                    TablixGridPresenter.prototype.onAppendRow = function (row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableRow = this._table.insertRow(-1);
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._table.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onInsertRowBefore = function (row, refRow) {
                        debug.assertValue(refRow.presenter.tableRow, 'refTableRow');
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            var tableRow = this._table.insertRow(Math.max(0, refRow.presenter.tableRow.rowIndex - 1));
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._table.tBodies[0].insertBefore(row.presenter.tableRow, refRow.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onRemoveRow = function (row) {
                        this._table.tBodies[0].removeChild(row.presenter.tableRow);
                    };
                    TablixGridPresenter.prototype.onAddFooterRow = function (row) {
                        var presenter = row.presenter;
                        if (presenter.tableRow === null) {
                            // For performance reason we use InsertRow() to create new table cells instead of AppendChild()
                            // We use -1 to insert at the end (that's the cross-browser way of doing it)
                            var tableRow = this._footerTable.insertRow(-1);
                            presenter.registerRow(tableRow);
                        }
                        else {
                            this._footerTable.tBodies[0].appendChild(row.presenter.tableRow);
                        }
                    };
                    TablixGridPresenter.prototype.onClear = function () {
                        controls.HTMLElementUtils.clearChildren(this._table);
                        controls.HTMLElementUtils.clearChildren(this._footerTable);
                    };
                    TablixGridPresenter.prototype.onFillColumnsProportionallyChanged = function (value) {
                        if (value) {
                            this._table.style.width = "100%";
                            this._footerTable.style.width = "100%";
                        }
                        else {
                            this._table.style.width = "auto";
                            this._footerTable.style.width = "auto";
                        }
                    };
                    TablixGridPresenter.prototype.invokeColumnResizeEndCallback = function (columnIndex, width) {
                        if (this._columnWidthManager)
                            this._columnWidthManager.onColumnWidthChanged(columnIndex, width);
                    };
                    TablixGridPresenter.prototype.getPersistedCellWidth = function (columnIndex) {
                        if (this._columnWidthManager)
                            return this._columnWidthManager.getPersistedColumnWidth(columnIndex);
                    };
                    return TablixGridPresenter;
                }());
                internal.TablixGridPresenter = TablixGridPresenter;
                var DashboardTablixGridPresenter = (function (_super) {
                    __extends(DashboardTablixGridPresenter, _super);
                    function DashboardTablixGridPresenter(sizeComputationManager) {
                        _super.call(this);
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    DashboardTablixGridPresenter.prototype.createRowPresenter = function () {
                        return new DashboardRowPresenter(this, this._owner.fillColumnsProportionally);
                    };
                    DashboardTablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        return new DashboardColumnPresenter(this);
                    };
                    Object.defineProperty(DashboardTablixGridPresenter.prototype, "sizeComputationManager", {
                        get: function () {
                            return this._sizeComputationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DashboardTablixGridPresenter.prototype.getWidth = function () {
                        return this._sizeComputationManager.gridWidth;
                    };
                    DashboardTablixGridPresenter.prototype.getHeight = function () {
                        return this._sizeComputationManager.gridHeight;
                    };
                    return DashboardTablixGridPresenter;
                }(TablixGridPresenter));
                internal.DashboardTablixGridPresenter = DashboardTablixGridPresenter;
                var CanvasTablixGridPresenter = (function (_super) {
                    __extends(CanvasTablixGridPresenter, _super);
                    function CanvasTablixGridPresenter(columnWidthManager) {
                        _super.call(this, columnWidthManager);
                    }
                    CanvasTablixGridPresenter.prototype.createRowPresenter = function () {
                        return new CanvasRowPresenter(this._owner.fillColumnsProportionally);
                    };
                    CanvasTablixGridPresenter.prototype.createColumnPresenter = function (index) {
                        return new CanvasColumnPresenter(this, index);
                    };
                    CanvasTablixGridPresenter.prototype.getWidth = function () {
                        return controls.HTMLElementUtils.getElementWidth(this._table);
                    };
                    CanvasTablixGridPresenter.prototype.getHeight = function () {
                        return controls.HTMLElementUtils.getElementHeight(this._table);
                    };
                    return CanvasTablixGridPresenter;
                }(TablixGridPresenter));
                internal.CanvasTablixGridPresenter = CanvasTablixGridPresenter;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                /**
                 * Base class for Tablix realization manager.
                 */
                var TablixDimensionRealizationManager = (function () {
                    function TablixDimensionRealizationManager(binder) {
                        this._binder = binder;
                        this._adjustmentFactor = 1;
                    }
                    TablixDimensionRealizationManager.prototype._getOwner = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getOwner");
                        return null;
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "binder", {
                        get: function () {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "adjustmentFactor", {
                        get: function () {
                            return this._adjustmentFactor;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsToRealizeCount", {
                        get: function () {
                            return this._itemsToRealizeCount;
                        },
                        set: function (count) {
                            this._itemsToRealizeCount = count;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "itemsEstimatedContextualWidth", {
                        get: function () {
                            return this._itemsEstimatedContextualWidth;
                        },
                        set: function (contextualWidth) {
                            this._itemsEstimatedContextualWidth = contextualWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype.onStartRenderingIteration = function () {
                        var owner = this._getOwner();
                        if (owner.measureEnabled && !owner.done) {
                            this._getEstimatedItemsToRealizeCount();
                        }
                        this._realizedLeavesCount = 0;
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingIteration = function (gridContextualWidth, filled) {
                        if (!filled && !this._getOwner().allItemsRealized)
                            this._adjustmentFactor *= this._getSizeAdjustment(gridContextualWidth);
                    };
                    TablixDimensionRealizationManager.prototype.onEndRenderingSession = function () {
                        this._adjustmentFactor = 1;
                    };
                    TablixDimensionRealizationManager.prototype.onCornerCellRealized = function (item, cell) {
                    };
                    TablixDimensionRealizationManager.prototype.onHeaderRealized = function (item, cell, leaf) {
                        if (leaf) {
                            this._realizedLeavesCount++;
                        }
                    };
                    Object.defineProperty(TablixDimensionRealizationManager.prototype, "needsToRealize", {
                        get: function () {
                            return this._realizedLeavesCount < this._itemsToRealizeCount;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixDimensionRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._calculateItemsToRealize");
                    };
                    TablixDimensionRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: TablixDimensionRealizationManager._getSizeAdjustment");
                        return 1;
                    };
                    return TablixDimensionRealizationManager;
                }());
                internal.TablixDimensionRealizationManager = TablixDimensionRealizationManager;
                /**
                 * DOM implementation for Row Tablix realization manager.
                 */
                var RowRealizationManager = (function (_super) {
                    __extends(RowRealizationManager, _super);
                    function RowRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(RowRealizationManager.prototype, "owner", {
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowRealizationManager.prototype._getOwner = function () {
                        return this._owner;
                    };
                    RowRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        this.estimateRowsToRealizeCount();
                    };
                    RowRealizationManager.prototype.estimateRowsToRealizeCount = function () {
                        debug.assertValue(this._owner, '_owner');
                        if (!this._owner.dimension.model) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        if (this._owner.alignToEnd)
                            this.itemsToRealizeCount = this._owner.dimension.getItemsCount() - this._owner.dimension.getIntegerScrollOffset() + 1;
                        else
                            this.itemsToRealizeCount = Math.ceil((this._owner.contextualWidthToFill / (this._owner.owner.getEstimatedRowHeight() * this.adjustmentFactor)) + this._owner.dimension.getFractionScrollOffset()) - this._owner.otherLayoutManager.dimension.getDepth() + 1;
                    };
                    RowRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
                        if (!this._owner.dimension.model || this._owner.dimension.getItemsCount() === 0)
                            return 0;
                        var levels = new RowWidths();
                        this.updateRowHiearchyEstimatedWidth(this._owner.dimension.model, this._owner.dimension._hierarchyNavigator.getIndex(this._owner.dimension.getFirstVisibleItem(0)), levels);
                        var levelsArray = levels.items;
                        var levelCount = levelsArray.length;
                        var width = 0;
                        for (var i = 0; i < levelCount; i++) {
                            var level = levelsArray[i];
                            if (level.maxNonLeafWidth !== 0)
                                width += level.maxNonLeafWidth;
                            else
                                width += level.maxLeafWidth;
                        }
                        return width;
                    };
                    RowRealizationManager.prototype.updateRowHiearchyEstimatedWidth = function (items, firstVisibleIndex, levels) {
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var binder = this.binder;
                        var length = hierarchyNavigator.getCount(items);
                        for (var i = firstVisibleIndex; i < length; i++) {
                            if (levels.leafCount === this.itemsToRealizeCount)
                                return;
                            var item = hierarchyNavigator.getAt(items, i);
                            var label = binder.getHeaderLabel(item);
                            var itemWidth = this._owner.getEstimatedHeaderWidth(label, firstVisibleIndex);
                            var isLeaf = hierarchyNavigator.isLeaf(item);
                            var l = hierarchyNavigator.getLevel(item);
                            var level = levels.items[l];
                            if (!level) {
                                level = new RowWidth();
                                levels.items[l] = level;
                            }
                            if (isLeaf) {
                                level.maxLeafWidth = Math.max(level.maxLeafWidth, itemWidth);
                                levels.leafCount = levels.leafCount + 1;
                            }
                            else {
                                level.maxNonLeafWidth = Math.max(level.maxNonLeafWidth, itemWidth);
                                this.updateRowHiearchyEstimatedWidth(hierarchyNavigator.getChildren(item), this._owner.dimension.getFirstVisibleChildIndex(item), levels);
                            }
                        }
                    };
                    RowRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        return gridContextualWidth / ((this._owner.getRealizedItemsCount() - this._owner.dimension.getFractionScrollOffset()) * this._owner.owner.getEstimatedRowHeight());
                    };
                    return RowRealizationManager;
                }(TablixDimensionRealizationManager));
                internal.RowRealizationManager = RowRealizationManager;
                /**
                 * DOM implementation for Column Tablix realization manager.
                 */
                var ColumnRealizationManager = (function (_super) {
                    __extends(ColumnRealizationManager, _super);
                    function ColumnRealizationManager() {
                        _super.apply(this, arguments);
                    }
                    Object.defineProperty(ColumnRealizationManager.prototype, "owner", {
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype._getOwner = function () {
                        return this._owner;
                    };
                    ColumnRealizationManager.prototype._getEstimatedItemsToRealizeCount = function () {
                        this.estimateColumnsToRealizeCount(this.getEstimatedRowHierarchyWidth());
                    };
                    Object.defineProperty(ColumnRealizationManager.prototype, "rowRealizationManager", {
                        get: function () {
                            return this._owner.otherLayoutManager.realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnRealizationManager.prototype.getEstimatedRowHierarchyWidth = function () {
                        if (this._owner.otherLayoutManager.done)
                            return this._owner.getOtherHierarchyContextualHeight();
                        return this.rowRealizationManager.getEstimatedRowHierarchyWidth() * this.adjustmentFactor;
                    };
                    ColumnRealizationManager.prototype.estimateColumnsToRealizeCount = function (rowHierarchyWidth) {
                        var widthToFill = this._owner.contextualWidthToFill - rowHierarchyWidth;
                        if (!this._owner.dimension.model || powerbi.Double.lessOrEqualWithPrecision(widthToFill, 0, internal.DimensionLayoutManager._pixelPrecision)) {
                            this.itemsToRealizeCount = 0;
                            return;
                        }
                        var binder = this.binder;
                        var hierarchyNavigator = this._owner.owner.owner.hierarchyNavigator;
                        var startColumnIndex = this._owner.dimension.getIntegerScrollOffset();
                        var endColumnIndex = this._owner.dimension.getItemsCount();
                        var columnCount = endColumnIndex - startColumnIndex;
                        var startRowIndex = this._owner.otherLayoutManager.dimension.getIntegerScrollOffset();
                        var endRowIndex = this._owner.otherLayoutManager.dimension.getItemsCount();
                        this.itemsEstimatedContextualWidth = 0;
                        if (this._owner.alignToEnd) {
                            this.itemsToRealizeCount = columnCount;
                            return;
                        }
                        for (var i = startColumnIndex; i < endColumnIndex; i++) {
                            if (powerbi.Double.greaterOrEqualWithPrecision(this.itemsEstimatedContextualWidth, widthToFill, internal.DimensionLayoutManager._pixelPrecision)) {
                                this.itemsToRealizeCount = i - startColumnIndex;
                                return;
                            }
                            var maxWidth = 0;
                            var visibleSizeRatio = void 0;
                            if (i === startColumnIndex) {
                                visibleSizeRatio = this._owner.getVisibleSizeRatio();
                            }
                            else {
                                visibleSizeRatio = 1;
                            }
                            var columnMember = hierarchyNavigator.getLeafAt(this._owner.dimension.model, i);
                            var label = binder.getHeaderLabel(columnMember);
                            maxWidth = Math.max(maxWidth, this._owner.getEstimatedHeaderWidth(label, i));
                            for (var j = startRowIndex; j < endRowIndex; j++) {
                                var intersection = hierarchyNavigator.getIntersection(hierarchyNavigator.getLeafAt(this._owner.otherLayoutManager.dimension.model, j), columnMember);
                                label = binder.getCellContent(intersection);
                                maxWidth = Math.max(maxWidth, this._owner.getEstimatedBodyCellWidth(label));
                            }
                            this.itemsEstimatedContextualWidth += maxWidth * visibleSizeRatio * this.adjustmentFactor;
                        }
                        this.itemsToRealizeCount = columnCount;
                    };
                    ColumnRealizationManager.prototype._getSizeAdjustment = function (gridContextualWidth) {
                        return gridContextualWidth / (this.getEstimatedRowHierarchyWidth() + this.itemsEstimatedContextualWidth);
                    };
                    return ColumnRealizationManager;
                }(TablixDimensionRealizationManager));
                internal.ColumnRealizationManager = ColumnRealizationManager;
                var RowWidths = (function () {
                    function RowWidths() {
                        this.items = [];
                        this.leafCount = 0;
                    }
                    return RowWidths;
                }());
                internal.RowWidths = RowWidths;
                var RowWidth = (function () {
                    function RowWidth() {
                        this.maxLeafWidth = 0;
                        this.maxNonLeafWidth = 0;
                    }
                    return RowWidth;
                }());
                internal.RowWidth = RowWidth;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var TablixCell = (function () {
                    function TablixCell(presenter, extension, row) {
                        this._scrollable = false;
                        this._presenter = presenter;
                        this.extension = extension;
                        this._presenter.initialize(this);
                        this._row = row;
                        this.item = null;
                        this.type = null;
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        this._colSpan = 1;
                        this._rowSpan = 1;
                        this._containerWidth = -1;
                        this._containerHeight = -1;
                        this.contentHeight = this.contentWidth = 0;
                        this.position = new internal.TablixUtils.CellPosition();
                    }
                    TablixCell.prototype.unfixRowHeight = function () {
                        this._row.unfixSize();
                    };
                    Object.defineProperty(TablixCell.prototype, "colSpan", {
                        get: function () {
                            return this._colSpan;
                        },
                        set: function (value) {
                            if (this._colSpan !== value) {
                                this._presenter.onColumnSpanChanged(value);
                                this._colSpan = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "rowSpan", {
                        get: function () {
                            return this._rowSpan;
                        },
                        set: function (value) {
                            if (this._rowSpan !== value) {
                                this._presenter.onRowSpanChanged(value);
                                this._rowSpan = value;
                                this._row.unfixSize();
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.getCellSpanningHeight = function () {
                        return this._row.getCellSpanningHeight(this);
                    };
                    Object.defineProperty(TablixCell.prototype, "textAlign", {
                        get: function () {
                            return this._textAlign;
                        },
                        set: function (value) {
                            if (value !== this._textAlign) {
                                this._presenter.onTextAlignChanged(value);
                                this._textAlign = value;
                            }
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "horizontalOffset", {
                        get: function () {
                            return this._horizontalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixCell.prototype, "verticalOffset", {
                        get: function () {
                            return this._verticalOffset;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.isScrollable = function () {
                        return this._scrollable;
                    };
                    TablixCell.prototype.clear = function () {
                        if (this.isScrollable()) {
                            this.initializeScrolling();
                        }
                        this._presenter.onClear();
                        this.setContainerWidth(-1);
                        this.setContainerHeight(-1);
                        this.contentHeight = this.contentWidth = 0;
                    };
                    TablixCell.prototype.initializeScrolling = function () {
                        this._presenter.onInitializeScrolling();
                        this._horizontalOffset = 0;
                        this._verticalOffset = 0;
                        if (this.colSpan === 1)
                            this.setContainerWidth(-1);
                        if (this.rowSpan === 1)
                            this.setContainerHeight(-1);
                    };
                    TablixCell.prototype.prepare = function (scrollable) {
                        if (this.isScrollable())
                            this.initializeScrolling();
                        this._scrollable = scrollable;
                    };
                    TablixCell.prototype.scrollVertically = function (height, offset) {
                        // Ceiling the offset because setting a fraction Width on the TD will ceil it
                        // We need to let the TD and the OuterDiv to align in order for Borders to touch
                        var offsetInPixels = Math.ceil(-height * offset);
                        this._verticalOffset = offsetInPixels;
                        if (this.isScrollable()) {
                            this._presenter.onVerticalScroll(height, offsetInPixels);
                            this.setContainerHeight(height + offsetInPixels);
                        }
                        else {
                            this.setContainerHeight(this._row.getCellSpanningHeight(this) + offsetInPixels);
                        }
                    };
                    TablixCell.prototype.scrollHorizontally = function (width, offset) {
                        if (!this.isScrollable()) {
                            return;
                        }
                        // Ceiling the offset because setting a fraction Width on the TD will ceil it
                        // We need to let the TD and the OuterDiv to align in order for Borders to touch
                        var offsetInPixels = Math.ceil(-width * offset);
                        this._horizontalOffset = offsetInPixels;
                        this._presenter.onHorizontalScroll(width, offsetInPixels);
                        this.setContainerWidth(width + offsetInPixels);
                    };
                    TablixCell.prototype.setContainerWidth = function (value) {
                        if (value === this._containerWidth)
                            return;
                        this._containerWidth = value;
                        this._presenter.onContainerWidthChanged(value);
                    };
                    Object.defineProperty(TablixCell.prototype, "containerWidth", {
                        get: function () {
                            return this._containerWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.setContainerHeight = function (value) {
                        if (value < 0)
                            value = -1;
                        if (value === this._containerHeight)
                            return;
                        this._containerHeight = value;
                        this._presenter.onContinerHeightChanged(value);
                    };
                    Object.defineProperty(TablixCell.prototype, "containerHeight", {
                        get: function () {
                            return this._containerHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixCell.prototype.applyStyle = function (style) {
                        if (style) {
                            style.applyStyle(this);
                            this.contentHeight += style.getExtraBottom() + style.getExtraTop();
                            this.contentWidth += style.getExtraLeft() + style.getExtraRight();
                        }
                    };
                    TablixCell.prototype.enableHorizontalResize = function (enable, handler) {
                        this._presenter.enableHorizontalResize(enable, handler);
                    };
                    return TablixCell;
                }());
                internal.TablixCell = TablixCell;
                var TablixColumn = (function () {
                    function TablixColumn(presenter, columnIndex) {
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._containerWidth = -1;
                        this._width = -1;
                        this._sizeFixed = false;
                        this._aligningWidth = -1;
                        this._fixedToAligningWidth = false;
                        this._items = [];
                        this._itemType = null;
                        this._footerCell = null;
                        this._columnIndex = columnIndex;
                    }
                    TablixColumn.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCornerCells = [];
                        this._realizedBodyCells = [];
                    };
                    Object.defineProperty(TablixColumn.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getType = function () {
                        if (this._realizedCornerCells.length > 0)
                            return 0 /* CornerCell */;
                        return 2 /* ColumnHeader */;
                    };
                    TablixColumn.prototype.getColumnHeadersOrCorners = function () {
                        if (this._realizedCornerCells.length > 0)
                            return this._realizedCornerCells;
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.columnHeadersOrCornersEqual = function (newType, headers, hierarchyNavigator) {
                        if (this._items.length !== headers.length)
                            return false;
                        var count = this._items.length;
                        for (var i = 0; i < count; i++) {
                            if (!this.columnHeaderOrCornerEquals(this._itemType, this._items[i], newType, headers[i].item, hierarchyNavigator))
                                return false;
                        }
                        return true;
                    };
                    Object.defineProperty(TablixColumn.prototype, "itemType", {
                        get: function () {
                            return this._itemType;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.getLeafItem = function () {
                        if (this._items.length === 0)
                            return null;
                        return this._items[this._items.length - 1];
                    };
                    TablixColumn.prototype.columnHeaderOrCornerEquals = function (type1, item1, type2, item2, hierarchyNavigator) {
                        if (type1 !== type2)
                            return false;
                        if (type1 === 0 /* CornerCell */) {
                            if (!hierarchyNavigator.cornerCellItemEquals(item1, item2))
                                return false;
                        }
                        else {
                            if (!hierarchyNavigator.headerItemEquals(item1, item2))
                                return false;
                        }
                        return true;
                    };
                    TablixColumn.prototype.OnLeafRealized = function (hierarchyNavigator) {
                        // if the headers/corner have changed we should clear the column size to accomodate for the new content
                        var type = this.getType();
                        var columnHeadersOrCorners = this.getColumnHeadersOrCorners();
                        if (this.columnHeadersOrCornersEqual(type, columnHeadersOrCorners, hierarchyNavigator)) {
                            this.clearSpanningCellsWidth(this._realizedColumnHeaders);
                        }
                        else {
                            var count = columnHeadersOrCorners.length;
                            this._items = [];
                            for (var i = 0; i < count; i++) {
                                this._items.push(columnHeadersOrCorners[i].item);
                            }
                            this._itemType = type;
                            this.clearSize();
                        }
                    };
                    TablixColumn.prototype.clearSpanningCellsWidth = function (cells) {
                        for (var i = 0; i < cells.length; i++) {
                            var cell = cells[i];
                            if (cell.colSpan > 1) {
                                cell.setContainerWidth(-1);
                            }
                        }
                    };
                    TablixColumn.prototype.addCornerCell = function (cell) {
                        cell._column = this;
                        this._realizedCornerCells.push(cell);
                        cell.setContainerWidth(this._containerWidth);
                    };
                    TablixColumn.prototype.addRowHeader = function (cell) {
                        cell._column = this;
                        this._realizedRowHeaders.push(cell);
                        cell.setContainerWidth(this._containerWidth);
                    };
                    TablixColumn.prototype.addColumnHeader = function (cell, isLeaf) {
                        cell._column = this;
                        this._realizedColumnHeaders.push(cell);
                        if (isLeaf) {
                            cell.setContainerWidth(this._containerWidth);
                        }
                    };
                    TablixColumn.prototype.addBodyCell = function (cell) {
                        cell._column = this;
                        this._realizedBodyCells.push(cell);
                        cell.setContainerWidth(this._containerWidth);
                    };
                    Object.defineProperty(TablixColumn.prototype, "footer", {
                        get: function () {
                            return this._footerCell;
                        },
                        set: function (footerCell) {
                            this._footerCell = footerCell;
                            footerCell._column = this;
                            footerCell.setContainerWidth(this._containerWidth);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixColumn.prototype.onResize = function (width) {
                        if (width === this.getContentContextualWidth())
                            return;
                        this._containerWidth = width;
                        this.setContainerWidth(this._containerWidth);
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = false;
                        this._aligningWidth = -1;
                    };
                    TablixColumn.prototype.onResizeEnd = function (width) {
                        // Invoke resize callback
                        var gridPresenter = this.owner._presenter;
                        if (gridPresenter)
                            gridPresenter.invokeColumnResizeEndCallback(this._columnIndex, width);
                    };
                    TablixColumn.prototype.fixSize = function () {
                        var shouldAlign = this._aligningWidth !== -1;
                        var switched = shouldAlign !== this._fixedToAligningWidth;
                        if ((this._sizeFixed && !switched && !shouldAlign))
                            return;
                        if (this._aligningWidth === -1) {
                            this.setContainerWidth(this._containerWidth);
                        }
                        else {
                            this.setContainerWidth(this._aligningWidth);
                        }
                        this._sizeFixed = true;
                        this._fixedToAligningWidth = this._aligningWidth !== -1;
                    };
                    TablixColumn.prototype.clearSize = function () {
                        this._containerWidth = -1;
                        this.setContainerWidth(this._containerWidth);
                        this._sizeFixed = false;
                    };
                    TablixColumn.prototype.getContentContextualWidth = function () {
                        return this._containerWidth;
                    };
                    TablixColumn.prototype.getCellIContentContextualWidth = function (cell) {
                        return this._presenter.getCellContentWidth(cell);
                    };
                    TablixColumn.prototype.getCellSpanningWidthWithScrolling = function (cell, tablixGrid) {
                        var width = this.getContextualWidth() + this.getScrollingOffset();
                        if (cell.colSpan > 1) {
                            var index = this.getIndex(tablixGrid);
                            var columns = tablixGrid.realizedColumns;
                            for (var i = 1; i < cell.colSpan; i++)
                                width += columns[i + index].getContextualWidth();
                        }
                        return width;
                    };
                    TablixColumn.prototype.getScrollingOffset = function () {
                        var offset = 0;
                        if (this._realizedColumnHeaders.length > 0)
                            offset = this._realizedColumnHeaders[this._realizedColumnHeaders.length - 1].horizontalOffset;
                        return offset;
                    };
                    TablixColumn.prototype.getContextualWidth = function () {
                        if (this._width === -1 || this._containerWidth === -1)
                            this._width = this._presenter.getWidth();
                        return this._width;
                    };
                    TablixColumn.prototype.calculateSize = function () {
                        if (this._sizeFixed)
                            return this._containerWidth;
                        var contentWidth = 0;
                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (cell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            if (cell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                            var cell = _g[_f];
                            contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(cell));
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1)
                                contentWidth = Math.max(contentWidth, this._presenter.getCellContentWidth(this._footerCell));
                        }
                        return this._containerWidth = contentWidth;
                    };
                    TablixColumn.prototype.setAligningContextualWidth = function (size) {
                        this._aligningWidth = size;
                    };
                    TablixColumn.prototype.getAligningContextualWidth = function () {
                        return this._aligningWidth;
                    };
                    TablixColumn.prototype.setContainerWidth = function (value) {
                        for (var _i = 0, _a = this._realizedColumnHeaders; _i < _a.length; _i++) {
                            var cell = _a[_i];
                            if (cell.colSpan === 1)
                                cell.setContainerWidth(value);
                        }
                        for (var _b = 0, _c = this._realizedRowHeaders; _b < _c.length; _b++) {
                            var cell = _c[_b];
                            if (cell.colSpan === 1)
                                cell.setContainerWidth(value);
                        }
                        for (var _d = 0, _e = this._realizedCornerCells; _d < _e.length; _d++) {
                            var cell = _e[_d];
                            cell.setContainerWidth(value);
                        }
                        for (var _f = 0, _g = this._realizedBodyCells; _f < _g.length; _f++) {
                            var cell = _g[_f];
                            cell.setContainerWidth(value);
                        }
                        if (this._footerCell !== null) {
                            if (this._footerCell.colSpan === 1)
                                this._footerCell.setContainerWidth(value);
                        }
                        this._width = value; // set cell width to new value
                    };
                    TablixColumn.prototype.getTablixCell = function () {
                        var realizedCells = this._realizedColumnHeaders.length > 0 ? this._realizedColumnHeaders : this._realizedCornerCells;
                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixColumn.prototype.getIndex = function (grid) {
                        return grid.realizedColumns.indexOf(this);
                    };
                    TablixColumn.prototype.getHeaders = function () {
                        return this._realizedColumnHeaders;
                    };
                    TablixColumn.prototype.getOtherDimensionHeaders = function () {
                        return this._realizedRowHeaders;
                    };
                    TablixColumn.prototype.getCellContextualSpan = function (cell) {
                        return cell.colSpan;
                    };
                    TablixColumn.prototype.getOtherDimensionOwner = function (cell) {
                        return cell._row;
                    };
                    return TablixColumn;
                }());
                internal.TablixColumn = TablixColumn;
                var TablixRow = (function () {
                    function TablixRow(presenter) {
                        this._containerHeight = -1;
                        this._presenter = presenter;
                        this._presenter.initialize(this);
                        this._allocatedCells = [];
                        this._heightFixed = false;
                        this._containerHeight = -1;
                        this._height = -1;
                    }
                    TablixRow.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._realizedRowHeaders = [];
                        this._realizedBodyCells = [];
                        this._realizedCornerCells = [];
                        this._realizedColumnHeaders = [];
                        this._realizedCellsCount = 0;
                    };
                    Object.defineProperty(TablixRow.prototype, "presenter", {
                        get: function () {
                            return this._presenter;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixRow.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixRow.prototype.releaseUnusedCells = function (owner) {
                        this.releaseCells(owner, this._realizedCellsCount);
                    };
                    TablixRow.prototype.releaseAllCells = function (owner) {
                        this.releaseCells(owner, 0);
                    };
                    TablixRow.prototype.releaseCells = function (owner, startIndex) {
                        var cells = this._allocatedCells;
                        var length = cells.length;
                        for (var i = startIndex; i < length; i++) {
                            var cell = cells[i];
                            owner._unbindCell(cell);
                            cell.clear();
                        }
                    };
                    TablixRow.prototype.moveScrollableCellsToEnd = function (count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells[i];
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onAppendCell(cell);
                            this._allocatedCells.push(cell);
                        }
                        this._allocatedCells.splice(frontIndex, count);
                    };
                    TablixRow.prototype.moveScrollableCellsToStart = function (count) {
                        var frontIndex = Math.max(this._realizedRowHeaders.length, this._realizedCornerCells.length);
                        for (var i = frontIndex; i < frontIndex + count; i++) {
                            var cell = this._allocatedCells.pop();
                            this._presenter.onRemoveCell(cell);
                            this._presenter.onInsertCellBefore(cell, this._allocatedCells[frontIndex]);
                            this._allocatedCells.splice(frontIndex, 0, cell);
                        }
                    };
                    TablixRow.prototype.getOrCreateCornerCell = function (column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.addCornerCell(cell);
                        this._realizedCornerCells.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateRowHeader = function (column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addRowHeader(cell);
                        this._realizedRowHeaders.push(cell);
                        if (leaf)
                            cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateColumnHeader = function (column, scrollable, leaf) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addColumnHeader(cell, leaf);
                        this._realizedColumnHeaders.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateBodyCell = function (column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.addBodyCell(cell);
                        this._realizedBodyCells.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterRowHeader = function (column) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(false);
                        column.footer = cell;
                        this._realizedRowHeaders.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getOrCreateFooterBodyCell = function (column, scrollable) {
                        var cell = this.getOrCreateCell();
                        cell.prepare(scrollable);
                        column.footer = cell;
                        this._realizedBodyCells.push(cell);
                        cell.setContainerHeight(this._containerHeight);
                        return cell;
                    };
                    TablixRow.prototype.getRowHeaderLeafIndex = function () {
                        var index = -1;
                        var count = this._allocatedCells.length;
                        for (var i = 0; i < count; i++) {
                            if (this._allocatedCells[i].type !== 1 /* RowHeader */)
                                break;
                            index++;
                        }
                        return index;
                    };
                    TablixRow.prototype.getAllocatedCellAt = function (index) {
                        return this._allocatedCells[index];
                    };
                    TablixRow.prototype.moveCellsBy = function (delta) {
                        if (this._allocatedCells.length === 0)
                            return;
                        if (delta > 0) {
                            var refCell = this._allocatedCells[0];
                            for (var i = 0; i < delta; i++) {
                                var cell = this.createCell(this);
                                this._presenter.onInsertCellBefore(cell, refCell);
                                this._allocatedCells.unshift(cell);
                                refCell = cell;
                            }
                        }
                        else {
                            delta = -delta;
                            for (var i = 0; i < delta; i++) {
                                this._presenter.onRemoveCell(this._allocatedCells[i]);
                            }
                            this._allocatedCells.splice(0, delta);
                        }
                    };
                    TablixRow.prototype.getRealizedCellCount = function () {
                        return this._realizedCellsCount;
                    };
                    TablixRow.prototype.getRealizedHeadersCount = function () {
                        return this._realizedRowHeaders.length;
                    };
                    TablixRow.prototype.getRealizedHeaderAt = function (index) {
                        return this._realizedRowHeaders[index];
                    };
                    TablixRow.prototype.getTablixCell = function () {
                        var realizedCells;
                        if (this._realizedRowHeaders.length > 0) {
                            realizedCells = this._realizedRowHeaders;
                        }
                        else if (this._realizedCornerCells.length > 0) {
                            realizedCells = this._realizedCornerCells;
                        }
                        else {
                            realizedCells = this._realizedColumnHeaders;
                        }
                        //Debug.assert(realizedCells.length !== 0, "At least on header should have been realized");
                        return realizedCells[realizedCells.length - 1];
                    };
                    TablixRow.prototype.getOrCreateEmptySpaceCell = function () {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        return cell;
                    };
                    TablixRow.prototype.createCell = function (row) {
                        var presenter = this._presenter.createCellPresenter(this._owner.owner.layoutManager.getLayoutKind());
                        return new TablixCell(presenter, presenter, this);
                    };
                    TablixRow.prototype.getOrCreateCell = function () {
                        var cell = this._allocatedCells[this._realizedCellsCount];
                        if (cell === undefined) {
                            cell = this.createCell(this);
                            this._allocatedCells[this._realizedCellsCount] = cell;
                            this._presenter.onAppendCell(cell);
                        }
                        else {
                            cell.colSpan = 1;
                            cell.rowSpan = 1;
                        }
                        this._realizedCellsCount = this._realizedCellsCount + 1;
                        return cell;
                    };
                    TablixRow.prototype.onResize = function (height) {
                        if (height === this.getContentContextualWidth())
                            return;
                        this._containerHeight = height;
                        this.setContentHeight();
                        this._heightFixed = true;
                        this.setAligningContextualWidth(-1);
                    };
                    TablixRow.prototype.onResizeEnd = function (height) { };
                    TablixRow.prototype.fixSize = function () {
                        if (this.sizeFixed())
                            return;
                        this.setContentHeight();
                        this._heightFixed = true;
                    };
                    TablixRow.prototype.unfixSize = function () {
                        this._heightFixed = false;
                        this._height = -1;
                    };
                    TablixRow.prototype.getContentContextualWidth = function () {
                        return this._containerHeight;
                    };
                    TablixRow.prototype.getCellIContentContextualWidth = function (cell) {
                        return this.presenter.getCellContentHeight(cell);
                    };
                    TablixRow.prototype.getCellSpanningHeight = function (cell) {
                        var height = this.getContextualWidth();
                        if (cell.rowSpan > 1) {
                            var index = this.getIndex(this.owner);
                            var rows = this.owner.realizedRows;
                            for (var i = 1; i < cell.rowSpan; i++)
                                height += rows[i + index].getContextualWidth();
                        }
                        return height;
                    };
                    TablixRow.prototype.getContextualWidth = function () {
                        if (this._height === -1 || this._containerHeight === -1)
                            this._height = this._presenter.getHeight();
                        return this._height;
                    };
                    TablixRow.prototype.sizeFixed = function () {
                        return this._heightFixed;
                    };
                    TablixRow.prototype.calculateSize = function () {
                        if (this._heightFixed)
                            return this._containerHeight;
                        var contentHeight = 0;
                        var count = this._realizedRowHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedRowHeaders[i];
                            if (cell.rowSpan === 1)
                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedCornerCells[i]));
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            if (cell.rowSpan === 1)
                                contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            contentHeight = Math.max(contentHeight, this._presenter.getCellContentHeight(this._realizedBodyCells[i]));
                        }
                        return this._containerHeight = contentHeight;
                    };
                    TablixRow.prototype.setAligningContextualWidth = function (size) {
                        // TODO should be implemented when we support variable row heights
                    };
                    TablixRow.prototype.getAligningContextualWidth = function () {
                        // TODO should be implemented when we support variable row heights
                        return -1;
                    };
                    TablixRow.prototype.setContentHeight = function () {
                        var count = this._realizedRowHeaders.length;
                        // Need to do them in reverse order so that leaf headers are set first
                        for (var i = count - 1; i >= 0; i--) {
                            var cell = this._realizedRowHeaders[i];
                            cell.setContainerHeight(this._containerHeight);
                            if (cell.rowSpan > 1)
                                cell.setContainerHeight(this.getCellSpanningHeight(cell));
                        }
                        count = this._realizedCornerCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedCornerCells[i].setContainerHeight(this._containerHeight);
                        }
                        count = this._realizedColumnHeaders.length;
                        for (var i = 0; i < count; i++) {
                            var cell = this._realizedColumnHeaders[i];
                            cell.setContainerHeight(this._containerHeight);
                            if (cell.rowSpan > 1)
                                cell.setContainerHeight(this.getCellSpanningHeight(cell));
                        }
                        count = this._realizedBodyCells.length;
                        for (var i = 0; i < count; i++) {
                            this._realizedBodyCells[i].setContainerHeight(this._containerHeight);
                        }
                        this._height = -1;
                    };
                    TablixRow.prototype.getIndex = function (grid) {
                        return grid.realizedRows.indexOf(this);
                    };
                    TablixRow.prototype.getHeaders = function () {
                        return this._realizedRowHeaders;
                    };
                    TablixRow.prototype.getOtherDimensionHeaders = function () {
                        return this._realizedColumnHeaders;
                    };
                    TablixRow.prototype.getCellContextualSpan = function (cell) {
                        return cell.rowSpan;
                    };
                    TablixRow.prototype.getOtherDimensionOwner = function (cell) {
                        return cell._column;
                    };
                    return TablixRow;
                }());
                internal.TablixRow = TablixRow;
                var TablixGrid = (function () {
                    function TablixGrid(presenter) {
                        this._presenter = presenter;
                        this._footerRow = null;
                    }
                    TablixGrid.prototype.initialize = function (owner, gridHost, footerHost) {
                        this._owner = owner;
                        this._presenter.initialize(this, gridHost, footerHost, owner);
                        this.fillColumnsProportionally = false;
                        this._realizedRows = [];
                        this._realizedColumns = [];
                        this._emptySpaceHeaderCell = null;
                        this._emptyFooterSpaceCell = null;
                    };
                    Object.defineProperty(TablixGrid.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "fillColumnsProportionally", {
                        get: function () {
                            return this._fillColumnsProportionally;
                        },
                        set: function (value) {
                            if (this._fillColumnsProportionally === value)
                                return;
                            this._fillColumnsProportionally = value;
                            this._presenter.onFillColumnsProportionallyChanged(value);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedColumns", {
                        get: function () {
                            return this._realizedColumns;
                        },
                        set: function (columns) {
                            this._realizedColumns = columns;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "realizedRows", {
                        get: function () {
                            return this._realizedRows;
                        },
                        set: function (rows) {
                            this._realizedRows = rows;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "footerRow", {
                        get: function () {
                            return this._footerRow;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceHeaderCell", {
                        get: function () {
                            return this._emptySpaceHeaderCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixGrid.prototype, "emptySpaceFooterCell", {
                        get: function () {
                            return this._emptyFooterSpaceCell;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixGrid.prototype.ShowEmptySpaceCells = function (rowSpan, width) {
                        if (this._realizedRows.length === 0)
                            return;
                        if (this._realizedRows.length !== 0 && !this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell = this._realizedRows[0].getOrCreateEmptySpaceCell();
                            this._emptySpaceHeaderCell.rowSpan = rowSpan;
                            this._emptySpaceHeaderCell.colSpan = 1;
                            this._emptySpaceHeaderCell.setContainerWidth(width);
                        }
                        if (this._footerRow && (this._emptyFooterSpaceCell === null)) {
                            this._emptyFooterSpaceCell = this._footerRow.getOrCreateEmptySpaceCell();
                            this._emptyFooterSpaceCell.rowSpan = 1;
                            this._emptyFooterSpaceCell.colSpan = 1;
                            this._emptyFooterSpaceCell.setContainerWidth(width);
                        }
                    };
                    TablixGrid.prototype.HideEmptySpaceCells = function () {
                        if (this._emptySpaceHeaderCell) {
                            this._emptySpaceHeaderCell.clear();
                            this._emptySpaceHeaderCell = null;
                        }
                        if (this._emptyFooterSpaceCell) {
                            this._emptyFooterSpaceCell.clear();
                            this._emptyFooterSpaceCell = null;
                        }
                    };
                    TablixGrid.prototype.onStartRenderingSession = function (clear) {
                        if (clear) {
                            this.clearRows();
                            this.clearColumns();
                        }
                    };
                    TablixGrid.prototype.onStartRenderingIteration = function () {
                        this.initializeRows();
                        this.initializeColumns();
                    };
                    TablixGrid.prototype.onEndRenderingIteration = function () {
                        var rows = this._rows;
                        if (rows !== undefined) {
                            var rowCount = rows.length;
                            for (var i = 0; i < rowCount; i++) {
                                rows[i].releaseUnusedCells(this._owner);
                            }
                        }
                        if (this._footerRow) {
                            this._footerRow.releaseUnusedCells(this._owner);
                        }
                    };
                    TablixGrid.prototype.getOrCreateRow = function (rowIndex) {
                        var currentRow = this._rows[rowIndex];
                        if (currentRow === undefined) {
                            currentRow = new TablixRow(this._presenter.createRowPresenter());
                            currentRow.initialize(this);
                            this._presenter.onAppendRow(currentRow);
                            this._rows[rowIndex] = currentRow;
                        }
                        if (this._realizedRows[rowIndex] === undefined) {
                            this._realizedRows[rowIndex] = currentRow;
                        }
                        return currentRow;
                    };
                    TablixGrid.prototype.getOrCreateFootersRow = function () {
                        if (this._footerRow === null) {
                            this._footerRow = new TablixRow(this._presenter.createRowPresenter());
                            this._footerRow.initialize(this);
                            this._presenter.onAddFooterRow(this._footerRow);
                        }
                        return this._footerRow;
                    };
                    TablixGrid.prototype.moveRowsToEnd = function (moveFromIndex, count) {
                        for (var i = 0; i < count; i++) {
                            var row = this._rows[i + moveFromIndex];
                            debug.assertValue(row, "Invalid Row Index");
                            row.unfixSize();
                            this._presenter.onRemoveRow(row);
                            this._presenter.onAppendRow(row);
                            this._rows.push(row);
                        }
                        this._rows.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveRowsToStart = function (moveToIndex, count) {
                        var refRow = this._rows[moveToIndex];
                        debug.assertValue(refRow, "Invalid Row Index");
                        for (var i = 0; i < count; i++) {
                            var row = this._rows.pop();
                            row.unfixSize();
                            this._presenter.onRemoveRow(row);
                            this._presenter.onInsertRowBefore(row, refRow);
                            this._rows.splice(moveToIndex + i, 0, row);
                        }
                    };
                    TablixGrid.prototype.moveColumnsToEnd = function (moveFromIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToEnd(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns[i + moveFromIndex];
                            //Debug.assertValue(column, "Invalid Column Index");
                            this._columns.push(column);
                        }
                        this._columns.splice(moveFromIndex, count);
                    };
                    TablixGrid.prototype.moveColumnsToStart = function (moveToIndex, count) {
                        var firstCol = this._rows[0]._realizedCornerCells.length;
                        var leafStartDepth = Math.max(this._columns[firstCol]._realizedColumnHeaders.length - 1, 0);
                        for (var i = leafStartDepth; i < this._rows.length; i++) {
                            this._rows[i].moveScrollableCellsToStart(count);
                        }
                        for (var i = 0; i < count; i++) {
                            var column = this._columns.pop();
                            this._columns.splice(moveToIndex + i, 0, column);
                        }
                    };
                    TablixGrid.prototype.getOrCreateColumn = function (columnIndex) {
                        var currentColumn = this._columns[columnIndex];
                        if (currentColumn === undefined) {
                            currentColumn = new TablixColumn(this._presenter.createColumnPresenter(columnIndex), columnIndex);
                            currentColumn.initialize(this);
                            this._columns[columnIndex] = currentColumn;
                        }
                        if (this._realizedColumns[columnIndex] === undefined) {
                            this._realizedColumns[columnIndex] = currentColumn;
                        }
                        return currentColumn;
                    };
                    TablixGrid.prototype.initializeColumns = function () {
                        if (!this._columns)
                            this._columns = [];
                        var length = this._columns.length;
                        for (var i = 0; i < length; i++) {
                            this._columns[i].initialize(this);
                        }
                        this._realizedColumns = [];
                    };
                    TablixGrid.prototype.clearColumns = function () {
                        this._columns = null;
                        this._realizedColumns = null;
                    };
                    TablixGrid.prototype.initializeRows = function () {
                        // make sure rowDimension confirms it and it's not null in the grid
                        var hasFooter = this._owner.rowDimension.hasFooter() && (this._footerRow !== null);
                        this._realizedRows = [];
                        if (!this._rows) {
                            this._rows = [];
                        }
                        var rows = this._rows;
                        var length = rows.length;
                        for (var i = 0; i < length; i++) {
                            rows[i].initialize(this);
                        }
                        if (hasFooter) {
                            if (!this._footerRow) {
                                this.getOrCreateFootersRow();
                            }
                            this._footerRow.initialize(this);
                        }
                    };
                    TablixGrid.prototype.clearRows = function () {
                        var rows = this._rows;
                        if (rows) {
                            var length_1 = rows.length;
                            for (var i = 0; i < length_1; i++) {
                                rows[i].releaseAllCells(this._owner);
                            }
                            if (this._footerRow)
                                this._footerRow.releaseAllCells(this._owner);
                            this._presenter.onClear();
                            this._footerRow = null;
                            this._rows = null;
                            this._realizedRows = null;
                        }
                    };
                    TablixGrid.prototype.getWidth = function () {
                        return this._presenter.getWidth();
                    };
                    TablixGrid.prototype.getHeight = function () {
                        return this._presenter.getHeight();
                    };
                    return TablixGrid;
                }());
                internal.TablixGrid = TablixGrid;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var PixelConverter = jsCommon.PixelConverter;
                /**
                 * This class is used for layouts that don't or cannot
                 * rely on DOM measurements.  Instead they compute all required
                 * widths and heights and store it in this structure.
                 */
                var SizeComputationManager = (function () {
                    function SizeComputationManager() {
                    }
                    Object.defineProperty(SizeComputationManager.prototype, "visibleWidth", {
                        get: function () {
                            return this._viewport ? this._viewport.width : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "visibleHeight", {
                        get: function () {
                            return this._viewport ? this._viewport.height : 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridWidth", {
                        get: function () {
                            return this.visibleWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "gridHeight", {
                        get: function () {
                            return this.visibleHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "rowHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellWidth", {
                        get: function () {
                            return this._cellWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "cellHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentWidth", {
                        get: function () {
                            return this._cellWidth;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(SizeComputationManager.prototype, "contentHeight", {
                        get: function () {
                            return this._cellHeight;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    SizeComputationManager.prototype.updateColumnCount = function (columnCount) {
                        this._columnCount = columnCount;
                    };
                    SizeComputationManager.prototype.updateRowHeight = function (rowHeight) {
                        this._cellHeight = rowHeight;
                    };
                    SizeComputationManager.prototype.updateScalingFactor = function (scalingFactor) {
                        this._scalingFactor = scalingFactor;
                        this._cellWidth = this.computeColumnWidth(this._columnCount);
                    };
                    SizeComputationManager.prototype.updateViewport = function (viewport) {
                        this._viewport = viewport;
                        this._cellWidth = this.computeColumnWidth(this._columnCount);
                        this._cellHeight = this.computeColumnHeight();
                    };
                    SizeComputationManager.prototype.computeColumnWidth = function (totalColumnCount) {
                        var scalingFactor = this._scalingFactor;
                        if (!scalingFactor)
                            scalingFactor = 1;
                        var minimumColumnWidth = scalingFactor * SizeComputationManager.TablixMinimumColumnWidth;
                        var maxAllowedColumns = Math.floor(this._viewport.width / minimumColumnWidth);
                        return this.fitToColumnCount(maxAllowedColumns, totalColumnCount);
                    };
                    SizeComputationManager.prototype.computeColumnHeight = function () {
                        if (!this.hasImageContent)
                            return this._cellHeight;
                        var width = this._viewport.width;
                        if (width <= 250) {
                            // Small
                            return 20;
                        }
                        else if (width <= 510) {
                            // Medium
                            return 51;
                        }
                        else if (width <= 770) {
                            // Large
                            return 52;
                        }
                        debug.assertFail("Fixed size is only for viewport up to 770px width.");
                    };
                    SizeComputationManager.prototype.fitToColumnCount = function (maxAllowedColumnCount, totalColumnCount) {
                        var columnsToFit = Math.min(maxAllowedColumnCount, totalColumnCount);
                        return Math.floor(this._viewport.width / columnsToFit);
                    };
                    // Minimum size for a column, used to calculate layout
                    SizeComputationManager.TablixMinimumColumnWidth = 75;
                    return SizeComputationManager;
                }());
                internal.SizeComputationManager = SizeComputationManager;
                var DimensionLayoutManager = (function () {
                    function DimensionLayoutManager(owner, grid, realizationManager) {
                        //debug.assertValue(realizationManager, "Realization Manager must be defined");
                        this._owner = owner;
                        this._grid = grid;
                        this._lastScrollOffset = null;
                        this._isScrolling = false;
                        this._fixedSizeEnabled = true;
                        this._done = false;
                        this._realizationManager = realizationManager;
                    }
                    Object.defineProperty(DimensionLayoutManager.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        set: function (owner) {
                            this._owner = owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "realizationManager", {
                        get: function () {
                            return this._realizationManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "fixedSizeEnabled", {
                        get: function () {
                            return this._fixedSizeEnabled;
                        },
                        set: function (enable) {
                            this._fixedSizeEnabled = enable;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onCornerCellRealized = function (item, cell, leaf) {
                        this._realizationManager.onCornerCellRealized(item, cell);
                    };
                    DimensionLayoutManager.prototype.onHeaderRealized = function (item, cell, leaf) {
                        this._realizationManager.onHeaderRealized(item, cell, leaf);
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "needsToRealize", {
                        get: function () {
                            return this._realizationManager.needsToRealize;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getVisibleSizeRatio = function () {
                        return 1 - this.dimension.getFractionScrollOffset();
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "alignToEnd", {
                        get: function () {
                            return this._alignToEnd;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "done", {
                        get: function () {
                            return this._done;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype._requiresMeasure = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._requiresMeasure");
                        return true;
                    };
                    DimensionLayoutManager.prototype.startScrollingSession = function () {
                        this._isScrolling = true;
                    };
                    DimensionLayoutManager.prototype.endScrollingSession = function () {
                        this._isScrolling = false;
                    };
                    DimensionLayoutManager.prototype.isScrolling = function () {
                        return this._isScrolling;
                    };
                    DimensionLayoutManager.prototype.isResizing = function () {
                        return false;
                    };
                    DimensionLayoutManager.prototype.getOtherHierarchyContextualHeight = function () {
                        var otherDimension = this.dimension.otherDimension;
                        var count = otherDimension.getDepth();
                        var contextualHeight = 0;
                        var items = this._getRealizedItems();
                        if (items.length > 0) {
                            for (var i = 0; i < count; i++) {
                                contextualHeight += items[i].getContextualWidth();
                            }
                        }
                        return contextualHeight;
                    };
                    DimensionLayoutManager.prototype._isAutoSized = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._isAutoSized");
                        return false;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingSession = function () {
                        this._measureEnabled = this._requiresMeasure();
                        this._gridOffset = this.dimension.otherDimension.getDepth();
                    };
                    DimensionLayoutManager.prototype.onEndRenderingSession = function () {
                        this._realizationManager.onEndRenderingSession();
                        this._alignToEnd = false;
                        this._done = false;
                        this._measureEnabled = true;
                        this._sendDimensionsToControl();
                    };
                    /**
                     * Implementing classes must override this to send dimentions to TablixControl.
                     */
                    DimensionLayoutManager.prototype._sendDimensionsToControl = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._sendDimensionsToControl");
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "measureEnabled", {
                        get: function () {
                            return this._measureEnabled;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getFooterContextualWidth = function () {
                        return 0;
                    };
                    DimensionLayoutManager.prototype.onStartRenderingIteration = function (clear, contextualWidth) {
                        if (this._measureEnabled && !this._done) {
                            this._contextualWidthToFill = (contextualWidth - this.otherScrollbarContextualWidth) * this.getGridScale() - this.getFooterContextualWidth();
                        }
                        this._realizationManager.onStartRenderingIteration();
                        if (clear) {
                            this._lastScrollOffset = null;
                        }
                        else if (this._lastScrollOffset !== null) {
                            this.swapElements();
                        }
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "allItemsRealized", {
                        get: function () {
                            return this.getRealizedItemsCount() - this._gridOffset === this.dimension.getItemsCount() || this.dimension.getItemsCount() === 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.onEndRenderingIteration = function () {
                        if (this._done) {
                            return;
                        }
                        if (!this._measureEnabled) {
                            this._lastScrollOffset = this.dimension.scrollOffset;
                            this._done = true;
                            return;
                        }
                        var gridContextualWidth = this.getGridContextualWidth();
                        var filled = powerbi.Double.greaterOrEqualWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                        var allRealized = this.allItemsRealized;
                        var newScrollOffset;
                        if (filled) {
                            newScrollOffset = this.scrollForwardToAlignEnd(gridContextualWidth);
                        }
                        else {
                            newScrollOffset = this.scrollBackwardToFill(gridContextualWidth);
                        }
                        this._realizationManager.onEndRenderingIteration(gridContextualWidth, filled);
                        var originalScrollbarVisible = this.dimension.scrollbar.visible;
                        this.updateScrollbar(gridContextualWidth);
                        this._done = (filled || allRealized) &&
                            this.dimension.scrollbar.visible === originalScrollbarVisible &&
                            powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision);
                        this.dimension.scrollOffset = newScrollOffset;
                        this._lastScrollOffset = this.dimension.scrollOffset;
                    };
                    DimensionLayoutManager.prototype.getScrollDeltaWithinPage = function () {
                        if (this._lastScrollOffset !== null) {
                            var delta = this.dimension.getIntegerScrollOffset() - Math.floor(this._lastScrollOffset);
                            if (Math.abs(delta) < this.getRealizedItemsCount() - this.dimension.otherDimension.getDepth()) {
                                return delta;
                            }
                        }
                        return null;
                    };
                    DimensionLayoutManager.prototype.swapElements = function () {
                        var delta = this.getScrollDeltaWithinPage();
                        if (delta !== null) {
                            var otherHierarchyDepth = this.dimension.otherDimension.getDepth();
                            if (Math.abs(delta) < this.getRealizedItemsCount() - otherHierarchyDepth) {
                                if (delta > 0) {
                                    this._moveElementsToBottom(otherHierarchyDepth, delta);
                                }
                                else if (delta < 0) {
                                    this._moveElementsToTop(otherHierarchyDepth, -delta);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype._getRealizedItems = function () {
                        // abstract
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._getRealizedItems");
                        return null;
                    };
                    DimensionLayoutManager.prototype.getRealizedItemsCount = function () {
                        var realizedItems = this._getRealizedItems();
                        return realizedItems.length;
                    };
                    DimensionLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToBottom");
                    };
                    DimensionLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._moveElementsToTop");
                    };
                    DimensionLayoutManager.prototype.isScrollingWithinPage = function () {
                        return this.getScrollDeltaWithinPage() !== null;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidth = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridContextualWidth");
                        return 0;
                    };
                    DimensionLayoutManager.prototype.updateScrollbar = function (gridContextualWidth) {
                        var scrollbar = this.dimension.scrollbar;
                        scrollbar.viewMin = this.dimension.scrollOffset;
                        scrollbar.min = 0;
                        scrollbar.max = this.dimension.getItemsCount();
                        scrollbar.viewSize = this.getViewSize(gridContextualWidth);
                        this.dimension.scrollbar.show(this.canScroll(gridContextualWidth));
                    };
                    DimensionLayoutManager.prototype.getViewSize = function (gridContextualWidth) {
                        var count = this.getRealizedItemsCount();
                        if (count === 0)
                            return 0;
                        var startIndex = this._gridOffset;
                        var sizeInItems = 0;
                        var sizeInPixels = 0;
                        var widthToFill = this._contextualWidthToFill;
                        var scrollableArea = widthToFill - this.getOtherHierarchyContextualHeight();
                        var error = this.getMeaurementError(gridContextualWidth);
                        for (var i = startIndex; i < count; i++) {
                            var visibleRatio = void 0;
                            if (i === startIndex) {
                                visibleRatio = this.getVisibleSizeRatio();
                            }
                            else
                                visibleRatio = 1;
                            var itemContextualWidth = this.getItemContextualWidthWithScrolling(i) * error;
                            sizeInPixels += itemContextualWidth;
                            sizeInItems += visibleRatio;
                            if (powerbi.Double.greaterWithPrecision(sizeInPixels, scrollableArea, DimensionLayoutManager._pixelPrecision)) {
                                sizeInItems -= ((sizeInPixels - scrollableArea) / itemContextualWidth) * visibleRatio;
                                break;
                            }
                        }
                        return sizeInItems;
                    };
                    DimensionLayoutManager.prototype.isScrollableHeader = function (item, items, index) {
                        if (index !== 0 || this.dimension.getFractionScrollOffset() === 0) {
                            return false;
                        }
                        var hierarchyNavigator = this.dimension._hierarchyNavigator;
                        if (hierarchyNavigator.isLeaf(item)) {
                            return true;
                        }
                        var currentItem = item;
                        var currentItems = items;
                        do {
                            currentItems = hierarchyNavigator.getChildren(currentItem);
                            currentItem = this.dimension.getFirstVisibleItem(hierarchyNavigator.getLevel(currentItem) + 1);
                            if (currentItem === undefined) {
                                break;
                            }
                            if (!hierarchyNavigator.isLastItem(currentItem, currentItems)) {
                                return false;
                            }
                        } while (!hierarchyNavigator.isLeaf(currentItem));
                        return true;
                    };
                    DimensionLayoutManager.prototype.reachedEnd = function () {
                        return this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount();
                    };
                    DimensionLayoutManager.prototype.scrollBackwardToFill = function (gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this.reachedEnd()) {
                            var widthToFill = this._contextualWidthToFill - gridContextualWidth;
                            if (this.dimension.getItemsCount() > 0) {
                                var averageColumnwidth = gridContextualWidth / (this.getRealizedItemsCount() - this.dimension.getFractionScrollOffset());
                                newScrollOffset = this.dimension.getValidScrollOffset(Math.floor(this.dimension.scrollOffset - (widthToFill / averageColumnwidth)));
                            }
                            this._alignToEnd = !powerbi.Double.equalWithPrecision(newScrollOffset, this.dimension.scrollOffset, DimensionLayoutManager._scrollOffsetPrecision); // this is an aproximate scrolling back, we have to ensure it is aligned to the end of the control
                        }
                        return newScrollOffset;
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidth = function (index) {
                        var realizedItems = this._getRealizedItems();
                        if (index >= realizedItems.length)
                            return null;
                        return realizedItems[index].getContextualWidth();
                    };
                    DimensionLayoutManager.prototype.getItemContextualWidthWithScrolling = function (index) {
                        return this.getSizeWithScrolling(this.getItemContextualWidth(index), index);
                    };
                    DimensionLayoutManager.prototype.getSizeWithScrolling = function (size, index) {
                        var ratio;
                        if (this._gridOffset === index) {
                            ratio = this.getVisibleSizeRatio();
                        }
                        else {
                            ratio = 1;
                        }
                        return size * ratio;
                    };
                    DimensionLayoutManager.prototype.getGridContextualWidthFromItems = function () {
                        var count = this.getRealizedItemsCount();
                        var contextualWidth = 0;
                        for (var i = 0; i < count; i++) {
                            contextualWidth += this.getItemContextualWidthWithScrolling(i);
                        }
                        return contextualWidth;
                    };
                    DimensionLayoutManager.prototype.getMeaurementError = function (gridContextualWidth) {
                        return gridContextualWidth / this.getGridContextualWidthFromItems();
                    };
                    DimensionLayoutManager.prototype.scrollForwardToAlignEnd = function (gridContextualWidth) {
                        var newScrollOffset = this.dimension.scrollOffset;
                        if (this._alignToEnd) {
                            var withinThreshold = powerbi.Double.equalWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                            if (!withinThreshold) {
                                var count = this.getRealizedItemsCount();
                                var startIndex = this._gridOffset;
                                var widthToScroll = gridContextualWidth - this._contextualWidthToFill;
                                var error = this.getMeaurementError(gridContextualWidth);
                                for (var i = startIndex; i < count; i++) {
                                    var itemContextualWidth = this.getItemContextualWidth(i) * error;
                                    if (powerbi.Double.lessWithPrecision(itemContextualWidth, widthToScroll, DimensionLayoutManager._pixelPrecision)) {
                                        widthToScroll -= itemContextualWidth;
                                    }
                                    else {
                                        var visibleRatio = startIndex === i ? 1 - this.dimension.getFractionScrollOffset() : 1;
                                        newScrollOffset = this.dimension.getValidScrollOffset(this.dimension.scrollOffset + (i - startIndex) + (widthToScroll * visibleRatio / itemContextualWidth));
                                        break;
                                    }
                                }
                            }
                            this._alignToEnd = !withinThreshold;
                        }
                        return newScrollOffset;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "dimension", {
                        get: function () {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.dimension");
                            return null;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherLayoutManager", {
                        get: function () {
                            return this.dimension.otherDimension.layoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(DimensionLayoutManager.prototype, "contextualWidthToFill", {
                        get: function () {
                            return this._contextualWidthToFill;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getGridScale = function () {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.getGridScale");
                        return 0;
                    };
                    Object.defineProperty(DimensionLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            debug.assertFail("PureVirtualMethod: DimensionLayoutManager.otherScrollbarContextualWidth");
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    DimensionLayoutManager.prototype.getActualContextualWidth = function (gridContextualWidth) {
                        if (this._isAutoSized() && !this.canScroll(gridContextualWidth))
                            return gridContextualWidth;
                        return this._contextualWidthToFill;
                    };
                    DimensionLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager.canScroll");
                        return false;
                    };
                    DimensionLayoutManager.prototype.calculateSizes = function () {
                        if (this.fixedSizeEnabled) {
                            this.calculateContextualWidths();
                            this.calculateSpans();
                        }
                    };
                    DimensionLayoutManager.prototype._calculateSize = function (item) {
                        debug.assertFail("PureVirtualMethod: DimensionLayoutManager._calculateSize");
                        return null;
                    };
                    DimensionLayoutManager.prototype.calculateContextualWidths = function () {
                        var items = this._getRealizedItems();
                        var count = items.length;
                        for (var i = 0; i < count; i++) {
                            var item = items[i];
                            if (this.measureEnabled)
                                item.setAligningContextualWidth(-1);
                            this._calculateSize(item);
                        }
                    };
                    DimensionLayoutManager.prototype.calculateSpans = function () {
                        if (this.measureEnabled) {
                            this.updateNonScrollableItemsSpans();
                            this.updateScrollableItemsSpans();
                        }
                        // TODO override in row layout manager to add footer to calculation, this is required for Matrix
                    };
                    DimensionLayoutManager.prototype.updateNonScrollableItemsSpans = function () {
                        var otherDimensionItems = this.otherLayoutManager._getRealizedItems();
                        var otherDimensionItemsCount = otherDimensionItems.length;
                        var startIndex = this.dimension.getDepth();
                        for (var i = startIndex; i < otherDimensionItemsCount; i++) {
                            var otherDimensionItem = otherDimensionItems[i];
                            this.updateSpans(otherDimensionItem, otherDimensionItem.getHeaders());
                        }
                    };
                    DimensionLayoutManager.prototype.updateScrollableItemsSpans = function () {
                        var otherRealizedItems = this.otherLayoutManager._getRealizedItems();
                        var otherRealizedItemsCount = Math.min(this.dimension.getDepth(), otherRealizedItems.length);
                        for (var i = 0; i < otherRealizedItemsCount; i++) {
                            var otherRealizedItem = otherRealizedItems[i];
                            this.updateSpans(otherRealizedItem, otherRealizedItem.getOtherDimensionHeaders());
                        }
                    };
                    DimensionLayoutManager.prototype.fixSizes = function () {
                        if (this.fixedSizeEnabled) {
                            var items = this._getRealizedItems();
                            var count = items.length;
                            for (var i = count - 1; i >= 0; i--) {
                                items[i].fixSize();
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateSpans = function (otherRealizedItem, cells) {
                        var realizedItems = this._getRealizedItems();
                        var cellCount = cells.length;
                        for (var j = 0; j < cellCount; j++) {
                            var cell = cells[j];
                            var owner = otherRealizedItem.getOtherDimensionOwner(cell);
                            var span = owner.getCellContextualSpan(cell);
                            if (span > 1) {
                                var totalSizeInSpan = 0;
                                var startIndex = owner.getIndex(this._grid);
                                for (var k = 0; k < span; k++) {
                                    var item = realizedItems[k + startIndex];
                                    totalSizeInSpan += item.getContentContextualWidth();
                                    if (k === span - 1)
                                        this.updateLastChildSize(cell, item, totalSizeInSpan);
                                }
                            }
                        }
                    };
                    DimensionLayoutManager.prototype.updateLastChildSize = function (spanningCell, item, totalSpanSize) {
                        var delta = item.getCellIContentContextualWidth(spanningCell) - totalSpanSize;
                        if (delta > 0)
                            item.setAligningContextualWidth(Math.max(item.getAligningContextualWidth(), delta + item.getContentContextualWidth()));
                    };
                    DimensionLayoutManager._pixelPrecision = 1.0001;
                    DimensionLayoutManager._scrollOffsetPrecision = 0.01;
                    return DimensionLayoutManager;
                }());
                internal.DimensionLayoutManager = DimensionLayoutManager;
                var ResizeState = (function () {
                    function ResizeState(column, width, scale) {
                        this.column = column;
                        this.item = column.getLeafItem();
                        this.itemType = column.itemType;
                        this.startColumnWidth = width;
                        this.resizingDelta = 0;
                        this.animationFrame = null;
                        this.scale = scale;
                    }
                    ResizeState.prototype.getNewSize = function () {
                        return this.startColumnWidth + this.resizingDelta;
                    };
                    return ResizeState;
                }());
                internal.ResizeState = ResizeState;
                var ColumnLayoutManager = (function (_super) {
                    __extends(ColumnLayoutManager, _super);
                    function ColumnLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager);
                        realizationManager.owner = this;
                        this.fillProportionally = false;
                        this._resizeState = null;
                    }
                    Object.defineProperty(ColumnLayoutManager.prototype, "dimension", {
                        get: function () {
                            return this.owner.owner.columnDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.isResizing = function () {
                        return this._resizeState !== null;
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "fillProportionally", {
                        get: function () {
                            return this._grid.fillColumnsProportionally;
                        },
                        set: function (value) {
                            this._grid.fillColumnsProportionally = value;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype.getGridScale = function () {
                        return this._grid._presenter.getScreenToCssRatioX();
                    };
                    Object.defineProperty(ColumnLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementWidth(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    ColumnLayoutManager.prototype._getRealizedItems = function () {
                        if (!this._grid.realizedColumns) {
                            this._grid.realizedColumns = [];
                        }
                        return this._grid.realizedColumns;
                    };
                    ColumnLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        this._grid.moveColumnsToEnd(moveFromIndex, count);
                    };
                    ColumnLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        this._grid.moveColumnsToStart(moveToIndex, count);
                    };
                    ColumnLayoutManager.prototype._requiresMeasure = function () {
                        // if the control is not scrolling in either dimension or is scrolling or is resizing
                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling()) || this.isScrolling() || this.isResizing();
                    };
                    ColumnLayoutManager.prototype.getGridContextualWidth = function () {
                        return this._grid.getWidth();
                    };
                    ColumnLayoutManager.prototype.getFirstVisibleColumn = function () {
                        return this._grid.realizedColumns[this._gridOffset];
                    };
                    ColumnLayoutManager.prototype._isAutoSized = function () {
                        return this.owner.owner.autoSizeWidth;
                    };
                    ColumnLayoutManager.prototype.applyScrolling = function () {
                        var columnOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleColumnWidth = 0;
                        if (columnOffset !== 0) {
                            var firstVisibleColumn = this.getFirstVisibleColumn();
                            if (firstVisibleColumn !== undefined) {
                                firstVisibleColumnWidth = firstVisibleColumn.getContextualWidth();
                                this.scroll(firstVisibleColumn, firstVisibleColumnWidth, columnOffset);
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.scroll = function (firstVisibleColumn, width, offset) {
                        this.scrollCells(firstVisibleColumn._realizedColumnHeaders, width, offset);
                        this.scrollBodyCells(this._grid.realizedRows, width, offset);
                        if (firstVisibleColumn.footer !== null) {
                            firstVisibleColumn.footer.scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollCells = function (cells, width, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollHorizontally(width, offset);
                        }
                    };
                    ColumnLayoutManager.prototype.scrollBodyCells = function (rows, width, offset) {
                        var length = rows.length;
                        var cells;
                        var cell;
                        for (var i = 0; i < length; i++) {
                            cells = rows[i]._realizedBodyCells;
                            if (cells !== undefined) {
                                cell = cells[0];
                                if (cell !== undefined) {
                                    cell.scrollHorizontally(width, offset);
                                }
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.onStartResize = function (cell, currentX, currentY) {
                        this._resizeState = new ResizeState(cell._column, cell._column.getContentContextualWidth(), controls.HTMLElementUtils.getAccumulatedScale(this.owner.owner.container));
                    };
                    ColumnLayoutManager.prototype.onResize = function (cell, deltaX, deltaY) {
                        var _this = this;
                        if (this.isResizing()) {
                            this._resizeState.resizingDelta = Math.round(Math.max(deltaX / this._resizeState.scale, ColumnLayoutManager.minColumnWidth - this._resizeState.startColumnWidth));
                            if (this._resizeState.animationFrame === null)
                                this._resizeState.animationFrame = requestAnimationFrame(function () { return _this.performResizing(); });
                        }
                    };
                    ColumnLayoutManager.prototype.onEndResize = function (cell) {
                        if (this.isResizing() && this._resizeState.animationFrame !== null) {
                            this.performResizing(); // if we reached the end and we are still waiting for the last animation frame, perform the pending resizing and clear the state 
                        }
                        this.endResizing();
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.onReset = function (cell) {
                        this._resizeState = new ResizeState(cell._column, -1, 1);
                        cell._column.clearSize();
                        this.endResizing();
                        this.owner.owner.refresh(false);
                        this._resizeState = null;
                    };
                    ColumnLayoutManager.prototype.updateItemToResizeState = function (realizedColumns) {
                        if (this._resizeState === null)
                            return;
                        var columnCount = realizedColumns.length;
                        var hierarchyNavigator = this.owner.owner.hierarchyNavigator;
                        // Only iterate over the columns that belong to column hierachy (i.e. skip the row hierarchy rows)
                        // as this post-rendering adjustment only applies to them.
                        var startIndex = this.otherLayoutManager.dimension.getDepth();
                        for (var i = startIndex; i < columnCount; i++) {
                            var column = realizedColumns[i];
                            if (!column.columnHeaderOrCornerEquals(this._resizeState.itemType, this._resizeState.item, column.itemType, column.getLeafItem(), hierarchyNavigator))
                                continue;
                            if (column !== this._resizeState.column) {
                                this._resizeState.column = column;
                                column.onResize(this._resizeState.getNewSize());
                                break;
                            }
                        }
                    };
                    ColumnLayoutManager.prototype.performResizing = function () {
                        if (this._resizeState === null)
                            return;
                        this._resizeState.animationFrame = null;
                        var newSize = this._resizeState.getNewSize();
                        this._resizeState.column.onResize(newSize);
                        this.owner.owner.refresh(false);
                    };
                    ColumnLayoutManager.prototype.endResizing = function () {
                        if (this._resizeState === null)
                            return;
                        var newSize = this._resizeState.getNewSize();
                        this._resizeState.column.onResizeEnd(newSize);
                    };
                    /**
                     * Sends column related data (pixel size, column count, etc) to TablixControl.
                     */
                    ColumnLayoutManager.prototype._sendDimensionsToControl = function () {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale(); // in case of canvas we have to convert the size from device pixel to css pixel
                        this.owner.owner.updateColumnDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, this.getViewSize(gridContextualWidth));
                    };
                    ColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    ColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        debug.assertFail("PureVirtualMethod: ColumnLayoutManager.getEstimatedBodyCellWidth");
                        return -1;
                    };
                    ColumnLayoutManager.minColumnWidth = 10;
                    return ColumnLayoutManager;
                }(DimensionLayoutManager));
                internal.ColumnLayoutManager = ColumnLayoutManager;
                var DashboardColumnLayoutManager = (function (_super) {
                    __extends(DashboardColumnLayoutManager, _super);
                    function DashboardColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    DashboardColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        if (this.ignoreColumn(headerIndex))
                            return 0;
                        // for dashboard layout it does not matter whether we pass an actual cell or not
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        // for dashboard layout it does not matter whether we pass an actual cell or not
                        return this.owner.getCellWidth(undefined);
                    };
                    DashboardColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return false;
                    };
                    DashboardColumnLayoutManager.prototype._calculateSize = function (item) {
                        var headerIndex = item.getIndex(this._grid);
                        var computedSize = 0;
                        if (!this.ignoreColumn(headerIndex)) {
                            // for dashboard layout it does not matter whether we pass an actual cell or not
                            computedSize = this.owner.getContentWidth(undefined);
                        }
                        item.onResize(computedSize);
                        item.onResizeEnd(computedSize);
                        return computedSize;
                    };
                    DashboardColumnLayoutManager.prototype.ignoreColumn = function (headerIndex) {
                        // On the dashboard, we need to return 0 if the row header is static
                        // (a table or a matrix without row groups)
                        return headerIndex === 0 && !this.owner.binder.hasRowGroups();
                    };
                    return DashboardColumnLayoutManager;
                }(ColumnLayoutManager));
                internal.DashboardColumnLayoutManager = DashboardColumnLayoutManager;
                var CanvasColumnLayoutManager = (function (_super) {
                    __extends(CanvasColumnLayoutManager, _super);
                    function CanvasColumnLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    CanvasColumnLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        // On the canvas the header width depends on the size of the content
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasColumnLayoutManager.prototype.getEstimatedBodyCellWidth = function (content) {
                        return this.owner.getEstimatedTextWidth(content);
                    };
                    CanvasColumnLayoutManager.prototype.calculateContextualWidths = function () {
                        var items = this._getRealizedItems();
                        var columnWidths = [];
                        for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                            var item = items_1[_i];
                            if (this.measureEnabled)
                                item.setAligningContextualWidth(-1);
                            columnWidths.push(this._calculateSize(item));
                        }
                        // Save all column widths. Needed when user turns off auto-sizing for column widths.
                        this.owner.columnWidthsToPersist = columnWidths;
                    };
                    CanvasColumnLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) ||
                            (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) ||
                            powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasColumnLayoutManager.prototype._calculateSize = function (item) {
                        return item.calculateSize();
                    };
                    return CanvasColumnLayoutManager;
                }(ColumnLayoutManager));
                internal.CanvasColumnLayoutManager = CanvasColumnLayoutManager;
                var RowLayoutManager = (function (_super) {
                    __extends(RowLayoutManager, _super);
                    function RowLayoutManager(owner, grid, realizationManager) {
                        _super.call(this, owner, grid, realizationManager);
                        realizationManager.owner = this;
                    }
                    Object.defineProperty(RowLayoutManager.prototype, "dimension", {
                        get: function () {
                            return this.owner.owner.rowDimension;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.getGridScale = function () {
                        return this._grid._presenter.getScreenToCssRatioY();
                    };
                    Object.defineProperty(RowLayoutManager.prototype, "otherScrollbarContextualWidth", {
                        get: function () {
                            if (this.dimension.otherDimension.scrollbar.visible) {
                                return controls.HTMLElementUtils.getElementHeight(this.dimension.otherDimension.scrollbar.element);
                            }
                            return 0;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    RowLayoutManager.prototype.startScrollingSession = function () {
                        _super.prototype.startScrollingSession.call(this);
                    };
                    RowLayoutManager.prototype._getRealizedItems = function () {
                        if (!this._grid.realizedRows) {
                            this._grid.realizedRows = [];
                        }
                        return this._grid.realizedRows;
                    };
                    RowLayoutManager.prototype._moveElementsToBottom = function (moveFromIndex, count) {
                        this._grid.moveRowsToEnd(moveFromIndex, count);
                    };
                    RowLayoutManager.prototype._moveElementsToTop = function (moveToIndex, count) {
                        this._grid.moveRowsToStart(moveToIndex, count);
                    };
                    RowLayoutManager.prototype._requiresMeasure = function () {
                        // if the control is not scrolling in either dimension and the column dimension is not resizing or row dimension is scrolling and reaching the end while scrolling 
                        return (!this.isScrolling() && !this.otherLayoutManager.isScrolling() && !this.otherLayoutManager.isResizing())
                            || (this.isScrolling() && (this.dimension.getIntegerScrollOffset() + (this.getRealizedItemsCount() - this._gridOffset) >= this.dimension.getItemsCount()));
                    };
                    RowLayoutManager.prototype.getGridContextualWidth = function () {
                        return this._grid.getHeight();
                    };
                    RowLayoutManager.prototype.getFirstVisibleRow = function () {
                        return this._grid.realizedRows[this._gridOffset];
                    };
                    RowLayoutManager.prototype._isAutoSized = function () {
                        return this.owner.owner.autoSizeHeight;
                    };
                    RowLayoutManager.prototype.applyScrolling = function () {
                        var rowOffset = this.dimension.getFractionScrollOffset();
                        var firstVisibleRowHeight = 0;
                        if (rowOffset !== 0) {
                            var firstVisibleRow = this.getFirstVisibleRow();
                            if (firstVisibleRow) {
                                firstVisibleRowHeight = firstVisibleRow.getContextualWidth();
                                this.scroll(firstVisibleRow, firstVisibleRowHeight, rowOffset);
                            }
                        }
                    };
                    RowLayoutManager.prototype.scroll = function (firstVisibleRow, height, offset) {
                        this.scrollCells(firstVisibleRow._realizedRowHeaders, height, offset);
                        this.scrollCells(firstVisibleRow._realizedBodyCells, height, offset);
                    };
                    RowLayoutManager.prototype.scrollCells = function (cells, height, offset) {
                        var length = cells.length;
                        for (var i = 0; i < length; i++) {
                            cells[i].scrollVertically(height, offset);
                        }
                    };
                    RowLayoutManager.prototype.getFooterContextualWidth = function () {
                        if (this.owner.owner.rowDimension.hasFooter()) {
                            if (this.owner.grid.footerRow) {
                                return this.owner.grid.footerRow.getContextualWidth();
                            }
                        }
                        return 0;
                    };
                    RowLayoutManager.prototype.calculateContextualWidths = function () {
                        _super.prototype.calculateContextualWidths.call(this);
                        if (this.fixedSizeEnabled) {
                            var footerRow = this._grid.footerRow;
                            if (footerRow) {
                                this._calculateSize(footerRow);
                            }
                        }
                    };
                    RowLayoutManager.prototype.fixSizes = function () {
                        _super.prototype.fixSizes.call(this);
                        if (this.fixedSizeEnabled) {
                            if (this._grid.footerRow) {
                                this._grid.footerRow.fixSize();
                            }
                        }
                    };
                    /**
                     * Sends row related data (pixel size, column count, etc) to TablixControl.
                     */
                    RowLayoutManager.prototype._sendDimensionsToControl = function () {
                        var gridContextualWidth = this.getGridContextualWidth();
                        var widthToFill = this.getActualContextualWidth(gridContextualWidth);
                        var otherContextualHeight = this.getOtherHierarchyContextualHeight();
                        var scale = this.getGridScale();
                        this.owner.owner.updateRowDimensions(otherContextualHeight / scale, (widthToFill - otherContextualHeight) / scale, gridContextualWidth / scale, this.getViewSize(gridContextualWidth), (this._grid.footerRow ? this._grid.footerRow.getContextualWidth() / scale : 0));
                    };
                    RowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        debug.assertFail("PureVirtualMethod: RowLayoutManager.getEstimatedHeaderWidth");
                        return -1;
                    };
                    return RowLayoutManager;
                }(DimensionLayoutManager));
                internal.RowLayoutManager = RowLayoutManager;
                var DashboardRowLayoutManager = (function (_super) {
                    __extends(DashboardRowLayoutManager, _super);
                    function DashboardRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    DashboardRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        return this.getHeaderWidth(headerIndex);
                    };
                    DashboardRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return false;
                    };
                    DashboardRowLayoutManager.prototype._calculateSize = function (item) {
                        return item.calculateSize();
                    };
                    DashboardRowLayoutManager.prototype.getHeaderWidth = function (headerIndex) {
                        // On the dashboard, we need to return 0 if the row header is static
                        // (a table or a matrix without row groups)
                        if (headerIndex === 0 && !this.owner.binder.hasRowGroups())
                            return 0;
                        // for dashboard layout it does not matter whether we pass an actual text or not
                        return this.owner.getEstimatedTextWidth(undefined);
                    };
                    return DashboardRowLayoutManager;
                }(RowLayoutManager));
                internal.DashboardRowLayoutManager = DashboardRowLayoutManager;
                var CanvasRowLayoutManager = (function (_super) {
                    __extends(CanvasRowLayoutManager, _super);
                    function CanvasRowLayoutManager() {
                        _super.apply(this, arguments);
                    }
                    CanvasRowLayoutManager.prototype.getEstimatedHeaderWidth = function (label, headerIndex) {
                        // On the canvas the header width depends on the size of the content
                        return this.owner.getEstimatedTextWidth(label);
                    };
                    CanvasRowLayoutManager.prototype.canScroll = function (gridContextualWidth) {
                        return !powerbi.Double.equalWithPrecision(this.dimension.scrollOffset, 0, DimensionLayoutManager._scrollOffsetPrecision) ||
                            (((this.getRealizedItemsCount() - this._gridOffset) < this.dimension.getItemsCount()) && this._contextualWidthToFill > 0) ||
                            powerbi.Double.greaterWithPrecision(gridContextualWidth, this._contextualWidthToFill, DimensionLayoutManager._pixelPrecision);
                    };
                    CanvasRowLayoutManager.prototype._calculateSize = function (item) {
                        return item.calculateSize();
                    };
                    return CanvasRowLayoutManager;
                }(RowLayoutManager));
                internal.CanvasRowLayoutManager = CanvasRowLayoutManager;
                var TablixLayoutManager = (function () {
                    function TablixLayoutManager(binder, grid, columnLayoutManager, rowLayoutManager) {
                        this._allowHeaderResize = true;
                        this._binder = binder;
                        this._grid = grid;
                        this._columnLayoutManager = columnLayoutManager;
                        this._rowLayoutManager = rowLayoutManager;
                        this._columnWidthsToPersist = [];
                    }
                    TablixLayoutManager.prototype.initialize = function (owner) {
                        this._owner = owner;
                        this._container = owner.container;
                        this._gridHost = owner.contentHost;
                        this._footersHost = owner.footerHost;
                        this._grid.initialize(owner, this._gridHost, this._footersHost);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "owner", {
                        get: function () {
                            return this._owner;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "binder", {
                        get: function () {
                            return this._binder;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "columnWidthsToPersist", {
                        get: function () {
                            return this._columnWidthsToPersist;
                        },
                        set: function (columnWidths) {
                            this._columnWidthsToPersist = columnWidths;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.getTablixClassName = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getTablixClassName");
                        return null;
                    };
                    TablixLayoutManager.prototype.getLayoutKind = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getLayoutKind");
                        // TODO ckerer: this method should not be necessary when we are done refactoring!
                        return null;
                    };
                    TablixLayoutManager.prototype.getOrCreateColumnHeader = function (item, items, rowIndex, columnIndex) {
                        var hierarchyNav = this.owner.hierarchyNavigator;
                        var row = this._grid.getOrCreateRow(rowIndex);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        var isLeaf = hierarchyNav.isLeaf(item);
                        var cell = row.getOrCreateColumnHeader(column, this._columnLayoutManager.isScrollableHeader(item, items, columnIndex), isLeaf);
                        var rowIdx = hierarchyNav.getLevel(item);
                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
                        cell.position.row.isFirst = rowIdx === 0;
                        cell.position.row.isLast = isLeaf;
                        var colIdx = hierarchyNav.getIndex(item);
                        cell.position.column.index = cell.position.row.indexInSiblings = colIdx;
                        cell.position.column.isFirst = hierarchyNav.areAllParentsFirst(item, items);
                        cell.position.column.isLast = hierarchyNav.areAllParentsLast(item, items);
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateRowHeader = function (item, items, rowIndex, columnIndex) {
                        var hierarchyNav = this.owner.hierarchyNavigator;
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex);
                        var isLeaf = hierarchyNav.isLeaf(item);
                        var scrollable = this._rowLayoutManager.isScrollableHeader(item, items, rowIndex);
                        if (row.getRealizedCellCount() === 0) {
                            this.alignRowHeaderCells(item, row);
                        }
                        var cell = row.getOrCreateRowHeader(column, scrollable, hierarchyNav.isLeaf(item));
                        var rowIdx = hierarchyNav.getIndex(item);
                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
                        cell.position.row.isFirst = hierarchyNav.areAllParentsFirst(item, items);
                        cell.position.row.isLast = hierarchyNav.areAllParentsLast(item, items);
                        var colIdx = hierarchyNav.getLevel(item);
                        cell.position.column.index = cell.position.column.indexInSiblings = colIdx;
                        cell.position.column.isFirst = colIdx === 0;
                        cell.position.column.isLast = isLeaf;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateCornerCell = function (item, rowLevel, columnLevel) {
                        var row = this._grid.getOrCreateRow(columnLevel);
                        var column = this._grid.getOrCreateColumn(rowLevel);
                        var columnDepth = this._columnLayoutManager.dimension.getDepth();
                        var isLeaf = columnLevel === (columnDepth - 1);
                        var cell = row.getOrCreateCornerCell(column);
                        var rowIdx = columnLevel;
                        cell.position.row.index = cell.position.row.indexInSiblings = rowIdx;
                        cell.position.row.isFirst = rowIdx === 0;
                        cell.position.row.isLast = isLeaf;
                        var colIdx = rowLevel;
                        cell.position.column.index = cell.position.column.indexInSiblings = colIdx;
                        cell.position.column.isFirst = colIdx === 0;
                        cell.position.column.isLast = colIdx === this._rowLayoutManager.dimension.getDepth() - 1;
                        this.enableCellHorizontalResize(isLeaf, cell);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateBodyCell = function (cellItem, rowItem, rowItems, rowIndex, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateRow(rowIndex + this._rowLayoutManager._gridOffset);
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        if (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0) {
                            scrollable = true;
                        }
                        else {
                            scrollable = this._rowLayoutManager.isScrollableHeader(rowItem, rowItems, rowIndex);
                        }
                        var cell = row.getOrCreateBodyCell(column, scrollable);
                        cell.position = cellItem.position;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterBodyCell = function (cellItem, columnIndex) {
                        var scrollable;
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(columnIndex + this._columnLayoutManager._gridOffset);
                        scrollable = (row._realizedBodyCells.length === 0 && this._owner.columnDimension.getFractionScrollOffset() !== 0);
                        var cell = row.getOrCreateFooterBodyCell(column, scrollable);
                        cell.position = cellItem.position;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getOrCreateFooterRowHeader = function (item, items) {
                        var row = this._grid.getOrCreateFootersRow();
                        var column = this._grid.getOrCreateColumn(0);
                        //debug.assert(this.owner.hierarchyNavigator.isLeaf(item), "Leaf item expected");
                        var cell = row.getOrCreateFooterRowHeader(column);
                        cell.position = undefined;
                        cell.enableHorizontalResize(false, this._columnLayoutManager);
                        return cell;
                    };
                    TablixLayoutManager.prototype.getVisibleWidth = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getVisibleHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getVisibleHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateColumnCount");
                    };
                    TablixLayoutManager.prototype.updateViewport = function (viewport) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.updateViewport");
                    };
                    TablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedRowHeight");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getCellWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getCellWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.getContentWidth = function (cell) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getContentWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.adjustContentSize = function (hasImage) {
                        // default implementation has no adjustment
                    };
                    /**
                     * This call makes room for parent header cells where neccessary.
                     * Since HTML cells that span vertically displace other rows,
                     * room has to be made for spanning headers that leave an exiting
                     * row to enter the new row that it starts from and removed when
                     * returning to an entering row.
                     */
                    TablixLayoutManager.prototype.alignRowHeaderCells = function (item, currentRow) {
                        var index = currentRow.getRowHeaderLeafIndex();
                        if (index === -1) {
                            return;
                        }
                        var rowDimension = this._owner.rowDimension;
                        var leaf = rowDimension.getFirstVisibleChildLeaf(item);
                        if (!this.owner.hierarchyNavigator.headerItemEquals(leaf, currentRow.getAllocatedCellAt(index).item)) {
                            return;
                        }
                        currentRow.moveCellsBy(this.owner.hierarchyNavigator.getLevel(leaf) - this.owner.hierarchyNavigator.getLevel(item) - index);
                    };
                    Object.defineProperty(TablixLayoutManager.prototype, "grid", {
                        get: function () {
                            return this._grid;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "rowLayoutManager", {
                        get: function () {
                            return this._rowLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TablixLayoutManager.prototype, "columnLayoutManager", {
                        get: function () {
                            return this._columnLayoutManager;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    TablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.showEmptySpaceHeader");
                        return false;
                    };
                    TablixLayoutManager.prototype.onStartRenderingSession = function (scrollingDimension, parentElement, clear) {
                        if (this.showEmptySpaceHeader()) {
                            var cell = this._grid.emptySpaceHeaderCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceHeaderCell(cell);
                            }
                            cell = this._grid.emptySpaceFooterCell;
                            if (cell) {
                                this._binder.unbindEmptySpaceFooterCell(cell);
                            }
                            this._grid.HideEmptySpaceCells();
                        }
                        this._scrollingDimension = scrollingDimension;
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.startScrollingSession();
                        }
                        this._rowLayoutManager.onStartRenderingSession();
                        this._columnLayoutManager.onStartRenderingSession();
                        this._grid.onStartRenderingSession(clear);
                        var measureEnabled = this._columnLayoutManager.measureEnabled || this._rowLayoutManager.measureEnabled;
                        if (measureEnabled)
                            this.measureSampleText(parentElement);
                    };
                    TablixLayoutManager.prototype.onEndRenderingSession = function () {
                        this._rowLayoutManager.onEndRenderingSession();
                        this._columnLayoutManager.onEndRenderingSession();
                        if (this._scrollingDimension) {
                            this._scrollingDimension.layoutManager.endScrollingSession();
                        }
                        this._scrollingDimension = null;
                        if (this.showEmptySpaceHeader()) {
                            var emptySpace = this._columnLayoutManager.contextualWidthToFill - this._columnLayoutManager.getGridContextualWidth();
                            if (emptySpace > 0) {
                                this._grid.ShowEmptySpaceCells(this._owner.columnDimension.getDepth(), emptySpace);
                                var cell = this._grid.emptySpaceHeaderCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceHeaderCell(cell);
                                }
                                cell = this._grid.emptySpaceFooterCell;
                                if (cell) {
                                    this._binder.bindEmptySpaceFooterCell(cell);
                                }
                            }
                        }
                    };
                    TablixLayoutManager.prototype.onStartRenderingIteration = function (clear) {
                        this._rowLayoutManager.onStartRenderingIteration(clear, this.getVisibleHeight());
                        this._columnLayoutManager.onStartRenderingIteration(clear, this.getVisibleWidth());
                        this._grid.onStartRenderingIteration();
                    };
                    TablixLayoutManager.prototype.onEndRenderingIteration = function () {
                        this._grid.onEndRenderingIteration();
                        // ANDREMI: Comment out for static tablix
                        this._columnLayoutManager.calculateSizes(); // calculate the entire grid first without altering the tree to avoid multiple measure pass invoking
                        this._rowLayoutManager.calculateSizes();
                        this._columnLayoutManager.fixSizes(); // now assign the sizes
                        this._rowLayoutManager.fixSizes();
                        this._columnLayoutManager.updateItemToResizeState(this._grid.realizedColumns); // if we are in a middle of a resize, the column to resize might have been swaped during the render, restore its resize state
                        this._columnLayoutManager.applyScrolling();
                        this._rowLayoutManager.applyScrolling();
                        this._columnLayoutManager.onEndRenderingIteration();
                        this._rowLayoutManager.onEndRenderingIteration();
                        return this._columnLayoutManager.done && this._rowLayoutManager.done;
                    };
                    TablixLayoutManager.prototype.onCornerCellRealized = function (item, cell) {
                        var columnLeaf = this.owner.hierarchyNavigator.isColumnHierarchyLeaf(item);
                        var rowLeaf = this.owner.hierarchyNavigator.isRowHierarchyLeaf(item);
                        if (columnLeaf)
                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onCornerCellRealized(item, cell, columnLeaf);
                        this._rowLayoutManager.onCornerCellRealized(item, cell, rowLeaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderRealized = function (item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        var tablixCell = cell;
                        if (tablixCell.colSpan > 1)
                            tablixCell.setContainerWidth(-1);
                        this._rowLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onRowHeaderFooterRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.onColumnHeaderRealized = function (item, cell) {
                        var hierarchyNavigator = this._owner.hierarchyNavigator;
                        var leaf = hierarchyNavigator.isLeaf(item);
                        if (leaf)
                            cell._column.OnLeafRealized(this._owner.hierarchyNavigator);
                        this._columnLayoutManager.onHeaderRealized(item, cell, leaf);
                    };
                    TablixLayoutManager.prototype.onBodyCellRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.onBodyCellFooterRealized = function (item, cell) {
                    };
                    TablixLayoutManager.prototype.setAllowHeaderResize = function (value) {
                        this._allowHeaderResize = value;
                    };
                    TablixLayoutManager.prototype.enableCellHorizontalResize = function (isLeaf, cell) {
                        var enableCellHorizontalResize = isLeaf && this._allowHeaderResize;
                        cell.enableHorizontalResize(enableCellHorizontalResize, this._columnLayoutManager);
                    };
                    TablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.getEstimatedTextWidth");
                        return -1;
                    };
                    TablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        debug.assertFail("PureVirtualMethod: TablixLayoutManager.measureSampleText");
                    };
                    return TablixLayoutManager;
                }());
                internal.TablixLayoutManager = TablixLayoutManager;
                var DashboardTablixLayoutManager = (function (_super) {
                    __extends(DashboardTablixLayoutManager, _super);
                    function DashboardTablixLayoutManager(binder, sizeComputationManager, grid, rowRealizationManager, columnRealizationManager) {
                        var dashboardColumnLayoutManager = new DashboardColumnLayoutManager(null, grid, columnRealizationManager);
                        var dashboardRowLayoutManager = new DashboardRowLayoutManager(null, grid, rowRealizationManager);
                        _super.call(this, binder, grid, dashboardColumnLayoutManager, dashboardRowLayoutManager);
                        dashboardColumnLayoutManager.owner = this;
                        dashboardRowLayoutManager.owner = this;
                        this._sizeComputationManager = sizeComputationManager;
                    }
                    DashboardTablixLayoutManager.createLayoutManager = function (binder) {
                        // computed sizes are shared between layout manager and grid presenter
                        var sizeComputationManager = new SizeComputationManager();
                        return new DashboardTablixLayoutManager(binder, sizeComputationManager, new internal.TablixGrid(new internal.DashboardTablixGridPresenter(sizeComputationManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    DashboardTablixLayoutManager.prototype.getTablixClassName = function () {
                        return "tablixDashboard";
                    };
                    DashboardTablixLayoutManager.prototype.getLayoutKind = function () {
                        return 1 /* DashboardTile */;
                    };
                    DashboardTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        return false;
                    };
                    DashboardTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        var textProperties = powerbi.TextMeasurementService.getSvgMeasurementProperties(parentElement);
                        this._characterHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                        this._sizeComputationManager.updateRowHeight(this._characterHeight);
                        var actualTextSize = PixelConverter.toPoint(parseFloat(textProperties.fontSize));
                        var scalingFactor = actualTextSize / controls.TablixDefaultTextSize;
                        this._sizeComputationManager.updateScalingFactor(powerbi.Double.toIncrement(scalingFactor, 0.05));
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleWidth = function () {
                        return this._sizeComputationManager.visibleWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getVisibleHeight = function () {
                        return this._sizeComputationManager.visibleHeight;
                    };
                    DashboardTablixLayoutManager.prototype.getCellWidth = function (cell) {
                        return this._sizeComputationManager.cellWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getContentWidth = function (cell) {
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedTextWidth = function (label) {
                        // On the dashboard it does not matter what text we render, 
                        // we always use the same content width
                        return this._sizeComputationManager.contentWidth;
                    };
                    DashboardTablixLayoutManager.prototype.adjustContentSize = function (hasImage) {
                        this._sizeComputationManager.hasImageContent = hasImage;
                    };
                    DashboardTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        // The total number of columns is the number (depth) of row groups + the number of (leaf) column group instances
                        var rowDimensionDepth = rowDimension ? rowDimension.getDepth() : 0;
                        var columnInstances = columnDimension ? columnDimension.getItemsCount() : 0;
                        var totalColumnCount = rowDimensionDepth + columnInstances;
                        // Adjust the column count by the static row header (if any)
                        if (!this.binder.hasRowGroups())
                            totalColumnCount--;
                        this._sizeComputationManager.updateColumnCount(totalColumnCount);
                    };
                    DashboardTablixLayoutManager.prototype.updateViewport = function (viewport) {
                        this._sizeComputationManager.updateViewport(viewport);
                    };
                    DashboardTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        return this._characterHeight;
                    };
                    return DashboardTablixLayoutManager;
                }(TablixLayoutManager));
                internal.DashboardTablixLayoutManager = DashboardTablixLayoutManager;
                var CanvasTablixLayoutManager = (function (_super) {
                    __extends(CanvasTablixLayoutManager, _super);
                    function CanvasTablixLayoutManager(binder, grid, rowRealizationManager, columnRealizationManager) {
                        var canvasColumnLayoutManager = new CanvasColumnLayoutManager(null, grid, columnRealizationManager);
                        var canvasRowLayoutManager = new CanvasRowLayoutManager(null, grid, rowRealizationManager);
                        _super.call(this, binder, grid, canvasColumnLayoutManager, canvasRowLayoutManager);
                        canvasColumnLayoutManager.owner = this;
                        canvasRowLayoutManager.owner = this;
                    }
                    CanvasTablixLayoutManager.createLayoutManager = function (binder, columnWidthManager) {
                        return new CanvasTablixLayoutManager(binder, new internal.TablixGrid(new controls.internal.CanvasTablixGridPresenter(columnWidthManager)), new internal.RowRealizationManager(binder), new internal.ColumnRealizationManager(binder));
                    };
                    CanvasTablixLayoutManager.prototype.getTablixClassName = function () {
                        return "tablixCanvas";
                    };
                    CanvasTablixLayoutManager.prototype.getLayoutKind = function () {
                        return 0 /* Canvas */;
                    };
                    CanvasTablixLayoutManager.prototype.measureSampleText = function (parentElement) {
                        // TODO: Use TextMeasurementService once the DOM methods are fixed (they are not working right now)
                        var textDiv = controls.internal.TablixUtils.createDiv();
                        textDiv.style.cssFloat = 'left';
                        textDiv.style.whiteSpace = 'nowrap';
                        textDiv.style.overflow = 'hidden';
                        textDiv.style.lineHeight = 'normal';
                        parentElement.appendChild(textDiv);
                        var textNode = document.createTextNode("a");
                        textDiv.appendChild(textNode);
                        this.characterWidth = controls.HTMLElementUtils.getElementWidth(textDiv);
                        this.characterHeight = controls.HTMLElementUtils.getElementHeight(textDiv);
                        textDiv.removeChild(textNode);
                        parentElement.removeChild(textDiv);
                    };
                    CanvasTablixLayoutManager.prototype.showEmptySpaceHeader = function () {
                        return !this._columnLayoutManager.fillProportionally;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleWidth = function () {
                        if (this._columnLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeWidth && this._owner.maxWidth) {
                                return this._owner.maxWidth;
                            }
                            else {
                                return controls.HTMLElementUtils.getElementWidth(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getVisibleHeight = function () {
                        if (this._rowLayoutManager.measureEnabled) {
                            if (this._owner.autoSizeHeight && this._owner.maxHeight) {
                                return this._owner.maxHeight;
                            }
                            else {
                                return controls.HTMLElementUtils.getElementHeight(this._container);
                            }
                        }
                        return -1;
                    };
                    CanvasTablixLayoutManager.prototype.getCellWidth = function (cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.tableCell);
                    };
                    CanvasTablixLayoutManager.prototype.getContentWidth = function (cell) {
                        return controls.HTMLElementUtils.getElementWidth(cell._presenter.contentElement);
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedTextWidth = function (text) {
                        return text ? text.length * this.characterWidth : 0;
                    };
                    CanvasTablixLayoutManager.prototype.updateColumnCount = function (rowDimension, columnDimension) {
                        // We currently only need to update model information when using dashboard layouts
                    };
                    CanvasTablixLayoutManager.prototype.updateViewport = function (viewport) {
                        // We currently only need to update model information when using dashboard layouts
                    };
                    CanvasTablixLayoutManager.prototype.getEstimatedRowHeight = function () {
                        return this.characterHeight;
                    };
                    return CanvasTablixLayoutManager;
                }(TablixLayoutManager));
                internal.CanvasTablixLayoutManager = CanvasTablixLayoutManager;
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var HTMLElementUtils;
            (function (HTMLElementUtils) {
                function clearChildren(element) {
                    if (!element) {
                        return;
                    }
                    while (element.hasChildNodes()) {
                        element.removeChild(element.firstChild);
                    }
                }
                HTMLElementUtils.clearChildren = clearChildren;
                function setElementTop(element, top) {
                    element.style.top = top + "px";
                }
                HTMLElementUtils.setElementTop = setElementTop;
                function setElementLeft(element, left) {
                    element.style.left = left + "px";
                }
                HTMLElementUtils.setElementLeft = setElementLeft;
                function setElementHeight(element, height) {
                    if (HTMLElementUtils.isAutoSize(height))
                        element.style.height = "";
                    else
                        element.style.height = height + "px";
                }
                HTMLElementUtils.setElementHeight = setElementHeight;
                function setElementWidth(element, width) {
                    if (HTMLElementUtils.isAutoSize(width))
                        element.style.width = "";
                    else
                        element.style.width = width + "px";
                }
                HTMLElementUtils.setElementWidth = setElementWidth;
                function getElementWidth(element) {
                    return element.offsetWidth;
                }
                HTMLElementUtils.getElementWidth = getElementWidth;
                function getElementHeight(element) {
                    return element.offsetHeight;
                }
                HTMLElementUtils.getElementHeight = getElementHeight;
                function isAutoSize(size) {
                    return size === -1;
                }
                HTMLElementUtils.isAutoSize = isAutoSize;
                function getAccumulatedScale(element) {
                    var scale = 1;
                    while (element) {
                        scale *= HTMLElementUtils.getScale(element);
                        element = element.parentElement;
                    }
                    return scale;
                }
                HTMLElementUtils.getAccumulatedScale = getAccumulatedScale;
                /**
                 * Get scale of element, return 1 when not scaled.
                 */
                function getScale(element) {
                    element = $(element);
                    var str = element.css('-webkit-transform') ||
                        element.css('-moz-transform') ||
                        element.css('-ms-transform') ||
                        element.css('-o-transform') ||
                        element.css('transform');
                    return (str && (str.match(/\d*\.\d*/) && Number(str.match(/\d*\.\d*/)[0]) ||
                        str.match(/\d+/) && Number(str.match(/\d+/)[0]))) || 1;
                }
                HTMLElementUtils.getScale = getScale;
            })(HTMLElementUtils = controls.HTMLElementUtils || (controls.HTMLElementUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var internal;
            (function (internal) {
                var DomFactory = InJs.DomFactory;
                var DataViewObjectDefinitions = powerbi.data.DataViewObjectDefinitions;
                var TablixObjects;
                (function (TablixObjects) {
                    TablixObjects.ObjectGeneral = "general";
                    TablixObjects.ObjectGrid = "grid";
                    TablixObjects.ObjectColumnHeaders = "columnHeaders";
                    TablixObjects.ObjectRowHeaders = "rowHeaders";
                    TablixObjects.ObjectValues = "values";
                    TablixObjects.ObjectTotal = "total";
                    TablixObjects.ObjectSubTotals = "subTotals";
                    /**
                     * Represents a DataViewObjects property related to the Tablix
                     */
                    var TablixProperty = (function () {
                        /**
                         * Creates a new TablixProperty
                         * @param {string} objectName Object Name
                         * @param {string} propertyName Property Name
                         * @param {any} defaultValue Default value of the Property
                         * @param {ObjectValueGetterFunction} getterFuntion Function used to get the Property value from the Objects
                         */
                        function TablixProperty(objectName, propertyName, defaultValue, getterFuntion) {
                            this.objectName = objectName;
                            this.propertyName = propertyName;
                            this.defaultValue = defaultValue;
                            this.getterFuntion = getterFuntion;
                        }
                        /**
                         * Gets the PropertyIdentifier for the Property
                         * @returns PropertyIdentifier for the Property
                         */
                        TablixProperty.prototype.getPropertyID = function () {
                            return { objectName: this.objectName, propertyName: this.propertyName };
                        };
                        /**
                         * Gets the value of the Property from the Objects
                         * @param {DataViewObjects} objects DataView Objects to get the value from
                         * @param {boolean} useDefault True to fall back to the Default value if the Property is missing from the objects. False to return undefined
                         * @returns Value of the property
                         */
                        TablixProperty.prototype.getValue = function (objects) {
                            // We use this when we intend to have undefined for missing properties. Useful in letting styles fallback to CSS if not defined
                            return this.getterFuntion(objects, this.getPropertyID(), this.defaultValue);
                        };
                        return TablixProperty;
                    }());
                    TablixObjects.TablixProperty = TablixProperty;
                    // Per Column
                    TablixObjects.PropColumnFormatString = new TablixProperty(TablixObjects.ObjectGeneral, 'formatString', undefined, powerbi.DataViewObjects.getValue);
                    // General
                    TablixObjects.PropGeneralAutoSizeColumns = new TablixProperty(TablixObjects.ObjectGeneral, 'autoSizeColumnWidth', true, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGeneralTextSize = new TablixProperty(TablixObjects.ObjectGeneral, 'textSize', 8, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGeneralTableTotals = new TablixProperty(TablixObjects.ObjectGeneral, 'totals', true, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGeneralMatrixRowSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, 'rowSubtotals', true, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGeneralMatrixColumnSubtotals = new TablixProperty(TablixObjects.ObjectGeneral, 'columnSubtotals', true, powerbi.DataViewObjects.getValue);
                    //Grid
                    TablixObjects.PropGridVertical = new TablixProperty(TablixObjects.ObjectGrid, 'gridVertical', false, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridVerticalColor = new TablixProperty(TablixObjects.ObjectGrid, 'gridVerticalColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridVerticalWeight = new TablixProperty(TablixObjects.ObjectGrid, 'gridVerticalWeight', 1, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridHorizontalTable = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontal', true, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridHorizontalMatrix = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontal', false, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridHorizontalColor = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontalColor', "#E8E8E8", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridHorizontalWeight = new TablixProperty(TablixObjects.ObjectGrid, 'gridHorizontalWeight', 1, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridRowPadding = new TablixProperty(TablixObjects.ObjectGrid, 'rowPadding', 0, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridOutlineColor = new TablixProperty(TablixObjects.ObjectGrid, 'outlineColor', "#CCC", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropGridOutlineWeight = new TablixProperty(TablixObjects.ObjectGrid, 'outlineWeight', 1, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropGridImageHeight = new TablixProperty(TablixObjects.ObjectGrid, 'imageHeight', 75, powerbi.DataViewObjects.getValue);
                    // Column Headers
                    TablixObjects.PropColumnsFontColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropColumnsBackColor = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropColumnsOutline = new TablixProperty(TablixObjects.ObjectColumnHeaders, 'outline', "BottomOnly", powerbi.DataViewObjects.getValue);
                    // Row Headers
                    TablixObjects.PropRowsFontColor = new TablixProperty(TablixObjects.ObjectRowHeaders, 'fontColor', "#666", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropRowsBackColor = new TablixProperty(TablixObjects.ObjectRowHeaders, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropRowsOutline = new TablixProperty(TablixObjects.ObjectRowHeaders, 'outline', "RightOnly", powerbi.DataViewObjects.getValue);
                    // Values
                    // VSTS 7167767: Remove temporary code for product demo.
                    TablixObjects.PropValuesBackColorConditionalFormatting = new TablixProperty(TablixObjects.ObjectValues, 'backgroundColorConditional', false, powerbi.DataViewObjects.getValue);
                    TablixObjects.PropValuesFontColorPrimary = new TablixProperty(TablixObjects.ObjectValues, 'fontColorPrimary', "#333", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesBackColorPrimary = new TablixProperty(TablixObjects.ObjectValues, 'backColorPrimary', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesFontColorSecondary = new TablixProperty(TablixObjects.ObjectValues, 'fontColorSecondary', "#333", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesBackColorSecondary = new TablixProperty(TablixObjects.ObjectValues, 'backColorSecondary', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropValuesOutline = new TablixProperty(TablixObjects.ObjectValues, 'outline', "None", powerbi.DataViewObjects.getValue);
                    TablixObjects.PropValuesUrlIconProp = new TablixProperty(TablixObjects.ObjectValues, 'urlIcon', false, powerbi.DataViewObjects.getValue);
                    // Total
                    TablixObjects.PropTotalFontColor = new TablixProperty(TablixObjects.ObjectTotal, 'fontColor', "#333", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropTotalBackColor = new TablixProperty(TablixObjects.ObjectTotal, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropTotalOutline = new TablixProperty(TablixObjects.ObjectTotal, 'outline', "TopOnly", powerbi.DataViewObjects.getValue);
                    // SubTotals
                    TablixObjects.PropSubTotalsFontColor = new TablixProperty(TablixObjects.ObjectSubTotals, 'fontColor', "#333", powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropSubTotalsBackColor = new TablixProperty(TablixObjects.ObjectSubTotals, 'backColor', undefined, powerbi.DataViewObjects.getFillColor);
                    TablixObjects.PropSubTotalsOutline = new TablixProperty(TablixObjects.ObjectSubTotals, 'outline', "TopOnly", powerbi.DataViewObjects.getValue);
                    /**
                     * Get the DataViewObject from the DataView
                     * @param {DataView} dataview The DataView
                     * @returns DataViewObjects (dataView.metadata.objects)
                     */
                    function getMetadadataObjects(dataview) {
                        if (dataview && dataview.metadata)
                            return dataview.metadata.objects;
                        return null;
                    }
                    TablixObjects.getMetadadataObjects = getMetadadataObjects;
                    function enumerateObjectInstances(options, enumeration, dataView, isConditionalFormattingEnabled, tablixType) {
                        debug.assertValue(dataView, "dataView can't be undefined");
                        var objects = getMetadadataObjects(dataView);
                        var totalsShown = true;
                        if (tablixType === controls.TablixType.Table) {
                            totalsShown = shouldShowTableTotalsOption(dataView) && shouldShowTableTotals(objects);
                        }
                        else {
                            totalsShown =
                                (shouldShowColumnSubtotalsOption(dataView) && shouldShowColumnSubtotals(objects)) ||
                                    (shouldShowRowSubtotalsOption(dataView) && shouldShowRowSubtotals(objects));
                        }
                        switch (options.objectName) {
                            case TablixObjects.ObjectGeneral:
                                enumerateGeneralOptions(enumeration, objects, tablixType, dataView);
                                break;
                            case TablixObjects.ObjectGrid:
                                enumerateGridOptions(enumeration, objects, tablixType);
                                break;
                            case TablixObjects.ObjectColumnHeaders:
                                enumerateColumnHeadersOptions(enumeration, objects);
                                break;
                            case TablixObjects.ObjectRowHeaders:
                                enumerateRowHeadersOptions(enumeration, objects);
                                break;
                            case TablixObjects.ObjectValues:
                                enumerateValuesOptions(enumeration, objects, tablixType);
                                if (tablixType === controls.TablixType.Table && isConditionalFormattingEnabled)
                                    enumerateValuesOptionConditionalFormat(enumeration, objects);
                                break;
                            case TablixObjects.ObjectTotal:
                                if (totalsShown)
                                    enumerateTotalOptions(enumeration, objects);
                                break;
                            case TablixObjects.ObjectSubTotals:
                                if (totalsShown)
                                    enumerateSubTotalsOptions(enumeration, objects);
                                break;
                            default:
                                break;
                        }
                    }
                    TablixObjects.enumerateObjectInstances = enumerateObjectInstances;
                    function enumerateGeneralOptions(enumeration, objects, tablixType, dataView) {
                        var visualObjectinstance = {
                            selector: null,
                            objectName: TablixObjects.ObjectGeneral,
                            properties: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                            }
                        };
                        var properties = visualObjectinstance.properties;
                        // Total and SubTotals
                        switch (tablixType) {
                            case controls.TablixType.Table:
                                if (shouldShowTableTotalsOption(dataView))
                                    properties[TablixObjects.PropGeneralTableTotals.propertyName] = shouldShowTableTotals(objects);
                                break;
                            case controls.TablixType.Matrix:
                                if (shouldShowRowSubtotalsOption(dataView))
                                    properties[TablixObjects.PropGeneralMatrixRowSubtotals.propertyName] = shouldShowRowSubtotals(objects);
                                if (shouldShowColumnSubtotalsOption(dataView))
                                    properties[TablixObjects.PropGeneralMatrixColumnSubtotals.propertyName] = shouldShowColumnSubtotals(objects);
                                break;
                        }
                        enumeration.pushInstance(visualObjectinstance);
                    }
                    TablixObjects.enumerateGeneralOptions = enumerateGeneralOptions;
                    function enumerateGridOptions(enumeration, objects, tablixType) {
                        var visualObjectinstance = {
                            selector: null,
                            objectName: TablixObjects.ObjectGeneral,
                            properties: {}
                        };
                        var properties = visualObjectinstance.properties;
                        // Vertical Grid
                        var verticalGridEnabled = TablixObjects.PropGridVertical.getValue(objects);
                        properties[TablixObjects.PropGridVertical.propertyName] = verticalGridEnabled;
                        if (verticalGridEnabled) {
                            properties[TablixObjects.PropGridVerticalColor.propertyName] = TablixObjects.PropGridVerticalColor.getValue(objects);
                            properties[TablixObjects.PropGridVerticalWeight.propertyName] = TablixObjects.PropGridVerticalWeight.getValue(objects);
                        }
                        // Horizontal Grid
                        var horizontalGridEnabled = (tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).getValue(objects);
                        properties[(tablixType === controls.TablixType.Table ? TablixObjects.PropGridHorizontalTable : TablixObjects.PropGridHorizontalMatrix).propertyName] = horizontalGridEnabled;
                        if (horizontalGridEnabled) {
                            properties[TablixObjects.PropGridHorizontalColor.propertyName] = TablixObjects.PropGridHorizontalColor.getValue(objects);
                            properties[TablixObjects.PropGridHorizontalWeight.propertyName] = TablixObjects.PropGridHorizontalWeight.getValue(objects);
                        }
                        // Row Padding
                        properties[TablixObjects.PropGridRowPadding.propertyName] = TablixObjects.PropGridRowPadding.getValue(objects);
                        // Outline
                        properties[TablixObjects.PropGridOutlineColor.propertyName] = TablixObjects.PropGridOutlineColor.getValue(objects);
                        properties[TablixObjects.PropGridOutlineWeight.propertyName] = TablixObjects.PropGridOutlineWeight.getValue(objects);
                        // Image Height
                        properties[TablixObjects.PropGridImageHeight.propertyName] = TablixObjects.PropGridImageHeight.getValue(objects);
                        enumeration.pushInstance(visualObjectinstance);
                    }
                    TablixObjects.enumerateGridOptions = enumerateGridOptions;
                    function enumerateColumnHeadersOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectColumnHeaders,
                            properties: {
                                fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                                backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                                outline: TablixObjects.PropColumnsOutline.getValue(objects),
                            }
                        });
                    }
                    TablixObjects.enumerateColumnHeadersOptions = enumerateColumnHeadersOptions;
                    function enumerateRowHeadersOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectRowHeaders,
                            properties: {
                                fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
                                backColor: TablixObjects.PropRowsBackColor.getValue(objects),
                                outline: TablixObjects.PropRowsOutline.getValue(objects),
                            }
                        });
                    }
                    TablixObjects.enumerateRowHeadersOptions = enumerateRowHeadersOptions;
                    function enumerateValuesOptions(enumeration, objects, tablixType) {
                        var instance = {
                            selector: null,
                            objectName: TablixObjects.ObjectValues,
                            properties: {
                                fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                                backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                                fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                                backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                                outline: TablixObjects.PropValuesOutline.getValue(objects),
                            }
                        };
                        if (tablixType === controls.TablixType.Table)
                            instance.properties[TablixObjects.PropValuesUrlIconProp.propertyName] = TablixObjects.PropValuesUrlIconProp.getValue(objects);
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateValuesOptions = enumerateValuesOptions;
                    // TODO: VSTS 7167767: Remove temporary code for product demo.
                    function enumerateValuesOptionConditionalFormat(enumeration, objects) {
                        var instance = {
                            selector: null,
                            objectName: TablixObjects.ObjectValues,
                            properties: {
                                backgroundColorConditional: TablixObjects.PropValuesBackColorConditionalFormatting.getValue(objects),
                            }
                        };
                        enumeration.pushInstance(instance);
                    }
                    TablixObjects.enumerateValuesOptionConditionalFormat = enumerateValuesOptionConditionalFormat;
                    function enumerateTotalOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectTotal,
                            properties: {
                                fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
                                backColor: TablixObjects.PropTotalBackColor.getValue(objects),
                                outline: TablixObjects.PropTotalOutline.getValue(objects),
                            }
                        });
                    }
                    TablixObjects.enumerateTotalOptions = enumerateTotalOptions;
                    function enumerateSubTotalsOptions(enumeration, objects) {
                        enumeration.pushInstance({
                            selector: null,
                            objectName: TablixObjects.ObjectSubTotals,
                            properties: {
                                fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
                                backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects),
                            }
                        });
                    }
                    TablixObjects.enumerateSubTotalsOptions = enumerateSubTotalsOptions;
                    function getTableObjects(dataView, isConditionalFormattingEnabled) {
                        var objects = getMetadadataObjects(dataView);
                        var formattingProperties = {
                            // TODO: VSTS 7167767: Remove temporary code for product demo.
                            isConditionalFormattingEnabled: isConditionalFormattingEnabled,
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                                totals: shouldShowTableTotals(objects),
                            },
                        };
                        formattingProperties.grid = {
                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                            gridHorizontal: TablixObjects.PropGridHorizontalTable.getValue(objects),
                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
                            imageHeight: TablixObjects.PropGridImageHeight.getValue(objects),
                        };
                        formattingProperties.columnHeaders = {
                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                            outline: TablixObjects.PropColumnsOutline.getValue(objects),
                        };
                        formattingProperties.values = {
                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                            outline: TablixObjects.PropValuesOutline.getValue(objects),
                            urlIcon: TablixObjects.PropValuesUrlIconProp.getValue(objects),
                        };
                        if (isConditionalFormattingEnabled) {
                            formattingProperties.values.conditionalFormatting = TablixObjects.PropValuesBackColorConditionalFormatting.getValue(objects);
                        }
                        formattingProperties.total = {
                            fontColor: TablixObjects.PropTotalFontColor.getValue(objects),
                            backColor: TablixObjects.PropTotalBackColor.getValue(objects),
                            outline: TablixObjects.PropTotalOutline.getValue(objects),
                        };
                        return formattingProperties;
                    }
                    TablixObjects.getTableObjects = getTableObjects;
                    // TODO: VSTS 7167767: Remove temporary code for product demo.
                    function getTableObjectConditionalFormatEnabled(dataView) {
                        return TablixObjects.PropValuesBackColorConditionalFormatting.getValue(getMetadadataObjects(dataView));
                    }
                    TablixObjects.getTableObjectConditionalFormatEnabled = getTableObjectConditionalFormatEnabled;
                    function getMatrixObjects(dataView) {
                        var objects = getMetadadataObjects(dataView);
                        var formattingProperties = {
                            general: {
                                autoSizeColumnWidth: TablixObjects.PropGeneralAutoSizeColumns.getValue(objects),
                                textSize: TablixObjects.PropGeneralTextSize.getValue(objects),
                                rowSubtotals: shouldShowRowSubtotals(objects),
                                columnSubtotals: shouldShowColumnSubtotals(objects),
                            },
                        };
                        formattingProperties.grid = {
                            gridVertical: TablixObjects.PropGridVertical.getValue(objects),
                            gridVerticalColor: TablixObjects.PropGridVerticalColor.getValue(objects),
                            gridVerticalWeight: TablixObjects.PropGridVerticalWeight.getValue(objects),
                            gridHorizontal: TablixObjects.PropGridHorizontalMatrix.getValue(objects),
                            gridHorizontalColor: TablixObjects.PropGridHorizontalColor.getValue(objects),
                            gridHorizontalWeight: TablixObjects.PropGridHorizontalWeight.getValue(objects),
                            outlineColor: TablixObjects.PropGridOutlineColor.getValue(objects),
                            outlineWeight: TablixObjects.PropGridOutlineWeight.getValue(objects),
                            rowPadding: TablixObjects.PropGridRowPadding.getValue(objects),
                            imageHeight: TablixObjects.PropGridImageHeight.getValue(objects),
                        };
                        formattingProperties.columnHeaders = {
                            fontColor: TablixObjects.PropColumnsFontColor.getValue(objects),
                            backColor: TablixObjects.PropColumnsBackColor.getValue(objects),
                            outline: TablixObjects.PropColumnsOutline.getValue(objects),
                        };
                        formattingProperties.rowHeaders = {
                            fontColor: TablixObjects.PropRowsFontColor.getValue(objects),
                            backColor: TablixObjects.PropRowsBackColor.getValue(objects),
                            outline: TablixObjects.PropRowsOutline.getValue(objects),
                        };
                        formattingProperties.values = {
                            fontColorPrimary: TablixObjects.PropValuesFontColorPrimary.getValue(objects),
                            backColorPrimary: TablixObjects.PropValuesBackColorPrimary.getValue(objects),
                            fontColorSecondary: TablixObjects.PropValuesFontColorSecondary.getValue(objects),
                            backColorSecondary: TablixObjects.PropValuesBackColorSecondary.getValue(objects),
                            outline: TablixObjects.PropValuesOutline.getValue(objects),
                        };
                        formattingProperties.subtotals = {
                            fontColor: TablixObjects.PropSubTotalsFontColor.getValue(objects),
                            backColor: TablixObjects.PropSubTotalsBackColor.getValue(objects),
                            outline: TablixObjects.PropSubTotalsOutline.getValue(objects),
                        };
                        return formattingProperties;
                    }
                    TablixObjects.getMatrixObjects = getMatrixObjects;
                    /**
                     * Generate default objects for the Table/Matrix to set default styling
                     * @param {TablixType} tablixType Tablix Type: table | matrix
                     * @returns DataViewObjects that can be attached to the DataViewMetadata
                     */
                    function generateTablixDefaultObjects(tablixType) {
                        return {
                            general: [{
                                    selector: null,
                                    properties: {
                                        textSize: DataViewObjectDefinitions.encodePropertyValue(12, { numeric: true }),
                                        totals: DataViewObjectDefinitions.encodePropertyValue(false, { bool: true }),
                                    }
                                }],
                        };
                    }
                    TablixObjects.generateTablixDefaultObjects = generateTablixDefaultObjects;
                    function getTextSizeInPx(textSize) {
                        return jsCommon.PixelConverter.fromPoint(textSize);
                    }
                    TablixObjects.getTextSizeInPx = getTextSizeInPx;
                    function shouldShowTableTotals(objects) {
                        return TablixObjects.PropGeneralTableTotals.getValue(objects);
                    }
                    TablixObjects.shouldShowTableTotals = shouldShowTableTotals;
                    function shouldShowTableTotalsOption(dataView) {
                        if (dataView && dataView.table && !_.isEmpty(dataView.table.columns)) {
                            var columns = dataView.table.columns;
                            if (_.some(columns, function (column) { return column.discourageAggregationAcrossGroups; }))
                                return false;
                        }
                        return true;
                    }
                    function shouldShowRowSubtotals(objects) {
                        return TablixObjects.PropGeneralMatrixRowSubtotals.getValue(objects);
                    }
                    TablixObjects.shouldShowRowSubtotals = shouldShowRowSubtotals;
                    function shouldShowRowSubtotalsOption(dataView) {
                        return !(dataView &&
                            dataView.matrix &&
                            dataView.matrix.rows &&
                            isDiscourageAggregationAcrossGroups(dataView.matrix.rows.levels));
                    }
                    function shouldShowColumnSubtotals(objects) {
                        return TablixObjects.PropGeneralMatrixColumnSubtotals.getValue(objects);
                    }
                    TablixObjects.shouldShowColumnSubtotals = shouldShowColumnSubtotals;
                    function shouldShowColumnSubtotalsOption(dataView) {
                        return !(dataView &&
                            dataView.matrix &&
                            dataView.matrix.columns &&
                            isDiscourageAggregationAcrossGroups(dataView.matrix.columns.levels));
                    }
                    TablixObjects.shouldShowColumnSubtotalsOption = shouldShowColumnSubtotalsOption;
                    function isDiscourageAggregationAcrossGroups(levels) {
                        var lastLevel = _.last(levels);
                        // If the last item is not Aggregatable, disable totals option since there will be no totals at all to display
                        // However, if the non-aggregatable filed is in the middle, there are totals showing up in matrix.
                        // Therefore, we still allow users to turn it off
                        return lastLevel && _.some(lastLevel.sources, function (source) { return source.discourageAggregationAcrossGroups; });
                    }
                    TablixObjects.isDiscourageAggregationAcrossGroups = isDiscourageAggregationAcrossGroups;
                })(TablixObjects = internal.TablixObjects || (internal.TablixObjects = {}));
                var TablixUtils;
                (function (TablixUtils) {
                    TablixUtils.CssClassTablixDiv = "tablixDiv"; // Any DIV inside the table (outer and inner)
                    TablixUtils.CssClassContentElement = "tablixCellContentElement"; // Outer DIV
                    TablixUtils.CssClassContentHost = "tablixCellContentHost"; // Inner DIV
                    TablixUtils.CssClassTablixHeader = "tablixHeader"; // Any Header in the Table/Matrix
                    TablixUtils.CssClassTablixColumnHeaderLeaf = "tablixColumnHeaderLeaf"; // Leaf Column Headers
                    TablixUtils.CssClassTablixValueNumeric = "tablixValueNumeric"; // Numeric cells, will also be applied to all Matrix body cells
                    TablixUtils.CssClassTablixValueTotal = "tablixValueTotal"; // Total cells,  will also be applied to subtotal Matrix body cells
                    TablixUtils.CssClassValueURLIcon = "powervisuals-glyph url-icon tablixUrlIconGlyph"; // Any <a> Tag
                    TablixUtils.CssClassValueURLIconContainer = "tablixValueUrlIcon"; // Container for the <a> tag
                    TablixUtils.CssClassMatrixRowHeaderLeaf = "matrixRowHeaderLeaf"; // Matrix Leaf Row Headers
                    TablixUtils.CssClassMatrixRowHeaderSubTotal = "matrixRowHeaderSubTotal"; // Matrix SubTotal Row Headers
                    TablixUtils.CssClassTableFooter = 'tableFooterCell'; // Any cell in the Footer area
                    TablixUtils.CssClassTableBodyCell = 'tableBodyCell'; // Any cell in the Table Body
                    TablixUtils.CssClassTableBodyCellBottom = 'tableBodyCellBottom'; // Bottom-Most Body cell
                    TablixUtils.StringNonBreakingSpace = '&nbsp;';
                    TablixUtils.UnitOfMeasurement = 'px';
                    var SortIconContainerClassName = "tablixSortIconContainer";
                    TablixUtils.CellPaddingLeft = 10;
                    TablixUtils.CellPaddingRight = 5;
                    TablixUtils.CellPaddingLeftMatrixTotal = 5;
                    TablixUtils.FontFamilyCell = "'Segoe UI','wf_segoe-ui_normal', helvetica, arial, sans-serif";
                    TablixUtils.FontFamilyHeader = "'Segoe UI','wf_segoe-ui_normal', helvetica, arial, sans-serif";
                    TablixUtils.FontFamilyTotal = "'Segoe UI Bold','wf_segoe-ui_bold', helvetica, arial, sans-serif";
                    TablixUtils.FontColorCells = "#333";
                    TablixUtils.FontColorHeaders = "#666";
                    var EdgeSettings = (function () {
                        function EdgeSettings(weight, color) {
                            this.applyParams(true, weight, color);
                        }
                        EdgeSettings.prototype.applyParams = function (shown, weight, color) {
                            if (shown) {
                                this.weight = weight == null ? 0 : weight;
                                this.color = color == null ? 'black' : color;
                            }
                            else {
                                this.weight = 0;
                                this.color = 'black';
                            }
                        };
                        EdgeSettings.prototype.getCSS = function () {
                            var css = [];
                            if (_.isNumber(this.weight)) {
                                css.push(this.weight + TablixUtils.UnitOfMeasurement);
                                if (this.color)
                                    css.push(this.color);
                                css.push('solid');
                            }
                            return css.join(' ');
                        };
                        return EdgeSettings;
                    }());
                    TablixUtils.EdgeSettings = EdgeSettings;
                    /**
                     * Style parameters for each Cell
                     */
                    var CellStyle = (function () {
                        function CellStyle() {
                            this.borders = {};
                            this.paddings = { top: 0, left: TablixUtils.CellPaddingLeft, bottom: 0, right: TablixUtils.CellPaddingRight };
                            // Initializing values with empty string would cause CSS attributes to not be set if they are undefined
                            this.fontFamily = "";
                            this.fontColor = "";
                            this.backColor = "";
                            this.hasImage = false;
                        }
                        /**
                         * Sets the Inline style for the Cell
                         * @param {ITablixCell} cell Cell to set style to
                         */
                        CellStyle.prototype.applyStyle = function (cell) {
                            var div = cell.extension.contentHost;
                            var style = div.style;
                            style.fontFamily = this.fontFamily;
                            style.color = this.fontColor;
                            style.backgroundColor = this.backColor;
                            /**
                             * We are setting the borders as inset shadow
                             * This way we can control how intersecting borders would look like when they have different colors
                             */
                            var borderShadow = [];
                            style.border = "none";
                            if (this.borders.left) {
                                borderShadow.push("inset " + this.borders.left.weight + TablixUtils.UnitOfMeasurement + " 0 0 0 " + this.borders.left.color);
                            }
                            if (this.borders.right) {
                                borderShadow.push("inset -" + this.borders.right.weight + TablixUtils.UnitOfMeasurement + " 0 0 0 " + this.borders.right.color);
                            }
                            if (this.borders.top) {
                                borderShadow.push("inset 0 " + this.borders.top.weight + TablixUtils.UnitOfMeasurement + " 0 0 " + this.borders.top.color);
                            }
                            if (this.borders.bottom) {
                                borderShadow.push("inset 0 -" + this.borders.bottom.weight + TablixUtils.UnitOfMeasurement + " 0 0 " + this.borders.bottom.color);
                            }
                            style.boxShadow = borderShadow.join(', ');
                            style.paddingTop = ((this.paddings.top == null ? 0 : this.paddings.top) + (this.borders.top == null ? 0 : this.borders.top.weight)) + TablixUtils.UnitOfMeasurement;
                            style.paddingRight = ((this.paddings.right == null ? TablixUtils.CellPaddingRight : this.paddings.right) + (this.borders.right == null ? 0 : this.borders.right.weight)) + TablixUtils.UnitOfMeasurement;
                            style.paddingBottom = ((this.paddings.bottom == null ? 0 : this.paddings.bottom) + (this.borders.bottom == null ? 0 : this.borders.bottom.weight)) + TablixUtils.UnitOfMeasurement;
                            style.paddingLeft = ((this.paddings.left == null ? TablixUtils.CellPaddingLeft : this.paddings.left) + (this.borders.left == null ? 0 : this.borders.left.weight)) + TablixUtils.UnitOfMeasurement;
                        };
                        CellStyle.prototype.getExtraTop = function () {
                            var extra = 0;
                            if (this.paddings.top)
                                extra += this.paddings.top;
                            if (this.borders.top)
                                extra += this.borders.top.weight;
                            return extra;
                        };
                        CellStyle.prototype.getExtraBottom = function () {
                            var extra = 0;
                            if (this.paddings.bottom)
                                extra += this.paddings.bottom;
                            if (this.borders.bottom)
                                extra += this.borders.bottom.weight;
                            return extra;
                        };
                        CellStyle.prototype.getExtraRight = function () {
                            var extra = 0;
                            if (this.paddings.right)
                                extra += this.paddings.right;
                            if (this.borders.right)
                                extra += this.borders.right.weight;
                            return extra;
                        };
                        CellStyle.prototype.getExtraLeft = function () {
                            var extra = 0;
                            if (this.paddings.left)
                                extra += this.paddings.left;
                            if (this.borders.left)
                                extra += this.borders.left.weight;
                            return extra;
                        };
                        return CellStyle;
                    }());
                    TablixUtils.CellStyle = CellStyle;
                    /**
                     * Index within a dimension (row/column)
                     */
                    var DimensionPosition = (function () {
                        function DimensionPosition() {
                        }
                        return DimensionPosition;
                    }());
                    TablixUtils.DimensionPosition = DimensionPosition;
                    /**
                     * Poistion information about the cell
                     */
                    var CellPosition = (function () {
                        function CellPosition() {
                            this.row = new DimensionPosition();
                            this.column = new DimensionPosition();
                        }
                        CellPosition.prototype.isMatch = function (position) {
                            return this.column.index === position.column.index &&
                                this.row.index === position.row.index;
                        };
                        return CellPosition;
                    }());
                    TablixUtils.CellPosition = CellPosition;
                    var TablixVisualCell = (function () {
                        function TablixVisualCell(dataPoint, isTotal, columnMetadata, formatter) {
                            this.dataPoint = dataPoint;
                            this.columnMetadata = columnMetadata;
                            this.formatter = formatter;
                            this.isTotal = isTotal;
                            this.backColorCustomFormatting = undefined;
                            this.position = new TablixUtils.CellPosition();
                        }
                        Object.defineProperty(TablixVisualCell.prototype, "textContent", {
                            get: function () {
                                if (this.dataPoint == null)
                                    return '';
                                if (this.formatter)
                                    return this.formatter(this.dataPoint, this.columnMetadata, TablixObjects.PropColumnFormatString.getPropertyID());
                                else
                                    return this.dataPoint;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        Object.defineProperty(TablixVisualCell.prototype, "domContent", {
                            get: function () {
                                if (this.columnMetadata && isValidStatusGraphic(this.columnMetadata.kpi, this.textContent))
                                    return createKpiDom(this.columnMetadata.kpi, this.textContent);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        Object.defineProperty(TablixVisualCell.prototype, "isNumeric", {
                            get: function () {
                                if (this.columnMetadata)
                                    return this.columnMetadata.type.numeric && !this.columnMetadata.kpi;
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        Object.defineProperty(TablixVisualCell.prototype, "isUrl", {
                            get: function () {
                                if (this.columnMetadata)
                                    return visuals.converterHelper.isWebUrlColumn(this.columnMetadata);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        Object.defineProperty(TablixVisualCell.prototype, "isImage", {
                            get: function () {
                                if (this.columnMetadata)
                                    return visuals.converterHelper.isImageUrlColumn(this.columnMetadata);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        Object.defineProperty(TablixVisualCell.prototype, "isValidUrl", {
                            get: function () {
                                return jsCommon.UrlUtils.isValidImageUrl(this.textContent);
                            },
                            enumerable: true,
                            configurable: true
                        });
                        ;
                        TablixVisualCell.prototype.isMatch = function (item) {
                            return this.position.isMatch(item.position);
                        };
                        return TablixVisualCell;
                    }());
                    TablixUtils.TablixVisualCell = TablixVisualCell;
                    function createTable() {
                        return document.createElement("table");
                    }
                    TablixUtils.createTable = createTable;
                    function createDiv() {
                        var div = document.createElement("div");
                        div.className = "tablixDiv";
                        return div;
                    }
                    TablixUtils.createDiv = createDiv;
                    function resetCellCssClass(cell) {
                        cell.extension.contentElement.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentElement;
                        cell.extension.contentHost.className = TablixUtils.CssClassTablixDiv + " " + TablixUtils.CssClassContentHost;
                    }
                    TablixUtils.resetCellCssClass = resetCellCssClass;
                    function addCellCssClass(cell, style) {
                        cell.extension.contentHost.className += " " + style;
                    }
                    TablixUtils.addCellCssClass = addCellCssClass;
                    /**
                     * Clears all inline styles (border, fontColor, background) and resets CSS classes
                     * Performed with unbind-<Cell>
                     */
                    function clearCellStyle(cell) {
                        cell.extension.contentHost.className = "";
                        cell.extension.contentHost.style.cssText = "";
                    }
                    TablixUtils.clearCellStyle = clearCellStyle;
                    function clearCellTextAndTooltip(cell) {
                        cell.extension.contentHost.textContent = '';
                        cell.extension.contentHost.removeAttribute('title');
                        cell.contentHeight = cell.contentWidth = 0;
                        controls.HTMLElementUtils.clearChildren(cell.extension.contentHost);
                    }
                    TablixUtils.clearCellTextAndTooltip = clearCellTextAndTooltip;
                    function setCellTextAndTooltip(cell, text) {
                        var val = visuals.TextUtil.replaceSpaceWithNBSP(text);
                        cell.extension.contentHost.textContent = val;
                        cell.extension.contentHost.title = val;
                    }
                    TablixUtils.setCellTextAndTooltip = setCellTextAndTooltip;
                    function isValidSortClick(e) {
                        var colHeader = e.target;
                        var x = e.offsetX;
                        return x >= 0 && x < colHeader.offsetWidth - internal.TablixResizer.resizeHandleSize;
                    }
                    TablixUtils.isValidSortClick = isValidSortClick;
                    function appendATagToBodyCell(value, cell, urlIcon) {
                        var element = cell.extension.contentHost;
                        var atag = null;
                        if (element.childElementCount === 0) {
                            atag = document.createElement('a');
                            element.appendChild(atag);
                        }
                        else {
                            atag = element.children[0];
                        }
                        atag.href = value;
                        atag.target = '_blank';
                        atag.title = value;
                        if (urlIcon === true) {
                            atag.className = TablixUtils.CssClassValueURLIcon;
                            element.className = TablixUtils.CssClassValueURLIconContainer;
                        }
                        else {
                            atag.innerText = value;
                        }
                    }
                    TablixUtils.appendATagToBodyCell = appendATagToBodyCell;
                    function appendImgTagToBodyCell(value, cell, imageHeight) {
                        var element = cell.extension.contentHost;
                        var imgContainer = TablixUtils.createDiv();
                        var imgTag = document.createElement('img');
                        imgContainer.style.height = imageHeight + "px";
                        imgContainer.style.width = "100%";
                        imgContainer.style.textAlign = "center";
                        imgTag.src = value;
                        imgTag.style.maxHeight = "100%";
                        imgTag.style.maxWidth = "100%";
                        imgContainer.appendChild(imgTag);
                        element.appendChild(imgContainer);
                    }
                    TablixUtils.appendImgTagToBodyCell = appendImgTagToBodyCell;
                    function createKpiDom(kpi, kpiValue) {
                        debug.assertValue(kpi, 'kpi');
                        debug.assertValue(kpiValue, 'kpiValue');
                        var className = visuals.KpiUtil.getClassForKpi(kpi, kpiValue) || '';
                        return DomFactory.div()
                            .addClass(className)
                            .css({
                            'display': 'inline-block',
                            'vertical-align': 'bottom',
                            'margin': '0',
                        });
                    }
                    TablixUtils.createKpiDom = createKpiDom;
                    function isValidStatusGraphic(kpi, kpiValue) {
                        if (!kpi || kpiValue === undefined) {
                            return false;
                        }
                        return !!visuals.KpiUtil.getClassForKpi(kpi, kpiValue);
                    }
                    TablixUtils.isValidStatusGraphic = isValidStatusGraphic;
                    function getCustomSortEventArgs(queryName, sortDirection) {
                        var sortDescriptors = [{
                                queryName: queryName,
                                sortDirection: sortDirection
                            }];
                        return { sortDescriptors: sortDescriptors };
                    }
                    TablixUtils.getCustomSortEventArgs = getCustomSortEventArgs;
                    function reverseSort(sortDirection) {
                        return sortDirection === 2 /* Descending */ ? 1 /* Ascending */ : 2 /* Descending */;
                    }
                    TablixUtils.reverseSort = reverseSort;
                    function createColumnHeaderWithSortIcon(item, cell) {
                        var colHeaderContainer = TablixUtils.createDiv();
                        if (item.sort) {
                            var itemSort = item.sort;
                            colHeaderContainer.appendChild(createSortIcon(itemSort, true));
                            colHeaderContainer.appendChild(createSortIcon(reverseSort(itemSort), false));
                        }
                        else {
                            colHeaderContainer.appendChild(createSortIcon(2 /* Descending */, false));
                        }
                        var colHeaderTitle = TablixUtils.createDiv();
                        // Preserving trailing and leading spaces
                        var title = item ? visuals.TextUtil.replaceSpaceWithNBSP(item.displayName) : '';
                        colHeaderTitle.textContent = title;
                        colHeaderContainer.appendChild(colHeaderTitle);
                        cell.extension.contentHost.title = title;
                        cell.extension.contentHost.appendChild(colHeaderContainer);
                    }
                    TablixUtils.createColumnHeaderWithSortIcon = createColumnHeaderWithSortIcon;
                    function createSortIcon(sort, isSorted) {
                        var imgSort = document.createElement('i');
                        imgSort.className = SortIconContainerClassName +
                            " " + (isSorted ? "sorted" : "future") +
                            " " + (sort === 1 /* Ascending */ ? "powervisuals-glyph caret-up" : "powervisuals-glyph caret-down");
                        return imgSort;
                    }
                    function checkSortIconExists(cell) {
                        for (var i = 0, len = cell.extension.contentElement.childElementCount; i < len; i++) {
                            var element = cell.extension.contentElement.children.item(i);
                            if (element.classList.contains(SortIconContainerClassName))
                                return true;
                        }
                        return false;
                    }
                    function removeSortIcons(cell) {
                        if (!checkSortIconExists(cell))
                            return;
                        $(cell.extension.contentElement).find('.' + SortIconContainerClassName).remove();
                    }
                    TablixUtils.removeSortIcons = removeSortIcons;
                })(TablixUtils = internal.TablixUtils || (internal.TablixUtils = {}));
            })(internal = controls.internal || (controls.internal = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            controls.TablixDefaultTextSize = jsCommon.TextSizeDefaults.TextSizeMin;
            var TablixControl = (function () {
                function TablixControl(hierarchyNavigator, layoutManager, binder, parentDomElement, options) {
                    var _this = this;
                    this.scrollBarElementWidth = 9;
                    // Options (fontSize set after container initialized)
                    this.options = options;
                    var isInteractive = options.interactive;
                    this.isTouchEnabled = isInteractive && options.enableTouchSupport;
                    // Main Div
                    this.mainDiv = controls.internal.TablixUtils.createDiv();
                    this.mainDiv.classList.add(TablixControl.TablixTableAreaClassName);
                    // Footer Div
                    this.footerDiv = controls.internal.TablixUtils.createDiv();
                    this.footerDiv.classList.add(TablixControl.TablixFooterClassName);
                    if (this.isTouchEnabled)
                        this.InitializeTouchSupport();
                    this.gridDimensions = {};
                    this.containerElement = controls.internal.TablixUtils.createDiv();
                    this.className = layoutManager.getTablixClassName();
                    this.autoSizeWidth = false;
                    this.autoSizeHeight = false;
                    this.fontFamily = controls.internal.TablixUtils.FontFamilyCell;
                    this.fontColor = controls.internal.TablixUtils.FontColorCells;
                    this.fontSize = options.fontSize;
                    parentDomElement.className = TablixControl.TablixContainerClassName;
                    parentDomElement.appendChild(this.containerElement);
                    this.containerElement.addEventListener("mousewheel", function (e) { _this.onMouseWheel(e); });
                    this.containerElement.addEventListener("DOMMouseScroll", function (e) { _this.onFireFoxMouseWheel(e); });
                    this.containerElement.appendChild(this.mainDiv);
                    this.containerElement.appendChild(this.footerDiv);
                    if (this.isTouchEnabled) {
                        this.touchInterpreter.initTouch(this.mainDiv, null, false);
                        this.footerTouchInterpreter.initTouch(this.footerDiv, this.mainDiv, false);
                    }
                    this.controlLayoutManager = layoutManager;
                    this.controlLayoutManager.initialize(this);
                    this.hierarchyTablixNavigator = hierarchyNavigator;
                    this.binder = binder;
                    this.columnDim = new controls.TablixColumnDimension(this);
                    this.rowDim = new controls.TablixRowDimension(this);
                    this.columnDim._otherDimension = this.rowDimension;
                    this.rowDim._otherDimension = this.columnDimension;
                    this.InitializeScrollbars();
                    if (!isInteractive) {
                        this.scrollbarWidth = 0;
                    }
                    this.updateHorizontalPosition();
                    this.updateVerticalPosition();
                    this.updateFooterVisibility();
                    this.lastRenderingArgs = {};
                }
                TablixControl.prototype.InitializeTouchSupport = function () {
                    this.touchManager = new controls.TouchUtils.TouchManager();
                    this.touchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager);
                    this.footerTouchInterpreter = new controls.TouchUtils.TouchEventInterpreter(this.touchManager);
                    this.columnTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.rowTouchDelegate = new controls.RowTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.bodyTouchDelegate = new controls.BodyTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.footerTouchDelegate = new controls.ColumnTouchDelegate(new controls.TouchUtils.Rectangle());
                    this.columnTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.rowTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.bodyTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.footerTouchDelegate.setHandler(this, this.onTouchEvent);
                    this.touchManager.addTouchRegion(this.columnTouchDelegate.dimension, this.columnTouchDelegate, this.columnTouchDelegate);
                    this.touchManager.addTouchRegion(this.rowTouchDelegate.dimension, this.rowTouchDelegate, this.rowTouchDelegate);
                    this.touchManager.addTouchRegion(this.bodyTouchDelegate.dimension, this.bodyTouchDelegate, this.bodyTouchDelegate);
                    this.touchManager.addTouchRegion(this.footerTouchDelegate.dimension, this.footerTouchDelegate, this.footerTouchDelegate);
                };
                TablixControl.prototype.InitializeScrollbars = function () {
                    // Row Dimension
                    this.rowDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                    var rowDimensionScrollbarStyle = this.rowDim.scrollbar.element.style;
                    rowDimensionScrollbarStyle.position = "absolute";
                    rowDimensionScrollbarStyle.top = "0" + TablixControl.UnitOfMeasurement;
                    rowDimensionScrollbarStyle.right = "0" + TablixControl.UnitOfMeasurement;
                    this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    // Default to true which is the more common case to avoid an extra rendering iteration
                    // when first rendering the visual
                    this.rowDim.scrollbar.show(true);
                    // Column Dimension
                    this.columnDim._initializeScrollbar(this.containerElement, null, this.options.layoutKind);
                    var columnDimensionScrollbarStyle = this.columnDim.scrollbar.element.style;
                    columnDimensionScrollbarStyle.position = "absolute";
                    columnDimensionScrollbarStyle.left = "0" + TablixControl.UnitOfMeasurement;
                    columnDimensionScrollbarStyle.bottom = "0" + TablixControl.UnitOfMeasurement;
                    this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    this.columnDim.scrollbar.show(false);
                };
                Object.defineProperty(TablixControl.prototype, "container", {
                    get: function () {
                        return this.containerElement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "contentHost", {
                    get: function () {
                        return this.mainDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "footerHost", {
                    get: function () {
                        return this.footerDiv;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "className", {
                    set: function (value) {
                        this.containerElement.className = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "hierarchyNavigator", {
                    get: function () {
                        return this.hierarchyTablixNavigator;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.getBinder = function () {
                    return this.binder;
                };
                Object.defineProperty(TablixControl.prototype, "autoSizeWidth", {
                    get: function () {
                        return this._autoSizeWidth;
                    },
                    set: function (value) {
                        this._autoSizeWidth = value;
                        if (!value) {
                            this.containerElement.style.minWidth = this.containerElement.style.maxWidth = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "autoSizeHeight", {
                    get: function () {
                        return this._autoSizeHeight;
                    },
                    set: function (value) {
                        if (!value) {
                            this.containerElement.style.minHeight = this.containerElement.style.maxHeight = "none";
                        }
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxWidth", {
                    get: function () {
                        return this.maximumWidth;
                    },
                    set: function (value) {
                        this.maximumWidth = value;
                        this.containerElement.style.maxWidth = this.maximumWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "viewport", {
                    get: function () {
                        return this.viewPort;
                    },
                    set: function (value) {
                        this.viewPort = value;
                        this.containerElement.style.width = this.viewPort.width + TablixControl.UnitOfMeasurement;
                        this.containerElement.style.height = this.viewPort.height + TablixControl.UnitOfMeasurement;
                        this.rowDim.scrollbar.invalidateArrange();
                        this.columnDim.scrollbar.invalidateArrange();
                        this.controlLayoutManager.updateViewport(this.viewPort);
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "maxHeight", {
                    get: function () {
                        return this.maximumHeight;
                    },
                    set: function (value) {
                        this.maximumHeight = value;
                        this.containerElement.style.maxHeight = this.maximumHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minWidth", {
                    get: function () {
                        return this.minimumWidth;
                    },
                    set: function (value) {
                        this.minimumWidth = value;
                        this.containerElement.style.minWidth = this.minimumWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "minHeight", {
                    get: function () {
                        return this.minimumHeight;
                    },
                    set: function (value) {
                        this.minimumHeight = value;
                        this.containerElement.style.minHeight = this.minimumHeight + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "fontSize", {
                    get: function () {
                        return this.textFontSize;
                    },
                    set: function (value) {
                        this.textFontSize = !value ? TablixControl.DefaultFontSize : value;
                        this.containerElement.style.fontSize = this.textFontSize;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "fontFamily", {
                    get: function () {
                        return this.textFontFamily;
                    },
                    set: function (value) {
                        this.textFontFamily = value;
                        this.containerElement.style.fontFamily = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "fontColor", {
                    get: function () {
                        return this.textFontColor;
                    },
                    set: function (value) {
                        this.textFontColor = value;
                        this.containerElement.style.color = value;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "scrollbarWidth", {
                    set: function (value) {
                        this.scrollBarElementWidth = value;
                        this.rowDim.scrollbar.width = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.columnDim.scrollbar.height = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.updateModels = function (resetScrollOffsets, rowModel, columnModel) {
                    this.rowDim.model = rowModel;
                    this.rowDim.modelDepth = this.hierarchyNavigator.getRowHierarchyDepth();
                    this.columnDim.model = columnModel;
                    this.columnDim.modelDepth = this.hierarchyNavigator.getColumnHierarchyDepth();
                    if (resetScrollOffsets) {
                        this.rowDim.scrollOffset = 0;
                        this.columnDim.scrollOffset = 0;
                    }
                    this.layoutManager.updateColumnCount(this.rowDim, this.columnDim);
                };
                TablixControl.prototype.updateColumnDimensions = function (rowHierarchyWidth, columnHierarchyWidth, count) {
                    var gridDimensions = this.gridDimensions;
                    gridDimensions.columnCount = count;
                    gridDimensions.rowHierarchyWidth = rowHierarchyWidth;
                    gridDimensions.columnHierarchyWidth = columnHierarchyWidth;
                };
                TablixControl.prototype.updateRowDimensions = function (columnHierarchyHeight, rowHierarchyHeight, rowHierarchyContentHeight, count, footerHeight) {
                    var gridDimensions = this.gridDimensions;
                    gridDimensions.rowCount = count;
                    gridDimensions.rowHierarchyHeight = rowHierarchyHeight;
                    gridDimensions.rowHierarchyContentHeight = rowHierarchyContentHeight;
                    gridDimensions.columnHierarchyHeight = columnHierarchyHeight;
                    gridDimensions.footerHeight = footerHeight;
                };
                TablixControl.prototype.updateTouchDimensions = function () {
                    var gridDimensions = this.gridDimensions;
                    this.columnTouchDelegate.resize(gridDimensions.rowHierarchyWidth, 0, gridDimensions.columnHierarchyWidth, gridDimensions.columnHierarchyHeight);
                    this.columnTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                    this.rowTouchDelegate.resize(0, gridDimensions.columnHierarchyHeight, gridDimensions.rowHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this.rowTouchDelegate.setScrollDensity(gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this.bodyTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.rowHierarchyHeight);
                    this.bodyTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth, gridDimensions.rowCount / gridDimensions.rowHierarchyHeight);
                    this.footerTouchDelegate.resize(gridDimensions.rowHierarchyWidth, gridDimensions.columnHierarchyHeight + gridDimensions.rowHierarchyHeight, gridDimensions.columnHierarchyWidth, gridDimensions.footerHeight);
                    this.footerTouchDelegate.setScrollDensity(gridDimensions.columnCount / gridDimensions.columnHierarchyWidth);
                };
                TablixControl.prototype.onMouseWheel = function (e) {
                    var dimension = this.determineDimensionToScroll();
                    if (dimension)
                        dimension.scrollbar.onMouseWheel(e);
                };
                TablixControl.prototype.onFireFoxMouseWheel = function (e) {
                    var dimension = this.determineDimensionToScroll();
                    if (dimension)
                        dimension.scrollbar.onFireFoxMouseWheel(e);
                };
                TablixControl.prototype.determineDimensionToScroll = function () {
                    if (this.rowDim.scrollbar.visible)
                        return this.rowDim;
                    // In the absence of the vertical scrollbar, we scroll the
                    // horizontal scrollbar.
                    if (this.columnDim.scrollbar.visible)
                        return this.columnDim;
                    return null;
                };
                Object.defineProperty(TablixControl.prototype, "layoutManager", {
                    get: function () {
                        return this.controlLayoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "columnDimension", {
                    get: function () {
                        return this.columnDim;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixControl.prototype, "rowDimension", {
                    get: function () {
                        return this.rowDim;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixControl.prototype.refresh = function (clear) {
                    this.render(clear, null);
                };
                TablixControl.prototype._onScrollAsync = function (dimension) {
                    var _this = this;
                    requestAnimationFrame(function () { _this.performPendingScroll(dimension); });
                };
                TablixControl.prototype.performPendingScroll = function (dimension) {
                    this.render(false, dimension);
                };
                TablixControl.prototype.updateHorizontalPosition = function () {
                    if (this.rowDim.scrollbar.visible) {
                        this.columnDim.scrollbar.element.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                        this.mainDiv.style.right = this.scrollBarElementWidth + TablixControl.UnitOfMeasurement;
                    }
                    else {
                        this.columnDim.scrollbar.element.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this.mainDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.right = "0" + TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.updateFooterVisibility = function () {
                    if (this.rowDim.hasFooter() ? (this.footerDiv.style.display !== "block") : (this.footerDiv.style.display !== "none")) {
                        if (this.rowDim.hasFooter()) {
                            this.footerDiv.style.display = "block";
                        }
                        else {
                            this.footerDiv.style.display = "none";
                        }
                    }
                };
                TablixControl.prototype.updateVerticalPosition = function () {
                    var hasVerticalScrollbar = this.rowDim.scrollbar.visible;
                    // TODO: ideally the tablix control would not know about where it is rendered but the layout manager
                    //       would provider that information; we should refactor the layout manager so that getLayoutKind is not needed anymore.
                    var isDashboardTile = this.controlLayoutManager.getLayoutKind() === 1 /* DashboardTile */;
                    var showFooter = hasVerticalScrollbar || isDashboardTile;
                    if (showFooter) {
                        var mainBottom = this.footerDiv.offsetHeight;
                        var footerBottom = 0;
                        var verticalScrollbarBottom = 0;
                        // If we have a horizontal scrollbar, we need to adjust the bottom
                        // value by the scrollbar width
                        var hasHorizontalScrollbar = this.columnDim.scrollbar.visible;
                        if (hasHorizontalScrollbar) {
                            mainBottom += this.scrollBarElementWidth;
                            footerBottom += this.scrollBarElementWidth;
                            verticalScrollbarBottom = this.scrollBarElementWidth;
                        }
                        this.mainDiv.style.bottom = mainBottom + TablixControl.UnitOfMeasurement;
                        this.rowDim.scrollbar.element.style.bottom = verticalScrollbarBottom + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.bottom = footerBottom + TablixControl.UnitOfMeasurement;
                        // With a vertical scrollbar, the footer is always rendered at the bottom
                        this.footerDiv.style.removeProperty("top");
                    }
                    else {
                        // Without a vertical scrollbar, the footer is rendered below the last row;
                        // this is controlled by the top value only
                        this.footerDiv.style.top = this.gridDimensions.rowHierarchyContentHeight + TablixControl.UnitOfMeasurement;
                        this.footerDiv.style.removeProperty("bottom");
                        this.mainDiv.style.removeProperty("bottom");
                    }
                };
                TablixControl.prototype.alreadyRendered = function (scrollingDimension) {
                    if (scrollingDimension !== this.lastRenderingArgs.scrollingDimension ||
                        this.rowDimension.scrollOffset !== this.lastRenderingArgs.rowScrollOffset ||
                        this.columnDimension.scrollOffset !== this.lastRenderingArgs.columnScrollOffset) {
                        return false;
                    }
                    return true;
                };
                TablixControl.prototype.render = function (clear, scrollingDimension) {
                    // at time of rendering always ensure the scroll offset is valid
                    this.columnDim.makeScrollOffsetValid();
                    this.rowDim.makeScrollOffsetValid();
                    if (clear || scrollingDimension === null) {
                        this.lastRenderingArgs = {};
                    }
                    else if (this.alreadyRendered(scrollingDimension)) {
                        return;
                    }
                    var done = false;
                    this.renderIterationCount = 0;
                    this.controlLayoutManager.onStartRenderingSession(scrollingDimension, this.mainDiv, clear);
                    var binder = this.binder;
                    binder.onStartRenderingSession();
                    var priorFooterHeight = this.gridDimensions.footerHeight;
                    var priorRowHierarchyHeight = this.gridDimensions.rowHierarchyHeight;
                    var priorRowHierarchyContentHeight = this.gridDimensions.rowHierarchyContentHeight;
                    while (!done && this.renderIterationCount < TablixControl.MaxRenderIterationCount) {
                        var hScrollbarVisibility = this.columnDim.scrollbar.visible;
                        var vScrollbarVisibility = this.rowDim.scrollbar.visible;
                        this.columnDim._onStartRenderingIteration();
                        this.rowDim._onStartRenderingIteration();
                        this.controlLayoutManager.onStartRenderingIteration(clear);
                        // These calls add cells to the table.
                        // Column needs to be rendered before rows as the row call will pair up with columns to produce the body cells.
                        this.renderCorner();
                        this.columnDim._render();
                        this.rowDim._render();
                        done = this.controlLayoutManager.onEndRenderingIteration();
                        this.columnDim._onEndRenderingIteration();
                        this.rowDim._onEndRenderingIteration();
                        if ((hScrollbarVisibility !== this.columnDim.scrollbar.visible)) {
                            this.updateVerticalPosition();
                        }
                        if (vScrollbarVisibility !== this.rowDim.scrollbar.visible) {
                            this.updateHorizontalPosition();
                        }
                        this.renderIterationCount++;
                    }
                    this.controlLayoutManager.onEndRenderingSession();
                    binder.onEndRenderingSession();
                    if (this.isTouchEnabled)
                        this.updateTouchDimensions();
                    this.lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    this.lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    this.updateContainerDimensions();
                    var lastRenderingArgs = this.lastRenderingArgs;
                    lastRenderingArgs.rowScrollOffset = this.rowDimension.scrollOffset;
                    lastRenderingArgs.columnScrollOffset = this.columnDimension.scrollOffset;
                    lastRenderingArgs.scrollingDimension = scrollingDimension;
                    if (priorFooterHeight !== this.gridDimensions.footerHeight ||
                        priorRowHierarchyHeight !== this.gridDimensions.rowHierarchyHeight ||
                        priorRowHierarchyContentHeight !== this.gridDimensions.rowHierarchyContentHeight) {
                        this.updateVerticalPosition();
                    }
                    // NOTE: it is critical that we refresh the scrollbars only after the vertical
                    //       position was updated above; otherwise the measurements can be incorrect.
                    if (this.options.interactive) {
                        this.columnDim.scrollbar.refresh();
                        this.rowDim.scrollbar.refresh();
                    }
                };
                TablixControl.prototype.updateContainerDimensions = function () {
                    var gridDimensions = this.gridDimensions;
                    if (this._autoSizeWidth) {
                        var vScrollBarWidth = this.rowDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                        this.containerElement.style.width =
                            gridDimensions.rowHierarchyWidth +
                                gridDimensions.columnHierarchyWidth +
                                vScrollBarWidth +
                                TablixControl.UnitOfMeasurement;
                    }
                    if (this._autoSizeHeight) {
                        var hScrollBarHeight = this.columnDim.scrollbar.visible ? this.scrollBarElementWidth : 0;
                        this.containerElement.style.height =
                            gridDimensions.columnHierarchyHeight +
                                gridDimensions.rowHierarchyHeight +
                                gridDimensions.footerHeight +
                                hScrollBarHeight +
                                TablixControl.UnitOfMeasurement;
                    }
                };
                TablixControl.prototype.cornerCellMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 0 /* CornerCell */ && previousItem && this.hierarchyTablixNavigator.cornerCellItemEquals(item, previousItem);
                };
                TablixControl.prototype.renderCorner = function () {
                    var columnDepth = this.columnDim.getDepth();
                    var rowDepth = this.rowDim.getDepth();
                    for (var i = 0; i < columnDepth; i++) {
                        for (var j = 0; j < rowDepth; j++) {
                            var item = this.hierarchyTablixNavigator.getCorner(j, i);
                            var cell = this.controlLayoutManager.getOrCreateCornerCell(item, j, i);
                            var match = this.cornerCellMatch(item, cell);
                            if (!match) {
                                this._unbindCell(cell);
                                cell.type = 0 /* CornerCell */;
                                cell.item = item;
                                this.binder.bindCornerCell(item, cell);
                            }
                            this.controlLayoutManager.onCornerCellRealized(item, cell);
                        }
                    }
                };
                TablixControl.prototype._unbindCell = function (cell) {
                    switch (cell.type) {
                        case 3 /* BodyCell */:
                            this.binder.unbindBodyCell(cell.item, cell);
                            break;
                        case 2 /* ColumnHeader */:
                            this.binder.unbindColumnHeader(cell.item, cell);
                            break;
                        case 1 /* RowHeader */:
                            this.binder.unbindRowHeader(cell.item, cell);
                            break;
                        case 0 /* CornerCell */:
                            this.binder.unbindCornerCell(cell.item, cell);
                    }
                    cell.item = null;
                    cell.type = null;
                };
                TablixControl.prototype.onTouchEvent = function (args) {
                    var colShift;
                    var rowShift;
                    var that;
                    if ((args) && (args.length > 0)) {
                        if (("columnDim" in args[0]) && ("rowDim" in args[0])) {
                            that = args[0];
                            colShift = that.columnDim.scrollbar.visible ? args[1] : 0;
                            rowShift = that.rowDim.scrollbar.visible ? args[2] : 0;
                            that.columnDim.scrollbar.viewMin = Math.max(0, that.columnDim.scrollbar.viewMin + colShift);
                            that.columnDim.scrollOffset = Math.max(0, that.columnDim.scrollOffset + colShift);
                            that.rowDim.scrollbar.viewMin = Math.max(0, that.rowDim.scrollbar.viewMin + rowShift);
                            that.rowDim.scrollOffset = Math.max(0, that.rowDim.scrollOffset + rowShift);
                            if (colShift === 0) {
                                that._onScrollAsync(that.rowDim);
                            }
                            else if (rowShift === 0) {
                                that._onScrollAsync(that.columnDim);
                            }
                            else {
                                that._onScrollAsync(null);
                            }
                        }
                    }
                };
                TablixControl.UnitOfMeasurement = 'px';
                TablixControl.TablixContainerClassName = 'tablixContainer';
                TablixControl.TablixTableAreaClassName = "tablixTableArea";
                TablixControl.TablixFooterClassName = "tableFooterArea";
                TablixControl.DefaultFontSize = jsCommon.PixelConverter.fromPoint(controls.TablixDefaultTextSize);
                /*
                * This is workaround for the infinite loop in rendering
                * BugID: 6518621
                * ToDo: Investigate the underlying cause for rendering to never report completion
                * Rendering typically require 3-5 iterations to complete, so 10 is enough
                */
                TablixControl.MaxRenderIterationCount = 10;
                return TablixControl;
            }());
            controls.TablixControl = TablixControl;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TablixDimension = (function () {
                function TablixDimension(tablixControl) {
                    this._scrollStep = 0.1;
                    this._owner = tablixControl;
                    this._hierarchyNavigator = tablixControl.hierarchyNavigator;
                    this._binder = tablixControl.getBinder();
                    this._tablixLayoutManager = tablixControl.layoutManager;
                    this.scrollOffset = 0;
                }
                TablixDimension.prototype._onStartRenderingIteration = function () {
                    this.updateScrollPosition();
                };
                TablixDimension.prototype._onEndRenderingIteration = function () {
                };
                TablixDimension.prototype.getValidScrollOffset = function (scrollOffset) {
                    return Math.min(Math.max(scrollOffset, 0), Math.max(this.getItemsCount() - this._scrollStep, 0));
                };
                TablixDimension.prototype.makeScrollOffsetValid = function () {
                    this.scrollOffset = this.getValidScrollOffset(this.scrollOffset);
                };
                TablixDimension.prototype.getIntegerScrollOffset = function () {
                    return Math.floor(this.scrollOffset);
                };
                TablixDimension.prototype.getFractionScrollOffset = function () {
                    return this.scrollOffset - this.getIntegerScrollOffset();
                };
                Object.defineProperty(TablixDimension.prototype, "scrollbar", {
                    get: function () {
                        return this._scrollbar;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype.getFirstVisibleItem = function (level) {
                    return this._scrollItems[level];
                };
                TablixDimension.prototype.getFirstVisibleChild = function (item) {
                    return this._hierarchyNavigator.getAt(this._hierarchyNavigator.getChildren(item), this.getFirstVisibleChildIndex(item));
                };
                TablixDimension.prototype.getFirstVisibleChildIndex = function (item) {
                    var startItem = this.getFirstVisibleItem(this._hierarchyNavigator.getLevel(item) + 1);
                    var firstVisibleIndex;
                    if (startItem === undefined || (startItem !== undefined && this._hierarchyNavigator.getParent(startItem) !== item)) {
                        firstVisibleIndex = 0;
                    }
                    else {
                        firstVisibleIndex = this._hierarchyNavigator.getIndex(startItem);
                    }
                    return firstVisibleIndex;
                };
                TablixDimension.prototype._initializeScrollbar = function (parentElement, touchDiv, layoutKind) {
                    var _this = this;
                    this._scrollbar = this._createScrollbar(parentElement, layoutKind);
                    this._scrollbar._onscroll.push(function (e) { return _this.onScroll(); });
                    if (touchDiv) {
                        this.scrollbar.initTouch(touchDiv, true);
                        touchDiv.style.setProperty("-ms-touch-action", "pinch-zoom");
                    }
                };
                TablixDimension.prototype.getItemsCount = function () {
                    return this.model ? this._hierarchyNavigator.getLeafCount(this.model) : 0;
                };
                TablixDimension.prototype.getDepth = function () {
                    return this.modelDepth;
                };
                TablixDimension.prototype.onScroll = function () {
                    this.scrollOffset = this._scrollbar.viewMin;
                    this._owner._onScrollAsync(this);
                };
                Object.defineProperty(TablixDimension.prototype, "otherDimension", {
                    get: function () {
                        return this._otherDimension;
                    },
                    enumerable: true,
                    configurable: true
                });
                Object.defineProperty(TablixDimension.prototype, "layoutManager", {
                    get: function () {
                        return this._layoutManager;
                    },
                    enumerable: true,
                    configurable: true
                });
                TablixDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    // abstract
                    debug.assertFail("PureVirtualMethod: TablixDimension._createScrollbar");
                    return null;
                };
                TablixDimension.prototype.updateScrollPosition = function () {
                    this._scrollItems = [];
                    if (!this.model) {
                        return;
                    }
                    var firstVisibleScrollIndex = this.getIntegerScrollOffset();
                    var firstVisible = this._hierarchyNavigator.getLeafAt(this.model, firstVisibleScrollIndex);
                    if (!firstVisible) {
                        return;
                    }
                    this._firstVisibleScrollIndex = firstVisibleScrollIndex;
                    do {
                        this._scrollItems[this._hierarchyNavigator.getLevel(firstVisible)] = firstVisible;
                        firstVisible = this._hierarchyNavigator.getParent(firstVisible);
                    } while (firstVisible !== null);
                };
                return TablixDimension;
            }());
            controls.TablixDimension = TablixDimension;
            var TablixRowDimension = (function (_super) {
                __extends(TablixRowDimension, _super);
                function TablixRowDimension(tablixControl) {
                    _super.call(this, tablixControl);
                    this._layoutManager = this._tablixLayoutManager.rowLayoutManager;
                    this._footer = null;
                }
                TablixRowDimension.prototype.setFooter = function (footerHeader) {
                    this._footer = footerHeader;
                    this._owner.updateFooterVisibility();
                };
                TablixRowDimension.prototype.hasFooter = function () {
                    return (this._footer !== null);
                };
                /**
                 * This method first populates the footer followed by each row and their correlating body cells from top to bottom.
                 */
                TablixRowDimension.prototype._render = function () {
                    var firstVisibleRowItem = this.getFirstVisibleItem(0);
                    if (this.hasFooter()) {
                        this.addFooterRowHeader(this._footer);
                        this.addFooterBodyCells(this._footer);
                    }
                    if (firstVisibleRowItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleRowItem));
                    }
                };
                TablixRowDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    return new controls.VerticalScrollbar(parentElement, layoutKind);
                };
                /**
                 * This function is a recursive call (with its recursive behavior in addNode()) that will navigate
                 * through the row hierarchy in DFS (Depth First Search) order and continue into a single row
                 * upto its estimated edge.
                 */
                TablixRowDimension.prototype.addNodes = function (items, rowIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    //for loop explores children of current "items"
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var item = this._hierarchyNavigator.getAt(items, i);
                        var cell = this.addNode(item, items, rowIndex, depth);
                        rowIndex += cell.rowSpan; //next node is bumped down according cells vertical span
                    }
                };
                TablixRowDimension.prototype.getFirstVisibleChildLeaf = function (item) {
                    var leaf = item;
                    while (!this._hierarchyNavigator.isLeaf(leaf)) {
                        leaf = this.getFirstVisibleChild(leaf);
                    }
                    return leaf;
                };
                TablixRowDimension.prototype.bindRowHeader = function (item, cell) {
                    this._binder.bindRowHeader(item, cell);
                };
                /**
                 * This method can be thought of as the continuation of addNodes() as it continues the DFS (Depth First Search)
                 * started from addNodes(). This function also handles ending the recursion with "_needsToRealize" being set to
                 * false.
                 *
                 * Once the body cells are reached, populating is done linearly with addBodyCells().
                 */
                TablixRowDimension.prototype.addNode = function (item, items, rowIndex, depth) {
                    var previousCount;
                    var rowHeaderCell = this._tablixLayoutManager.getOrCreateRowHeader(item, items, rowIndex, this._hierarchyNavigator.getLevel(item));
                    var match = this.rowHeaderMatch(item, rowHeaderCell);
                    if (!match) {
                        this._owner._unbindCell(rowHeaderCell);
                        rowHeaderCell.type = 1 /* RowHeader */;
                        rowHeaderCell.item = item;
                        rowHeaderCell.unfixRowHeight();
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        rowHeaderCell.colSpan = depth - this._hierarchyNavigator.getLevel(item);
                        rowHeaderCell.rowSpan = 1;
                        if (!match)
                            this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                        this.addBodyCells(item, items, rowIndex);
                    }
                    else {
                        previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), rowIndex, depth, this.getFirstVisibleChildIndex(item));
                        rowHeaderCell.colSpan = 1;
                        rowHeaderCell.rowSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                        if (!match)
                            this.bindRowHeader(item, rowHeaderCell);
                        this._tablixLayoutManager.onRowHeaderRealized(item, rowHeaderCell);
                    }
                    return rowHeaderCell;
                };
                TablixRowDimension.prototype.rowHeaderMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 1 /* RowHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                TablixRowDimension.prototype.addBodyCells = function (item, items, rowIndex) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension._layoutManager.getRealizedItemsCount() - this.getDepth();
                    var hierarchyNavigator = this._hierarchyNavigator;
                    var otherModel = this._otherDimension.model;
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        //get column header "item" by index to pair up with row header to find corelating body cell
                        var cellItem = hierarchyNavigator.getIntersection(item, hierarchyNavigator.getLeafAt(otherModel, firstVisibleColumnIndex + i));
                        var cell = layoutManager.getOrCreateBodyCell(cellItem, item, items, rowIndex, i);
                        this.bindBodyCell(cellItem, cell);
                        layoutManager.onBodyCellRealized(cellItem, cell);
                    }
                };
                TablixRowDimension.prototype.bindBodyCell = function (item, cell) {
                    var match = this.bodyCelMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 3 /* BodyCell */;
                        cell.item = item;
                        cell.unfixRowHeight();
                        this._binder.bindBodyCell(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterRowHeader = function (item) {
                    var cell = this._tablixLayoutManager.getOrCreateFooterRowHeader(item, this.model);
                    cell.colSpan = this.getDepth();
                    var match = this.rowHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 1 /* RowHeader */;
                        cell.item = item;
                        cell.unfixRowHeight();
                        this.bindRowHeader(item, cell);
                        this._tablixLayoutManager.onRowHeaderFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.addFooterBodyCells = function (rowItem) {
                    var firstVisibleColumnIndex = this._otherDimension.getIntegerScrollOffset();
                    var columnCount = this._otherDimension.layoutManager.getRealizedItemsCount() - this.getDepth();
                    var layoutManager = this._tablixLayoutManager;
                    for (var i = 0; i < columnCount; i++) {
                        //get column header "item" by index to pair up with row header to find corelating body cell
                        var columnItem = this._hierarchyNavigator.getLeafAt(this._otherDimension.model, firstVisibleColumnIndex + i);
                        //get corelating body cell and bind it
                        var item = this._hierarchyNavigator.getIntersection(rowItem, columnItem);
                        var cell = layoutManager.getOrCreateFooterBodyCell(item, i);
                        this.bindBodyCell(item, cell);
                        layoutManager.onBodyCellFooterRealized(item, cell);
                    }
                };
                TablixRowDimension.prototype.bodyCelMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 3 /* BodyCell */ && previousItem && this._hierarchyNavigator.bodyCellItemEquals(item, previousItem);
                };
                return TablixRowDimension;
            }(TablixDimension));
            controls.TablixRowDimension = TablixRowDimension;
            var TablixColumnDimension = (function (_super) {
                __extends(TablixColumnDimension, _super);
                function TablixColumnDimension(tablixControl) {
                    _super.call(this, tablixControl);
                    this._layoutManager = this._tablixLayoutManager.columnLayoutManager;
                }
                TablixColumnDimension.prototype._render = function () {
                    var firstVisibleColumnItem = this.getFirstVisibleItem(0);
                    if (firstVisibleColumnItem !== undefined) {
                        this.addNodes(this.model, 0, this.getDepth(), this._hierarchyNavigator.getIndex(firstVisibleColumnItem));
                    }
                };
                TablixColumnDimension.prototype._createScrollbar = function (parentElement, layoutKind) {
                    var scrollbar = new controls.HorizontalScrollbar(parentElement, layoutKind);
                    // Set smallest increment of the scrollbar to 0.2 rows
                    scrollbar.smallIncrement = 0.2;
                    return scrollbar;
                };
                TablixColumnDimension.prototype.addNodes = function (items, columnIndex, depth, firstVisibleIndex) {
                    var count = this._hierarchyNavigator.getCount(items);
                    for (var i = firstVisibleIndex; i < count; i++) {
                        if (!this._layoutManager.needsToRealize) {
                            return;
                        }
                        var cell = this.addNode(this._hierarchyNavigator.getAt(items, i), items, columnIndex, depth);
                        columnIndex += cell.colSpan;
                    }
                };
                TablixColumnDimension.prototype.addNode = function (item, items, columnIndex, depth) {
                    var cell = this._tablixLayoutManager.getOrCreateColumnHeader(item, items, this._hierarchyNavigator.getLevel(item), columnIndex);
                    var match = this.columnHeaderMatch(item, cell);
                    if (!match) {
                        this._owner._unbindCell(cell);
                        cell.type = 2 /* ColumnHeader */;
                        cell.item = item;
                        cell.unfixRowHeight();
                    }
                    if (this._hierarchyNavigator.isLeaf(item)) {
                        cell.rowSpan = depth - this._hierarchyNavigator.getLevel(item);
                    }
                    else {
                        var previousCount = this._layoutManager.getRealizedItemsCount();
                        this.addNodes(this._hierarchyNavigator.getChildren(item), columnIndex, depth, this.getFirstVisibleChildIndex(item));
                        // In case we have a grand total with multiple measures, the multi-measures will be direct children
                        // There can be difference in level > 1. In this case, we want the Total cell to have rowspan = the difference
                        var childrenLevelDifference = this._hierarchyNavigator.getChildrenLevelDifference(item);
                        if (childrenLevelDifference === Infinity)
                            cell.rowSpan = 1;
                        else
                            cell.rowSpan = childrenLevelDifference;
                        cell.colSpan = this._layoutManager.getRealizedItemsCount() - previousCount + 1;
                    }
                    if (!match)
                        this._binder.bindColumnHeader(item, cell);
                    this._tablixLayoutManager.onColumnHeaderRealized(item, cell);
                    return cell;
                };
                TablixColumnDimension.prototype.columnHeaderMatch = function (item, cell) {
                    var previousItem = cell.item;
                    return cell.type === 2 /* ColumnHeader */ && previousItem && this._hierarchyNavigator.headerItemEquals(item, previousItem);
                };
                return TablixColumnDimension;
            }(TablixDimension));
            controls.TablixColumnDimension = TablixColumnDimension;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            /**
             * This class represents the touch region of the column headers (this can also apply to footer/total).
             * This class is reponsible for interpreting gestures in terms of pixels to changes in column position.
             *
             * Unlike the table body, this can only scroll in one direction.
             */
            var ColumnTouchDelegate = (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function ColumnTouchDelegate(region) {
                    this.dim = region;
                    this.averageSize = 1; //default
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(ColumnTouchDelegate.prototype, "dimension", {
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of columns to be shifted per delta in pixels.
                 *
                 * @param xRatio Column to pixel ratio (# columns / # pixels).
                 */
                ColumnTouchDelegate.prototype.setScrollDensity = function (xRatio) {
                    this.averageSize = xRatio;
                };
                /**
                 * Resize element.
                 *
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                ColumnTouchDelegate.prototype.resize = function (x, y, width, height) {
                    this.dim.x = x;
                    this.dim.y = y;
                    this.dim.width = width;
                    this.dim.height = height;
                };
                /**
                 * @see IPixelToItem.
                 */
                ColumnTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this.averageSize, 0, down, -dx * this.averageSize, 0);
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                ColumnTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [];
                    args[0] = this.tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                ColumnTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                return ColumnTouchDelegate;
            }());
            controls.ColumnTouchDelegate = ColumnTouchDelegate;
            /**
             * This class represents the touch region of the row headers (left or right side aligned).
             * This class is reponsible for interpreting gestures in terms of pixels to changes in row position.
             *
             * Unlike the table body, this can only scroll in one direction.
             */
            var RowTouchDelegate = (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function RowTouchDelegate(region) {
                    this.dim = region;
                    this.averageSize = 30; //default
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(RowTouchDelegate.prototype, "dimension", {
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of rows to be shifted per delta in pixels.
                 *
                 * @param yRatio Row to pixel ratio (# rows / # pixels).
                 */
                RowTouchDelegate.prototype.setScrollDensity = function (yRatio) {
                    this.averageSize = yRatio;
                };
                /**
                 * Resize element.
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                RowTouchDelegate.prototype.resize = function (x, y, width, height) {
                    this.dim.x = x;
                    this.dim.y = y;
                    this.dim.width = width;
                    this.dim.height = height;
                };
                /**
                 * @see: IPixelToItem
                 */
                RowTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    var event = new controls.TouchUtils.TouchEvent(0, y * this.averageSize, down, 0, -dy * this.averageSize);
                    return event;
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                RowTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [];
                    args[0] = this.tablixControl;
                    args[1] = e.dx;
                    args[2] = e.dy;
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                RowTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                return RowTouchDelegate;
            }());
            controls.RowTouchDelegate = RowTouchDelegate;
            /**
             * This class represents the touch region covering the body of the table.
             * This class is reponsible for interpreting gestures in terms of pixels to
             * changes in row and column position.
             */
            var BodyTouchDelegate = (function () {
                /**
                 * @constructor
                 * @param region Location and area of the touch region in respect to its HTML element.
                 */
                function BodyTouchDelegate(region) {
                    this.dim = region;
                    this.averageSizeX = BodyTouchDelegate.DefaultAverageSizeX;
                    this.averageSizeY = BodyTouchDelegate.DefaultAverageSizeY;
                    this.handlers = null;
                    this.tablixControl = null;
                }
                Object.defineProperty(BodyTouchDelegate.prototype, "dimension", {
                    /**
                     * Returns dimension.
                     *
                     * @return The dimentions of the region this delegate listens to.
                     */
                    get: function () {
                        return this.dim;
                    },
                    enumerable: true,
                    configurable: true
                });
                /**
                 * Sets the amount of rows and columns to be shifted per delta in pixels.
                 *
                 * @param xRatio Column to pixel ratio (# columns / # pixels)
                 * @param yRatio Row to pixel ratio (# rows / # pixels)
                 */
                BodyTouchDelegate.prototype.setScrollDensity = function (xRatio, yRatio) {
                    this.averageSizeX = xRatio;
                    this.averageSizeY = yRatio;
                };
                /**
                 * Resize element.
                 *
                 * @param x X location from upper left of listened HTML element.
                 * @param y Y location from upper left of listened HTML element.
                 * @param width Width of area to listen for events.
                 * @param height Height of area to listen for events.
                 */
                BodyTouchDelegate.prototype.resize = function (x, y, width, height) {
                    var dimension = this.dim;
                    dimension.x = x;
                    dimension.y = y;
                    dimension.width = width;
                    dimension.height = height;
                };
                /**
                 * @see: IPixelToItem.
                 */
                BodyTouchDelegate.prototype.getPixelToItem = function (x, y, dx, dy, down) {
                    return new controls.TouchUtils.TouchEvent(x * this.averageSizeX, y * this.averageSizeY, down, -dx * this.averageSizeX, -dy * this.averageSizeY);
                };
                /**
                 * Fires event to Tablix Control to scroll with the event passed from the TouchManager.
                 *
                 * @param e Event recieved from touch manager.
                 */
                BodyTouchDelegate.prototype.touchEvent = function (e) {
                    var args = [this.tablixControl, e.dx, e.dy];
                    if (this.handlers) {
                        controls.fire([this.handlers], args);
                    }
                };
                /**
                 * Asigns handler for scrolling when scroll event is fired.
                 *
                 * @param tablixObj TablixControl that's handling the fired event.
                 * @param handlerCall The call to be made (EXAMPLE: handlerCall = object.method;).
                 */
                BodyTouchDelegate.prototype.setHandler = function (tablixObj, handlerCall) {
                    this.handlers = handlerCall;
                    this.tablixControl = tablixObj;
                };
                BodyTouchDelegate.DefaultAverageSizeX = 30;
                BodyTouchDelegate.DefaultAverageSizeY = 30;
                return BodyTouchDelegate;
            }());
            controls.BodyTouchDelegate = BodyTouchDelegate;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var TouchUtils;
            (function (TouchUtils) {
                var Point = (function () {
                    function Point(x, y) {
                        this.x = x || 0;
                        this.y = y || 0;
                    }
                    Point.prototype.offset = function (offsetX, offsetY) {
                        this.x += offsetX;
                        this.y += offsetY;
                    };
                    return Point;
                }());
                TouchUtils.Point = Point;
                var Rectangle = (function (_super) {
                    __extends(Rectangle, _super);
                    function Rectangle(x, y, width, height) {
                        _super.call(this, x, y);
                        this.width = width || 0;
                        this.height = height || 0;
                    }
                    Object.defineProperty(Rectangle.prototype, "point", {
                        get: function () {
                            return new Point(this.x, this.y);
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Rectangle.prototype.contains = function (p) {
                        return Rectangle.contains(this, p);
                    };
                    Rectangle.contains = function (rect, p) {
                        if (p && !Rectangle.isEmpty(rect)) {
                            return rect.x <= p.x && p.x < rect.x + rect.width && rect.y <= p.y && p.y < rect.y + rect.height;
                        }
                        return false;
                    };
                    Rectangle.isEmpty = function (rect) {
                        return !(rect !== undefined && rect.width >= 0 && rect.height >= 0);
                    };
                    return Rectangle;
                }(Point));
                TouchUtils.Rectangle = Rectangle;
                (function (MouseButton) {
                    MouseButton[MouseButton["NoClick"] = 0] = "NoClick";
                    MouseButton[MouseButton["LeftClick"] = 1] = "LeftClick";
                    MouseButton[MouseButton["RightClick"] = 2] = "RightClick";
                    MouseButton[MouseButton["CenterClick"] = 3] = "CenterClick";
                })(TouchUtils.MouseButton || (TouchUtils.MouseButton = {}));
                var MouseButton = TouchUtils.MouseButton;
                /**
                 * A simple touch event class that's abstracted away from any platform specific traits.
                 */
                var TouchEvent = (function () {
                    /**
                     * @constructor
                     * @param x X Location of mouse.
                     * @param y Y Location of mouse.
                     * @param isMouseDown Indicates if the mouse button is held down or a finger press on screen.
                     * @param dx (optional) The change in x of the gesture.
                     * @param dy (optional) The change in y of the gesture.
                     */
                    function TouchEvent(x, y, isMouseDown, dx, dy) {
                        this._x = x;
                        this._y = y;
                        this.isMouseButtonDown = isMouseDown;
                        this._dx = dx || 0;
                        this._dy = dy || 0;
                    }
                    Object.defineProperty(TouchEvent.prototype, "x", {
                        get: function () {
                            return this._x;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "y", {
                        get: function () {
                            return this._y;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dx", {
                        get: function () {
                            return this._dx;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "dy", {
                        get: function () {
                            return this._dy;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    Object.defineProperty(TouchEvent.prototype, "isMouseDown", {
                        /**
                         * Returns a boolean indicating if the mouse button is held down.
                         *
                         * @return: True if the the mouse button is held down,
                         * otherwise false.
                         */
                        get: function () {
                            return this.isMouseButtonDown;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    return TouchEvent;
                }());
                TouchUtils.TouchEvent = TouchEvent;
                /**
                 * This class "listens" to the TouchEventInterpreter  to recieve touch events and sends it to all
                 * "Touch Delegates" with  TouchRegions that contain the mouse event. Prior to sending off the
                 * event, its position is put in respect to the delegate's TouchRegion and converted to the appropriate
                 * unit (see IPixelToItem).
                 */
                var TouchManager = (function () {
                    /**
                     * Default constructor.
                     *
                     * The default behavior is to enable thresholds and lock to axis.
                     */
                    function TouchManager() {
                        this.touchList = [];
                        this.swipeDirection = 2 /* FreeForm */;
                        this.matchingDirectionCount = 0;
                        this.lockThreshold = true;
                        this.scrollThreshold = true;
                        this.lastTouchEvent = new TouchEvent(0, 0, false);
                    }
                    Object.defineProperty(TouchManager.prototype, "lastEvent", {
                        get: function () {
                            return this.lastTouchEvent;
                        },
                        enumerable: true,
                        configurable: true
                    });
                    /**
                     * @param region Rectangle indicating the locations of the touch region.
                     * @param handler Handler for recieved touch events.
                     * @param converter Converts from pixels to the wanted item of measure (rows, columns, etc).
                     *
                     * EXAMPLE: dx -> from # of pixels to the right to # of columns moved to the right.
                     */
                    TouchManager.prototype.addTouchRegion = function (region, handler, converter) {
                        var item = {
                            lastPoint: new TouchEvent(0, 0, false),
                            handler: handler,
                            region: region,
                            converter: converter
                        };
                        this.touchList = this.touchList.concat([item]);
                    };
                    /**
                     * Sends a mouse up event to all regions with their last event as a mouse down event.
                     */
                    TouchManager.prototype.upAllTouches = function () {
                        var eventPoint;
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].lastPoint.isMouseDown) {
                                eventPoint = this.touchList[i].converter.getPixelToItem(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, 0, 0, false);
                                this.touchList[i].handler.touchEvent(eventPoint);
                            }
                            this.touchList[i].lastPoint = new TouchEvent(this.touchList[i].lastPoint.x, this.touchList[i].lastPoint.y, false);
                        }
                        this.lastTouchEvent = new TouchEvent(0, 0, false);
                    };
                    TouchManager.prototype.touchEvent = function (e) {
                        var list;
                        var length;
                        var x = 0;
                        var y = 0;
                        var dx = 0;
                        var dy = 0;
                        var angle = 0;
                        var eventPoint = null;
                        //assume there are already regions in the middle of a drag event and get those regions
                        list = this._getActive();
                        //if this is the start of a mouse drag event, repopulate the list with touched regions
                        if (!this.lastTouchEvent.isMouseDown && e.isMouseDown) {
                            list = this._findRegions(e);
                        }
                        //determine the delta values and update last event (delta ignored on first mouse down event)
                        dx = this.lastTouchEvent.x - e.x;
                        dy = this.lastTouchEvent.y - e.y;
                        this.lastTouchEvent = new TouchEvent(e.x, e.y, e.isMouseDown, dx, dy);
                        //go through the list
                        length = list.length;
                        for (var i = 0; i < length; i++) {
                            x = e.x - list[i].region.point.x;
                            y = e.y - list[i].region.point.y;
                            //is this in the middle of a drag?
                            if (list[i].lastPoint.isMouseDown && e.isMouseDown) {
                                dx = x - list[i].lastPoint.x;
                                dy = y - list[i].lastPoint.y;
                                //calculate the absolute angle from the horizontal axis
                                angle = Math.abs(180 / Math.PI * Math.atan(dy / dx));
                                if (this.scrollThreshold) {
                                    //is the gesture already locked? (6 prior events within the threshold)
                                    if (this.lockThreshold && (this.matchingDirectionCount > 5)) {
                                        if (this.swipeDirection === 1 /* Horizontal */) {
                                            dy = 0;
                                        }
                                        else if (this.swipeDirection === 0 /* Vertical */) {
                                            dx = 0;
                                        }
                                    }
                                    else {
                                        //is it within the horizontal threshold?
                                        if (angle < 20) {
                                            dy = 0;
                                            if (this.swipeDirection === 1 /* Horizontal */) {
                                                this.matchingDirectionCount++;
                                            }
                                            else {
                                                this.matchingDirectionCount = 1;
                                                this.swipeDirection = 1 /* Horizontal */;
                                            }
                                        }
                                        else {
                                            //calculate the absolute angle from the vertical axis
                                            angle = Math.abs(180 / Math.PI * Math.atan(dx / dy));
                                            //is it within the horizontal threshold?
                                            if (angle < 20) {
                                                dx = 0;
                                                if (this.swipeDirection === 0 /* Vertical */) {
                                                    this.matchingDirectionCount++;
                                                }
                                                else {
                                                    this.matchingDirectionCount = 1;
                                                    this.swipeDirection = 0 /* Vertical */;
                                                }
                                            }
                                            else {
                                                if (this.swipeDirection === 2 /* FreeForm */) {
                                                    this.matchingDirectionCount++;
                                                }
                                                else {
                                                    this.swipeDirection = 2 /* FreeForm */;
                                                    this.matchingDirectionCount = 1;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            else {
                                dx = 0;
                                dy = 0;
                                this.swipeDirection = 2 /* FreeForm */;
                                this.matchingDirectionCount = 0;
                            }
                            list[i].lastPoint = new TouchEvent(x, y, e.isMouseDown, dx, dy);
                            eventPoint = list[i].converter.getPixelToItem(x, y, dx, dy, e.isMouseDown);
                            list[i].handler.touchEvent(eventPoint);
                        }
                    };
                    /**
                     * @param e Position of event used to find touched regions
                     * @return Array of regions that contain the event point.
                     */
                    TouchManager.prototype._findRegions = function (e) {
                        var list = [];
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].region.contains(new Point(e.x, e.y))) {
                                list = list.concat([this.touchList[i]]);
                            }
                        }
                        return list;
                    };
                    /**
                     * @return Array of regions that contain a mouse down event. (see ITouchHandlerSet.lastPoint).
                     */
                    TouchManager.prototype._getActive = function () {
                        var list = [];
                        var length;
                        length = this.touchList.length;
                        for (var i = 0; i < length; i++) {
                            if (this.touchList[i].lastPoint.isMouseDown) {
                                list = list.concat([this.touchList[i]]);
                            }
                        }
                        return list;
                    };
                    return TouchManager;
                }());
                TouchUtils.TouchManager = TouchManager;
                var MinDistanceForSwipe = 80;
                var MaxTimeForSwipe = 600;
                /**
                 * This class is responsible for establishing connections to handle touch events
                 * and to interpret those events so they're compatible with the touch abstractions.
                 *
                 * Touch events with platform specific handles should be done here.
                 */
                var TouchEventInterpreter = (function () {
                    function TouchEventInterpreter(manager) {
                        this.manager = manager;
                        this.allowMouseDrag = true;
                        this.touchPanel = null;
                        this.scale = 1;
                        this.documentMouseMoveWrapper = null;
                        this.documentMouseUpWrapper = null;
                        this.sliding = false;
                    }
                    TouchEventInterpreter.prototype.initTouch = function (panel, touchReferencePoint, allowMouseDrag) {
                        var _this = this;
                        panel.style.setProperty("-ms-touch-action", "pinch-zoom");
                        this.touchReferencePoint = touchReferencePoint;
                        this.touchPanel = panel;
                        this.allowMouseDrag = allowMouseDrag === undefined ? true : allowMouseDrag;
                        if ("ontouchmove" in panel) {
                            panel.addEventListener("touchstart", function (e) { return _this.onTouchStart(e); });
                            panel.addEventListener("touchend", function (e) { return _this.onTouchEnd(e); });
                        }
                        else {
                            panel.addEventListener("mousedown", function (e) { return _this.onTouchMouseDown(e); });
                            panel.addEventListener("mouseup", function (e) { return _this.onTouchMouseUp(e); });
                        }
                    };
                    TouchEventInterpreter.prototype.getXYByClient = function (pageX, pageY, rect) {
                        var x = rect.left;
                        var y = rect.top;
                        // Fix for Safari
                        if (window["scrollX"] !== undefined) {
                            x += window["scrollX"];
                            y += window["scrollY"];
                        }
                        var point = new Point(0, 0);
                        point.offset(pageX - x, pageY - y);
                        return point;
                    };
                    TouchEventInterpreter.prototype.onTouchStart = function (e) {
                        if (e.touches.length === 1) {
                            e.cancelBubble = true;
                            var mouchEvent = e.touches[0];
                            this.touchStartTime = new Date().getTime();
                            this.touchStartPageY = mouchEvent.pageY;
                            this.onTouchMouseDown(mouchEvent);
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMove = function (e) {
                        if (e.touches.length === 1) {
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            var mouchEvent = e.touches[0];
                            this.touchLastPageY = mouchEvent.pageY;
                            this.touchLastPageX = mouchEvent.pageX;
                            // while sliding ignore the touch move event 
                            if (!this.sliding) {
                                this.onTouchMouseMove(mouchEvent);
                            }
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchEnd = function (e) {
                        this.clearTouchEvents();
                        var swipeInfo = this.getSwipeInfo();
                        if (this.didUserSwipe(swipeInfo)) {
                            this.startSlideAffect(swipeInfo);
                        }
                        else if (!this.sliding) {
                            this.upAllTouches();
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMouseDown = function (e) {
                        var _this = this;
                        this.scale = controls.HTMLElementUtils.getAccumulatedScale(this.touchPanel);
                        //any prior touch scrolling that produced a selection outside Tablix will prevent the next touch scroll (1262519)
                        document.getSelection().removeAllRanges();
                        this.rect = (this.touchReferencePoint ? this.touchReferencePoint : this.touchPanel).getBoundingClientRect();
                        if ("ontouchmove" in this.touchPanel) {
                            this.documentMouseMoveWrapper = function (e) { return _this.onTouchMove(e); };
                            document.addEventListener("touchmove", this.documentMouseMoveWrapper);
                            this.documentMouseUpWrapper = function (e) { return _this.onTouchEnd(e); };
                            document.addEventListener("touchend", this.documentMouseUpWrapper);
                        }
                        else {
                            this.documentMouseMoveWrapper = function (e) { return _this.onTouchMouseMove(e); };
                            document.addEventListener("mousemove", this.documentMouseMoveWrapper);
                            this.documentMouseUpWrapper = function (e) { return _this.onTouchMouseUp(e); };
                            document.addEventListener("mouseup", this.documentMouseUpWrapper);
                        }
                        if ("setCapture" in this.touchPanel) {
                            this.touchPanel.setCapture();
                        }
                    };
                    TouchEventInterpreter.prototype.onTouchMouseMove = function (e) {
                        var event;
                        var point;
                        var rect = this.rect;
                        var validMouseDragEvent = (rect !== null) && (e.which !== MouseButton.NoClick);
                        // Ignore events that are not part of a drag event
                        if (!validMouseDragEvent || this.sliding)
                            return;
                        point = this.getXYByClient(e.pageX, e.pageY, rect);
                        event = new TouchEvent(point.x / this.scale, point.y / this.scale, validMouseDragEvent);
                        this.manager.touchEvent(event);
                        if (e.preventDefault)
                            e.preventDefault();
                        else if ("returnValue" in e)
                            e["returnValue"] = false;
                    };
                    TouchEventInterpreter.prototype.onTouchMouseUp = function (e, bubble) {
                        this.upAllTouches();
                        this.clearTouchEvents();
                    };
                    TouchEventInterpreter.prototype.getSwipeInfo = function () {
                        var touchEndTime = new Date().getTime();
                        var touchTime = touchEndTime - this.touchStartTime;
                        var touchDist = this.touchLastPageY - this.touchStartPageY;
                        var touchDirection = touchDist < 0 ? -1 : 1;
                        return {
                            direction: touchDirection,
                            distance: touchDist,
                            endTime: touchEndTime,
                            time: touchTime,
                        };
                    };
                    TouchEventInterpreter.prototype.didUserSwipe = function (swipeInfo) {
                        return swipeInfo.time < MaxTimeForSwipe && swipeInfo.distance * swipeInfo.direction > MinDistanceForSwipe;
                    };
                    /**
                     * In case of swipe - auto advance to the swipe direction in 2 steps.
                     */
                    TouchEventInterpreter.prototype.startSlideAffect = function (swipeInfo) {
                        var _this = this;
                        if (this.sliding) {
                            return;
                        }
                        this.sliding = true;
                        var point = this.getXYByClient(this.touchLastPageX, this.touchLastPageY, this.rect);
                        this.slide(point, 300, swipeInfo);
                        // second step
                        requestAnimationFrame(function () {
                            // in case the user is now scrolling in the opposite direction stop the slide
                            if (!_this.didUserChangeDirection(swipeInfo)) {
                                _this.slide(point, 200, swipeInfo);
                            }
                            _this.clearSlide();
                        });
                    };
                    TouchEventInterpreter.prototype.didUserChangeDirection = function (swipeInfo) {
                        if (this.touchStartTime <= swipeInfo.endTime) {
                            return false;
                        }
                        var updatedDist = this.touchLastPageY - this.touchStartPageY;
                        var updatedDirection = updatedDist < 0 ? -1 : 1;
                        return updatedDirection !== swipeInfo.direction;
                    };
                    TouchEventInterpreter.prototype.slide = function (point, slideDist, swipeInfo) {
                        var updatedDist = this.touchStartTime > swipeInfo.endTime ? this.touchLastPageY - this.touchStartPageY : 0;
                        point.y += slideDist * swipeInfo.direction + updatedDist;
                        var event = new TouchEvent(point.x / this.scale, point.y / this.scale, true);
                        this.manager.touchEvent(event);
                    };
                    TouchEventInterpreter.prototype.clearSlide = function () {
                        this.sliding = false;
                        this.upAllTouches();
                    };
                    TouchEventInterpreter.prototype.upAllTouches = function () {
                        if (this.documentMouseMoveWrapper !== null)
                            return;
                        this.rect = null;
                        this.manager.upAllTouches();
                    };
                    TouchEventInterpreter.prototype.clearTouchEvents = function () {
                        if ("releaseCapture" in this.touchPanel) {
                            this.touchPanel.releaseCapture();
                        }
                        if (this.documentMouseMoveWrapper === null)
                            return;
                        if ("ontouchmove" in this.touchPanel) {
                            document.removeEventListener("touchmove", this.documentMouseMoveWrapper);
                            document.removeEventListener("touchend", this.documentMouseUpWrapper);
                        }
                        else {
                            document.removeEventListener("mousemove", this.documentMouseMoveWrapper);
                            document.removeEventListener("mouseup", this.documentMouseUpWrapper);
                        }
                        this.documentMouseMoveWrapper = null;
                        this.documentMouseUpWrapper = null;
                    };
                    return TouchEventInterpreter;
                }());
                TouchUtils.TouchEventInterpreter = TouchEventInterpreter;
            })(TouchUtils = controls.TouchUtils || (controls.TouchUtils = {}));
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            (function (TablixType) {
                TablixType[TablixType["Matrix"] = 0] = "Matrix";
                TablixType[TablixType["Table"] = 1] = "Table";
            })(controls.TablixType || (controls.TablixType = {}));
            var TablixType = controls.TablixType;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var controls;
        (function (controls) {
            var PropAutoSizeWidth = controls.internal.TablixObjects.PropGeneralAutoSizeColumns;
            var getMetadataObjects = controls.internal.TablixObjects.getMetadadataObjects;
            var TablixColumnWidthManager = (function () {
                function TablixColumnWidthManager(dataView, isMatrix, hostPersistCallBack, matrixLeafNodes) {
                    this.columnWidthObjects = [];
                    this.isMatrix = isMatrix;
                    this.updateDataView(dataView, matrixLeafNodes);
                    this.hostPersistCallBack = hostPersistCallBack;
                }
                /**
                 * Update the current DataView
                 * @param {dataView} DataView new DataView
                 * @param {MatrixVisualNode[]} matrixLeafNodes? (Optional)Matrix Leaf Nodes
                 */
                TablixColumnWidthManager.prototype.updateDataView = function (dataView, matrixLeafNodes) {
                    this.previousDataView = this.currentDataView;
                    if (this.previousDataView)
                        this.previousAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.previousDataView));
                    else
                        this.previousAutoColumnSizePropertyValue = undefined;
                    this.currentDataView = dataView;
                    if (this.currentDataView)
                        this.currentAutoColumnSizePropertyValue = PropAutoSizeWidth.getValue(getMetadataObjects(this.currentDataView));
                    else
                        this.currentAutoColumnSizePropertyValue = undefined;
                    this.matrixLeafNodes = matrixLeafNodes;
                    this.updateColumnWidthObjects();
                    this.updateTablixColumnWidths();
                };
                /**
                * Destroy columnWidthObjects and construct it again from the currently displayed Columns
                */
                TablixColumnWidthManager.prototype.updateColumnWidthObjects = function () {
                    this.columnWidthObjects.length = 0;
                    if (this.isMatrix)
                        this.updateMatrixColumnWidthObjects();
                    else
                        this.updateTableColumnWidthObjects();
                };
                TablixColumnWidthManager.prototype.updateTableColumnWidthObjects = function () {
                    if (this.currentDataView && this.currentDataView.table) {
                        var columnMetaData = this.currentDataView.table.columns;
                        for (var i = 0, len = columnMetaData.length; i < len; i++) {
                            var query = columnMetaData[i].queryName;
                            this.columnWidthObjects.push({
                                queryName: query,
                                width: undefined
                            });
                        }
                    }
                };
                TablixColumnWidthManager.prototype.updateMatrixColumnWidthObjects = function () {
                    // Matrix visual columns are row headers and column hierarchy leaves
                    if (this.currentDataView && this.currentDataView.matrix && this.currentDataView.matrix.rows) {
                        // Get query names of row groups (row headers)
                        for (var i = 0, len = this.currentDataView.matrix.rows.levels.length; i < len; i++) {
                            var rowGroup = this.currentDataView.matrix.rows.levels[i]; // TODO: Investigate multi-source groups
                            if (!_.isEmpty(rowGroup.sources))
                                this.columnWidthObjects.push({
                                    queryName: rowGroup.sources[0].queryName,
                                    width: undefined
                                });
                        }
                    }
                    // Get query names of columns leaves or values
                    if (this.matrixLeafNodes) {
                        for (var i = 0, len = this.matrixLeafNodes.length; i < len; i++) {
                            var query = this.matrixLeafNodes[i].queryName;
                            this.columnWidthObjects.push({
                                queryName: query,
                                width: undefined
                            });
                        }
                    }
                };
                /**
                 * Update the column widths after a dataViewChange
                 */
                TablixColumnWidthManager.prototype.updateTablixColumnWidths = function () {
                    var columnMetaData = this.currentDataView && this.currentDataView.metadata && this.currentDataView.metadata.columns;
                    if (columnMetaData) {
                        // Auto-Size false to true.
                        // Blow away any saved widths and revert back to default of calculating column sizes
                        if (this.shouldClearAllColumnWidths()) {
                            this.autoSizeAllColumns();
                        }
                        else {
                            this.deserializeColumnWidths(columnMetaData);
                        }
                    }
                };
                /**
                 * Read the Column Widths from the Columns metadata
                 * @param {DataViewMetadataColumn[]} columnMetaData Columns metadata
                 */
                TablixColumnWidthManager.prototype.deserializeColumnWidths = function (columnMetaData) {
                    // Clear existing widths
                    this.columnWidthObjects.forEach(function (obj) {
                        obj.width = undefined;
                    });
                    for (var _i = 0, columnMetaData_1 = columnMetaData; _i < columnMetaData_1.length; _i++) {
                        var column = columnMetaData_1[_i];
                        var columnWidthPropValue = powerbi.DataViewObjects.getValue(column.objects, TablixColumnWidthManager.columnWidthProp);
                        if (!_.isNumber(columnWidthPropValue)) {
                            continue;
                        }
                        for (var _a = 0, _b = this.columnWidthObjects; _a < _b.length; _a++) {
                            var obj = _b[_a];
                            if (obj.queryName === column.queryName) {
                                obj.width = columnWidthPropValue;
                            }
                        }
                    }
                };
                /**
                 * Returns a value indicating that autoSizeColumns was flipped from true to false
                 */
                TablixColumnWidthManager.prototype.shouldPersistAllColumnWidths = function () {
                    // We don't have a previous DataView -> Don't persist
                    if (!this.previousDataView)
                        // TODO: 6928446
                        // Once 6927388 gets fixed, we need to persist the DataView is first loaded with AutoSize off to count for missing set widths
                        return false;
                    else
                        return !this.currentAutoColumnSizePropertyValue && this.previousAutoColumnSizePropertyValue;
                };
                /**
                 * Returns a value indicating that autoSizeColumns was flipped from false to true
                 */
                TablixColumnWidthManager.prototype.shouldClearAllColumnWidths = function () {
                    return this.previousDataView != null && this.previousAutoColumnSizePropertyValue === false
                        && this.currentDataView != null && this.currentAutoColumnSizePropertyValue === true;
                };
                /**
                 * Returns the current columnWidthObjects
                 * @returns current columnWidthObjects including undefined widths for autosized columns
                 */
                TablixColumnWidthManager.prototype.getColumnWidthObjects = function () {
                    return this.columnWidthObjects;
                };
                /**
                 * Returns the current columnWidthObjects for only the fixed-size columns
                 * @returns Returns the current columnWidthObjects excluding auto-sized columns
                 */
                TablixColumnWidthManager.prototype.getFixedColumnWidthObjects = function () {
                    return this.columnWidthObjects.filter(function (obj) {
                        return obj.width != null;
                    });
                };
                /**
                 * Get the persisted width of a certain column in px, or undefined if the columns is set to autosize or index is out of range
                 * @param {number} index index of the Column
                 * @returns Column persisted width in pixel
                 */
                TablixColumnWidthManager.prototype.getPersistedColumnWidth = function (index) {
                    var colIndex = this.isMatrix ? index : index - 1;
                    var item = this.columnWidthObjects[colIndex];
                    if (item)
                        return item.width;
                    else
                        return undefined;
                };
                /**
                 * Call the host to persist the data
                 * @param {boolean} generateInstances
                 */
                TablixColumnWidthManager.prototype.callHostToPersist = function (generateInstances) {
                    if (generateInstances)
                        this.generateVisualObjectInstancesToPersist();
                    if (this.hostPersistCallBack) {
                        this.hostPersistCallBack(this.visualObjectInstancesToPersist);
                    }
                };
                /**
                 * Remove all persisted columns widths and Update visualObjectInstancesToPersist
                 */
                TablixColumnWidthManager.prototype.autoSizeAllColumns = function () {
                    this.visualObjectInstancesToPersist = {
                        merge: [this.getAutoSizeColumnWidthObject()],
                        remove: [],
                    };
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var columnWidthObject = _a[_i];
                        this.visualObjectInstancesToPersist.remove.push({
                            selector: { metadata: columnWidthObject.queryName },
                            objectName: 'general',
                            properties: {
                                columnWidth: undefined
                            }
                        });
                    }
                    this.callHostToPersist(false);
                };
                /**
                 * Remove persisted column width for a specific column and Update visualObjectInstancesToPersist
                 */
                TablixColumnWidthManager.prototype.onColumnAutosized = function (queryName) {
                    // If AutoSize option is ON, remove the persisted value
                    // Else, update the persisted value
                    var width = this.currentAutoColumnSizePropertyValue ? undefined : -1;
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        if (obj.queryName === queryName) {
                            obj.width = width;
                        }
                    }
                    ;
                    // If AutoSize option is ON, remove the persisted value
                    if (this.currentAutoColumnSizePropertyValue) {
                        this.visualObjectInstancesToPersist = {
                            remove: [{
                                    selector: { metadata: queryName },
                                    objectName: 'general',
                                    properties: { columnWidth: undefined }
                                }],
                        };
                        this.callHostToPersist(false);
                    }
                    // Else, do nothing. A Column Resize will be triggered soon
                };
                /**
                 * Handler for a column width change by the user
                 * @param {number} index zero-based index of the column, including hidden row header for table
                 * @param {number} width new width
                 */
                TablixColumnWidthManager.prototype.onColumnWidthChanged = function (index, width) {
                    // Table has a hidden row headers column
                    var colIndex = this.isMatrix ? index : index - 1;
                    if (_.isEmpty(this.columnWidthObjects) || colIndex < 0 || colIndex >= this.columnWidthObjects.length)
                        return;
                    var queryName = this.columnWidthObjects[colIndex].queryName;
                    // Column Autosize
                    if (width === -1) {
                        this.onColumnAutosized(queryName);
                    }
                    else {
                        for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                            var obj = _a[_i];
                            if (obj.queryName === queryName) {
                                obj.width = width;
                            }
                        }
                        ;
                        this.callHostToPersist(true);
                    }
                };
                /**
                 * Persist all column widths, called when autoSizeColumns flipped to false
                 * @param {number[]} widthsToPersist Widths to persist, including an empty row header for table
                 */
                TablixColumnWidthManager.prototype.persistAllColumnWidths = function (widthsToPersist) {
                    var _this = this;
                    // Table indices are offset with an empty header. 
                    var widths = this.isMatrix ? widthsToPersist : widthsToPersist.slice(1, widthsToPersist.length);
                    // ToDo: Handle this properly
                    // This happens when autosizing turns OFF before knowing all widths (lots of columns outside of ViewPort)
                    if (this.columnWidthObjects.length !== widths.length) {
                        return;
                    }
                    // Pick the maximum for each queryName
                    // This will ensure going from autoSize ON to OFF will not show any ellipsis
                    var dictionary = new Array();
                    widths.forEach(function (w, i) {
                        var query = _this.columnWidthObjects[i].queryName;
                        if (dictionary[query] == null)
                            dictionary[query] = w;
                        else
                            dictionary[query] = Math.max(w, dictionary[query]);
                    });
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        var width = dictionary[obj.queryName];
                        if (width != null)
                            obj.width = width;
                    }
                    this.callHostToPersist(true);
                };
                /**
                 * Construct a ColumnAutoSize object
                 * @returns ColumnAutoSize object
                 */
                TablixColumnWidthManager.prototype.getAutoSizeColumnWidthObject = function () {
                    return {
                        selector: null,
                        objectName: 'general',
                        properties: {
                            autoSizeColumnWidth: this.currentAutoColumnSizePropertyValue
                        }
                    };
                };
                /**
                 * Generate visualObjectInstances with autoSizeColumns and Column Widths
                 */
                TablixColumnWidthManager.prototype.generateVisualObjectInstancesToPersist = function () {
                    // ToDo: Ensure lists need to be reset after call to persist
                    // AutoSize Property
                    this.visualObjectInstancesToPersist = {
                        merge: [this.getAutoSizeColumnWidthObject()]
                    };
                    // Column Widths
                    var added = new Array();
                    for (var _i = 0, _a = this.columnWidthObjects; _i < _a.length; _i++) {
                        var obj = _a[_i];
                        // Only persist width if we have a valid queryName to use as selector
                        // ToDo: Not sure how we can have an item without a queryName
                        if (obj.queryName && _.isNumber(obj.width) && !added[obj.queryName]) {
                            this.visualObjectInstancesToPersist.merge.push({
                                selector: { metadata: obj.queryName },
                                objectName: 'general',
                                properties: {
                                    columnWidth: obj.width
                                }
                            });
                            added[obj.queryName] = true;
                        }
                    }
                };
                /**
                * PropertyID for Column Widths (General > columnWidth)
                */
                TablixColumnWidthManager.columnWidthProp = { objectName: 'general', propertyName: 'columnWidth' };
                return TablixColumnWidthManager;
            }());
            controls.TablixColumnWidthManager = TablixColumnWidthManager;
        })(controls = visuals.controls || (visuals.controls = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Base class for values that are animated when resized.
         */
        var AnimatedText = (function () {
            function AnimatedText(name) {
                this.mainText = jsCommon.CssConstants.createClassAndSelector('mainText');
                this.name = name;
                this.visualConfiguration = { maxFontSize: 60 };
            }
            AnimatedText.prototype.getMetaDataColumn = function (dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            this.metaDataColumn = column;
                            break;
                        }
                    }
                }
            };
            AnimatedText.prototype.getAdjustedFontHeight = function (availableWidth, textToMeasure, seedFontHeight) {
                var textProperties = {
                    fontFamily: null,
                    fontSize: null,
                    text: textToMeasure
                };
                var fontHeight = this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight, 0);
                return fontHeight;
            };
            AnimatedText.prototype.getAdjustedFontHeightCore = function (textProperties, availableWidth, seedFontHeight, iteration) {
                // Too many attempts - just return what we have so we don't sacrifice perf
                if (iteration > 10) {
                    return seedFontHeight;
                }
                textProperties.fontSize = jsCommon.PixelConverter.toString(seedFontHeight);
                var candidateLength = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                if (candidateLength < availableWidth)
                    return seedFontHeight;
                return this.getAdjustedFontHeightCore(textProperties, availableWidth, seedFontHeight * 0.9, iteration + 1);
            };
            AnimatedText.prototype.clear = function () {
                this.svg.select(this.mainText.selector).text('');
            };
            AnimatedText.prototype.doValueTransition = function (startValue, endValue, displayUnitSystemType, animationOptions, duration, forceUpdate, formatter) {
                if (!forceUpdate && startValue === endValue && endValue != null)
                    return;
                if (!startValue)
                    startValue = 0;
                var svg = this.svg, viewport = this.currentViewport, height = viewport.height, width = viewport.width, endValueArr = [endValue], seedFontHeight = this.getSeedFontHeight(width, height), translateX = this.getTranslateX(width), translateY = this.getTranslateY(seedFontHeight), metaDataColumn = this.metaDataColumn;
                // Respect the formatter default value
                if (!formatter) {
                    formatter = visuals.valueFormatter.create({
                        format: this.getFormatString(metaDataColumn),
                        value: endValue,
                        displayUnitSystemType: displayUnitSystemType,
                        formatSingleValues: true,
                        allowFormatBeautification: true,
                        columnType: metaDataColumn ? metaDataColumn.type : undefined
                    });
                }
                var startText = formatter.format(startValue), endText = formatter.format(endValue);
                svg.attr('class', this.name);
                var textElement = svg
                    .selectAll('text')
                    .data(endValueArr);
                textElement
                    .enter()
                    .append('text')
                    .attr('class', this.mainText.class);
                var fontHeight = this.getAdjustedFontHeight(width, endText, seedFontHeight);
                translateY = this.getTranslateY(fontHeight + (height - fontHeight) / 2);
                var textElementUpdate = textElement
                    .text(startText)
                    .attr({
                    'text-anchor': this.getTextAnchor(),
                    'font-size': fontHeight,
                    'transform': visuals.SVGUtil.translate(translateX, translateY),
                })
                    .style({
                    'fill': this.style.titleText.color.value,
                })
                    .call(visuals.tooltipUtils.tooltipUpdate, [startText]);
                if (endValue == null) {
                    textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [endText]);
                }
                else if (metaDataColumn && visuals.AxisHelper.isDateTime(metaDataColumn.type)) {
                    textElementUpdate.text(endText).call(visuals.tooltipUtils.tooltipUpdate, [endText]);
                }
                else {
                    var interpolatedValue_1 = startValue;
                    textElementUpdate
                        .transition()
                        .duration(duration)
                        .tween('text', function (d) {
                        var i = d3.interpolate(interpolatedValue_1, d);
                        return function (t) {
                            var num = i(t);
                            this.textContent = formatter.format(num);
                        };
                    });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(animationOptions);
            };
            AnimatedText.prototype.setTextColor = function (color) {
                this.style.titleText.color.value = color;
            };
            AnimatedText.prototype.getSeedFontHeight = function (boundingWidth, boundingHeight) {
                // Simply an estimate - it should eventually be modified based on the actual text length
                var estimatedSize = Math.floor(Math.min(boundingWidth, boundingHeight) * 0.75);
                var maxFontSize = this.visualConfiguration.maxFontSize;
                if (maxFontSize)
                    return Math.min(maxFontSize, estimatedSize);
                return estimatedSize;
            };
            AnimatedText.prototype.getTranslateX = function (width) {
                if (this.visualConfiguration) {
                    switch (this.visualConfiguration.align) {
                        case 'left':
                            return 0;
                        case 'right':
                            return width;
                    }
                }
                return width / 2;
            };
            AnimatedText.prototype.getTranslateY = function (height) {
                return height;
            };
            AnimatedText.prototype.getTextAnchor = function () {
                if (this.visualConfiguration) {
                    switch (this.visualConfiguration.align) {
                        case 'left':
                            return 'start';
                        case 'right':
                            return 'end';
                    }
                }
                return 'middle';
            };
            AnimatedText.prototype.getFormatString = function (column) {
                debug.assertAnyValue(column, 'column');
                return visuals.valueFormatter.getFormatString(column, AnimatedText.formatStringProp);
            };
            /** Note: Public for testability */
            AnimatedText.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            return AnimatedText;
        }());
        visuals.AnimatedText = AnimatedText;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * Renders a number that can be animate change in value.
         */
        var AnimatedNumber = (function (_super) {
            __extends(AnimatedNumber, _super);
            function AnimatedNumber(svg, animator) {
                _super.call(this, 'animatedNumber');
                if (svg)
                    this.svg = svg;
                if (animator)
                    this.animator = animator;
            }
            AnimatedNumber.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                if (!this.svg)
                    this.svg = d3.select(element.get(0)).append('svg');
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.style = options.style;
                this.updateViewportDependantProperties();
            };
            AnimatedNumber.prototype.updateViewportDependantProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width)
                    .attr('height', viewport.height);
            };
            AnimatedNumber.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (!dataViews || !dataViews[0]) {
                    return;
                }
                var dataView = dataViews[0];
                this.updateViewportDependantProperties();
                this.getMetaDataColumn(dataView);
                var newValue = dataView && dataView.single ? dataView.single.value : 0;
                if (newValue != null) {
                    this.updateInternal(newValue, options.suppressAnimations, true, this.formatter);
                }
            };
            AnimatedNumber.prototype.setFormatter = function (formatter) {
                this.formatter = formatter;
            };
            AnimatedNumber.prototype.onDataChanged = function (options) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            };
            AnimatedNumber.prototype.onResizing = function (viewport) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewport: viewport
                });
            };
            AnimatedNumber.prototype.canResizeTo = function (viewport) {
                // Temporarily disabling resize restriction.
                return true;
            };
            AnimatedNumber.prototype.updateInternal = function (target, suppressAnimations, forceUpdate, formatter) {
                if (forceUpdate === void 0) { forceUpdate = false; }
                var start = this.value || 0;
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                this.doValueTransition(start, target, 
                /*displayUnitSystemType*/ null, this.options.animation, duration, forceUpdate, formatter);
                this.value = target;
            };
            return AnimatedNumber;
        }(visuals.AnimatedText));
        visuals.AnimatedNumber = AnimatedNumber;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var BasicShapeVisual = (function () {
            function BasicShapeVisual(options) {
            }
            Object.defineProperty(BasicShapeVisual.prototype, "shapeType", {
                /**property for the shape line color */
                get: function () {
                    return this.data ? this.data.shapeType : BasicShapeVisual.DefaultShape;
                },
                set: function (shapeType) {
                    this.data.shapeType = shapeType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "lineColor", {
                /**property for the shape line color */
                get: function () {
                    return this.data ? this.data.lineColor : BasicShapeVisual.DefaultStrokeColor;
                },
                set: function (color) {
                    this.data.lineColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "lineTransparency", {
                /**property for the shape line transparency */
                get: function () {
                    return this.data ? this.data.lineTransparency : BasicShapeVisual.DefaultLineTransValue;
                },
                set: function (trans) {
                    this.data.lineTransparency = trans;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "lineWeight", {
                /**property for the shape line weight */
                get: function () {
                    return this.data ? this.data.lineWeight : BasicShapeVisual.DefaultWeightValue;
                },
                set: function (weight) {
                    this.data.lineWeight = weight;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "roundEdge", {
                /**property for the shape round edge */
                get: function () {
                    return this.data ? this.data.roundEdge : BasicShapeVisual.DefaultRoundEdgeValue;
                },
                set: function (roundEdge) {
                    this.data.roundEdge = roundEdge;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "showFill", {
                /**property for showing the fill properties */
                get: function () {
                    return this.data ? this.data.showFill : BasicShapeVisual.DefaultFillShowValue;
                },
                set: function (show) {
                    this.data.showFill = show;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "fillColor", {
                /**property for the shape line color */
                get: function () {
                    return this.data ? this.data.fillColor : BasicShapeVisual.DefaultFillColor;
                },
                set: function (color) {
                    this.data.fillColor = color;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "shapeTransparency", {
                /**property for the shape fill transparency */
                get: function () {
                    return this.data ? this.data.shapeTransparency : BasicShapeVisual.DefaultFillTransValue;
                },
                set: function (trans) {
                    this.data.shapeTransparency = trans;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BasicShapeVisual.prototype, "angle", {
                /**property for the shape angle */
                get: function () {
                    return this.data ? this.data.angle : BasicShapeVisual.DefaultAngle;
                },
                set: function (angle) {
                    this.data.angle = this.scaleTo360Deg(angle);
                },
                enumerable: true,
                configurable: true
            });
            BasicShapeVisual.prototype.init = function (options) {
                this.element = options.element;
                this.selection = d3.select(this.element.context);
                this.currentViewport = options.viewport;
            };
            BasicShapeVisual.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var dataViews = options.dataViews;
                if (!_.isEmpty(dataViews)) {
                    var dataView = options.dataViews[0];
                    if (dataView.metadata && dataView.metadata.objects) {
                        var dataViewObject = options.dataViews[0].metadata.objects;
                        this.data = this.getDataFromDataView(dataViewObject);
                    }
                }
                this.render();
            };
            BasicShapeVisual.prototype.getDataFromDataView = function (dataViewObject) {
                if (dataViewObject) {
                    return {
                        shapeType: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.general.shapeType, BasicShapeVisual.DefaultShape),
                        lineColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.lineColor, BasicShapeVisual.DefaultStrokeColor)),
                        lineTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.transparency, BasicShapeVisual.DefaultLineTransValue),
                        lineWeight: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.weight, BasicShapeVisual.DefaultWeightValue),
                        roundEdge: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.line.roundEdge, BasicShapeVisual.DefaultRoundEdgeValue),
                        shapeTransparency: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.transparency, BasicShapeVisual.DefaultFillTransValue),
                        fillColor: this.getValueFromColor(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.fillColor, BasicShapeVisual.DefaultFillColor)),
                        showFill: powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.fill.show, BasicShapeVisual.DefaultFillShowValue),
                        angle: this.scaleTo360Deg(powerbi.DataViewObjects.getValue(dataViewObject, visuals.basicShapeProps.rotation.angle, BasicShapeVisual.DefaultAngle))
                    };
                }
                return null;
            };
            BasicShapeVisual.prototype.scaleTo360Deg = function (angle) {
                if (angle !== 0 && (Math.abs(angle) % 360) === 0)
                    return angle;
                angle = angle % 360;
                angle = (angle + 360) % 360;
                return angle;
            };
            BasicShapeVisual.prototype.getValueFromColor = function (color) {
                return color.solid ? color.solid.color : color;
            };
            BasicShapeVisual.prototype.enumerateObjectInstances = function (options) {
                var objectInstances = [];
                switch (options.objectName) {
                    case 'line':
                        var instance = {
                            selector: null,
                            properties: {
                                lineColor: this.lineColor,
                                transparency: this.lineTransparency,
                                weight: this.lineWeight
                            },
                            objectName: options.objectName
                        };
                        if (this.data.shapeType === visuals.basicShapeType.rectangle) {
                            instance.properties['roundEdge'] = this.roundEdge;
                        }
                        objectInstances.push(instance);
                        return objectInstances;
                    case 'fill':
                        if (this.shapeType !== visuals.basicShapeType.line) {
                            objectInstances.push({
                                selector: null,
                                properties: {
                                    show: this.showFill,
                                    fillColor: this.fillColor,
                                    transparency: this.shapeTransparency
                                },
                                objectName: options.objectName
                            });
                        }
                        return objectInstances;
                    case 'rotation':
                        objectInstances.push({
                            selector: null,
                            properties: {
                                angle: this.angle
                            },
                            objectName: options.objectName
                        });
                        return objectInstances;
                }
                return null;
            };
            BasicShapeVisual.prototype.render = function () {
                this.selection.html('');
                switch (this.shapeType) {
                    case visuals.basicShapeType.rectangle:
                        visuals.ShapeFactory.createRectangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    case visuals.basicShapeType.oval:
                        visuals.ShapeFactory.createOval(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    case visuals.basicShapeType.line:
                        visuals.ShapeFactory.createLine(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    case visuals.basicShapeType.arrow:
                        visuals.ShapeFactory.createUpArrow(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    case visuals.basicShapeType.triangle:
                        visuals.ShapeFactory.createTriangle(this.data, this.currentViewport.height, this.currentViewport.width, this.selection, this.angle);
                        break;
                    default:
                        break;
                }
            };
            BasicShapeVisual.DefaultShape = visuals.basicShapeType.rectangle;
            BasicShapeVisual.DefaultStrokeColor = '#00B8AA';
            BasicShapeVisual.DefaultFillColor = '#E6E6E6';
            BasicShapeVisual.DefaultFillShowValue = true;
            BasicShapeVisual.DefaultFillTransValue = 0;
            BasicShapeVisual.DefaultWeightValue = 3;
            BasicShapeVisual.DefaultLineTransValue = 0;
            BasicShapeVisual.DefaultRoundEdgeValue = 0;
            BasicShapeVisual.DefaultAngle = 0;
            return BasicShapeVisual;
        }());
        visuals.BasicShapeVisual = BasicShapeVisual;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var DEFAULT_AXIS_SCALE_TYPE = visuals.axisScale.linear;
        var COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE = 0.1;
        // the interactive right margin is set to be the circle selection radius of the hover line
        var INTERACTIVITY_RIGHT_MARGIN = 6;
        visuals.DEFAULT_AXIS_COLOR = '#777';
        /**
         * Renders a data series as a cartestian visual.
         */
        var CartesianChart = (function () {
            function CartesianChart(options) {
                this.xRefLine = createClassAndSelector('x-ref-line');
                this.y1RefLine = createClassAndSelector('y1-ref-line');
                var isScrollable = false;
                this.trimOrdinalDataOnOverflow = true;
                if (options) {
                    this.tooltipsEnabled = options.tooltipsEnabled;
                    this.type = options.chartType;
                    this.isLabelInteractivityEnabled = options.isLabelInteractivityEnabled;
                    this.lineChartLabelDensityEnabled = options.lineChartLabelDensityEnabled;
                    if (options.trimOrdinalDataOnOverflow !== undefined)
                        this.trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow;
                    if (options.isScrollable)
                        isScrollable = options.isScrollable;
                    this.animator = options.animator;
                    if (options.cartesianSmallViewPortProperties) {
                        this.cartesianSmallViewPortProperties = options.cartesianSmallViewPortProperties;
                    }
                    if (options.behavior) {
                        this.behavior = options.behavior;
                    }
                }
                this.axes = new CartesianAxes(isScrollable, ScrollableAxes.ScrollbarWidth, this.trimOrdinalDataOnOverflow);
                this.svgAxes = new SvgCartesianAxes(this.axes);
                this.svgBrush = new SvgBrush(ScrollableAxes.ScrollbarWidth);
                this.scrollableAxes = new ScrollableAxes(this.axes, this.svgBrush);
            }
            CartesianChart.getAxisVisibility = function (type) {
                switch (type) {
                    case 6 /* StackedBar */:
                    case 5 /* ClusteredBar */:
                    case 7 /* HundredPercentStackedBar */:
                        return 1 /* ShowLinesOnXAxis */;
                    case 9 /* Scatter */:
                        return 3 /* ShowLinesOnBothAxis */;
                    default:
                        return 2 /* ShowLinesOnYAxis */;
                }
            };
            CartesianChart.prototype.init = function (options) {
                this.visualInitOptions = options;
                this.layers = [];
                var element = this.element = options.element;
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                var chartAreaSvg = this.chartAreaSvg = d3.select(element.get(0)).append('svg');
                chartAreaSvg.classed(CartesianChart.ClassName, true);
                chartAreaSvg.style('position', 'absolute');
                if (this.behavior) {
                    this.clearCatcher = visuals.appendClearCatcher(chartAreaSvg);
                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
                }
                if (options.style.maxMarginFactor != null)
                    this.axes.setMaxMarginFactor(options.style.maxMarginFactor);
                var axisLinesVisibility = CartesianChart.getAxisVisibility(this.type);
                this.axes.setAxisLinesVisibility(axisLinesVisibility);
                this.svgAxes.init(chartAreaSvg);
                this.svgBrush.init(chartAreaSvg);
                this.sharedColorPalette = new SharedColorPalette(options.style.colorPalette.dataColors);
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.type !== 12 /* Waterfall */ ? this.interactivityService : undefined, this.axes.isScrollable);
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
            };
            CartesianChart.prototype.isPlayAxis = function () {
                if (!this.dataViews || !this.dataViews[0])
                    return false;
                var dataView = this.dataViews[0];
                var categoryRoleIsPlay = dataView.categorical
                    && dataView.categorical.categories
                    && dataView.categorical.categories[0]
                    && dataView.categorical.categories[0].source
                    && dataView.categorical.categories[0].source.roles
                    && dataView.categorical.categories[0].source.roles['Play'];
                return this.type === 9 /* Scatter */
                    && (this.animator || this.isMobileChart)
                    && dataView.matrix != null
                    && (!dataView.categorical || categoryRoleIsPlay);
            };
            CartesianChart.getIsScalar = function (objects, propertyId, type) {
                var axisTypeValue = powerbi.DataViewObjects.getValue(objects, propertyId);
                if (!objects || axisTypeValue === undefined) {
                    // If we don't have anything set (Auto), show charts as Scalar if the category type is numeric or time. 
                    // If we have the property, it will override the type.
                    return !visuals.AxisHelper.isOrdinal(type);
                }
                // also checking type here to be in sync with AxisHelper, which ignores scalar if the type is non-numeric.
                return (axisTypeValue === visuals.axisType.scalar) && !visuals.AxisHelper.isOrdinal(type);
            };
            CartesianChart.getAdditionalTelemetry = function (dataView) {
                var telemetry = {};
                var categoryColumn = dataView && dataView.categorical && _.first(dataView.categorical.categories);
                if (categoryColumn) {
                    telemetry.axisType = visuals.CartesianChart.getIsScalar(dataView.metadata.objects, visuals.columnChartProps.categoryAxis.axisType, categoryColumn.source.type)
                        ? 'scalar'
                        : 'categorical';
                }
                return telemetry;
            };
            CartesianChart.detectScalarMapping = function (dataViewMapping) {
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return false;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (_.isEmpty(categoryItems))
                    return false;
                var categoryType = categoryItems[0].type;
                if (!dataViewMapping.metadata)
                    return false;
                var objects = dataViewMapping.metadata.objects;
                return CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType);
            };
            CartesianChart.prototype.populateObjectProperties = function (dataViews) {
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    if (dataViewMetadata) {
                        this.legendObjectProperties = powerbi.DataViewObjects.getObject(dataViewMetadata.objects, 'legend', {});
                        this.xAxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, 'xAxisReferenceLine');
                        this.y1AxisReferenceLines = powerbi.DataViewObjects.getUserDefinedObjects(dataViewMetadata.objects, 'y1AxisReferenceLine');
                    }
                    else {
                        this.legendObjectProperties = {};
                    }
                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                }
            };
            CartesianChart.prototype.updateInternal = function (options, dataChanged) {
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                if (!dataViews)
                    return;
                if (this.layers.length === 0) {
                    // Lazily instantiate the chart layers on the first data load.
                    var objects = this.extractMetadataObjects(dataViews);
                    this.layers = this.createAndInitLayers(objects);
                    debug.assert(this.layers.length > 0, 'createAndInitLayers should update the layers.');
                }
                var layers = this.layers;
                if (dataChanged) {
                    if (!_.isEmpty(dataViews)) {
                        this.populateObjectProperties(dataViews);
                        this.axes.update(dataViews);
                        this.svgAxes.update(this.categoryAxisProperties, this.valueAxisProperties);
                        var dataView = dataViews[0];
                        if (dataView.metadata) {
                            // flatten background data
                            this.background = {
                                image: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.image),
                                transparency: powerbi.DataViewObjects.getValue(dataView.metadata.objects, visuals.scatterChartProps.plotArea.transparency, visuals.visualBackgroundHelper.getDefaultTransparency()),
                            };
                        }
                    }
                    this.sharedColorPalette.clearPreferredScale();
                    var layerDataViews = getLayerDataViews(dataViews);
                    var trendLineDataViews = _.filter(dataViews, function (dataView) { return visuals.TrendLineHelper.isDataViewForRegression(dataView); });
                    this.trendLines = [];
                    for (var i = 0, layerCount = layers.length; i < layerCount; i++) {
                        var layerDataView = layerDataViews[i];
                        layers[i].setData(layerDataView ? [layerDataView] : []);
                        if (this.supportsTrendLines(i)) {
                            var trendLineDataView = trendLineDataViews[i];
                            if (trendLineDataView) {
                                var y2 = (i > 0);
                                var trendLines = visuals.TrendLineHelper.readDataView(trendLineDataView, layerDataView, y2, this.sharedColorPalette);
                                (_a = this.trendLines).push.apply(_a, trendLines);
                            }
                        }
                        if (layerCount > 1)
                            this.sharedColorPalette.rotateScale();
                    }
                }
                this.render(!this.hasSetData || options.suppressAnimations, options.resizeMode);
                this.hasSetData = this.hasSetData || (dataViews && dataViews.length > 0);
                if (dataViews && dataViews.length > 0) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                    this.axes.addWarnings(warnings);
                    if (warnings && warnings.length > 0)
                        this.hostServices.setWarnings(warnings);
                }
                var _a;
            };
            // TODO: Remove onDataChanged & onResizing once we have a flag to distinguish between resize and data changed events.
            CartesianChart.prototype.onDataChanged = function (options) {
                this.updateInternal({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                }, true);
            };
            // TODO: Remove onDataChanged & onResizing once we have a flag to distinguish between resize and data changed events.
            CartesianChart.prototype.onResizing = function (viewport, resizeMode) {
                this.updateInternal({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewport: viewport,
                    resizeMode: resizeMode,
                }, false);
            };
            CartesianChart.prototype.scrollTo = function (position) {
                this.scrollableAxes.scrollTo(position);
            };
            CartesianChart.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                var layersLength = this.layers ? this.layers.length : 0;
                if (options.objectName === 'legend') {
                    if (!this.shouldShowLegendCard())
                        return;
                    var show = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.show, this.legend.isVisible());
                    var showTitle = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.showTitle, true);
                    var titleText = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.titleText, this.layerLegendData ? this.layerLegendData.title : '');
                    var labelColor = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                    var fontSize = powerbi.DataViewObject.getValue(this.legendObjectProperties, visuals.legendProps.fontSize, this.layerLegendData && this.layerLegendData.fontSize ? this.layerLegendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt);
                    enumeration.pushInstance({
                        selector: null,
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: fontSize,
                        },
                        objectName: options.objectName
                    });
                }
                else if (options.objectName === 'categoryAxis' && this.axes.hasCategoryAxis()) {
                    this.getCategoryAxisValues(enumeration);
                }
                else if (options.objectName === 'valueAxis') {
                    this.getValueAxisValues(enumeration);
                }
                else if (options.objectName === 'y1AxisReferenceLine') {
                    var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                    visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.y1AxisReferenceLines, refLinedefaultColor, options.objectName);
                }
                else if (options.objectName === 'xAxisReferenceLine') {
                    var refLinedefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                    visuals.ReferenceLineHelper.enumerateObjectInstances(enumeration, this.xAxisReferenceLines, refLinedefaultColor, options.objectName);
                }
                else if (options.objectName === 'trend') {
                    if (this.supportsTrendLines()) {
                        visuals.TrendLineHelper.enumerateObjectInstances(enumeration, this.trendLines);
                    }
                }
                else if (options.objectName === 'plotArea') {
                    visuals.visualBackgroundHelper.enumeratePlot(enumeration, this.background);
                }
                if (options.objectName === 'dataPoint' &&
                    visuals.ComboChart.isComboChart(this.type)) {
                    visuals.ComboChart.enumerateDataPoints(enumeration, options, this.layers);
                }
                else {
                    for (var i = 0, len = layersLength; i < len; i++) {
                        var layer = this.layers[i];
                        if (layer.enumerateObjectInstances) {
                            layer.enumerateObjectInstances(enumeration, options);
                        }
                    }
                }
                return enumeration.complete();
            };
            CartesianChart.prototype.supportsTrendLines = function (layerIndex) {
                var layerDataViews = getLayerDataViews(this.dataViews);
                if (_.isEmpty(this.layers))
                    return false;
                // If layerIndex was not given then check all layers.
                var layers = layerIndex == null ? this.layers : [this.layers[layerIndex]];
                return _.all(layers, function (layer, index) {
                    if (!layerDataViews[index])
                        return true;
                    return layer.supportsTrendLine && layer.supportsTrendLine();
                });
            };
            CartesianChart.prototype.shouldShowLegendCard = function () {
                var layers = this.layers;
                var dataViews = this.dataViews;
                if (layers && dataViews) {
                    var layersLength = layers.length;
                    var layersWithValuesCtr = 0;
                    for (var i = 0; i < layersLength; i++) {
                        if (layers[i].hasLegend()) {
                            return true;
                        }
                        // if there are at least two layers with values legend card should be shown (even if each of the individual layers don't have legend)
                        var dataView = dataViews[i];
                        if (dataView && dataView.categorical && dataView.categorical.values && dataView.categorical.values.length > 0) {
                            layersWithValuesCtr++;
                            if (layersWithValuesCtr > 1) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            };
            CartesianChart.prototype.getAxisScaleOptions = function (axisType) {
                var scaleOptions = [DEFAULT_AXIS_SCALE_TYPE];
                if (this.axes.isLogScaleAllowed(axisType))
                    scaleOptions.push(visuals.axisScale.log);
                return scaleOptions;
            };
            CartesianChart.prototype.getCategoryAxisValues = function (enumeration) {
                if (!this.categoryAxisProperties) {
                    return;
                }
                var supportedType = visuals.axisType.both;
                var isScalar = false;
                var scaleOptions = this.getAxisScaleOptions(0 /* X */);
                if (this.layers && this.layers[0].getSupportedCategoryAxisType) {
                    supportedType = this.layers[0].getSupportedCategoryAxisType();
                    if (supportedType === visuals.axisType.scalar) {
                        isScalar = true;
                    }
                    else {
                        isScalar = visuals.CartesianHelper.isScalar(supportedType === visuals.axisType.both, this.categoryAxisProperties);
                    }
                }
                if (!isScalar) {
                    this.categoryAxisProperties['start'] = null;
                    this.categoryAxisProperties['end'] = null;
                }
                var instance = {
                    selector: null,
                    properties: {},
                    objectName: 'categoryAxis',
                    validValues: {
                        axisScale: scaleOptions,
                        axisStyle: this.axes.categoryAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                    }
                };
                instance.properties['show'] = this.categoryAxisProperties['show'] != null ? this.categoryAxisProperties['show'] : true;
                if (this.axes.isYAxisCategorical())
                    instance.properties['position'] = this.valueAxisProperties && this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                if (supportedType === visuals.axisType.both) {
                    instance.properties['axisType'] = isScalar ? visuals.axisType.scalar : visuals.axisType.categorical;
                }
                if (isScalar) {
                    instance.properties['axisScale'] = this.categoryAxisProperties['axisScale'] || DEFAULT_AXIS_SCALE_TYPE;
                    instance.properties['start'] = this.categoryAxisProperties['start'];
                    instance.properties['end'] = this.categoryAxisProperties['end'];
                }
                instance.properties['showAxisTitle'] = this.categoryAxisProperties['showAxisTitle'] != null ? this.categoryAxisProperties['showAxisTitle'] : false;
                instance.properties['axisStyle'] = this.categoryAxisProperties['axisStyle'] ? this.categoryAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly;
                instance.properties['labelColor'] = this.categoryAxisProperties['labelColor'] || visuals.DEFAULT_AXIS_COLOR;
                if (isScalar) {
                    instance.properties['labelDisplayUnits'] = this.categoryAxisProperties['labelDisplayUnits'] ? this.categoryAxisProperties['labelDisplayUnits'] : 0;
                    var labelPrecision = this.categoryAxisProperties['labelPrecision'];
                    instance.properties['labelPrecision'] = (labelPrecision === undefined || labelPrecision < 0)
                        ? visuals.dataLabelUtils.defaultLabelPrecision
                        : labelPrecision;
                }
                enumeration.pushInstance(instance);
            };
            //todo: wrap all these object getters and other related stuff into an interface
            CartesianChart.prototype.getValueAxisValues = function (enumeration) {
                if (!this.valueAxisProperties) {
                    return;
                }
                var scaleOptions = this.getAxisScaleOptions(1 /* Y1 */);
                var secScaleOption = this.getAxisScaleOptions(2 /* Y2 */);
                var instance = {
                    selector: null,
                    properties: {},
                    objectName: 'valueAxis',
                    validValues: {
                        axisScale: scaleOptions,
                        secAxisScale: secScaleOption,
                        axisStyle: this.axes.valueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly]
                    }
                };
                instance.properties['show'] = this.valueAxisProperties['show'] != null ? this.valueAxisProperties['show'] : true;
                if (!this.axes.isYAxisCategorical()) {
                    instance.properties['position'] = this.valueAxisProperties['position'] != null ? this.valueAxisProperties['position'] : visuals.yAxisPosition.left;
                }
                instance.properties['axisScale'] = this.valueAxisProperties['axisScale'] || DEFAULT_AXIS_SCALE_TYPE;
                instance.properties['start'] = this.valueAxisProperties['start'];
                instance.properties['end'] = this.valueAxisProperties['end'];
                instance.properties['showAxisTitle'] = this.valueAxisProperties['showAxisTitle'] != null ? this.valueAxisProperties['showAxisTitle'] : false;
                instance.properties['axisStyle'] = this.valueAxisProperties['axisStyle'] != null ? this.valueAxisProperties['axisStyle'] : visuals.axisStyle.showTitleOnly;
                instance.properties['labelColor'] = this.valueAxisProperties['labelColor'] || visuals.DEFAULT_AXIS_COLOR;
                if (this.type !== 7 /* HundredPercentStackedBar */ && this.type !== 8 /* HundredPercentStackedColumn */) {
                    instance.properties['labelDisplayUnits'] = this.valueAxisProperties['labelDisplayUnits'] ? this.valueAxisProperties['labelDisplayUnits'] : 0;
                    var labelPrecision = this.valueAxisProperties['labelPrecision'];
                    instance.properties['labelPrecision'] = (labelPrecision === undefined || labelPrecision < 0)
                        ? visuals.dataLabelUtils.defaultLabelPrecision
                        : labelPrecision;
                }
                enumeration.pushInstance(instance);
                if (this.layers.length === 2) {
                    instance.properties['secShow'] = this.valueAxisProperties['secShow'] != null ? this.valueAxisProperties['secShow'] : this.axes.hasY2Axis();
                    if (instance.properties['secShow']) {
                        instance.properties['axisLabel'] = '';
                    }
                }
                if (this.axes.hasY2Axis() && instance.properties['secShow']) {
                    enumeration.pushContainer({
                        displayName: powerbi.data.createDisplayNameGetter('Visual_YAxis_ShowSecondary'),
                    });
                    var secInstance = {
                        selector: null,
                        properties: {},
                        objectName: 'valueAxis'
                    };
                    secInstance.properties['secAxisLabel'] = '';
                    secInstance.properties['secPosition'] = this.valueAxisProperties['secPosition'] != null ? this.valueAxisProperties['secPosition'] : visuals.yAxisPosition.right;
                    secInstance.properties['secAxisScale'] = this.valueAxisProperties['secAxisScale'] || DEFAULT_AXIS_SCALE_TYPE;
                    secInstance.properties['secStart'] = this.valueAxisProperties['secStart'];
                    secInstance.properties['secEnd'] = this.valueAxisProperties['secEnd'];
                    secInstance.properties['secShowAxisTitle'] = this.valueAxisProperties['secShowAxisTitle'] != null ? this.valueAxisProperties['secShowAxisTitle'] : false;
                    enumeration
                        .pushInstance(secInstance)
                        .pushInstance({
                        selector: null,
                        properties: {
                            secAxisStyle: this.valueAxisProperties['secAxisStyle'] ? this.valueAxisProperties['secAxisStyle'] : visuals.axisStyle.showTitleOnly,
                            labelColor: this.valueAxisProperties['secLabelColor'],
                            secLabelDisplayUnits: this.valueAxisProperties['secLabelDisplayUnits'] ? this.valueAxisProperties['secLabelDisplayUnits'] : 0,
                            secLabelPrecision: this.valueAxisProperties['secLabelPrecision'] < 0 ? 0 : this.valueAxisProperties['secLabelPrecision']
                        },
                        objectName: 'valueAxis',
                        validValues: {
                            secAxisStyle: this.axes.secondaryValueAxisHasUnitType ? [visuals.axisStyle.showTitleOnly, visuals.axisStyle.showUnitOnly, visuals.axisStyle.showBoth] : [visuals.axisStyle.showTitleOnly],
                            axisScale: scaleOptions
                        },
                    });
                    enumeration.popContainer();
                }
            };
            CartesianChart.prototype.onClearSelection = function () {
                if (this.hasSetData) {
                    for (var i = 0, len = this.layers.length; i < len; i++) {
                        var layer = this.layers[i];
                        layer.onClearSelection();
                        layer.render(true /* suppressAnimations */);
                    }
                }
            };
            CartesianChart.prototype.extractMetadataObjects = function (dataViews) {
                var objects;
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    if (dataViewMetadata)
                        objects = dataViewMetadata.objects;
                }
                return objects;
            };
            CartesianChart.prototype.createAndInitLayers = function (objects) {
                var _this = this;
                // Create the layers
                var layers = CartesianLayerFactory.createLayers(this.type, objects, this.interactivityService, this.animator, this.axes.isScrollable, this.tooltipsEnabled, this.lineChartLabelDensityEnabled);
                // Initialize the layers
                var cartesianOptions = powerbi.Prototype.inherit(this.visualInitOptions);
                cartesianOptions.svg = this.svgAxes.getScrollableRegion();
                cartesianOptions.labelsContext = this.svgAxes.getLabelsRegion();
                cartesianOptions.cartesianHost = {
                    updateLegend: function (data) { return _this.legend.drawLegend(data, _this.currentViewport); },
                    getSharedColors: function () { return _this.sharedColorPalette; },
                    triggerRender: function (suppressAnimations) { return _this.render(suppressAnimations); },
                };
                cartesianOptions.chartType = this.type;
                for (var i = 0, len = layers.length; i < len; i++)
                    layers[i].init(cartesianOptions);
                return layers;
            };
            CartesianChart.prototype.renderLegend = function () {
                var layers = this.layers;
                var legendData = { title: "", dataPoints: [] };
                for (var i = 0, len = layers.length; i < len; i++) {
                    this.layerLegendData = layers[i].calculateLegend();
                    if (this.layerLegendData) {
                        legendData.title = i === 0 ? this.layerLegendData.title || ""
                            : legendData.title;
                        legendData.labelColor = this.layerLegendData.labelColor;
                        legendData.dataPoints = legendData.dataPoints.concat(this.layerLegendData.dataPoints || []);
                        legendData.fontSize = this.layerLegendData.fontSize || visuals.SVGLegend.DefaultFontSizeInPt;
                        if (this.layerLegendData.grouped) {
                            legendData.grouped = true;
                        }
                    }
                }
                var legendProperties = this.legendObjectProperties;
                if (legendProperties) {
                    visuals.LegendData.update(legendData, legendProperties);
                    var position = legendProperties[visuals.legendProps.position];
                    if (position)
                        this.legend.changeOrientation(visuals.LegendPosition[position]);
                }
                else {
                    this.legend.changeOrientation(visuals.LegendPosition.Top);
                }
                if ((legendData.dataPoints.length === 1 && !legendData.grouped) || this.hideLegends()) {
                    legendData.dataPoints = [];
                }
                this.legend.drawLegend(legendData, this.currentViewport);
            };
            CartesianChart.prototype.hideLegends = function () {
                if (this.cartesianSmallViewPortProperties) {
                    if (this.cartesianSmallViewPortProperties.hideLegendOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightLegendVisible)) {
                        return true;
                    }
                }
                return false;
            };
            CartesianChart.prototype.render = function (suppressAnimations, resizeMode) {
                var _this = this;
                // Note: interactive legend shouldn't be rendered explicitly here
                // The interactive legend is being rendered in the render method of ICartesianVisual
                if (!(this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend)) {
                    this.renderLegend();
                }
                var legendMargins = this.legendMargins = this.legend.getMargins();
                var legendOrientation = this.legend.getOrientation();
                var hideAxisLabels = this.hideAxisLabels(legendMargins);
                var plotAreaViewport = {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
                var padding = powerbi.Prototype.inherit(SvgCartesianAxes.AxisPadding);
                var playAxisControlLayout;
                if (this.isPlayAxis()) {
                    plotAreaViewport.height -= CartesianChart.PlayAxisBottomMargin;
                    playAxisControlLayout = {
                        left: visuals.Legend.isLeft(legendOrientation) ? legendMargins.width : 0,
                        top: visuals.Legend.isTop(legendOrientation) ? legendMargins.height + plotAreaViewport.height : plotAreaViewport.height,
                        height: CartesianChart.PlayAxisBottomMargin,
                        width: plotAreaViewport.width
                    };
                }
                this.chartAreaSvg.attr({
                    'width': plotAreaViewport.width,
                    'height': plotAreaViewport.height,
                });
                visuals.Legend.positionChartArea(this.chartAreaSvg, this.legend);
                var interactivityRightMargin = this.calculateInteractivityRightMargin();
                var _a = this.getMinimumDomainExtents(), ensureXDomain = _a[0], ensureYDomain = _a[1];
                var axesLayout = this.axes.negotiateAxes(this.layers, plotAreaViewport, padding, playAxisControlLayout, hideAxisLabels, CartesianChart.AxisTextProperties, interactivityRightMargin, ensureXDomain, ensureYDomain);
                // Even if the caller thinks animations are ok, now that we've laid out the axes and legend we should disable animations
                // if the plot area changed. Animations for property changes like legend on/off are not desired.
                var plotAreaHasChanged = !this.renderedPlotArea
                    || (this.renderedPlotArea.height !== axesLayout.plotArea.height ||
                        this.renderedPlotArea.width !== axesLayout.plotArea.width);
                suppressAnimations = suppressAnimations || plotAreaHasChanged;
                this.scrollableAxes.render(axesLayout, this.layers, suppressAnimations, function (layers, axesLayout, suppressAnimations) { return _this.renderPlotArea(layers, axesLayout, suppressAnimations, legendMargins, resizeMode); });
                // attach scroll event
                this.chartAreaSvg.on('wheel', function () {
                    if (!(_this.axes.isXScrollBarVisible || _this.axes.isYScrollBarVisible))
                        return;
                    visuals.TooltipManager.ToolTipInstance.hide();
                    var wheelEvent = d3.event;
                    var dy = wheelEvent.deltaY;
                    _this.scrollableAxes.scrollDelta(dy);
                });
                this.renderedPlotArea = axesLayout.plotArea;
            };
            /**
             * Gets any minimum domain extents.
             * Reference lines and trend lines may enforce minimum extents on X and/or Y domains.
             */
            CartesianChart.prototype.getMinimumDomainExtents = function () {
                var xs = [];
                var ys = [];
                if (!_.isEmpty(this.xAxisReferenceLines)) {
                    var xAxisReferenceLineProperties = this.xAxisReferenceLines[0].object;
                    var value = visuals.ReferenceLineHelper.extractReferenceLineValue(xAxisReferenceLineProperties);
                    xs.push(value);
                }
                if (!_.isEmpty(this.y1AxisReferenceLines)) {
                    var y1AxisReferenceLineProperties = this.y1AxisReferenceLines[0].object;
                    var value = visuals.ReferenceLineHelper.extractReferenceLineValue(y1AxisReferenceLineProperties);
                    ys.push(value);
                }
                var ensureXDomain = {
                    min: d3.min(xs),
                    max: d3.max(xs)
                };
                var ensureYDomain = {
                    min: d3.min(ys),
                    max: d3.max(ys)
                };
                return [ensureXDomain, ensureYDomain];
            };
            CartesianChart.prototype.getPlotAreaRect = function (axesLayout, legendMargins) {
                var rect = {
                    left: axesLayout.margin.left,
                    top: axesLayout.margin.top,
                    width: axesLayout.plotArea.width,
                    height: axesLayout.plotArea.height,
                };
                // Adjust the margins to the legend position 
                if (this.legend) {
                    var legendPosition_1 = this.legend.getOrientation();
                    if (visuals.Legend.isTop(legendPosition_1)) {
                        rect.top += legendMargins.height;
                    }
                    else if (visuals.Legend.isLeft(legendPosition_1)) {
                        rect.left += legendMargins.width;
                    }
                }
                return rect;
            };
            CartesianChart.prototype.renderBackgroundImage = function (layout) {
                visuals.visualBackgroundHelper.renderBackgroundImage(this.background, this.element, layout);
            };
            CartesianChart.prototype.hideAxisLabels = function (legendMargins) {
                if (this.cartesianSmallViewPortProperties) {
                    if (this.cartesianSmallViewPortProperties.hideAxesOnSmallViewPort && (this.currentViewport.height < this.cartesianSmallViewPortProperties.MinHeightAxesVisible) && !this.visualInitOptions.interactivity.isInteractiveLegend) {
                        return true;
                    }
                }
                return false;
            };
            CartesianChart.prototype.calculateInteractivityRightMargin = function () {
                // add right margin in order not to cut the circle selection of the hover line 
                if (this.visualInitOptions.interactivity && this.visualInitOptions.interactivity.isInteractiveLegend && !this.trimOrdinalDataOnOverflow) {
                    return INTERACTIVITY_RIGHT_MARGIN;
                }
                else {
                    return 0;
                }
            };
            CartesianChart.prototype.renderPlotArea = function (layers, axesLayout, suppressAnimations, legendMargins, resizeMode) {
                debug.assertValue(layers, 'layers');
                var axes = axesLayout.axes;
                var plotArea = axesLayout.plotArea;
                var plotAreaRect = this.getPlotAreaRect(axesLayout, legendMargins);
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                this.renderBackgroundImage(plotAreaRect);
                this.svgAxes.renderAxes(axesLayout, duration);
                this.renderReferenceLines(axesLayout);
                this.renderLayers(layers, plotArea, axes, suppressAnimations, resizeMode);
                this.renderTrendLines(axesLayout);
            };
            CartesianChart.prototype.renderTrendLines = function (axesLayout) {
                var scrollableRegion = this.svgAxes.getScrollableRegion();
                visuals.TrendLineHelper.render(this.trendLines, scrollableRegion, axesLayout.axes, axesLayout.plotArea);
            };
            CartesianChart.prototype.renderReferenceLines = function (axesLayout) {
                var axes = axesLayout.axes;
                var plotArea = axesLayout.plotArea;
                var scrollableRegion = this.svgAxes.getScrollableRegion();
                var refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                var showY1ReferenceLines = false;
                if (this.y1AxisReferenceLines) {
                    for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
                        var referenceLineProperties = _a[_i];
                        var object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
                            var isHorizontal = !axes.y1.isCategoryAxis;
                            var y1RefLineOptions = {
                                graphicContext: scrollableRegion,
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                classAndSelector: this.y1RefLine,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal
                            };
                            visuals.ReferenceLineHelper.render(y1RefLineOptions);
                            showY1ReferenceLines = true;
                        }
                    }
                }
                if (!showY1ReferenceLines) {
                    scrollableRegion.selectAll(this.y1RefLine.selector).remove();
                }
                var showXReferenceLines = false;
                if (this.xAxisReferenceLines) {
                    for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
                        var referenceLineProperties = _c[_b];
                        var object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show]) {
                            var isHorizontal = false;
                            var xRefLineOptions = {
                                graphicContext: scrollableRegion,
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                classAndSelector: this.xRefLine,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal
                            };
                            visuals.ReferenceLineHelper.render(xRefLineOptions);
                            showXReferenceLines = true;
                        }
                    }
                }
                if (!showXReferenceLines) {
                    scrollableRegion.selectAll(this.xRefLine.selector).remove();
                }
            };
            CartesianChart.prototype.getReferenceLineLabels = function (axes, plotArea) {
                var refLineDefaultColor = this.sharedColorPalette.getColorByIndex(0).value;
                var referenceLineLabels = [];
                if (this.y1AxisReferenceLines) {
                    for (var _i = 0, _a = this.y1AxisReferenceLines; _i < _a.length; _i++) {
                        var referenceLineProperties = _a[_i];
                        var object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
                            var isHorizontal = !axes.y1.isCategoryAxis;
                            var y1RefLineLabelOptions = {
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal,
                                key: JSON.stringify({
                                    type: 'y1AxisReferenceLine',
                                    id: referenceLineProperties.id,
                                }),
                            };
                            referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(y1RefLineLabelOptions));
                        }
                    }
                }
                if (this.xAxisReferenceLines) {
                    for (var _b = 0, _c = this.xAxisReferenceLines; _b < _c.length; _b++) {
                        var referenceLineProperties = _c[_b];
                        var object = referenceLineProperties.object;
                        if (object[visuals.ReferenceLineHelper.referenceLineProps.show] && object[visuals.ReferenceLineHelper.referenceLineProps.dataLabelShow]) {
                            var isHorizontal = false;
                            var xRefLineLabelOptions = {
                                referenceLineProperties: object,
                                axes: axes,
                                viewport: plotArea,
                                defaultColor: refLineDefaultColor,
                                isHorizontal: isHorizontal,
                                key: JSON.stringify({
                                    type: 'xAxisReferenceLine',
                                    id: referenceLineProperties.id,
                                }),
                            };
                            referenceLineLabels.push(visuals.ReferenceLineHelper.createLabelDataPoint(xRefLineLabelOptions));
                        }
                    }
                }
                return referenceLineLabels;
            };
            CartesianChart.prototype.renderDataLabels = function (labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, isCombo) {
                var labelBackgroundRegion = this.svgAxes.getLabelBackground();
                var labelRegion = this.svgAxes.getLabelsRegion();
                if (this.behavior) {
                    var labelLayoutOptions = visuals.NewDataLabelUtils.getDataLabelLayoutOptions(this.type);
                    var labelLayout = new powerbi.LabelLayout(labelLayoutOptions);
                    var dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
                    if (isCombo) {
                        visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", 0.7);
                    }
                    var svgLabels = void 0;
                    if (this.animator && !suppressAnimations) {
                        var isPlayAxis = this.isPlayAxis();
                        var duration = isPlayAxis ? visuals.PlayChart.FrameAnimationDuration : this.animator.getDuration();
                        svgLabels = visuals.NewDataLabelUtils.animateDefaultLabels(labelRegion, dataLabels, duration, labelsAreNumeric, isPlayAxis ? 'linear' : undefined);
                    }
                    else {
                        svgLabels = visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
                    }
                    if (labelLayoutOptions.allowLeaderLines) {
                        var filteredLabels = _.filter(dataLabels, function (d) { return d.leaderLinePoints != null && !_.isEmpty(d.leaderLinePoints) && d.identity != null; });
                        visuals.NewDataLabelUtils.drawLabelLeaderLines(labelRegion, filteredLabels, function (d) { return d.identity.getKey(); });
                    }
                    if (this.interactivityService && this.isLabelInteractivityEnabled) {
                        var labelsBehaviorOptions = {
                            labelItems: svgLabels,
                        };
                        this.interactivityService.bind(dataLabels, new visuals.LabelsBehavior(), labelsBehaviorOptions, { isLabels: true });
                    }
                }
                else {
                    var labelLayout = new powerbi.LabelLayout({
                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset,
                        attemptToMoveLabelsIntoViewport: true,
                    });
                    var dataLabels = labelLayout.layout(labelDataPointGroups, plotArea);
                    if (isCombo) {
                        visuals.NewDataLabelUtils.drawLabelBackground(labelBackgroundRegion, dataLabels, "#FFFFFF", 0.7);
                    }
                    visuals.NewDataLabelUtils.drawDefaultLabels(labelRegion, dataLabels, labelsAreNumeric);
                }
            };
            CartesianChart.prototype.renderLayers = function (layers, plotArea, axes, suppressAnimations, resizeMode) {
                var labelDataPointGroups = [];
                var dataPoints = [];
                var layerBehaviorOptions = [];
                var labelsAreNumeric = true;
                for (var i = 0, len = layers.length; i < len; i++) {
                    var result = layers[i].render(suppressAnimations, resizeMode);
                    if (result) {
                        if (this.behavior) {
                            // NOTE: these are not needed if we don't have interactivity
                            dataPoints = dataPoints.concat(result.dataPoints);
                            layerBehaviorOptions.push(result.behaviorOptions);
                        }
                        if (result.labelDataPointGroups) {
                            var resultLabelDataPointsGroups = result.labelDataPointGroups;
                            for (var _i = 0, resultLabelDataPointsGroups_1 = resultLabelDataPointsGroups; _i < resultLabelDataPointsGroups_1.length; _i++) {
                                var resultLabelDataPointsGroup = resultLabelDataPointsGroups_1[_i];
                                if (!resultLabelDataPointsGroup)
                                    continue;
                                labelDataPointGroups.push({
                                    labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultLabelDataPointsGroup.labelDataPoints || []),
                                    maxNumberOfLabels: resultLabelDataPointsGroup.maxNumberOfLabels,
                                });
                            }
                        }
                        else {
                            var resultsLabelDataPoints = result.labelDataPoints || [];
                            labelDataPointGroups.push({
                                labelDataPoints: visuals.NewDataLabelUtils.removeDuplicates(resultsLabelDataPoints),
                                maxNumberOfLabels: resultsLabelDataPoints.length,
                            });
                        }
                        labelsAreNumeric = labelsAreNumeric && result.labelsAreNumeric;
                    }
                }
                var referenceLineLabels = this.getReferenceLineLabels(axes, plotArea);
                if (!_.isEmpty(referenceLineLabels)) {
                    labelDataPointGroups.unshift({
                        labelDataPoints: referenceLineLabels,
                        maxNumberOfLabels: referenceLineLabels.length,
                    });
                }
                this.renderDataLabels(labelDataPointGroups, labelsAreNumeric, plotArea, suppressAnimations, visuals.ComboChart.isComboChart(this.type));
                if (this.interactivityService) {
                    var behaviorOptions = {
                        layerOptions: layerBehaviorOptions,
                        clearCatcher: this.clearCatcher,
                    };
                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                }
            };
            /**
             * Returns the actual viewportWidth if visual is not scrollable.
             * @return If visual is scrollable, returns the plot area needed to draw all the datapoints.
             */
            CartesianChart.getPreferredPlotArea = function (categoryCount, categoryThickness, viewport, isScrollable, isScalar, margin, noOuterPadding) {
                if (!margin)
                    margin = { top: 0, right: 0, bottom: 0, left: 0 };
                var plotArea = {
                    height: viewport.height - margin.top - margin.bottom,
                    width: viewport.width - margin.left - margin.right
                };
                if (!isScalar && isScrollable) {
                    var preferredCategorySpan = CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness, noOuterPadding);
                    plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                }
                return plotArea;
            };
            /**
             * Returns preferred Category span if the visual is scrollable.
             */
            CartesianChart.getPreferredCategorySpan = function (categoryCount, categoryThickness, noOuterPadding) {
                var span = (categoryThickness * categoryCount);
                if (noOuterPadding)
                    return span;
                return span + (categoryThickness * CartesianChart.OuterPaddingRatio * 2);
            };
            /**
             * Note: Public for testing access.
             */
            CartesianChart.getLayout = function (data, options) {
                var categoryCount = options.categoryCount, availableWidth = options.availableWidth, domain = options.domain, trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow, isScalar = !!options.isScalar, isScrollable = !!options.isScrollable;
                var categoryThickness = CartesianChart.getCategoryThickness(data ? data.series : null, categoryCount, availableWidth, domain, isScalar, trimOrdinalDataOnOverflow);
                // Total width of the outer padding, the padding that exist on the far right and far left of the chart.
                var totalOuterPadding = categoryThickness * CartesianChart.OuterPaddingRatio * 2;
                // visibleCategoryCount will be used to discard data that overflows on ordinal-axis charts.
                // Needed for dashboard visuals            
                var calculatedBarCount = powerbi.Double.floorWithPrecision((availableWidth - totalOuterPadding) / categoryThickness);
                var visibleCategoryCount = Math.min(calculatedBarCount, categoryCount);
                var willScroll = visibleCategoryCount < categoryCount && isScrollable;
                var outerPaddingRatio = CartesianChart.OuterPaddingRatio;
                if (!isScalar && !willScroll) {
                    // use dynamic outer padding to improve spacing when we have few categories
                    var oneOuterPadding = (availableWidth - (categoryThickness * visibleCategoryCount)) / 2;
                    outerPaddingRatio = oneOuterPadding / categoryThickness;
                }
                // If scrollable, visibleCategoryCount will be total categories
                if (!isScalar && isScrollable)
                    visibleCategoryCount = categoryCount;
                return {
                    categoryCount: visibleCategoryCount,
                    categoryThickness: categoryThickness,
                    outerPaddingRatio: outerPaddingRatio,
                    isScalar: isScalar
                };
            };
            /**
             * Returns the thickness for each category.
             * For clustered charts, you still need to divide by
             * the number of series to get column width after calling this method.
             * For linear or time scales, category thickness accomodates for
             * the minimum interval between consequtive points.
             * For all types, return value has accounted for outer padding,
             * but not inner padding.
             */
            CartesianChart.getCategoryThickness = function (seriesList, numCategories, plotLength, domain, isScalar, trimOrdinalDataOnOverflow) {
                var thickness;
                if (numCategories < 2)
                    thickness = plotLength * (1 - CartesianChart.OuterPaddingRatio);
                else if (isScalar && domain && domain.length > 1) {
                    // the smallest interval defines the column width.
                    var minInterval = CartesianChart.getMinInterval(seriesList);
                    var domainSpan = domain[domain.length - 1] - domain[0];
                    // account for outside padding
                    var ratio = minInterval / (domainSpan + (minInterval * CartesianChart.OuterPaddingRatio * 2));
                    thickness = plotLength * ratio;
                    thickness = Math.max(thickness, CartesianChart.MinScalarRectThickness);
                }
                else {
                    // Divide the available width up including outer padding (in terms of category thickness) on
                    // both sides of the chart, and categoryCount categories. Reverse math:
                    // availableWidth = (categoryThickness * categoryCount) + (categoryThickness * (outerPadding * 2)),
                    // availableWidth = categoryThickness * (categoryCount + (outerPadding * 2)),
                    // categoryThickness = availableWidth / (categoryCount + (outerpadding * 2))
                    thickness = plotLength / (numCategories + (CartesianChart.OuterPaddingRatio * 2));
                    if (trimOrdinalDataOnOverflow) {
                        thickness = Math.max(thickness, CartesianChart.MinOrdinalRectThickness);
                    }
                }
                // spec calls for using the whole plot area, but the max rectangle thickness is "as if there were three categories"
                // (outerPaddingRatio has the same units as '# of categories' so they can be added)
                var maxRectThickness = plotLength / (3 + (CartesianChart.OuterPaddingRatio * 2));
                thickness = Math.min(thickness, maxRectThickness);
                if (!isScalar && numCategories >= 3 && trimOrdinalDataOnOverflow) {
                    return Math.max(thickness, CartesianChart.MinOrdinalRectThickness);
                }
                return thickness;
            };
            CartesianChart.getMinInterval = function (seriesList) {
                var minInterval = Number.MAX_VALUE;
                if (seriesList.length > 0) {
                    var series0data = seriesList[0].data.filter(function (d) { return !d.highlight; });
                    for (var i = 0, ilen = series0data.length - 1; i < ilen; i++) {
                        minInterval = Math.min(minInterval, Math.abs(series0data[i + 1].categoryValue - series0data[i].categoryValue));
                    }
                }
                return minInterval;
            };
            CartesianChart.MinOrdinalRectThickness = 20;
            CartesianChart.MinScalarRectThickness = 2;
            CartesianChart.OuterPaddingRatio = 0.4;
            CartesianChart.InnerPaddingRatio = 0.2;
            CartesianChart.TickLabelPadding = 2; // between text labels, used by AxisHelper
            CartesianChart.ClassName = 'cartesianChart';
            CartesianChart.PlayAxisBottomMargin = 80; //do not change unless we add dynamic label measurements for play slider
            CartesianChart.FontSize = 11;
            CartesianChart.FontSizeString = jsCommon.PixelConverter.toString(CartesianChart.FontSize);
            CartesianChart.AxisTextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: CartesianChart.FontSizeString,
            };
            return CartesianChart;
        }());
        visuals.CartesianChart = CartesianChart;
        function getLayerDataViews(dataViews) {
            if (_.isEmpty(dataViews))
                return [];
            // TODO: figure out a more general way to correlate between layers and input data views.
            return _.filter(dataViews, function (dataView) { return !visuals.TrendLineHelper.isDataViewForRegression(dataView); });
        }
        function hasMultipleYAxes(layers) {
            debug.assertValue(layers, 'layers');
            return layers.length > 1;
        }
        /**
         * Returns a boolean, that indicates if y axis title should be displayed.
         * @return True if y axis title should be displayed,
         * otherwise false.
         */
        function shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge) {
            return ((layerNumber === 0 && !!valueAxisProperties && !!valueAxisProperties['showAxisTitle']) ||
                (layerNumber === 1 && !yAxisWillMerge && !!valueAxisProperties && !!valueAxisProperties['secShowAxisTitle']));
        }
        function tryMergeYDomains(layers, visualOptions) {
            debug.assert(layers.length < 3, 'merging of more than 2 layers is not supported');
            var noMerge = {
                domain: undefined,
                merged: false,
                tickCount: undefined
            };
            if (layers.length < 2)
                return noMerge;
            var min;
            var max;
            var minOfMax;
            var maxOfMin;
            // TODO: replace full calculateAxesProperties with just a data domain calc
            // we need to be aware of which chart require zero (column/bar) and which don't (line)
            var y1props = layers[0].calculateAxesProperties(visualOptions)[1];
            var y2props = layers[1].calculateAxesProperties(visualOptions)[1];
            var firstYDomain = y1props.scale.domain();
            var secondYDomain = y2props.scale.domain();
            if (y1props.values && y1props.values.length > 0 && y2props.values && y2props.values.length > 0) {
                noMerge.tickCount = Math.max(y1props.values.length, y2props.values.length);
            }
            min = Math.min(firstYDomain[0], secondYDomain[0]);
            max = Math.max(firstYDomain[1], secondYDomain[1]);
            if (visualOptions.forceMerge) {
                return {
                    domain: [min, max],
                    merged: true,
                    tickCount: noMerge.tickCount
                };
            }
            // If domains don't intersect don't merge axis.
            if (firstYDomain[0] > secondYDomain[1] || firstYDomain[1] < secondYDomain[0])
                return noMerge;
            maxOfMin = Math.max(firstYDomain[0], secondYDomain[0]);
            minOfMax = Math.min(firstYDomain[1], secondYDomain[1]);
            var range = (max - min);
            if (range === 0) {
                return noMerge;
            }
            var intersection = Math.abs((minOfMax - maxOfMin) / range);
            // Only merge if intersection of domains greater than 10% of total range.
            if (intersection < COMBOCHART_DOMAIN_OVERLAP_TRESHOLD_PERCENTAGE)
                return noMerge;
            else
                return {
                    domain: [min, max],
                    merged: true,
                    tickCount: noMerge.tickCount
                };
        }
        /**
         * Computes the Cartesian Chart axes from the set of layers.
         */
        function calculateAxes(layers, viewport, margin, playAxisControlLayout, categoryAxisProperties, valueAxisProperties, textProperties, scrollbarVisible, existingAxisProperties, trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain) {
            debug.assertValue(layers, 'layers');
            var visualOptions = {
                viewport: viewport,
                margin: margin,
                forcedXDomain: [categoryAxisProperties ? categoryAxisProperties['start'] : null, categoryAxisProperties ? categoryAxisProperties['end'] : null],
                forceMerge: valueAxisProperties && valueAxisProperties['secShow'] === false,
                showCategoryAxisLabel: false,
                showValueAxisLabel: false,
                trimOrdinalDataOnOverflow: trimOrdinalDataOnOverflow,
                categoryAxisScaleType: categoryAxisProperties && categoryAxisProperties['axisScale'] != null ? categoryAxisProperties['axisScale'] : DEFAULT_AXIS_SCALE_TYPE,
                valueAxisScaleType: valueAxisProperties && valueAxisProperties['axisScale'] != null ? valueAxisProperties['axisScale'] : DEFAULT_AXIS_SCALE_TYPE,
                categoryAxisDisplayUnits: categoryAxisProperties && categoryAxisProperties['labelDisplayUnits'] != null ? categoryAxisProperties['labelDisplayUnits'] : 0,
                valueAxisDisplayUnits: valueAxisProperties && valueAxisProperties['labelDisplayUnits'] != null ? valueAxisProperties['labelDisplayUnits'] : 0,
                categoryAxisPrecision: categoryAxisProperties ? visuals.CartesianHelper.getPrecision(categoryAxisProperties['labelPrecision']) : null,
                valueAxisPrecision: valueAxisProperties ? visuals.CartesianHelper.getPrecision(valueAxisProperties['labelPrecision']) : null,
                playAxisControlLayout: playAxisControlLayout,
                ensureXDomain: ensureXDomain,
                ensureYDomain: ensureYDomain,
            };
            var skipMerge = valueAxisProperties && valueAxisProperties['secShow'] === true;
            var yAxisWillMerge = false;
            var mergeResult;
            if (hasMultipleYAxes(layers) && !skipMerge) {
                mergeResult = tryMergeYDomains(layers, visualOptions);
                yAxisWillMerge = mergeResult.merged;
                if (yAxisWillMerge) {
                    visualOptions.forcedYDomain = mergeResult.domain;
                }
                else {
                    visualOptions.forcedTickCount = mergeResult.tickCount;
                }
            }
            if (valueAxisProperties) {
                visualOptions.forcedYDomain = visuals.AxisHelper.applyCustomizedDomain([valueAxisProperties['start'], valueAxisProperties['end']], visualOptions.forcedYDomain);
            }
            var result;
            for (var layerNumber = 0, len = layers.length; layerNumber < len; layerNumber++) {
                var currentlayer = layers[layerNumber];
                if (layerNumber === 1 && !yAxisWillMerge) {
                    visualOptions.forcedYDomain = valueAxisProperties ? [valueAxisProperties['secStart'], valueAxisProperties['secEnd']] : null;
                    visualOptions.valueAxisScaleType = valueAxisProperties && valueAxisProperties['secAxisScale'] != null ? valueAxisProperties['secAxisScale'] : DEFAULT_AXIS_SCALE_TYPE;
                    visualOptions.valueAxisDisplayUnits = valueAxisProperties && valueAxisProperties['secLabelDisplayUnits'] != null ? valueAxisProperties['secLabelDisplayUnits'] : 0;
                    visualOptions.valueAxisPrecision = valueAxisProperties ? visuals.CartesianHelper.getPrecision(valueAxisProperties['secLabelPrecision']) : null;
                }
                visualOptions.showCategoryAxisLabel = (!!categoryAxisProperties && !!categoryAxisProperties['showAxisTitle']); //here
                visualOptions.showValueAxisLabel = shouldShowYAxisLabel(layerNumber, valueAxisProperties, yAxisWillMerge);
                var axes = currentlayer.calculateAxesProperties(visualOptions);
                if (layerNumber === 0) {
                    result = {
                        x: axes[0],
                        y1: axes[1]
                    };
                }
                else if (axes && !result.y2) {
                    if (result.x.usingDefaultDomain || _.isEmpty(result.x.dataDomain)) {
                        visualOptions.showValueAxisLabel = (!!valueAxisProperties && !!valueAxisProperties['showAxisTitle']);
                        var axes_1 = currentlayer.calculateAxesProperties(visualOptions);
                        // no categories returned for the first layer, use second layer x-axis properties
                        result.x = axes_1[0];
                        // and 2nd value axis to be the primary
                        result.y1 = axes_1[1];
                    }
                    else {
                        // make sure all layers use the same x-axis/scale for drawing
                        currentlayer.overrideXScale(result.x);
                        if (!yAxisWillMerge && !axes[1].usingDefaultDomain)
                            result.y2 = axes[1];
                    }
                }
                if (existingAxisProperties && existingAxisProperties.x) {
                    result.x.willLabelsFit = existingAxisProperties.x.willLabelsFit;
                    result.x.willLabelsWordBreak = existingAxisProperties.x.willLabelsWordBreak;
                }
                else {
                    var width = viewport.width - (margin.left + margin.right);
                    result.x.willLabelsFit = visuals.AxisHelper.LabelLayoutStrategy.willLabelsFit(result.x, width, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    // If labels do not fit and we are not scrolling, try word breaking
                    result.x.willLabelsWordBreak = (!result.x.willLabelsFit && !scrollbarVisible) && visuals.AxisHelper.LabelLayoutStrategy.willLabelsWordBreak(result.x, margin, width, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, powerbi.TextMeasurementService.getTailoredTextOrDefault, textProperties);
                }
            }
            return result;
        }
        var SvgBrush = (function () {
            function SvgBrush(brushWidth) {
                this.brush = d3.svg.brush();
                this.brushWidth = brushWidth;
            }
            SvgBrush.prototype.init = function (element) {
                this.element = element;
            };
            SvgBrush.prototype.remove = function () {
                this.element.selectAll(SvgBrush.Brush.selector).remove();
                this.brushGraphicsContext = undefined;
            };
            SvgBrush.prototype.getExtent = function () {
                return this.brush.extent();
            };
            SvgBrush.prototype.setExtent = function (extent) {
                this.brush.extent(extent);
            };
            SvgBrush.prototype.setScale = function (scale) {
                if (this.isHorizontal)
                    this.brush.x(scale);
                else
                    this.brush.y(scale);
            };
            SvgBrush.prototype.setOrientation = function (isHorizontal) {
                this.isHorizontal = isHorizontal;
            };
            SvgBrush.prototype.renderBrush = function (extentLength, brushX, brushY, scrollCallback) {
                var _this = this;
                // create graphics context if it doesn't exist
                if (!this.brushGraphicsContext) {
                    this.brushGraphicsContext = this.element.append("g")
                        .classed(SvgBrush.Brush.class, true);
                }
                this.scrollCallback = scrollCallback;
                // events
                this.brush
                    .on("brushstart", function () { return _this.brushStartExtent = _this.brush.extent(); })
                    .on("brush", function () {
                    window.requestAnimationFrame(scrollCallback);
                })
                    .on("brushend", function () {
                    _this.resizeExtent(extentLength);
                    _this.updateExtentPosition(extentLength);
                    _this.brushStartExtent = null;
                });
                // position the graphics context
                var brushContext = this.brushGraphicsContext
                    .attr({
                    "transform": visuals.SVGUtil.translate(brushX, brushY),
                    "drag-resize-disabled": "true" /* Disables resizing of the visual when dragging the scrollbar in edit mode */
                })
                    .call(this.brush);
                // Disable the zooming feature by removing the resize elements
                brushContext.selectAll(".resize")
                    .remove();
                if (this.isHorizontal)
                    brushContext.selectAll("rect").attr("height", this.brushWidth);
                else
                    brushContext.selectAll("rect").attr("width", this.brushWidth);
            };
            SvgBrush.prototype.scroll = function (scrollBarLength) {
                this.updateExtentPosition(scrollBarLength);
                this.scrollCallback();
            };
            SvgBrush.prototype.updateExtentPosition = function (scrollBarLength) {
                var extent = this.brush.extent();
                debug.assertNonEmpty(extent, 'updateExtentPosition, extent');
                var newStartPos = extent[0];
                var halfScrollBarLen = scrollBarLength / 2;
                if (extent[0] === extent[1]) {
                    // user clicked on the brush background, width will be zero, offset x by half width
                    newStartPos = newStartPos - halfScrollBarLen;
                }
                if (extent[1] - extent[0] > scrollBarLength) {
                    // user is dragging one edge after mousedown in the background, figure out which side is moving
                    // also, center up on the new extent center
                    var halfDragLength = (extent[1] - extent[0]) / 2;
                    if (extent[0] < this.brushStartExtent[0])
                        newStartPos = extent[0] + halfDragLength - halfScrollBarLen;
                    else
                        newStartPos = extent[1] - halfDragLength - halfScrollBarLen;
                }
                if (this.isHorizontal)
                    this.brushGraphicsContext.select(".extent").attr('x', newStartPos);
                else
                    this.brushGraphicsContext.select(".extent").attr('y', newStartPos);
            };
            SvgBrush.prototype.resizeExtent = function (extentLength) {
                if (this.isHorizontal)
                    this.brushGraphicsContext.select(".extent").attr("width", extentLength);
                else
                    this.brushGraphicsContext.select(".extent").attr("height", extentLength);
            };
            SvgBrush.Brush = createClassAndSelector('brush');
            return SvgBrush;
        }());
        var ScrollableAxes = (function () {
            function ScrollableAxes(axes, svgBrush) {
                this.axes = axes;
                this.brush = svgBrush;
            }
            ScrollableAxes.prototype.filterDataToViewport = function (mainAxisScale, layers, axes, scrollScale, extent, visibleCategoryCount) {
                if (scrollScale) {
                    var selected = void 0;
                    var data_1 = [];
                    // NOTE: using start + numVisibleCategories to make sure we don't have issues with exactness related to extent start/end
                    //      (don't use extent[1])
                    /*
                     When extent[0] and extent[1] are very close to the boundary of a new index, due to floating point err,
                     the "start" might move to the next index but the "end" might not change until you slide one more pixel.
                     It makes things really jittery during scrolling, sometimes you see N columns and sometimes you briefly see N+1.
                    */
                    var startIndex = visuals.AxisHelper.lookupOrdinalIndex(scrollScale, extent[0]);
                    var endIndex = startIndex + visibleCategoryCount; // NOTE: intentionally 1 past end index
                    var domain = scrollScale.domain();
                    selected = domain.slice(startIndex, endIndex); // NOTE: Up to but not including 'end'
                    if (selected && selected.length > 0) {
                        for (var i = 0; i < layers.length; i++) {
                            data_1[i] = layers[i].setFilteredData(selected[0], selected[selected.length - 1] + 1);
                        }
                        mainAxisScale.domain(selected);
                        var axisPropsToUpdate = void 0;
                        if (this.axes.isXScrollBarVisible) {
                            axisPropsToUpdate = axes.x;
                        }
                        else {
                            axisPropsToUpdate = axes.y1;
                        }
                        axisPropsToUpdate.axis.scale(mainAxisScale);
                        axisPropsToUpdate.scale(mainAxisScale);
                        // tick values are indices for ordinal axes
                        axisPropsToUpdate.axis.ticks(selected.length);
                        axisPropsToUpdate.axis.tickValues(selected);
                        // use the original tick format to format the tick values
                        var tickFormat_1 = axisPropsToUpdate.axis.tickFormat();
                        axisPropsToUpdate.values = _.map(selected, function (d) { return tickFormat_1(d); });
                    }
                }
            };
            ScrollableAxes.prototype.render = function (axesLayout, layers, suppressAnimations, renderDelegate) {
                var _this = this;
                var plotArea = axesLayout.plotArea;
                if (plotArea.width < 1 || plotArea.height < 1)
                    return; //do nothing - too small
                this.axisScale = null;
                var brushX;
                var brushY;
                var scrollbarLength;
                var numVisibleCategories;
                var categoryThickness;
                var newAxisLength;
                if (this.axes.isXScrollBarVisible) {
                    this.axisScale = axesLayout.axes.x.scale;
                    brushX = axesLayout.margin.left;
                    brushY = axesLayout.viewport.height;
                    categoryThickness = axesLayout.axes.x.categoryThickness;
                    var outerPadding = axesLayout.axes.x.outerPadding;
                    numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.width - outerPadding * 2) / categoryThickness);
                    scrollbarLength = (numVisibleCategories + 1) * categoryThickness;
                    newAxisLength = plotArea.width;
                }
                else if (this.axes.isYScrollBarVisible) {
                    this.axisScale = axesLayout.axes.y1.scale;
                    brushX = axesLayout.viewport.width;
                    brushY = axesLayout.margin.top;
                    categoryThickness = axesLayout.axes.y1.categoryThickness;
                    var outerPadding = axesLayout.axes.y1.outerPadding;
                    numVisibleCategories = powerbi.Double.floorWithPrecision((plotArea.height - outerPadding * 2) / categoryThickness);
                    scrollbarLength = (numVisibleCategories + 1) * categoryThickness;
                    newAxisLength = plotArea.height;
                }
                else {
                    // No scrollbars, render the chart normally.
                    this.brush.remove();
                    renderDelegate(layers, axesLayout, suppressAnimations);
                    return;
                }
                // viewport is REALLY small
                if (numVisibleCategories < 1)
                    return; // don't do anything
                this.scrollScale = this.axisScale.copy();
                this.scrollScale.rangeBands([0, scrollbarLength]); //no inner/outer padding, keep the math simple
                this.brushMinExtent = this.scrollScale(numVisibleCategories - 1);
                // Options: use newAxisLength to squeeze-pop and keep the chart balanced, 
                //          or use scrollbarLength to keep rects still - but it leaves unbalanced right edge
                // 1. newAxisLength ex: As you resize smaller we constantly adjust the inner/outer padding to keep things balanced with the same # of rects, 
                //      when we need to drop a rect we pop out the rectangle and the padding seems to jump (to keep things cenetered and balanced). 
                // 2. scrollbarLenghth ex: As you resize smaller we can leave all rectangles in the exact same place, no squeezing inner/outer padding,
                //      when we need to drop a rect we just remove it - but this leaves the right side with lots of empty room (bad for dashboard tiles)
                // we are using option 1 to squeeze pop and show balanced layout at all sizes, but this is the less ideal experience during resize.
                // we should consider using option 2 during resize, then switch to option 1 when resize ends.
                this.axisScale.rangeBands([0, newAxisLength], CartesianChart.InnerPaddingRatio, CartesianChart.OuterPaddingRatio);
                this.brush.setOrientation(this.axes.isXScrollBarVisible);
                this.brush.setScale(this.scrollScale);
                this.brush.setExtent([0, this.brushMinExtent]);
                // This function will be called whenever we scroll.
                var renderOnScroll = function (extent, suppressAnimations) {
                    _this.filterDataToViewport(_this.axisScale, layers, axesLayout.axes, _this.scrollScale, extent, numVisibleCategories);
                    renderDelegate(layers, axesLayout, suppressAnimations);
                };
                var scrollCallback = function () { return _this.onBrushed(scrollbarLength, renderOnScroll); };
                this.brush.renderBrush(this.brushMinExtent, brushX, brushY, scrollCallback);
                renderOnScroll(this.brush.getExtent(), suppressAnimations);
            };
            ScrollableAxes.prototype.scrollDelta = function (delta) {
                if (this.axisScale && !_.isEmpty(this.axisScale.domain())) {
                    var currentStartIndex = this.axisScale.domain()[0];
                    var newStartIndex = currentStartIndex + Math.round(delta / CartesianChart.MinOrdinalRectThickness);
                    this.scrollTo(newStartIndex);
                }
            };
            // PUBLIC FOR UNIT TESTING ONLY
            ScrollableAxes.prototype.scrollTo = function (startIndex) {
                debug.assert(this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible, 'scrolling is not available');
                debug.assertValue(this.scrollScale, 'scrollScale');
                var lastIndex = _.last(this.scrollScale.domain());
                startIndex = Math.max(0, Math.min(startIndex, lastIndex));
                var extent = this.brush.getExtent();
                var extentLength = extent[1] - extent[0];
                var halfCategoryThickness = (this.scrollScale(1) - this.scrollScale(0)) / 2;
                extent[0] = this.scrollScale(startIndex) + halfCategoryThickness;
                extent[1] = extent[0] + extentLength + halfCategoryThickness;
                this.brush.setExtent(extent);
                var scrollbarLength = this.scrollScale.rangeExtent()[1];
                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
                this.brush.scroll(scrollbarLength);
            };
            ScrollableAxes.prototype.onBrushed = function (scrollbarLength, render) {
                var brush = this.brush;
                ScrollableAxes.clampBrushExtent(this.brush, scrollbarLength, this.brushMinExtent);
                var extent = brush.getExtent();
                render(extent, /*suppressAnimations*/ true);
            };
            ScrollableAxes.clampBrushExtent = function (brush, scrollbarLength, minExtent) {
                var extent = brush.getExtent();
                var width = extent[1] - extent[0];
                if (width === minExtent && extent[1] <= scrollbarLength && extent[0] >= 0)
                    return;
                if (width > minExtent) {
                    var padding = (width - minExtent) / 2;
                    extent[0] += padding;
                    extent[1] -= padding;
                }
                else if (width < minExtent) {
                    var padding = (minExtent - width) / 2;
                    extent[0] -= padding;
                    extent[1] += padding;
                }
                if (extent[0] < 0) {
                    extent[0] = 0;
                    extent[1] = minExtent;
                }
                else if (extent[0] > scrollbarLength - minExtent) {
                    extent[0] = scrollbarLength - minExtent;
                    extent[1] = scrollbarLength;
                }
                brush.setExtent(extent);
            };
            ScrollableAxes.ScrollbarWidth = 10;
            return ScrollableAxes;
        }());
        var SvgCartesianAxes = (function () {
            function SvgCartesianAxes(axes) {
                this.axes = axes;
            }
            SvgCartesianAxes.prototype.getScrollableRegion = function () {
                return this.axisGraphicsContextScrollable;
            };
            SvgCartesianAxes.prototype.getLabelsRegion = function () {
                return this.labelRegion;
            };
            SvgCartesianAxes.prototype.getLabelBackground = function () {
                return this.labelBackgroundRegion;
            };
            SvgCartesianAxes.prototype.getXAxis = function () {
                return this.xAxisGraphicsContext;
            };
            SvgCartesianAxes.prototype.getY1Axis = function () {
                return this.y1AxisGraphicsContext;
            };
            SvgCartesianAxes.prototype.getY2Axis = function () {
                return this.y2AxisGraphicsContext;
            };
            SvgCartesianAxes.prototype.update = function (categoryAxisProperties, valueAxisProperties) {
                this.categoryAxisProperties = categoryAxisProperties;
                this.valueAxisProperties = valueAxisProperties;
            };
            SvgCartesianAxes.prototype.init = function (svg) {
                /*
                    The layout of the visual will look like:
                    <svg>
                        <g>
                            <nonscrollable axis/>
                        </g>
                        <svgScrollable>
                            <g>
                                <scrollable axis/>
                            </g>
                        </svgScrollable>
                        <g xbrush/>
                    </svg>
    
                */
                var axisGraphicsContext = this.axisGraphicsContext = svg.append('g')
                    .classed(SvgCartesianAxes.AxisGraphicsContext.class, true);
                this.svgScrollable = svg.append('svg')
                    .classed('svgScrollable', true)
                    .style('overflow', 'hidden');
                var axisGraphicsContextScrollable = this.axisGraphicsContextScrollable = this.svgScrollable.append('g')
                    .classed(SvgCartesianAxes.AxisGraphicsContext.class, true);
                this.labelBackgroundRegion = this.svgScrollable.append('g')
                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
                this.labelRegion = this.svgScrollable.append('g')
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                var showLinesOnX = this.axes.showLinesOnX;
                var showLinesOnY = this.axes.showLinesOnY;
                // NOTE: We infer the axis which should scroll based on whether or not we draw grid lines for the other axis, and
                // only allow one axis to scroll.
                var scrollX = showLinesOnY;
                var scrollY = !scrollX;
                if (scrollY) {
                    this.y1AxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'y axis');
                    this.y2AxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'y axis');
                }
                else {
                    this.y1AxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'y axis');
                    this.y2AxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'y axis');
                }
                if (scrollX) {
                    this.xAxisGraphicsContext = axisGraphicsContextScrollable.append('g').attr('class', 'x axis');
                }
                else {
                    this.xAxisGraphicsContext = axisGraphicsContext.append('g').attr('class', 'x axis');
                }
                this.xAxisGraphicsContext.classed('showLinesOnAxis', showLinesOnX);
                this.y1AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                this.y2AxisGraphicsContext.classed('showLinesOnAxis', showLinesOnY);
                this.xAxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnX);
                this.y1AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
                this.y2AxisGraphicsContext.classed('hideLinesOnAxis', !showLinesOnY);
            };
            SvgCartesianAxes.updateAnimatedTickTooltips = function (axisSelection, values) {
                axisSelection.each('end', function () {
                    d3.select(this)
                        .selectAll('text')
                        .append('title')
                        .text(function (d, i) { return values[i]; });
                });
            };
            SvgCartesianAxes.updateTickTooltips = function (axisSelection, values) {
                axisSelection.selectAll('text').append('title').text(function (d, i) { return values[i]; });
            };
            SvgCartesianAxes.prototype.renderAxes = function (axesLayout, duration) {
                var marginLimits = axesLayout.marginLimits;
                var plotArea = axesLayout.plotArea;
                var viewport = axesLayout.viewport;
                var margin = axesLayout.margin;
                var axes = axesLayout.axes;
                var tickLabelMargins = axesLayout.tickLabelMargins;
                var bottomMarginLimit = marginLimits.bottom;
                var leftRightMarginLimit = marginLimits.left;
                var xLabelColor;
                var yLabelColor;
                var y2LabelColor;
                if (this.axes.shouldRenderAxis(axes.x)) {
                    if (axes.x.isCategoryAxis) {
                        xLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
                    }
                    else {
                        xLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
                    }
                    axes.x.axis.orient("bottom");
                    // we only rotate ordinal tick labels
                    if (!axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale))
                        axes.x.axis.tickPadding(SvgCartesianAxes.TickPaddingRotatedX);
                    var xAxisGraphicsElement = this.xAxisGraphicsContext;
                    if (duration) {
                        xAxisGraphicsElement
                            .transition()
                            .duration(duration)
                            .call(axes.x.axis)
                            .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.x.values);
                    }
                    else {
                        xAxisGraphicsElement
                            .call(axes.x.axis);
                    }
                    xAxisGraphicsElement
                        .call(SvgCartesianAxes.darkenZeroLine)
                        .call(SvgCartesianAxes.setAxisLabelColor, xLabelColor);
                    var xAxisTextNodes = xAxisGraphicsElement.selectAll('text');
                    if (axes.x.willLabelsWordBreak) {
                        xAxisTextNodes
                            .call(visuals.AxisHelper.LabelLayoutStrategy.wordBreak, axes.x, bottomMarginLimit);
                    }
                    else {
                        xAxisTextNodes
                            .call(visuals.AxisHelper.LabelLayoutStrategy.rotate, bottomMarginLimit, powerbi.TextMeasurementService.getTailoredTextOrDefault, CartesianChart.AxisTextProperties, !axes.x.willLabelsFit && visuals.AxisHelper.isOrdinalScale(axes.x.scale), bottomMarginLimit === tickLabelMargins.xMax, axes.x, margin, this.axes.isXScrollBarVisible || this.axes.isYScrollBarVisible);
                    }
                    if (!duration) {
                        SvgCartesianAxes.updateTickTooltips(xAxisGraphicsElement, axes.x.values);
                    }
                }
                else {
                    this.xAxisGraphicsContext.selectAll('*').remove();
                }
                if (this.axes.shouldRenderAxis(axes.y1)) {
                    if (axes.y1.isCategoryAxis) {
                        yLabelColor = this.categoryAxisProperties && this.categoryAxisProperties['labelColor'] ? this.categoryAxisProperties['labelColor'] : null;
                    }
                    else {
                        yLabelColor = this.valueAxisProperties && this.valueAxisProperties['labelColor'] ? this.valueAxisProperties['labelColor'] : null;
                    }
                    var showY1OnRight = this.axes.shouldShowY1OnRight();
                    var y1TickPadding = showY1OnRight ? axesLayout.tickPadding.right : axesLayout.tickPadding.left;
                    axes.y1.axis
                        .tickSize(-plotArea.width)
                        .tickPadding(y1TickPadding)
                        .orient(this.axes.getYAxisOrientation().toLowerCase());
                    var y1AxisGraphicsElement = this.y1AxisGraphicsContext;
                    if (duration) {
                        y1AxisGraphicsElement
                            .transition()
                            .duration(duration)
                            .call(axes.y1.axis)
                            .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y1.values);
                    }
                    else {
                        y1AxisGraphicsElement
                            .call(axes.y1.axis);
                    }
                    y1AxisGraphicsElement
                        .call(SvgCartesianAxes.darkenZeroLine)
                        .call(SvgCartesianAxes.setAxisLabelColor, yLabelColor);
                    if (tickLabelMargins.yLeft >= leftRightMarginLimit) {
                        y1AxisGraphicsElement.selectAll('text')
                            .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                        // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                        leftRightMarginLimit - y1TickPadding, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    if (!duration) {
                        SvgCartesianAxes.updateTickTooltips(y1AxisGraphicsElement, axes.y1.values);
                    }
                    if (axes.y2 && (!this.valueAxisProperties || this.valueAxisProperties['secShow'] == null || this.valueAxisProperties['secShow'])) {
                        y2LabelColor = this.valueAxisProperties && this.valueAxisProperties['secLabelColor'] ? this.valueAxisProperties['secLabelColor'] : null;
                        var y2TickPadding = showY1OnRight ? axesLayout.tickPadding.left : axesLayout.tickPadding.right;
                        axes.y2.axis
                            .tickSize(SvgCartesianAxes.Y2TickSize)
                            .tickPadding(y2TickPadding)
                            .orient(showY1OnRight ? visuals.yAxisPosition.left.toLowerCase() : visuals.yAxisPosition.right.toLowerCase());
                        var y2AxisGraphicsElement = this.y2AxisGraphicsContext;
                        if (duration) {
                            y2AxisGraphicsElement
                                .transition()
                                .duration(duration)
                                .call(axes.y2.axis)
                                .call(SvgCartesianAxes.updateAnimatedTickTooltips, axes.y2.values);
                        }
                        else {
                            y2AxisGraphicsElement
                                .call(axes.y2.axis);
                        }
                        y2AxisGraphicsElement
                            .call(SvgCartesianAxes.darkenZeroLine)
                            .call(SvgCartesianAxes.setAxisLabelColor, y2LabelColor);
                        if (tickLabelMargins.yRight >= leftRightMarginLimit) {
                            y2AxisGraphicsElement.selectAll('text')
                                .call(visuals.AxisHelper.LabelLayoutStrategy.clip, 
                            // Can't use padding space to render text, so subtract that from available space for ellipses calculations
                            leftRightMarginLimit - y2TickPadding, powerbi.TextMeasurementService.svgEllipsis);
                        }
                        if (!duration) {
                            SvgCartesianAxes.updateTickTooltips(y2AxisGraphicsElement, axes.y2.values);
                        }
                    }
                    else {
                        this.y2AxisGraphicsContext.selectAll('*').remove();
                    }
                }
                else {
                    this.y1AxisGraphicsContext.selectAll('*').remove();
                    this.y2AxisGraphicsContext.selectAll('*').remove();
                }
                // Axis labels
                //TODO: Add label for second Y axis for combo chart
                var axisLabels = axesLayout.axisLabels;
                var chartHasAxisLabels = (axisLabels.x != null) || (axisLabels.y != null || axisLabels.y2 != null);
                if (chartHasAxisLabels) {
                    var hideXAxisTitle = !this.axes.shouldRenderAxisTitle(axes.x, /* defaultValue */ true, /* secondary */ false);
                    var hideYAxisTitle = !this.axes.shouldRenderAxisTitle(axes.y1, /* defaultValue */ true, /* secondary */ false);
                    var hideY2AxisTitle = !this.axes.shouldRenderAxisTitle(axes.y2, /* defaultValue */ false, /* secondary */ true);
                    var renderAxisOptions = {
                        axisLabels: axisLabels,
                        viewport: viewport,
                        margin: margin,
                        hideXAxisTitle: hideXAxisTitle,
                        hideYAxisTitle: hideYAxisTitle,
                        hideY2AxisTitle: hideY2AxisTitle,
                        xLabelColor: xLabelColor,
                        yLabelColor: yLabelColor,
                        y2LabelColor: y2LabelColor,
                        fontSize: SvgCartesianAxes.AxisLabelFontSize,
                    };
                    this.renderAxesLabels(renderAxisOptions);
                }
                else {
                    this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                    this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                }
                this.translateAxes(viewport, margin);
            };
            SvgCartesianAxes.prototype.renderAxesLabels = function (options) {
                debug.assertValue(options, 'options');
                debug.assertValue(options.viewport, 'options.viewport');
                debug.assertValue(options.axisLabels, 'options.axisLabels');
                this.axisGraphicsContext.selectAll('.xAxisLabel').remove();
                this.axisGraphicsContext.selectAll('.yAxisLabel').remove();
                var margin = options.margin;
                var width = options.viewport.width - (margin.left + margin.right);
                var height = options.viewport.height;
                var fontSize = options.fontSize;
                var heightOffset = fontSize;
                var showOnRight = this.axes.shouldShowY1OnRight();
                if (!options.hideXAxisTitle) {
                    var xAxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .text(options.axisLabels.x)
                        .call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "xAxisLabel",
                                "transform": visuals.SVGUtil.translate(width / 2, height - heightOffset)
                            });
                        });
                    });
                    xAxisLabel.style("fill", options.xLabelColor ? options.xLabelColor.solid.color : null);
                    xAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.x]);
                }
                if (!options.hideYAxisTitle) {
                    var yAxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .text(options.axisLabels.y)
                        .call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                "transform": "rotate(-90)",
                                "y": showOnRight ? width + margin.right - fontSize : -margin.left,
                                "x": -((height - margin.top - margin.bottom) / 2),
                                "dy": "1em",
                            });
                        });
                    });
                    yAxisLabel.style("fill", options.yLabelColor ? options.yLabelColor.solid.color : null);
                    yAxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.y]);
                }
                if (!options.hideY2AxisTitle && options.axisLabels.y2) {
                    var y2AxisLabel = this.axisGraphicsContext.append("text")
                        .style("text-anchor", "middle")
                        .text(options.axisLabels.y2)
                        .call(function (text) {
                        text.each(function () {
                            var text = d3.select(this);
                            text.attr({
                                "class": "yAxisLabel",
                                "transform": "rotate(-90)",
                                "y": showOnRight ? -margin.left : width + margin.right - fontSize,
                                "x": -((height - margin.top - margin.bottom) / 2),
                                "dy": "1em",
                            });
                        });
                    });
                    y2AxisLabel.style("fill", options.y2LabelColor ? options.y2LabelColor.solid.color : null);
                    y2AxisLabel.call(visuals.AxisHelper.LabelLayoutStrategy.clip, height - (margin.bottom + margin.top), powerbi.TextMeasurementService.svgEllipsis)
                        .call(visuals.tooltipUtils.tooltipUpdate, [options.axisLabels.y2]);
                }
            };
            // Margin convention: http://bl.ocks.org/mbostock/3019563
            SvgCartesianAxes.prototype.translateAxes = function (viewport, margin) {
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var showY1OnRight = this.axes.shouldShowY1OnRight();
                this.xAxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(0, height));
                this.y1AxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? width : 0, 0));
                this.y2AxisGraphicsContext
                    .attr('transform', visuals.SVGUtil.translate(showY1OnRight ? 0 : width, 0));
                this.svgScrollable.attr({
                    'x': 0,
                    'width': viewport.width,
                    'height': viewport.height
                });
                this.axisGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.labelRegion.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.labelBackgroundRegion.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                if (this.axes.isXScrollBarVisible) {
                    this.svgScrollable.attr({
                        'x': margin.left
                    });
                    this.axisGraphicsContextScrollable.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.labelRegion.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.labelBackgroundRegion.attr('transform', visuals.SVGUtil.translate(0, margin.top));
                    this.svgScrollable.attr('width', width);
                }
                else if (this.axes.isYScrollBarVisible) {
                    this.svgScrollable.attr('height', height + margin.top);
                }
            };
            /**
             * Within the context of the given selection (g), find the offset of
             * the zero tick using the d3 attached datum of g.tick elements.
             * 'Classed' is undefined for transition selections
             */
            SvgCartesianAxes.darkenZeroLine = function (g) {
                // remove zero-line class from all first, filtering can cause lines that are no longer zero to still be dark (since the key is index based)
                g.selectAll('g.tick line').classed('zero-line', false);
                var zeroTick = g.selectAll('g.tick').filter(function (data) { return data === 0; }).node();
                if (zeroTick) {
                    d3.select(zeroTick).select('line').classed('zero-line', true);
                }
            };
            SvgCartesianAxes.setAxisLabelColor = function (g, fill) {
                g.selectAll('g.tick text').style('fill', fill ? fill.solid.color : null);
            };
            // These match D3's internal axis padding values
            SvgCartesianAxes.AxisPadding = {
                left: 10,
                right: 10,
                top: 0,
                bottom: 13,
            };
            SvgCartesianAxes.AxisGraphicsContext = createClassAndSelector('axisGraphicsContext');
            SvgCartesianAxes.TickPaddingRotatedX = 5;
            SvgCartesianAxes.AxisLabelFontSize = 11;
            SvgCartesianAxes.Y2TickSize = -6;
            return SvgCartesianAxes;
        }());
        visuals.SvgCartesianAxes = SvgCartesianAxes;
        var CartesianAxes = (function () {
            function CartesianAxes(isScrollable, scrollbarWidth, trimOrdinalDataOnOverflow) {
                this.scrollbarWidth = scrollbarWidth;
                this.isScrollable = isScrollable;
                this.maxMarginFactor = CartesianAxes.MaxMarginFactor;
                this.yAxisOrientation = visuals.yAxisPosition.left;
                this.trimOrdinalDataOnOverflow = trimOrdinalDataOnOverflow;
            }
            CartesianAxes.prototype.shouldShowY1OnRight = function () {
                return this.yAxisOrientation === visuals.yAxisPosition.right;
            };
            CartesianAxes.prototype.isYAxisCategorical = function () {
                return this.layout && this.layout.axes.y1.isCategoryAxis;
            };
            CartesianAxes.prototype.hasCategoryAxis = function () {
                var axes = this.layout && this.layout.axes;
                if (!axes)
                    return false;
                return this.isYAxisCategorical()
                    ? axes.y1 && axes.y1.axis != null
                    : axes.x && axes.x.axis != null;
            };
            CartesianAxes.prototype.hasY2Axis = function () {
                return this.layout && this.layout.axes.y2 != null;
            };
            CartesianAxes.prototype.getYAxisOrientation = function () {
                return this.yAxisOrientation;
            };
            CartesianAxes.prototype.setAxisLinesVisibility = function (axisLinesVisibility) {
                this.showLinesOnX = EnumExtensions.hasFlag(axisLinesVisibility, 3 /* ShowLinesOnBothAxis */) ||
                    EnumExtensions.hasFlag(axisLinesVisibility, 1 /* ShowLinesOnXAxis */);
                this.showLinesOnY = EnumExtensions.hasFlag(axisLinesVisibility, 3 /* ShowLinesOnBothAxis */) ||
                    EnumExtensions.hasFlag(axisLinesVisibility, 2 /* ShowLinesOnYAxis */);
            };
            CartesianAxes.prototype.setMaxMarginFactor = function (factor) {
                this.maxMarginFactor = factor;
            };
            CartesianAxes.prototype.update = function (dataViews) {
                if (dataViews && dataViews.length > 0) {
                    var dataViewMetadata = dataViews[0].metadata;
                    this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                    this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                }
                var axisPosition = this.valueAxisProperties['position'];
                this.yAxisOrientation = axisPosition ? axisPosition.toString() : visuals.yAxisPosition.left;
            };
            CartesianAxes.prototype.addWarnings = function (warnings) {
                var axes = this.layout && this.layout.axes;
                if (axes && axes.x && axes.x.hasDisallowedZeroInDomain
                    || axes.y1 && axes.y1.hasDisallowedZeroInDomain
                    || axes.y2 && axes.y2.hasDisallowedZeroInDomain) {
                    warnings.unshift(new visuals.ZeroValueWarning());
                }
            };
            /**
             * Negotiate the axes regions, the plot area, and determine if we need a scrollbar for ordinal categories.
             * @param layers an array of Cartesian layout layers (column, line, etc.)
             * @param parentViewport the full viewport for the visual
             * @param padding the D3 axis padding values
             * @param playAxisControlLayout if this is a playable Cartesian chart, includes the layout for the play controls (start/stop, time slider)
             * @param hideAxisLabels forces axis titles to be hidden
             * @param textProperties text properties to be used by text measurement
             * @param interactivityRightMargin extra right margin for the interactivity
             * @param ensureXDomain if non null, includes values that must be part of the axis domain
             * @param ensureYDomain if non null, includes values that must be part of the axis domain
             */
            CartesianAxes.prototype.negotiateAxes = function (layers, parentViewport, padding, playAxisControlLayout, hideAxisLabels, textProperties, interactivityRightMargin, ensureXDomain, ensureYDomain) {
                // 1> MinMargins -> some initial axis properties / text
                // 2> Get axis margins for the initial text, no rotateXTickLabels90. margins grown? -> axis properties / text again (possibly more tick labels now)
                // ?> do we have more labels? do we need rotate? are we done?
                // 3> margins again (rotate? margins grow?) -> text again (less tick labls now?)
                // FREEZE PROPERTIES THAT CAN CHANGE
                // 4> margins (final), axes (final)
                // 1.a) initialize margins
                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
                var viewport = powerbi.Prototype.inherit(parentViewport);
                var leftRightMarginLimit = viewport.width * this.maxMarginFactor;
                var bottomMarginLimit = Math.max(CartesianAxes.MinimumMargin.bottom, Math.ceil(viewport.height * this.maxMarginFactor));
                var marginLimits = {
                    left: leftRightMarginLimit,
                    right: leftRightMarginLimit,
                    top: 0,
                    bottom: bottomMarginLimit,
                };
                // 1.b) Calculate axis properties using initial margins
                var axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, 
                /*scrollbarVisible*/ false, 
                /*previousAxisProperties*/ null, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain);
                // these are used by getTickLabelMargins
                var renderXAxis = this.shouldRenderAxis(axes.x);
                var renderY1Axis = this.shouldRenderAxis(axes.y1);
                var renderY2Axis = this.shouldRenderAxis(axes.y2, true);
                var showY1OnRight = this.shouldShowY1OnRight();
                var plotArea = {
                    width: viewport.width - (margin.left + margin.right),
                    height: viewport.height - (margin.top + margin.bottom)
                };
                var isScalar = false;
                if (!_.isEmpty(layers)) {
                    if (layers[0].getVisualCategoryAxisIsScalar)
                        isScalar = layers[0].getVisualCategoryAxisIsScalar();
                }
                // 2.a) calculate axis tick margins
                var tickLabelMargins = undefined;
                tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, 
                /*scrolling*/ false, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisLabels, isScalar ? 0 : interactivityRightMargin);
                // if any of these change, we need to calculate margins again
                var previousTickCountY1 = axes.y1 && axes.y1.values.length;
                var previousTickCountY2 = axes.y2 && axes.y2.values.length;
                var previousWillFitX = axes.x && axes.x.willLabelsFit;
                var previousWillBreakX = axes.x && axes.x.willLabelsWordBreak;
                // 2.b) Re-calculate the axes with the new margins.
                axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, 
                /*scrollbarVisible*/ false, 
                /*previousAxes*/ null, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain);
                plotArea.width = viewport.width - (margin.left + margin.right);
                plotArea.height = viewport.height - (margin.top + margin.bottom);
                // check properties that affect getTickLabelMargin - if these are the same, we don't need to calculate axis margins again
                var preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                var rotateXTickLabels90 = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
                var allDone = ((!axes.y1 || axes.y1.values.length === previousTickCountY1)
                    && (!axes.y2 || axes.y2.values.length === previousTickCountY2)
                    && (!axes.x || axes.x.willLabelsFit === previousWillFitX)
                    && (!axes.x || axes.x.willLabelsWordBreak === previousWillBreakX)
                    && !rotateXTickLabels90);
                this.isXScrollBarVisible = false;
                this.isYScrollBarVisible = false;
                if (!allDone) {
                    // 3.a) calculate axis tick margins
                    tickLabelMargins = visuals.AxisHelper.getTickLabelMargins(plotArea, marginLimits.left, powerbi.TextMeasurementService.measureSvgTextWidth, powerbi.TextMeasurementService.estimateSvgTextHeight, axes, marginLimits.bottom, textProperties, rotateXTickLabels90, showY1OnRight, renderXAxis, renderY1Axis, renderY2Axis);
                    margin = this.updateAxisMargins(axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisLabels, isScalar ? 0 : interactivityRightMargin);
                    // 3.b) Re-calculate the axes with the new final margins
                    axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, 
                    /*scrollbarVisible*/ rotateXTickLabels90, axes, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain);
                    // now we can determine if we need actual scrolling
                    // rotateXTickLabels90 will give more plotArea to categories since the left-overflow of a rotated category label doesn't exist anymore
                    plotArea.width = viewport.width - (margin.left + margin.right);
                    plotArea.height = viewport.height - (margin.top + margin.bottom);
                    preferredPlotArea = this.getPreferredPlotArea(axes, layers, isScalar);
                    var willScroll = !this.willAllCategoriesFitInPlotArea(plotArea, preferredPlotArea);
                    if (willScroll) {
                        if (this.showLinesOnY) {
                            this.isXScrollBarVisible = true;
                            plotArea.height -= this.scrollbarWidth;
                            viewport.height -= this.scrollbarWidth;
                        }
                        if (this.showLinesOnX) {
                            this.isYScrollBarVisible = true;
                            plotArea.width -= this.scrollbarWidth;
                            viewport.width -= this.scrollbarWidth;
                        }
                        // 3.c) Re-calculate the axes with the final margins (and the updated viewport - scrollbarWidth)
                        axes = calculateAxes(layers, viewport, margin, playAxisControlLayout, this.categoryAxisProperties, this.valueAxisProperties, textProperties, 
                        /*scrollbarVisible*/ true, axes, this.trimOrdinalDataOnOverflow, ensureXDomain, ensureYDomain);
                    }
                }
                ///////DONE
                var axisLabels = hideAxisLabels ?
                    { x: null, y: null, y2: null } :
                    { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
                this.layout = {
                    axes: axes,
                    axisLabels: axisLabels,
                    margin: margin,
                    marginLimits: marginLimits,
                    viewport: viewport,
                    plotArea: plotArea,
                    preferredPlotArea: preferredPlotArea,
                    tickLabelMargins: tickLabelMargins,
                    tickPadding: padding,
                    rotateXTickLabels90: rotateXTickLabels90,
                };
                return this.layout;
            };
            CartesianAxes.prototype.getPreferredPlotArea = function (axes, layers, isScalar) {
                var preferredPlotArea;
                if (!isScalar && this.isScrollable && !_.isEmpty(layers) && layers[0].getPreferredPlotArea) {
                    var categoryThickness = this.showLinesOnY ? axes.x.categoryThickness : axes.y1.categoryThickness;
                    var categoryCount = this.showLinesOnY ? axes.x.dataDomain.length : axes.y1.dataDomain.length;
                    preferredPlotArea = layers[0].getPreferredPlotArea(isScalar, categoryCount, categoryThickness);
                }
                return preferredPlotArea;
            };
            CartesianAxes.prototype.willAllCategoriesFitInPlotArea = function (plotArea, preferredPlotArea) {
                if (this.showLinesOnY && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.width, plotArea.width)) {
                    return false;
                }
                if (this.showLinesOnX && preferredPlotArea && powerbi.Double.greaterWithPrecision(preferredPlotArea.height, plotArea.height)) {
                    return false;
                }
                return true;
            };
            CartesianAxes.prototype.updateAxisMargins = function (axes, tickLabelMargins, padding, showY1OnRight, renderY1Axis, renderY2Axis, hideAxisTitles, interactivityRightMargin) {
                // We look at the y axes as main and second sides, if the y axis orientation is right then the main side represents the right side.
                var maxY1Padding = showY1OnRight ? tickLabelMargins.yRight : tickLabelMargins.yLeft, maxY2Padding = showY1OnRight ? tickLabelMargins.yLeft : tickLabelMargins.yRight, maxXAxisBottom = tickLabelMargins.xMax;
                maxY1Padding += padding.left;
                if ((renderY2Axis && !showY1OnRight) || (showY1OnRight && renderY1Axis))
                    maxY2Padding += padding.right;
                maxXAxisBottom += padding.bottom;
                // Adjust for axis titles
                if (hideAxisTitles) {
                    axes.x.axisLabel = null;
                    axes.y1.axisLabel = null;
                    if (axes.y2) {
                        axes.y2.axisLabel = null;
                    }
                }
                this.addUnitTypeToAxisLabels(axes);
                var axisLabels = { x: axes.x.axisLabel, y: axes.y1.axisLabel, y2: axes.y2 ? axes.y2.axisLabel : null };
                if (axisLabels.x != null)
                    maxXAxisBottom += CartesianAxes.XAxisLabelPadding;
                if (axisLabels.y != null)
                    maxY1Padding += CartesianAxes.YAxisLabelPadding;
                if (axisLabels.y2 != null)
                    maxY2Padding += CartesianAxes.YAxisLabelPadding;
                var margin = powerbi.Prototype.inherit(CartesianAxes.MinimumMargin);
                margin.left = showY1OnRight ? maxY2Padding : maxY1Padding;
                margin.right = showY1OnRight ? maxY1Padding : maxY2Padding;
                margin.right += interactivityRightMargin; // for mobile interactive legend
                margin.bottom = maxXAxisBottom;
                return margin;
            };
            CartesianAxes.prototype.isLogScaleAllowed = function (axisType) {
                var axes = this.layout && this.layout.axes;
                if (!axes)
                    return false;
                switch (axisType) {
                    case 0 /* X */:
                        return axes.x.isLogScaleAllowed;
                    case 1 /* Y1 */:
                        return axes.y1.isLogScaleAllowed;
                    case 2 /* Y2 */:
                        return axes.y2 && axes.y2.isLogScaleAllowed;
                }
            };
            CartesianAxes.prototype.axesHaveTicks = function (viewport) {
                if (!this.layout)
                    return false;
                var margin = this.layout.margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                // TODO: this is never the case, remove.
                if (visuals.AxisHelper.getRecommendedNumberOfTicksForXAxis(width) === 0
                    && visuals.AxisHelper.getRecommendedNumberOfTicksForYAxis(height) === 0) {
                    return false;
                }
                return true;
            };
            CartesianAxes.prototype.shouldRenderAxisTitle = function (axisProperties, defaultValue, secondary) {
                var propertyName = secondary ? 'secShowAxisTitle' : 'showAxisTitle';
                return !!this.getAxisProperty(axisProperties, propertyName, defaultValue);
            };
            CartesianAxes.prototype.shouldRenderAxis = function (axisProperties, secondary) {
                if (secondary === void 0) { secondary = false; }
                if (!axisProperties)
                    return false;
                var propertyName = secondary ? 'secShow' : 'show';
                return this.getAxisProperty(axisProperties, propertyName, true)
                    && axisProperties.values
                    && axisProperties.values.length > 0;
            };
            CartesianAxes.prototype.getAxisProperty = function (axisProperties, propertyName, defaultValue) {
                if (!axisProperties)
                    return defaultValue;
                var properties = axisProperties.isCategoryAxis
                    ? this.categoryAxisProperties
                    : this.valueAxisProperties;
                if (properties && properties[propertyName] != null)
                    return properties[propertyName];
                else
                    return defaultValue;
            };
            // TODO: clean this up
            CartesianAxes.prototype.addUnitTypeToAxisLabels = function (axes) {
                var unitType = CartesianAxes.getUnitType(axes.x.formatter);
                if (axes.x.isCategoryAxis) {
                    this.categoryAxisHasUnitType = unitType != null;
                }
                else {
                    this.valueAxisHasUnitType = unitType != null;
                }
                if (axes.x.axisLabel && unitType) {
                    if (axes.x.isCategoryAxis) {
                        axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.x.axisLabel, unitType);
                    }
                    else {
                        axes.x.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.x.axisLabel, unitType);
                    }
                }
                unitType = CartesianAxes.getUnitType(axes.y1.formatter);
                if (!axes.y1.isCategoryAxis) {
                    this.valueAxisHasUnitType = unitType != null;
                }
                else {
                    this.categoryAxisHasUnitType = unitType != null;
                }
                if (axes.y1.axisLabel && unitType) {
                    if (!axes.y1.isCategoryAxis) {
                        axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y1.axisLabel, unitType);
                    }
                    else {
                        axes.y1.axisLabel = visuals.AxisHelper.createAxisLabel(this.categoryAxisProperties, axes.y1.axisLabel, unitType);
                    }
                }
                if (axes.y2) {
                    var unitType_1 = CartesianAxes.getUnitType(axes.y2.formatter);
                    this.secondaryValueAxisHasUnitType = unitType_1 != null;
                    if (axes.y2.axisLabel && unitType_1) {
                        axes.y2.axisLabel = visuals.AxisHelper.createAxisLabel(this.valueAxisProperties, axes.y2.axisLabel, unitType_1, true);
                    }
                }
            };
            CartesianAxes.getUnitType = function (formatter) {
                if (formatter &&
                    formatter.displayUnit &&
                    formatter.displayUnit.value > 1)
                    return formatter.displayUnit.title;
            };
            CartesianAxes.YAxisLabelPadding = 20;
            CartesianAxes.XAxisLabelPadding = 18;
            CartesianAxes.MaxMarginFactor = 0.25;
            CartesianAxes.MinimumMargin = {
                left: 1,
                right: 1,
                top: 8,
                bottom: 25,
            };
            return CartesianAxes;
        }());
        visuals.CartesianAxes = CartesianAxes;
        var CartesianLayerFactory;
        (function (CartesianLayerFactory) {
            function createLayers(type, objects, interactivityService, animator, isScrollable, tooltipsEnabled, lineChartLabelDensityEnabled) {
                if (isScrollable === void 0) { isScrollable = false; }
                var layers = [];
                var cartesianOptions = {
                    isScrollable: isScrollable,
                    animator: animator,
                    interactivityService: interactivityService,
                    tooltipsEnabled: tooltipsEnabled,
                    lineChartLabelDensityEnabled: lineChartLabelDensityEnabled,
                };
                switch (type) {
                    case 1 /* Area */:
                        layers.push(createLineChartLayer(2 /* area */, /* inComboChart */ false, cartesianOptions));
                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
                        break;
                    case 0 /* Line */:
                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ false, cartesianOptions));
                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
                        break;
                    case 2 /* StackedArea */:
                        layers.push(createLineChartLayer(16 /* stackedArea */, /* inComboChart */ false, cartesianOptions));
                        break;
                    case 9 /* Scatter */:
                        layers.push(createScatterChartLayer(cartesianOptions));
                        //layers.push(createLineChartLayer(LineChartType.default, /* inComboChart */ false, cartesianOptions, true));
                        break;
                    case 12 /* Waterfall */:
                        layers.push(createWaterfallChartLayer(cartesianOptions));
                        break;
                    case 11 /* DataDot */:
                        layers.push(createDataDotChartLayer(cartesianOptions));
                        break;
                    case 4 /* StackedColumn */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
                        break;
                    case 3 /* ClusteredColumn */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
                        break;
                    case 8 /* HundredPercentStackedColumn */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedColumn, cartesianOptions));
                        break;
                    case 6 /* StackedBar */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedBar, cartesianOptions));
                        break;
                    case 5 /* ClusteredBar */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredBar, cartesianOptions));
                        break;
                    case 7 /* HundredPercentStackedBar */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.hundredPercentStackedBar, cartesianOptions));
                        break;
                    case 10 /* ComboChart */:
                        var columnType = getComboColumnType();
                        layers.push(createColumnChartLayer(columnType, cartesianOptions));
                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
                        break;
                    case 13 /* LineClusteredColumnCombo */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
                        break;
                    case 14 /* LineStackedColumnCombo */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
                        layers.push(createLineChartLayer(1 /* default */, /* inComboChart */ true, cartesianOptions));
                        break;
                    case 15 /* DataDotClusteredColumnCombo */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.clusteredColumn, cartesianOptions));
                        layers.push(createDataDotChartLayer(cartesianOptions));
                        break;
                    case 16 /* DataDotStackedColumnCombo */:
                        layers.push(createColumnChartLayer(visuals.ColumnChartType.stackedColumn, cartesianOptions));
                        layers.push(createDataDotChartLayer(cartesianOptions));
                        break;
                }
                return layers;
            }
            CartesianLayerFactory.createLayers = createLayers;
            function createLineChartLayer(type, inComboChart, defaultOptions, isTrendLayer) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    tooltipsEnabled: !isTrendLayer && defaultOptions.tooltipsEnabled,
                    chartType: type,
                    lineChartLabelDensityEnabled: defaultOptions.lineChartLabelDensityEnabled,
                    isTrendLayer: isTrendLayer,
                };
                if (inComboChart) {
                    options.chartType = options.chartType | 8 /* lineShadow */;
                }
                return new visuals.LineChart(options);
            }
            function createScatterChartLayer(defaultOptions) {
                defaultOptions.isScrollable = false;
                return new visuals.ScatterChart(defaultOptions);
            }
            function createWaterfallChartLayer(defaultOptions) {
                return new visuals.WaterfallChart(defaultOptions);
            }
            function createDataDotChartLayer(defaultOptions) {
                return new visuals.DataDotChart(defaultOptions);
            }
            function createColumnChartLayer(type, defaultOptions) {
                var options = {
                    animator: defaultOptions.animator,
                    interactivityService: defaultOptions.interactivityService,
                    isScrollable: defaultOptions.isScrollable,
                    tooltipsEnabled: defaultOptions.tooltipsEnabled,
                    chartType: type
                };
                return new visuals.ColumnChart(options);
            }
            function getComboColumnType(objects) {
                // This supports existing serialized forms of pinned combo-chart visuals
                var columnType = visuals.ColumnChartType.clusteredColumn;
                if (objects) {
                    var comboChartTypes = objects.general;
                    if (comboChartTypes) {
                        switch (comboChartTypes.visualType1) {
                            case 'Column':
                                columnType = visuals.ColumnChartType.clusteredColumn;
                                break;
                            case 'ColumnStacked':
                                columnType = visuals.ColumnChartType.stackedColumn;
                                break;
                            default:
                                debug.assertFail('Unsupported cartesian chart type ' + comboChartTypes.visualType1);
                        }
                        // second visual is always LineChart (for now)
                        if (comboChartTypes.visualType2) {
                            debug.assert(comboChartTypes.visualType2 === 'Line', 'expecting a LineChart for VisualType2');
                        }
                    }
                }
                return columnType;
            }
        })(CartesianLayerFactory || (CartesianLayerFactory = {}));
        var SharedColorPalette = (function () {
            function SharedColorPalette(palette) {
                this.palette = palette;
                this.clearPreferredScale();
            }
            SharedColorPalette.prototype.getColorScaleByKey = function (scaleKey) {
                this.setPreferredScale(scaleKey);
                return this.preferredScale;
            };
            SharedColorPalette.prototype.getNewColorScale = function () {
                return this.preferredScale;
            };
            SharedColorPalette.prototype.getColorByIndex = function (index) {
                return this.palette.getColorByIndex(index);
            };
            SharedColorPalette.prototype.getSentimentColors = function () {
                return this.palette.getSentimentColors();
            };
            SharedColorPalette.prototype.getBasePickerColors = function () {
                return this.palette.getBasePickerColors();
            };
            SharedColorPalette.prototype.clearPreferredScale = function () {
                this.preferredScale = this.palette.getNewColorScale();
                this.rotated = false;
            };
            SharedColorPalette.prototype.rotateScale = function () {
                // We create a new rotated the scale such that the first color of the new scale is the first
                // free color of the previous scale. Note that the new scale does not have any colors allocated
                // to particular keys.
                this.preferredScale = this.preferredScale.clone();
                this.preferredScale.clearAndRotateScale();
                this.rotated = true;
            };
            SharedColorPalette.prototype.setPreferredScale = function (scaleKey) {
                if (!this.rotated) {
                    // The first layer to express a preference sets the preferred scale.
                    this.preferredScale = this.palette.getColorScaleByKey(scaleKey);
                }
            };
            return SharedColorPalette;
        }());
        visuals.SharedColorPalette = SharedColorPalette;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var flagBar = 1 << 1;
        var flagColumn = 1 << 2;
        var flagClustered = 1 << 3;
        var flagStacked = 1 << 4;
        var flagStacked100 = flagStacked | (1 << 5);
        (function (ColumnChartType) {
            ColumnChartType[ColumnChartType["clusteredBar"] = flagBar | flagClustered] = "clusteredBar";
            ColumnChartType[ColumnChartType["clusteredColumn"] = flagColumn | flagClustered] = "clusteredColumn";
            ColumnChartType[ColumnChartType["hundredPercentStackedBar"] = flagBar | flagStacked100] = "hundredPercentStackedBar";
            ColumnChartType[ColumnChartType["hundredPercentStackedColumn"] = flagColumn | flagStacked100] = "hundredPercentStackedColumn";
            ColumnChartType[ColumnChartType["stackedBar"] = flagBar | flagStacked] = "stackedBar";
            ColumnChartType[ColumnChartType["stackedColumn"] = flagColumn | flagStacked] = "stackedColumn";
        })(visuals.ColumnChartType || (visuals.ColumnChartType = {}));
        var ColumnChartType = visuals.ColumnChartType;
        var RoleNames = {
            category: 'Category',
            series: 'Series',
            y: 'Y',
        };
        /**
         * Renders a stacked and clustered column chart.
         */
        var ColumnChart = (function () {
            function ColumnChart(options) {
                debug.assertValue(options, 'options');
                var chartType = options.chartType;
                debug.assertValue(chartType, 'chartType');
                this.chartType = chartType;
                this.categoryAxisType = null;
                this.animator = options.animator;
                this.isScrollable = options.isScrollable;
                this.tooltipsEnabled = options.tooltipsEnabled;
                this.interactivityService = options.interactivityService;
            }
            ColumnChart.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return;
                dataViewMapping.categorical.dataVolume = 4;
                if (visuals.CartesianChart.detectScalarMapping(dataViewMapping)) {
                    var dataViewCategories = dataViewMapping.categorical.categories;
                    dataViewCategories.dataReductionAlgorithm = { sample: {} };
                }
            };
            ColumnChart.getSortableRoles = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!_.isEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects = void 0;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    //TODO: column chart should be sortable by X if it has scalar axis
                    // But currenly it doesn't support this. Return 'category' once
                    // it is supported.
                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.columnChartProps.categoryAxis.axisType, categoryType)) {
                        return ['Category', 'Y'];
                    }
                }
                return null;
            };
            ColumnChart.prototype.updateVisualMetadata = function (x, y, margin) {
                this.xAxisProperties = x;
                this.yAxisProperties = y;
                this.margin = margin;
            };
            ColumnChart.prototype.init = function (options) {
                this.svg = options.svg;
                this.svg.classed(ColumnChart.ColumnChartClassName, true);
                this.unclippedGraphicsContext = this.svg.append('g').classed('columnChartUnclippedGraphicsContext', true);
                this.mainGraphicsContext = this.unclippedGraphicsContext.append('svg').classed('columnChartMainGraphicsContext', true);
                this.style = options.style;
                this.currentViewport = options.viewport;
                this.hostService = options.host;
                this.interactivity = options.interactivity;
                this.colors = this.style.colorPalette.dataColors;
                this.cartesianVisualHost = options.cartesianHost;
                this.options = options;
                this.isComboChart = visuals.ComboChart.isComboChart(options.chartType);
                this.element = options.element;
            };
            ColumnChart.prototype.getCategoryLayout = function (numCategoryValues, options) {
                var availableWidth;
                if (ColumnChart.isBar(this.chartType)) {
                    availableWidth = this.currentViewport.height - (this.margin.top + this.margin.bottom);
                }
                else {
                    availableWidth = this.currentViewport.width - (this.margin.left + this.margin.right);
                }
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var isScalar = this.data ? this.data.scalarCategoryAxis : false;
                var domain = visuals.AxisHelper.createDomain(this.data.series, categoryDataType, isScalar, options.forcedXDomain, options.ensureXDomain);
                return visuals.CartesianChart.getLayout(this.data, {
                    availableWidth: availableWidth,
                    categoryCount: numCategoryValues,
                    domain: domain,
                    isScalar: isScalar,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                });
            };
            ColumnChart.converter = function (dataView, colors, is100PercentStacked, isScalar, dataViewMetadata, chartType, interactivityService, tooltipsEnabled) {
                if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                if (isScalar === void 0) { isScalar = false; }
                if (dataViewMetadata === void 0) { dataViewMetadata = null; }
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                debug.assertValue(dataView, 'dataView');
                debug.assertValue(colors, 'colors');
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataViewMetadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataViewMetadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                var dataViewCat = visuals.ColumnUtil.applyUserMinMax(isScalar, dataView.categorical, xAxisCardProperties);
                var converterStrategy = new ColumnChartConverterHelper(dataView);
                var categoryInfo = visuals.converterHelper.getPivotedCategories(dataViewCat, visuals.columnChartProps.general.formatString);
                var categories = categoryInfo.categories, categoryFormatter = categoryInfo.categoryFormatter, categoryIdentities = categoryInfo.categoryIdentities, categoryMetadata = dataViewCat && dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0].source : undefined;
                var labelSettings = visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PercentStacked || ColumnChart.isStacked(chartType));
                var defaultLegendLabelColor = visuals.LegendData.DefaultLegendLabelFillColor;
                var defaultDataPointColor = undefined;
                var showAllDataPoints = undefined;
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                    showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints);
                    defaultLegendLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.legend.labelColor, visuals.LegendData.DefaultLegendLabelFillColor);
                    var labelsObj = objects['labels'];
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, labelSettings);
                }
                // Allocate colors
                var legendAndSeriesInfo = converterStrategy.getLegend(colors, defaultLegendLabelColor, defaultDataPointColor);
                var legend = legendAndSeriesInfo.legend.dataPoints;
                var seriesSources = legendAndSeriesInfo.seriesSources;
                // Determine data points
                var result = ColumnChart.createDataPoints(dataView, categories, categoryIdentities, legend, legendAndSeriesInfo.seriesObjects, converterStrategy, labelSettings, is100PercentStacked, isScalar, visuals.converterHelper.categoryIsAlsoSeriesRole(dataView, RoleNames.series, RoleNames.category), categoryInfo.categoryObjects, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled);
                var columnSeries = result.series;
                var valuesMetadata = [];
                for (var j = 0, jlen = legend.length; j < jlen; j++) {
                    valuesMetadata.push(seriesSources[j]);
                }
                var labels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, categoryMetadata, valuesMetadata);
                if (!ColumnChart.isColumn(chartType)) {
                    // Replace between x and y axes
                    var temp = labels.xAxisLabel;
                    labels.xAxisLabel = labels.yAxisLabel;
                    labels.yAxisLabel = temp;
                }
                if (interactivityService) {
                    for (var _i = 0, columnSeries_1 = columnSeries; _i < columnSeries_1.length; _i++) {
                        var series = columnSeries_1[_i];
                        interactivityService.applySelectionStateToData(series.data);
                    }
                    interactivityService.applySelectionStateToData(legendAndSeriesInfo.legend.dataPoints);
                }
                return {
                    categories: categories,
                    categoryFormatter: categoryFormatter,
                    series: columnSeries,
                    valuesMetadata: valuesMetadata,
                    legendData: legendAndSeriesInfo.legend,
                    hasHighlights: result.hasHighlights,
                    categoryMetadata: categoryMetadata,
                    scalarCategoryAxis: isScalar,
                    labelSettings: labelSettings,
                    axesLabels: { x: labels.xAxisLabel, y: labels.yAxisLabel },
                    hasDynamicSeries: result.hasDynamicSeries,
                    isMultiMeasure: result.isMultiMeasure,
                    defaultDataPointColor: defaultDataPointColor,
                    showAllDataPoints: showAllDataPoints,
                };
            };
            ColumnChart.canSupportOverflow = function (chartType, seriesCount) {
                return !ColumnChart.isStacked(chartType) || seriesCount === 1;
            };
            ColumnChart.createDataPoints = function (dataView, categories, categoryIdentities, legend, seriesObjectsList, converterStrategy, defaultLabelSettings, is100PercentStacked, isScalar, isCategoryAlsoSeries, categoryObjectsList, defaultDataPointColor, chartType, categoryMetadata, tooltipsEnabled) {
                if (is100PercentStacked === void 0) { is100PercentStacked = false; }
                if (isScalar === void 0) { isScalar = false; }
                var dataViewCat = dataView.categorical;
                var grouped = dataViewCat && dataViewCat.values ? dataViewCat.values.grouped() : undefined;
                var categoryCount = categories.length;
                var seriesCount = legend.length;
                var columnSeries = [];
                if (seriesCount < 1 || categoryCount < 1)
                    return { series: columnSeries, hasHighlights: false, hasDynamicSeries: false, isMultiMeasure: false };
                var dvCategories = dataViewCat.categories;
                categoryMetadata = (dvCategories && dvCategories.length > 0)
                    ? dvCategories[0].source
                    : null;
                var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var baseValuesPos = [], baseValuesNeg = [];
                var rawValues = [];
                var rawHighlightValues = [];
                var hasDynamicSeries = !!(dataViewCat.values && dataViewCat.values.source);
                var isMultiMeasure = !hasDynamicSeries && seriesCount > 1;
                var highlightsOverflow = false; // Overflow means the highlight larger than value or the signs being different
                var hasHighlights = converterStrategy.hasHighlightValues(0);
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var seriesValues = [];
                    var seriesHighlightValues = [];
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        var value = converterStrategy.getValueBySeriesAndCategory(seriesIndex, categoryIndex);
                        seriesValues[categoryIndex] = value;
                        if (hasHighlights) {
                            var highlightValue = converterStrategy.getHighlightBySeriesAndCategory(seriesIndex, categoryIndex);
                            seriesHighlightValues[categoryIndex] = highlightValue;
                            // There are two cases where we don't use overflow logic; if all are false, use overflow logic appropriate for the chart.
                            if (!((value >= 0 && highlightValue >= 0 && value >= highlightValue) ||
                                (value <= 0 && highlightValue <= 0 && value <= highlightValue))) {
                                highlightsOverflow = true;
                            }
                        }
                    }
                    rawValues.push(seriesValues);
                    if (hasHighlights) {
                        rawHighlightValues.push(seriesHighlightValues);
                    }
                }
                if (highlightsOverflow && !ColumnChart.canSupportOverflow(chartType, seriesCount)) {
                    highlightsOverflow = false;
                    hasHighlights = false;
                    rawValues = rawHighlightValues;
                }
                var dataPointObjects = categoryObjectsList, formatStringProp = visuals.columnChartProps.general.formatString;
                for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                    var seriesDataPoints = [], legendItem = legend[seriesIndex], seriesLabelSettings = void 0;
                    if (!hasDynamicSeries) {
                        var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
                        var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
                        if (labelObjects) {
                            seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);
                            visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
                        }
                    }
                    columnSeries.push({
                        displayName: legendItem.label,
                        key: 'series' + seriesIndex,
                        index: seriesIndex,
                        data: seriesDataPoints,
                        identity: legendItem.identity,
                        color: legendItem.color,
                        labelSettings: seriesLabelSettings,
                    });
                    if (seriesCount > 1)
                        dataPointObjects = seriesObjectsList[seriesIndex];
                    var metadata = dataViewCat.values[seriesIndex].source;
                    var gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(dataViewCat);
                    var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCat);
                    var valueMeasureIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Y");
                    var formatString = visuals.valueFormatter.getFormatString(metadata, formatStringProp);
                    var pctFormatString = visuals.valueFormatter.getLocalizedString('Percentage');
                    for (var categoryIndex = 0; categoryIndex < categoryCount; categoryIndex++) {
                        if (seriesIndex === 0) {
                            baseValuesPos.push(0);
                            baseValuesNeg.push(0);
                        }
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[seriesIndex][categoryIndex]);
                        if (value == null) {
                            // Optimization: Ignore null dataPoints from the fabricated category/series combination in the self cross-join.
                            // However, we must retain the first series because it is used to compute things like axis scales, and value lookups.
                            if (seriesIndex > 0)
                                continue;
                        }
                        var originalValue = value;
                        var categoryValue = categories[categoryIndex];
                        // ignore variant measures
                        if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
                            continue;
                        if (isDateTime && categoryValue)
                            categoryValue = categoryValue.getTime();
                        if (isScalar && (categoryValue == null || isNaN(categoryValue)))
                            continue;
                        var multipliers = void 0;
                        if (is100PercentStacked)
                            multipliers = visuals.StackedUtil.getStackedMultiplier(dataViewCat, categoryIndex, seriesCount, categoryCount, converterStrategy);
                        var unadjustedValue = value, isNegative = value < 0;
                        if (multipliers) {
                            if (isNegative)
                                value *= multipliers.neg;
                            else
                                value *= multipliers.pos;
                        }
                        var valueAbsolute = Math.abs(value);
                        var position = void 0;
                        if (isNegative) {
                            position = baseValuesNeg[categoryIndex];
                            if (!isNaN(valueAbsolute))
                                baseValuesNeg[categoryIndex] -= valueAbsolute;
                        }
                        else {
                            if (!isNaN(valueAbsolute))
                                baseValuesPos[categoryIndex] += valueAbsolute;
                            position = baseValuesPos[categoryIndex];
                        }
                        var seriesGroup = grouped && grouped.length > seriesIndex && grouped[seriesIndex].values ? grouped[seriesIndex].values[valueMeasureIndex] : null;
                        var category = dataViewCat.categories && dataViewCat.categories.length > 0 ? dataViewCat.categories[0] : null;
                        var identity = visuals.SelectionIdBuilder.builder()
                            .withCategory(category, categoryIndex)
                            .withSeries(dataViewCat.values, seriesGroup)
                            .withMeasure(converterStrategy.getMeasureNameByIndex(seriesIndex))
                            .createSelectionId();
                        var rawCategoryValue = categories[categoryIndex];
                        var color = ColumnChart.getDataPointColor(legendItem, categoryIndex, dataPointObjects);
                        var gradientColumnForTooltip = gradientMeasureIndex === 0 ? null : gradientValueColumn;
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            if (is100PercentStacked) {
                                var originalValueAndPct = void 0;
                                if (valueAbsolute != null && originalValue != null) {
                                    var originalPct = visuals.valueFormatter.format(valueAbsolute, pctFormatString);
                                    originalValueAndPct = visuals.valueFormatter.format(originalValue, formatString) + ' (' + originalPct + ')';
                                }
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValueAndPct, null, null, seriesIndex, categoryIndex, null, gradientColumnForTooltip);
                            }
                            else {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue, originalValue, null, null, seriesIndex, categoryIndex, null, gradientColumnForTooltip);
                            }
                        }
                        var series = columnSeries[seriesIndex];
                        var dataPointLabelSettings = (series.labelSettings) ? series.labelSettings : defaultLabelSettings;
                        var labelColor = dataPointLabelSettings.labelColor;
                        var lastValue = undefined;
                        //Stacked column/bar label color is white by default (except last series)
                        if ((ColumnChart.isStacked(chartType))) {
                            lastValue = this.getStackedLabelColor(isNegative, seriesIndex, seriesCount, categoryIndex, rawValues);
                            labelColor = (lastValue || (seriesIndex === seriesCount - 1 && !isNegative)) ? labelColor : visuals.dataLabelUtils.defaultInsideLabelColor;
                        }
                        var dataPoint = {
                            categoryValue: categoryValue,
                            value: value,
                            position: position,
                            valueAbsolute: valueAbsolute,
                            valueOriginal: unadjustedValue,
                            seriesIndex: seriesIndex,
                            labelSettings: dataPointLabelSettings,
                            categoryIndex: categoryIndex,
                            color: color,
                            selected: false,
                            originalValue: value,
                            originalPosition: position,
                            originalValueAbsolute: valueAbsolute,
                            identity: identity,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            labelFill: labelColor,
                            labelFormatString: metadata.format,
                            lastSeries: lastValue,
                            chartType: chartType
                        };
                        seriesDataPoints.push(dataPoint);
                        if (hasHighlights) {
                            var valueHighlight = rawHighlightValues[seriesIndex][categoryIndex];
                            var unadjustedValueHighlight = valueHighlight;
                            var highlightedTooltip = true;
                            if (valueHighlight === null) {
                                valueHighlight = 0;
                                highlightedTooltip = false;
                            }
                            if (is100PercentStacked) {
                                valueHighlight *= multipliers.pos;
                            }
                            var absoluteValueHighlight = Math.abs(valueHighlight);
                            var highlightPosition = position;
                            if (valueHighlight > 0) {
                                highlightPosition -= valueAbsolute - absoluteValueHighlight;
                            }
                            else if (valueHighlight === 0 && value > 0) {
                                highlightPosition -= valueAbsolute;
                            }
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var rawCategoryValue_1 = categories[categoryIndex];
                            var highlightedValueAndPct = void 0;
                            if (highlightedTooltip && unadjustedValueHighlight != null) {
                                var highlightedPct = visuals.valueFormatter.format(valueHighlight, pctFormatString);
                                highlightedValueAndPct = visuals.valueFormatter.format(unadjustedValueHighlight, formatString) + ' (' + highlightedPct + ')';
                            }
                            var tooltipInfo_1 = void 0;
                            if (tooltipsEnabled) {
                                if (is100PercentStacked) {
                                    var originalValueAndPct = void 0;
                                    if (valueAbsolute != null && originalValue != null) {
                                        var originalPct = visuals.valueFormatter.format(valueAbsolute, pctFormatString);
                                        originalValueAndPct = visuals.valueFormatter.format(originalValue, formatString) + ' (' + originalPct + ')';
                                    }
                                    tooltipInfo_1 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue_1, originalValueAndPct, null, null, seriesIndex, categoryIndex, highlightedValueAndPct, gradientColumnForTooltip);
                                }
                                else {
                                    tooltipInfo_1 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataViewCat, rawCategoryValue_1, originalValue, null, null, seriesIndex, categoryIndex, unadjustedValueHighlight, gradientColumnForTooltip);
                                }
                            }
                            if (highlightedTooltip) {
                                // Override non highlighted data point
                                dataPoint.tooltipInfo = tooltipInfo_1;
                            }
                            var highlightDataPoint = {
                                categoryValue: categoryValue,
                                value: valueHighlight,
                                position: highlightPosition,
                                valueAbsolute: absoluteValueHighlight,
                                valueOriginal: unadjustedValueHighlight,
                                seriesIndex: seriesIndex,
                                labelSettings: dataPointLabelSettings,
                                categoryIndex: categoryIndex,
                                color: color,
                                selected: false,
                                highlight: true,
                                originalValue: value,
                                originalPosition: position,
                                originalValueAbsolute: valueAbsolute,
                                drawThinner: highlightsOverflow,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                tooltipInfo: tooltipInfo_1,
                                labelFormatString: metadata.format,
                                labelFill: labelColor,
                                lastSeries: lastValue,
                                chartType: chartType
                            };
                            seriesDataPoints.push(highlightDataPoint);
                        }
                    }
                }
                return {
                    series: columnSeries,
                    hasHighlights: hasHighlights,
                    hasDynamicSeries: hasDynamicSeries,
                    isMultiMeasure: isMultiMeasure,
                };
            };
            ColumnChart.getDataPointColor = function (legendItem, categoryIndex, dataPointObjects) {
                debug.assertValue(legendItem, 'legendItem');
                debug.assertValue(categoryIndex, 'categoryIndex');
                debug.assertAnyValue(dataPointObjects, 'dataPointObjects');
                if (dataPointObjects) {
                    var colorOverride = powerbi.DataViewObjects.getFillColor(dataPointObjects[categoryIndex], visuals.columnChartProps.dataPoint.fill);
                    if (colorOverride)
                        return colorOverride;
                }
                return legendItem.color;
            };
            ColumnChart.getStackedLabelColor = function (isNegative, seriesIndex, seriesCount, categoryIndex, rawValues) {
                var lastValue = !(isNegative && seriesIndex === seriesCount - 1 && seriesCount !== 1);
                //run for the next series and check if current series is last
                for (var i = seriesIndex + 1; i < seriesCount; i++) {
                    var nextValues = visuals.AxisHelper.normalizeNonFiniteNumber(rawValues[i][categoryIndex]);
                    if ((nextValues !== null) && (((!isNegative || (isNegative && seriesIndex === 0)) && nextValues > 0) || (isNegative && seriesIndex !== 0))) {
                        lastValue = false;
                        break;
                    }
                }
                return lastValue;
            };
            ColumnChart.sliceSeries = function (series, endIndex, startIndex) {
                if (startIndex === void 0) { startIndex = 0; }
                var newSeries = [];
                if (series && series.length > 0) {
                    for (var i = 0, len = series.length; i < len; i++) {
                        var iNewSeries = newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        // TODO: [investigate] possible perf improvement.
                        // if data[n].categoryIndex > endIndex implies data[n+1].categoryIndex > endIndex
                        // then we could short circuit the filter loop.
                        iNewSeries.data = series[i].data.filter(function (d) { return d.categoryIndex >= startIndex && d.categoryIndex < endIndex; });
                    }
                }
                return newSeries;
            };
            ColumnChart.getInteractiveColumnChartDomElement = function (element) {
                return element.children("svg").get(0);
            };
            ColumnChart.prototype.setData = function (dataViews) {
                debug.assertValue(dataViews, "dataViews");
                var is100PctStacked = ColumnChart.isStacked100(this.chartType);
                this.data = {
                    categories: [],
                    categoryFormatter: null,
                    series: [],
                    valuesMetadata: [],
                    legendData: null,
                    hasHighlights: false,
                    categoryMetadata: null,
                    scalarCategoryAxis: false,
                    labelSettings: visuals.dataLabelUtils.getDefaultColumnLabelSettings(is100PctStacked || ColumnChart.isStacked(this.chartType)),
                    axesLabels: { x: null, y: null },
                    hasDynamicSeries: false,
                    defaultDataPointColor: null,
                    isMultiMeasure: false,
                };
                if (dataViews.length > 0) {
                    var dataView = this.dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dvCategories = dataView.categorical.categories;
                        var categoryMetadata = (dvCategories && dvCategories.length > 0)
                            ? dvCategories[0].source
                            : null;
                        var categoryType = visuals.AxisHelper.getCategoryValueType(categoryMetadata);
                        this.data = ColumnChart.converter(dataView, this.cartesianVisualHost.getSharedColors(), is100PctStacked, visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.columnChartProps.categoryAxis.axisType, categoryType), dataView.metadata, this.chartType, this.interactivityService, this.tooltipsEnabled);
                    }
                }
                this.setChartStrategy();
            };
            ColumnChart.prototype.setChartStrategy = function () {
                switch (this.chartType) {
                    case ColumnChartType.clusteredBar:
                        this.columnChart = new visuals.ClusteredBarChartStrategy();
                        break;
                    case ColumnChartType.clusteredColumn:
                        this.columnChart = new visuals.ClusteredColumnChartStrategy();
                        break;
                    case ColumnChartType.stackedBar:
                    case ColumnChartType.hundredPercentStackedBar:
                        this.columnChart = new visuals.StackedBarChartStrategy();
                        break;
                    case ColumnChartType.stackedColumn:
                    case ColumnChartType.hundredPercentStackedColumn:
                    default:
                        this.columnChart = new visuals.StackedColumnChartStrategy();
                        break;
                }
                // For single series, render stacked as a clustered
                if (ColumnChart.isStacked(this.chartType) && this.data.series.length === 1) {
                    switch (this.chartType) {
                        case (ColumnChartType.stackedBar):
                            this.columnChart = new visuals.ClusteredBarChartStrategy();
                            break;
                        case (ColumnChartType.stackedColumn):
                            this.columnChart = new visuals.ClusteredColumnChartStrategy();
                            break;
                    }
                }
            };
            ColumnChart.prototype.calculateLegend = function () {
                // if we're in interactive mode, return the interactive legend 
                if (this.interactivity && this.interactivity.isInteractiveLegend) {
                    return this.createInteractiveLegendDataPoints(0);
                }
                var legendData = this.data ? this.data.legendData : null;
                var legendDataPoints = legendData ? legendData.dataPoints : [];
                if (_.isEmpty(legendDataPoints))
                    return null;
                return legendData;
            };
            ColumnChart.prototype.hasLegend = function () {
                return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
            };
            ColumnChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        if (this.dataView && !visuals.GradientUtils.hasGradientRole(this.dataView.categorical))
                            this.enumerateDataPoints(enumeration);
                        break;
                    case 'labels':
                        this.enumerateDataLabels(enumeration);
                        break;
                }
            };
            ColumnChart.prototype.enumerateDataLabels = function (enumeration) {
                var data = this.data, labelSettings = this.data.labelSettings, seriesCount = data.series.length, showLabelPerSeries = !data.hasDynamicSeries && (seriesCount > 1 || !data.categoryMetadata);
                //Draw default settings
                visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries));
                if (seriesCount === 0)
                    return;
                //Draw series settings
                if (showLabelPerSeries && labelSettings.showLabelPerSeries) {
                    for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i], labelSettings_1 = (series.labelSettings) ? series.labelSettings : this.data.labelSettings;
                        enumeration.pushContainer({ displayName: series.displayName });
                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_1, series));
                        enumeration.popContainer();
                    }
                }
            };
            ColumnChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, series, showAll) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: true,
                    displayUnits: !ColumnChart.isStacked100(this.chartType),
                    precision: true,
                    selector: series && series.identity ? series.identity.getSelector() : null,
                    showAll: showAll,
                    fontSize: true,
                };
            };
            ColumnChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var seriesCount = data.series.length;
                if (seriesCount === 0)
                    return;
                if (data.hasDynamicSeries || seriesCount > 1 || !data.categoryMetadata) {
                    for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: series.displayName,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: { solid: { color: series.color } }
                            },
                        });
                    }
                }
                else {
                    // For single-category, single-measure column charts, the user can color the individual bars.
                    var singleSeriesData = data.series[0].data;
                    var categoryFormatter = data.categoryFormatter;
                    // Add default color and show all slices
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                        }
                    }).pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: !!data.showAllDataPoints
                        }
                    });
                    if (data.showAllDataPoints) {
                        for (var i = 0; i < singleSeriesData.length; i++) {
                            var singleSeriesDataPoints = singleSeriesData[i], categoryValue = data.categories[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: categoryFormatter ? categoryFormatter.format(categoryValue) : categoryValue,
                                selector: visuals.ColorHelper.normalizeSelector(singleSeriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
                                properties: {
                                    fill: { solid: { color: singleSeriesDataPoints.color } }
                                },
                            });
                        }
                    }
                }
            };
            ColumnChart.prototype.calculateAxesProperties = function (options) {
                var data = this.data;
                this.currentViewport = options.viewport;
                var margin = this.margin = options.margin;
                var origCatgSize = (data && data.categories) ? data.categories.length : 0;
                var chartLayout = data ? this.getCategoryLayout(origCatgSize, options) : {
                    categoryCount: 0,
                    categoryThickness: visuals.CartesianChart.MinOrdinalRectThickness,
                    outerPaddingRatio: visuals.CartesianChart.OuterPaddingRatio,
                    isScalar: false
                };
                this.categoryAxisType = chartLayout.isScalar ? visuals.axisType.scalar : null;
                if (data && !chartLayout.isScalar && !this.isScrollable && options.trimOrdinalDataOnOverflow) {
                    // trim data that doesn't fit on dashboard
                    var catgSize = Math.min(origCatgSize, chartLayout.categoryCount);
                    if (catgSize !== origCatgSize) {
                        data = powerbi.Prototype.inherit(data);
                        data.series = ColumnChart.sliceSeries(data.series, catgSize);
                        data.categories = data.categories.slice(0, catgSize);
                    }
                }
                this.columnChart.setData(data);
                var preferredPlotArea = this.getPreferredPlotArea(chartLayout.isScalar, chartLayout.categoryCount, chartLayout.categoryThickness);
                var is100Pct = ColumnChart.isStacked100(this.chartType);
                var chartContext = {
                    height: preferredPlotArea.height,
                    width: preferredPlotArea.width,
                    duration: 0,
                    hostService: this.hostService,
                    unclippedGraphicsContext: this.unclippedGraphicsContext,
                    mainGraphicsContext: this.mainGraphicsContext,
                    margin: this.margin,
                    layout: chartLayout,
                    animator: this.animator,
                    interactivityService: this.interactivityService,
                    viewportHeight: this.currentViewport.height - (margin.top + margin.bottom),
                    viewportWidth: this.currentViewport.width - (margin.left + margin.right),
                    is100Pct: is100Pct,
                    isComboChart: this.isComboChart,
                };
                this.ApplyInteractivity(chartContext);
                this.columnChart.setupVisualProps(chartContext);
                var ensureXDomain;
                var ensureYDomain;
                var isBarChart = ColumnChart.isBar(this.chartType);
                if (isBarChart) {
                    var temp = options.forcedXDomain;
                    options.forcedXDomain = options.forcedYDomain;
                    options.forcedYDomain = temp;
                    // In the case of clustered and stacked bar charts, the y1 reference line is a vertical line
                    ensureXDomain = options.ensureYDomain;
                }
                else {
                    ensureYDomain = options.ensureYDomain;
                }
                this.xAxisProperties = this.columnChart.setXScale(is100Pct, options.forcedTickCount, options.forcedXDomain, isBarChart ? options.valueAxisScaleType : options.categoryAxisScaleType, isBarChart ? options.valueAxisDisplayUnits : options.categoryAxisDisplayUnits, isBarChart ? options.valueAxisPrecision : options.categoryAxisPrecision, ensureXDomain);
                this.yAxisProperties = this.columnChart.setYScale(is100Pct, options.forcedTickCount, options.forcedYDomain, isBarChart ? options.categoryAxisScaleType : options.valueAxisScaleType, isBarChart ? options.categoryAxisDisplayUnits : options.valueAxisDisplayUnits, isBarChart ? options.categoryAxisPrecision : options.valueAxisPrecision, ensureYDomain);
                if (options.showCategoryAxisLabel && this.xAxisProperties.isCategoryAxis || options.showValueAxisLabel && !this.xAxisProperties.isCategoryAxis) {
                    this.xAxisProperties.axisLabel = data.axesLabels.x;
                }
                else {
                    this.xAxisProperties.axisLabel = null;
                }
                if (options.showValueAxisLabel && !this.yAxisProperties.isCategoryAxis || options.showCategoryAxisLabel && this.yAxisProperties.isCategoryAxis) {
                    this.yAxisProperties.axisLabel = data.axesLabels.y;
                }
                else {
                    this.yAxisProperties.axisLabel = null;
                }
                return [this.xAxisProperties, this.yAxisProperties];
            };
            ColumnChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                var plotArea = {
                    height: this.currentViewport.height - this.margin.top - this.margin.bottom,
                    width: this.currentViewport.width - this.margin.left - this.margin.right
                };
                if (this.isScrollable && !isScalar) {
                    var preferredCategorySpan = visuals.CartesianChart.getPreferredCategorySpan(categoryCount, categoryThickness);
                    if (ColumnChart.isBar(this.chartType)) {
                        plotArea.height = Math.max(preferredCategorySpan, plotArea.height);
                    }
                    else
                        plotArea.width = Math.max(preferredCategorySpan, plotArea.width);
                }
                return plotArea;
            };
            ColumnChart.prototype.ApplyInteractivity = function (chartContext) {
                var _this = this;
                var interactivity = this.interactivity;
                if (interactivity) {
                    if (interactivity.dragDataPoint) {
                        chartContext.onDragStart = function (datum) {
                            if (!datum.identity)
                                return;
                            _this.hostService.onDragStart({
                                event: d3.event,
                                data: {
                                    data: datum.identity.getSelector()
                                }
                            });
                        };
                    }
                    if (interactivity.isInteractiveLegend) {
                        var dragMove = function () {
                            var mousePoint = d3.mouse(_this.mainGraphicsContext[0][0]); // get the x and y for the column area itself
                            var x = mousePoint[0];
                            var y = mousePoint[1];
                            var index = _this.columnChart.getClosestColumnIndex(x, y);
                            _this.selectColumn(index);
                        };
                        var ColumnChartSvg = ColumnChart.getInteractiveColumnChartDomElement(this.element);
                        //set click interaction on the visual
                        this.svg.on('click', dragMove);
                        //set click interaction on the background
                        d3.select(ColumnChartSvg)
                            .on('click', dragMove)
                            .style('touch-action', 'none');
                        var drag = d3.behavior.drag()
                            .origin(Object)
                            .on("drag", dragMove);
                        //set drag interaction on the visual
                        this.svg.call(drag);
                        //set drag interaction on the background
                        d3.select(ColumnChartSvg).call(drag);
                    }
                }
            };
            ColumnChart.prototype.selectColumn = function (indexOfColumnSelected, force) {
                if (force === void 0) { force = false; }
                if (!force && this.lastInteractiveSelectedColumnIndex === indexOfColumnSelected)
                    return; // same column, nothing to do here
                var legendData = this.createInteractiveLegendDataPoints(indexOfColumnSelected);
                var legendDataPoints = legendData.dataPoints;
                this.cartesianVisualHost.updateLegend(legendData);
                if (legendDataPoints.length > 0) {
                    this.columnChart.selectColumn(indexOfColumnSelected, this.lastInteractiveSelectedColumnIndex);
                }
                this.lastInteractiveSelectedColumnIndex = indexOfColumnSelected;
            };
            ColumnChart.prototype.createInteractiveLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data || _.isEmpty(data.series))
                    return { dataPoints: [] };
                var formatStringProp = visuals.columnChartProps.general.formatString;
                var legendDataPoints = [];
                var category = data.categories && data.categories[columnIndex];
                var allSeries = data.series;
                var dataPoints = data.legendData && data.legendData.dataPoints;
                var converterStrategy = new ColumnChartConverterHelper(this.dataView);
                for (var i = 0, len = allSeries.length; i < len; i++) {
                    var measure = converterStrategy.getValueBySeriesAndCategory(i, columnIndex);
                    var valueMetadata = data.valuesMetadata[i];
                    var formattedLabel = visuals.converterHelper.getFormattedLegendLabel(valueMetadata, this.dataView.categorical.values, formatStringProp);
                    var dataPointColor = void 0;
                    if (allSeries.length === 1) {
                        var series = allSeries[0];
                        dataPointColor = series.data.length > columnIndex && series.data[columnIndex].color;
                    }
                    else {
                        dataPointColor = dataPoints.length > i && dataPoints[i].color;
                    }
                    legendDataPoints.push({
                        color: dataPointColor,
                        icon: visuals.LegendIcon.Box,
                        label: formattedLabel,
                        category: data.categoryFormatter ? data.categoryFormatter.format(category) : category,
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(valueMetadata, formatStringProp)),
                        identity: visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return { dataPoints: legendDataPoints };
            };
            ColumnChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            ColumnChart.prototype.render = function (suppressAnimations) {
                var columnChartDrawInfo = this.columnChart.drawColumns(!suppressAnimations /* useAnimations */);
                var data = this.data;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var width = viewport.width - (margin.left + margin.right);
                this.mainGraphicsContext
                    .attr('height', height)
                    .attr('width', width);
                if (this.tooltipsEnabled)
                    visuals.TooltipManager.addTooltip(columnChartDrawInfo.eventGroup, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                var allDataPoints = [];
                var behaviorOptions = undefined;
                if (this.interactivityService) {
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        allDataPoints = allDataPoints.concat(data.series[i].data);
                    }
                    behaviorOptions = {
                        datapoints: allDataPoints,
                        eventGroup: columnChartDrawInfo.eventGroup,
                        bars: columnChartDrawInfo.shapesSelection,
                        hasHighlights: data.hasHighlights,
                        mainGraphicsContext: this.mainGraphicsContext,
                        viewport: columnChartDrawInfo.viewport,
                        axisOptions: columnChartDrawInfo.axisOptions,
                        showLabel: data.labelSettings.show
                    };
                }
                if (this.interactivity && this.interactivity.isInteractiveLegend) {
                    if (this.data.series.length > 0) {
                        this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(this.data.series), true); // start with the last column
                    }
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                return { dataPoints: allDataPoints, behaviorOptions: behaviorOptions, labelDataPoints: columnChartDrawInfo.labelDataPoints, labelsAreNumeric: true };
            };
            ColumnChart.prototype.onClearSelection = function () {
                if (this.interactivityService) {
                    this.interactivityService.clearSelection();
                }
            };
            ColumnChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return this.data ? this.data.scalarCategoryAxis : false;
            };
            ColumnChart.prototype.getSupportedCategoryAxisType = function () {
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var valueType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var isOrdinal = visuals.AxisHelper.isOrdinal(valueType);
                return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
            };
            ColumnChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var data = powerbi.Prototype.inherit(this.data);
                data.series = ColumnChart.sliceSeries(data.series, endIndex, startIndex);
                data.categories = data.categories.slice(startIndex, endIndex);
                this.columnChart.setData(data);
                return data;
            };
            ColumnChart.getLabelFill = function (labelColor, isInside, isCombo) {
                if (labelColor) {
                    return labelColor;
                }
                if (isInside && !isCombo) {
                    return visuals.NewDataLabelUtils.defaultInsideLabelColor;
                }
                return visuals.NewDataLabelUtils.defaultLabelColor;
            };
            ColumnChart.prototype.supportsTrendLine = function () {
                var isScalar = this.data ? this.data.scalarCategoryAxis : false;
                return this.chartType === ColumnChartType.clusteredColumn && isScalar;
            };
            ColumnChart.isBar = function (chartType) {
                return EnumExtensions.hasFlag(chartType, flagBar);
            };
            ColumnChart.isColumn = function (chartType) {
                return EnumExtensions.hasFlag(chartType, flagColumn);
            };
            ColumnChart.isClustered = function (chartType) {
                return EnumExtensions.hasFlag(chartType, flagClustered);
            };
            ColumnChart.isStacked = function (chartType) {
                return EnumExtensions.hasFlag(chartType, flagStacked);
            };
            ColumnChart.isStacked100 = function (chartType) {
                return EnumExtensions.hasFlag(chartType, flagStacked100);
            };
            ColumnChart.ColumnChartClassName = 'columnChart';
            ColumnChart.clusteredValidLabelPositions = [16 /* OutsideEnd */, 4 /* InsideEnd */, 1 /* InsideCenter */, 2 /* InsideBase */];
            ColumnChart.stackedValidLabelPositions = [1 /* InsideCenter */, 4 /* InsideEnd */, 2 /* InsideBase */];
            ColumnChart.SeriesClasses = jsCommon.CssConstants.createClassAndSelector('series');
            return ColumnChart;
        }());
        visuals.ColumnChart = ColumnChart;
        var ColumnChartConverterHelper = (function () {
            function ColumnChartConverterHelper(dataView) {
                this.dataView = dataView && dataView.categorical;
                this.reader = powerbi.data.createIDataViewCategoricalReader(dataView);
            }
            ColumnChartConverterHelper.prototype.getLegend = function (colors, defaultLegendLabelColor, defaultColor) {
                var legend = [];
                var seriesSources = [];
                var seriesObjects = [];
                var grouped = false;
                var colorHelper = new visuals.ColorHelper(colors, visuals.columnChartProps.dataPoint.fill, defaultColor);
                var legendTitle = undefined;
                if (this.dataView && this.dataView.values) {
                    var allValues = this.dataView.values;
                    var valueGroups = allValues.grouped();
                    var hasDynamicSeries = !!(allValues && allValues.source);
                    var formatStringProp = visuals.columnChartProps.general.formatString;
                    for (var valueGroupsIndex = 0, valueGroupsLen = valueGroups.length; valueGroupsIndex < valueGroupsLen; valueGroupsIndex++) {
                        var valueGroup = valueGroups[valueGroupsIndex], valueGroupObjects = valueGroup.objects, values = valueGroup.values;
                        for (var valueIndex = 0, valuesLen = values.length; valueIndex < valuesLen; valueIndex++) {
                            var series = values[valueIndex];
                            var source = series.source;
                            // Gradient measures do not create series.
                            if (DataRoleHelper.hasRole(source, 'Gradient') && !DataRoleHelper.hasRole(source, 'Y'))
                                continue;
                            seriesSources.push(source);
                            seriesObjects.push(series.objects);
                            var selectionId = series.identity ?
                                visuals.SelectionId.createWithIdAndMeasure(series.identity, source.queryName) :
                                visuals.SelectionId.createWithMeasure(this.getMeasureNameByIndex(valueIndex));
                            var label = visuals.converterHelper.getFormattedLegendLabel(source, allValues, formatStringProp);
                            var color = hasDynamicSeries
                                ? colorHelper.getColorForSeriesValue(valueGroupObjects || source.objects, allValues.identityFields, source.groupName)
                                : colorHelper.getColorForMeasure(valueGroupObjects || source.objects, source.queryName);
                            legend.push({
                                icon: visuals.LegendIcon.Box,
                                color: color,
                                label: label,
                                identity: selectionId,
                                selected: false,
                            });
                            if (series.identity && source.groupName !== undefined) {
                                grouped = true;
                            }
                        }
                    }
                    var dvValues = this.dataView.values;
                    legendTitle = dvValues && dvValues.source ? dvValues.source.displayName : "";
                }
                var legendData = {
                    title: legendTitle,
                    dataPoints: legend,
                    grouped: grouped,
                    labelColor: defaultLegendLabelColor,
                };
                return {
                    legend: legendData,
                    seriesSources: seriesSources,
                    seriesObjects: seriesObjects,
                };
            };
            ColumnChartConverterHelper.prototype.getValueBySeriesAndCategory = function (series, category) {
                if (this.reader.hasDynamicSeries()) {
                    // Combo chart dynamic series is broken when line and column have the same measure, so for now,
                    //   work around this by using the grouped directly instead of relying on the reader and roles
                    var grouped = this.dataView.values.grouped();
                    return grouped[series].values[0].values[category];
                }
                return this.reader.getValue('Y', category, series);
            };
            ColumnChartConverterHelper.prototype.getMeasureNameByIndex = function (index) {
                return this.dataView.values[index].source.queryName;
            };
            ColumnChartConverterHelper.prototype.hasHighlightValues = function (series) {
                var column = this.dataView && this.dataView.values ? this.dataView.values[series] : undefined;
                return column && !!column.highlights;
            };
            ColumnChartConverterHelper.prototype.getHighlightBySeriesAndCategory = function (series, category) {
                return this.dataView.values[series].highlights[category];
            };
            return ColumnChartConverterHelper;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var ClusteredColumnChartStrategy = (function () {
            function ClusteredColumnChartStrategy() {
            }
            ClusteredColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
                this.graphicsContext = columnChartProps;
                this.margin = columnChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = columnChartProps.layout;
                this.animator = columnChartProps.animator;
                this.interactivityService = columnChartProps.interactivityService;
                this.viewportHeight = columnChartProps.viewportHeight;
                this.viewportWidth = columnChartProps.viewportWidth;
                this.isComboChart = columnChartProps.isComboChart;
            };
            ClusteredColumnChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            ClusteredColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                var width = this.width;
                var forcedXMin, forcedXMax;
                if (forcedXDomain && forcedXDomain.length === 2) {
                    forcedXMin = forcedXDomain[0];
                    forcedXMax = forcedXDomain[1];
                }
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain);
                // create clustered offset scale
                var seriesLength = this.data.series.length;
                var columnWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio)) / seriesLength;
                this.seriesOffsetScale = d3.scale.ordinal()
                    .domain(this.data.series.map(function (s) { return s.index; }))
                    .rangeBands([0, seriesLength * columnWidth]);
                return props;
            };
            ClusteredColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                debug.assert(!is100Pct, 'Cannot have 100% clustered chart.');
                var height = this.viewportHeight;
                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true) || visuals.emptyDomain;
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomain, ensureYDomain);
                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
                this.yProps = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: this.data.valuesMetadata[0],
                    formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    shouldClamp: shouldClamp,
                });
                return this.yProps;
            };
            ClusteredColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data could not be null or undefined');
                this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var categoryWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio));
                var columnWidth = categoryWidth / data.series.length;
                var axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var clusteredColumnLayout = this.layout = ClusteredColumnChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var labelDataPoints = [];
                if (dataLabelSettings && dataLabelSettings.show) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredColumnLayout,
                        itemCS: ClusteredColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: { height: this.height, width: this.width }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredColumnLayout, ClusteredColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: { height: this.height, width: this.width },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints,
                };
            };
            ClusteredColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            ClusteredColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            };
            /**
             * Get the chart's columns centers (x value).
             */
            ClusteredColumnChartStrategy.prototype.getColumnsCenters = function () {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var xScaleOffset_1 = 0;
                        if (!this.categoryLayout.isScalar)
                            xScaleOffset_1 = categoryWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_1; });
                    }
                }
                return this.columnsCenters;
            };
            ClusteredColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters();
                var x = columnCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append('g');
                    handle.append('line')
                        .classed('interactive-hover-line', true)
                        .attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height,
                    });
                    handle.append('circle')
                        .attr({
                        cx: x,
                        cy: this.height,
                        r: '6px',
                    })
                        .classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ x1: x, x2: x });
                    handle.select('circle').attr({ cx: x });
                }
            };
            ClusteredColumnChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var scaledY0 = yScale(0);
                var xScaleOffset = 0;
                if (isScalar)
                    xScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    shapeLayout: {
                        width: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.value), 0); },
                        height: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.value)); },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset; },
                        y: function (d) { return scaledY0 + visuals.AxisHelper.diffScaled(yScale, Math.max(0, d.originalValue), 0); },
                        height: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(yScale, 0, d.originalValue)); },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - xScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        y: function (d) { return scaledY0; },
                        height: function (d) { return 0; },
                    },
                };
            };
            ClusteredColumnChartStrategy.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = this.layout.shapeLayout;
                for (var _i = 0, series_2 = series; _i < series_2.length; _i++) {
                    var currentSeries = series_2[_i];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (!labelSettings.show)
                        continue;
                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                            continue;
                        }
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        // Calculate label text
                        var formatString = dataPoint.labelFormatString;
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
                                validPositions: visuals.ColumnChart.clusteredValidLabelPositions,
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                        });
                    }
                }
                return labelDataPoints;
            };
            ClusteredColumnChartStrategy.classes = {
                item: {
                    class: 'column',
                    selector: '.column',
                },
            };
            return ClusteredColumnChartStrategy;
        }());
        visuals.ClusteredColumnChartStrategy = ClusteredColumnChartStrategy;
        var ClusteredBarChartStrategy = (function () {
            function ClusteredBarChartStrategy() {
            }
            ClusteredBarChartStrategy.prototype.setupVisualProps = function (barChartProps) {
                this.graphicsContext = barChartProps;
                this.margin = barChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = barChartProps.layout;
                this.animator = barChartProps.animator;
                this.interactivityService = barChartProps.interactivityService;
                this.viewportHeight = barChartProps.viewportHeight;
                this.viewportWidth = barChartProps.viewportWidth;
                this.isComboChart = barChartProps.isComboChart;
            };
            ClusteredBarChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            ClusteredBarChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                var height = this.height;
                var forcedYMin, forcedYMax;
                if (forcedYDomain && forcedYDomain.length === 2) {
                    forcedYMin = forcedYDomain[0];
                    forcedYMax = forcedYDomain[1];
                }
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain);
                // create clustered offset scale
                var seriesLength = this.data.series.length;
                var columnWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio)) / seriesLength;
                this.seriesOffsetScale = d3.scale.ordinal()
                    .domain(this.data.series.map(function (s) { return s.index; }))
                    .rangeBands([0, seriesLength * columnWidth]);
                return props;
            };
            ClusteredBarChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                debug.assert(!is100Pct, 'Cannot have 100% clustered chart.');
                debug.assert(forcedTickCount === undefined, 'Cannot have clustered bar chart as combo chart.');
                var width = this.width;
                var valueDomain = visuals.AxisHelper.createValueDomain(this.data.series, true) || visuals.emptyDomain;
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomain, ensureXDomain);
                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomain);
                this.xProps = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedDomain,
                    metaDataColumn: this.data.valuesMetadata[0],
                    formatString: visuals.valueFormatter.getFormatString(this.data.valuesMetadata[0], visuals.columnChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: false,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    shouldClamp: shouldClamp,
                });
                this.xProps.axis.tickSize(-this.viewportHeight, 0);
                return this.xProps;
            };
            ClusteredBarChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data could not be null or undefined');
                this.barsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var categoryWidth = (this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio));
                var columnWidth = categoryWidth / data.series.length;
                var axisOptions = {
                    columnWidth: columnWidth,
                    categoryWidth: categoryWidth,
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    seriesOffsetScale: this.seriesOffsetScale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var clusteredBarLayout = this.layout = ClusteredBarChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var labelDataPoints = [];
                if (dataLabelSettings && dataLabelSettings.show) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: clusteredBarLayout,
                        itemCS: ClusteredBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: { height: this.height, width: this.width }
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, clusteredBarLayout, ClusteredBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: { height: this.height, width: this.width },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints,
                };
            };
            ClusteredBarChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, ClusteredBarChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            ClusteredBarChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            };
            /**
             * Get the chart's columns centers (y value).
             */
            ClusteredBarChartStrategy.prototype.getBarsCenters = function () {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var yScaleOffset_1 = 0;
                        if (!this.categoryLayout.isScalar)
                            yScaleOffset_1 = barWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function (d) { return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_1; });
                    }
                }
                return this.barsCenters;
            };
            ClusteredBarChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var barCenters = this.getBarsCenters();
                var y = barCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append('g');
                    handle.append('line')
                        .classed('interactive-hover-line', true)
                        .attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y,
                    });
                    handle.append('circle')
                        .attr({
                        cx: 0,
                        cy: y,
                        r: '6px',
                    })
                        .classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ y1: y, y2: y });
                    handle.select('circle').attr({ cy: y });
                }
            };
            ClusteredBarChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var halfColumnWidth = 0.5 * columnWidth;
                var quarterColumnWidth = halfColumnWidth / 2;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var seriesOffsetScale = axisOptions.seriesOffsetScale;
                var scaledX0 = xScale(0);
                var yScaleOffset = 0;
                if (isScalar)
                    yScaleOffset = axisOptions.categoryWidth / 2;
                return {
                    shapeLayout: {
                        width: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.value)); },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        height: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return Math.abs(visuals.AxisHelper.diffScaled(xScale, 0, d.originalValue)); },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.originalValue), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return 0; },
                        x: function (d) { return scaledX0 + visuals.AxisHelper.diffScaled(xScale, Math.min(0, d.value), 0); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) + seriesOffsetScale(d.seriesIndex) - yScaleOffset + (d.drawThinner ? quarterColumnWidth : 0); },
                        height: function (d) { return d.drawThinner ? halfColumnWidth : columnWidth; },
                    },
                };
            };
            ClusteredBarChartStrategy.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = this.layout.shapeLayout;
                for (var _i = 0, series_3 = series; _i < series_3.length; _i++) {
                    var currentSeries = series_3[_i];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (!labelSettings.show)
                        continue;
                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((this.interactivityService && this.interactivityService.hasSelection() && !dataPoint.selected) || (data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                            continue;
                        }
                        // Calculate label text
                        var formatString = dataPoint.labelFormatString;
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 3 /* HorizontalLeftBased */ : 4 /* HorizontalRightBased */,
                                validPositions: visuals.ColumnChart.clusteredValidLabelPositions,
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                        });
                    }
                }
                return labelDataPoints;
            };
            ClusteredBarChartStrategy.classes = {
                item: {
                    class: 'bar',
                    selector: '.bar'
                },
            };
            return ClusteredBarChartStrategy;
        }());
        visuals.ClusteredBarChartStrategy = ClusteredBarChartStrategy;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var StackedColumnChartStrategy = (function () {
            function StackedColumnChartStrategy() {
            }
            StackedColumnChartStrategy.prototype.setupVisualProps = function (columnChartProps) {
                this.graphicsContext = columnChartProps;
                this.margin = columnChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = columnChartProps.layout;
                this.animator = columnChartProps.animator;
                this.interactivityService = columnChartProps.interactivityService;
                this.viewportHeight = columnChartProps.viewportHeight;
                this.viewportWidth = columnChartProps.viewportWidth;
                this.isComboChart = columnChartProps.isComboChart;
            };
            StackedColumnChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            StackedColumnChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue) {
                var width = this.width;
                var forcedXMin, forcedXMax;
                if (forcedXDomain && forcedXDomain.length === 2) {
                    forcedXMin = forcedXDomain[0];
                    forcedXMax = forcedXDomain[1];
                }
                var props = this.xProps = visuals.ColumnUtil.getCategoryAxis(this.data, width, this.categoryLayout, false, forcedXMin, forcedXMax, axisScaleType, axisDisplayUnits, axisPrecision, xReferenceLineValue);
                return props;
            };
            StackedColumnChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, y1ReferenceLineValue) {
                var height = this.viewportHeight;
                var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);
                var valueDomainArr = [valueDomain.min, valueDomain.max];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedYDomain, valueDomainArr, y1ReferenceLineValue);
                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
                var metadataColumn = this.data.valuesMetadata[0];
                var formatString = is100Pct ?
                    this.graphicsContext.hostService.getLocalizedString('Percentage')
                    : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                this.yProps = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: metadataColumn,
                    formatString: formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    is100Pct: is100Pct,
                    shouldClamp: shouldClamp,
                });
                return this.yProps;
            };
            StackedColumnChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data should not be null or undefined');
                this.columnsCenters = null; // invalidate the columnsCenters so that will be calculated again
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var stackedColumnLayout = this.layout = StackedColumnChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var labelDataPoints = [];
                if (dataLabelSettings && dataLabelSettings.show) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedColumnLayout,
                        itemCS: StackedColumnChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: { height: this.height, width: this.width },
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedColumnLayout, StackedColumnChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: { height: this.height, width: this.width },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints,
                };
            };
            StackedColumnChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedColumnChartStrategy.classes.item.selector, selectedColumnIndex, lastSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            StackedColumnChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(x, this.getColumnsCenters());
            };
            /**
             * Get the chart's columns centers (x value).
             */
            StackedColumnChartStrategy.prototype.getColumnsCenters = function () {
                var _this = this;
                if (!this.columnsCenters) {
                    var categoryWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var xScaleOffset_2 = 0;
                        if (!this.categoryLayout.isScalar)
                            xScaleOffset_2 = categoryWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.columnsCenters = firstSeries.data.map(function (d) { return _this.xProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + xScaleOffset_2; });
                    }
                }
                return this.columnsCenters;
            };
            StackedColumnChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var columnCenters = this.getColumnsCenters();
                var x = columnCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append('g');
                    handle.append('line')
                        .classed('interactive-hover-line', true)
                        .attr({
                        x1: x,
                        x2: x,
                        y1: 0,
                        y2: this.height,
                    });
                    handle.append('circle')
                        .attr({
                        cx: x,
                        cy: this.height,
                        r: '6px',
                    })
                        .classed('drag-handle', true);
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ x1: x, x2: x });
                    handle.select('circle').attr({ cx: x });
                }
            };
            StackedColumnChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var xScaleOffset = 0;
                if (isScalar)
                    xScaleOffset = columnWidth / 2;
                // d.position is the top left corner (for drawing) - set in columnChart.converter
                // for positive values, this is the previous stack position + the new value,
                // for negative values it is just the previous stack position
                return {
                    shapeLayout: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d) { return yScale(d.position); },
                        height: function (d) { return yScale(d.position - d.valueAbsolute) - yScale(d.position); },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d) { return yScale(d.originalPosition); },
                        height: function (d) { return yScale(d.originalPosition - d.originalValueAbsolute) - yScale(d.originalPosition); },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return columnWidth; },
                        x: function (d) { return xScale(isScalar ? d.categoryValue : d.categoryIndex) - xScaleOffset; },
                        y: function (d) { return d.value >= 0 ? yScale(d.position - d.valueAbsolute) : yScale(d.position); },
                        height: function (d) { return 0; }
                    },
                };
            };
            StackedColumnChartStrategy.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = this.layout.shapeLayout;
                for (var _i = 0, series_4 = series; _i < series_4.length; _i++) {
                    var currentSeries = series_4[_i];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (!labelSettings.show)
                        continue;
                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                            continue;
                        }
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        // Calculate label text
                        var formatString = "";
                        if (this.graphicsContext.is100Pct) {
                            formatString = visuals.NewDataLabelUtils.hundredPercentFormat;
                        }
                        else {
                            formatString = dataPoint.labelFormatString;
                        }
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
                                validPositions: visuals.ColumnChart.stackedValidLabelPositions,
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                        });
                    }
                }
                return labelDataPoints;
            };
            StackedColumnChartStrategy.classes = {
                item: {
                    class: 'column',
                    selector: '.column'
                },
                highlightItem: {
                    class: 'highlightColumn',
                    selector: '.highlightColumn'
                },
            };
            return StackedColumnChartStrategy;
        }());
        visuals.StackedColumnChartStrategy = StackedColumnChartStrategy;
        var StackedBarChartStrategy = (function () {
            function StackedBarChartStrategy() {
            }
            StackedBarChartStrategy.prototype.setupVisualProps = function (barChartProps) {
                this.graphicsContext = barChartProps;
                this.margin = barChartProps.margin;
                this.width = this.graphicsContext.width;
                this.height = this.graphicsContext.height;
                this.categoryLayout = barChartProps.layout;
                this.animator = barChartProps.animator;
                this.interactivityService = barChartProps.interactivityService;
                this.viewportHeight = barChartProps.viewportHeight;
                this.viewportWidth = barChartProps.viewportWidth;
                this.isComboChart = barChartProps.isComboChart;
            };
            StackedBarChartStrategy.prototype.setData = function (data) {
                this.data = data;
            };
            StackedBarChartStrategy.prototype.setYScale = function (is100Pct, forcedTickCount, forcedYDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain) {
                var height = this.height;
                var forcedYMin, forcedYMax;
                if (forcedYDomain && forcedYDomain.length === 2) {
                    forcedYMin = forcedYDomain[0];
                    forcedYMax = forcedYDomain[1];
                }
                var props = this.yProps = visuals.ColumnUtil.getCategoryAxis(this.data, height, this.categoryLayout, true, forcedYMin, forcedYMax, axisScaleType, axisDisplayUnits, axisPrecision, ensureYDomain);
                return props;
            };
            StackedBarChartStrategy.prototype.setXScale = function (is100Pct, forcedTickCount, forcedXDomain, axisScaleType, axisDisplayUnits, axisPrecision, ensureXDomain) {
                debug.assert(forcedTickCount === undefined, 'Cannot have stacked bar chart as combo chart.');
                var width = this.width;
                var valueDomain = visuals.StackedUtil.calcValueDomain(this.data.series, is100Pct);
                var valueDomainArr = [valueDomain.min, valueDomain.max];
                var combinedDomain = visuals.AxisHelper.combineDomain(forcedXDomain, valueDomainArr, ensureXDomain);
                var shouldClamp = visuals.AxisHelper.scaleShouldClamp(combinedDomain, valueDomainArr);
                var metadataColumn = this.data.valuesMetadata[0];
                var formatString = is100Pct ?
                    this.graphicsContext.hostService.getLocalizedString('Percentage')
                    : visuals.valueFormatter.getFormatString(metadataColumn, visuals.columnChartProps.general.formatString);
                this.xProps = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedDomain,
                    metaDataColumn: metadataColumn,
                    formatString: formatString,
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: false,
                    forcedTickCount: forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: axisScaleType,
                    axisDisplayUnits: axisDisplayUnits,
                    axisPrecision: axisPrecision,
                    is100Pct: is100Pct,
                    shouldClamp: shouldClamp,
                });
                this.xProps.axis.tickSize(-this.viewportHeight, 0);
                return this.xProps;
            };
            StackedBarChartStrategy.prototype.drawColumns = function (useAnimation) {
                var data = this.data;
                debug.assertValue(data, 'data should not be null or undefined');
                this.barsCenters = null; // invalidate the barsCenters so that will be calculated again
                var axisOptions = {
                    columnWidth: this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio),
                    xScale: this.xProps.scale,
                    yScale: this.yProps.scale,
                    isScalar: this.categoryLayout.isScalar,
                    margin: this.margin,
                };
                var stackedBarLayout = this.layout = StackedBarChartStrategy.getLayout(data, axisOptions);
                var dataLabelSettings = data.labelSettings;
                var labelDataPoints = [];
                if (dataLabelSettings && dataLabelSettings.show) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var result;
                var shapes;
                var series = visuals.ColumnUtil.drawSeries(data, this.graphicsContext.mainGraphicsContext, axisOptions);
                if (this.animator && useAnimation) {
                    result = this.animator.animate({
                        viewModel: data,
                        series: series,
                        layout: stackedBarLayout,
                        itemCS: StackedBarChartStrategy.classes.item,
                        interactivityService: this.interactivityService,
                        mainGraphicsContext: this.graphicsContext.mainGraphicsContext,
                        viewPort: { height: this.height, width: this.width },
                    });
                    shapes = result.shapes;
                }
                if (!this.animator || !useAnimation || result.failed) {
                    shapes = visuals.ColumnUtil.drawDefaultShapes(data, series, stackedBarLayout, StackedBarChartStrategy.classes.item, !this.animator, this.interactivityService && this.interactivityService.hasSelection());
                }
                visuals.ColumnUtil.applyInteractivity(shapes, this.graphicsContext.onDragStart);
                return {
                    eventGroup: this.graphicsContext.mainGraphicsContext,
                    shapesSelection: shapes,
                    viewport: { height: this.height, width: this.width },
                    axisOptions: axisOptions,
                    labelDataPoints: labelDataPoints,
                };
            };
            StackedBarChartStrategy.prototype.selectColumn = function (selectedColumnIndex, lastInteractiveSelectedColumnIndex) {
                visuals.ColumnUtil.setChosenColumnOpacity(this.graphicsContext.mainGraphicsContext, StackedBarChartStrategy.classes.item.selector, selectedColumnIndex, lastInteractiveSelectedColumnIndex);
                this.moveHandle(selectedColumnIndex);
            };
            StackedBarChartStrategy.prototype.getClosestColumnIndex = function (x, y) {
                return visuals.ColumnUtil.getClosestColumnIndex(y, this.getBarsCenters());
            };
            /**
             * Get the chart's columns centers (y value).
             */
            StackedBarChartStrategy.prototype.getBarsCenters = function () {
                var _this = this;
                if (!this.barsCenters) {
                    var barWidth = this.categoryLayout.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                    // use the axis scale and first series data to get category centers
                    if (this.data.series.length > 0) {
                        var yScaleOffset_2 = 0;
                        if (!this.categoryLayout.isScalar)
                            yScaleOffset_2 = barWidth / 2;
                        var firstSeries = this.data.series[0];
                        this.barsCenters = firstSeries.data.map(function (d) { return _this.yProps.scale(_this.categoryLayout.isScalar ? d.categoryValue : d.categoryIndex) + yScaleOffset_2; });
                    }
                }
                return this.barsCenters;
            };
            StackedBarChartStrategy.prototype.moveHandle = function (selectedColumnIndex) {
                var barCenters = this.getBarsCenters();
                var y = barCenters[selectedColumnIndex];
                if (!this.columnSelectionLineHandle) {
                    var handle = this.columnSelectionLineHandle = this.graphicsContext.unclippedGraphicsContext.append('g');
                    handle.append('line')
                        .classed('interactive-hover-line', true)
                        .attr({
                        x1: 0,
                        x2: this.width,
                        y1: y,
                        y2: y
                    });
                    handle.append('circle')
                        .classed('drag-handle', true)
                        .attr({
                        cx: 0,
                        cy: y,
                        r: '6px',
                    });
                }
                else {
                    var handle = this.columnSelectionLineHandle;
                    handle.select('line').attr({ y1: y, y2: y });
                    handle.select('circle').attr({ cy: y });
                }
            };
            StackedBarChartStrategy.getLayout = function (data, axisOptions) {
                var columnWidth = axisOptions.columnWidth;
                var isScalar = axisOptions.isScalar;
                var xScale = axisOptions.xScale;
                var yScale = axisOptions.yScale;
                var yScaleOffset = 0;
                if (isScalar)
                    yScaleOffset = columnWidth / 2;
                // d.position is the top right corner for bars - set in columnChart.converter
                // for positive values, this is the previous stack position + the new value,
                // for negative values it is just the previous stack position
                return {
                    shapeLayout: {
                        width: function (d) { return xScale(d.position) - xScale(d.position - d.valueAbsolute); },
                        x: function (d) { return xScale(d.position - d.valueAbsolute); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: function (d) { return xScale(d.originalPosition) - xScale(d.originalPosition - d.originalValueAbsolute); },
                        x: function (d) { return xScale(d.originalPosition - d.originalValueAbsolute); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                    zeroShapeLayout: {
                        width: function (d) { return 0; },
                        x: function (d) { return d.value >= 0 ? xScale(d.position - d.valueAbsolute) : xScale(d.position); },
                        y: function (d) { return yScale(isScalar ? d.categoryValue : d.categoryIndex) - yScaleOffset; },
                        height: function (d) { return columnWidth; },
                    },
                };
            };
            StackedBarChartStrategy.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var shapeLayout = this.layout.shapeLayout;
                for (var _i = 0, series_5 = series; _i < series_5.length; _i++) {
                    var currentSeries = series_5[_i];
                    var labelSettings = currentSeries.labelSettings ? currentSeries.labelSettings : data.labelSettings;
                    if (!labelSettings.show)
                        continue;
                    var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yProps.formatter, labelSettings);
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        if ((this.interactivityService && this.interactivityService.hasSelection() && !dataPoint.selected) || (data.hasHighlights && !dataPoint.highlight) || dataPoint.value == null) {
                            continue;
                        }
                        // Calculate label text
                        var formatString = undefined;
                        if (this.graphicsContext.is100Pct) {
                            formatString = visuals.NewDataLabelUtils.hundredPercentFormat;
                        }
                        else {
                            formatString = dataPoint.labelFormatString;
                        }
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        // Calculate parent rectangle
                        var parentRect = {
                            left: shapeLayout.x(dataPoint),
                            top: shapeLayout.y(dataPoint),
                            width: shapeLayout.width(dataPoint),
                            height: shapeLayout.height(dataPoint),
                        };
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, false, this.isComboChart),
                            insideFill: visuals.ColumnChart.getLabelFill(labelSettings.labelColor, true, this.isComboChart),
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 3 /* HorizontalLeftBased */ : 4 /* HorizontalRightBased */,
                                validPositions: visuals.ColumnChart.stackedValidLabelPositions,
                            },
                            identity: dataPoint.identity,
                            fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                        });
                    }
                }
                return labelDataPoints;
            };
            StackedBarChartStrategy.classes = {
                item: {
                    class: 'bar',
                    selector: '.bar'
                },
                highlightItem: {
                    class: 'highlightBar',
                    selector: '.highlightBar'
                },
            };
            return StackedBarChartStrategy;
        }());
        visuals.StackedBarChartStrategy = StackedBarChartStrategy;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var samples;
        (function (samples) {
            var SelectionManager = visuals.utility.SelectionManager;
            var HelloIVisual = (function () {
                function HelloIVisual() {
                }
                HelloIVisual.converter = function (dataView) {
                    var viewModel = {
                        size: HelloIVisual.getSize(dataView),
                        color: HelloIVisual.getFill(dataView).solid.color,
                        text: HelloIVisual.DefaultText,
                        toolTipInfo: [{
                                displayName: 'Test',
                                value: '1...2....3... can you see me? I am sending random strings to the tooltip',
                            }],
                        selector: visuals.SelectionId.createNull()
                    };
                    var table = dataView.table;
                    if (!table)
                        return viewModel;
                    viewModel.text = table.rows[0][0];
                    if (dataView.categorical) {
                        viewModel.selector = dataView.categorical.categories[0].identity
                            ? visuals.SelectionId.createWithId(dataView.categorical.categories[0].identity[0])
                            : visuals.SelectionId.createNull();
                    }
                    return viewModel;
                };
                HelloIVisual.prototype.init = function (options) {
                    this.root = d3.select(options.element.get(0))
                        .append('svg')
                        .classed('hello', true);
                    this.svgText = this.root
                        .append('text')
                        .style('cursor', 'pointer')
                        .style('stroke', 'green')
                        .style('stroke-width', '0px')
                        .attr('text-anchor', 'middle');
                    this.selectiionManager = new SelectionManager({ hostServices: options.host });
                };
                HelloIVisual.prototype.update = function (options) {
                    if (!options.dataViews && !options.dataViews[0])
                        return;
                    var dataView = this.dataView = options.dataViews[0];
                    var viewport = options.viewport;
                    var viewModel = HelloIVisual.converter(dataView);
                    this.root.attr({
                        'height': viewport.height,
                        'width': viewport.width
                    });
                    var textProperties = {
                        fontFamily: 'tahoma',
                        fontSize: viewModel.size + 'px',
                        text: viewModel.text
                    };
                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties);
                    var selectionManager = this.selectiionManager;
                    this.svgText.style({
                        'fill': viewModel.color,
                        'font-size': textProperties.fontSize,
                        'font-family': textProperties.fontFamily,
                    }).attr({
                        'y': viewport.height / 2 + textHeight / 3 + 'px',
                        'x': viewport.width / 2,
                    }).text(viewModel.text)
                        .on('click', function () {
                        var _this = this;
                        selectionManager
                            .select(viewModel.selector)
                            .then(function (ids) { return d3.select(_this).style('stroke-width', ids.length > 0 ? '2px' : '0px'); });
                    })
                        .data([viewModel]);
                    visuals.TooltipManager.addTooltip(this.svgText, function (tooltipEvent) { return tooltipEvent.data.toolTipInfo; });
                };
                HelloIVisual.getFill = function (dataView) {
                    if (dataView) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = objects['general'];
                            if (general) {
                                var fill = general['fill'];
                                if (fill)
                                    return fill;
                            }
                        }
                    }
                    return { solid: { color: 'red' } };
                };
                HelloIVisual.getSize = function (dataView) {
                    if (dataView) {
                        var objects = dataView.metadata.objects;
                        if (objects) {
                            var general = objects['general'];
                            if (general) {
                                var size = general['size'];
                                if (size)
                                    return size;
                            }
                        }
                    }
                    return 100;
                };
                HelloIVisual.prototype.enumerateObjectInstances = function (options) {
                    var instances = [];
                    var dataView = this.dataView;
                    switch (options.objectName) {
                        case 'general':
                            var general = {
                                objectName: 'general',
                                displayName: 'General',
                                selector: null,
                                properties: {
                                    fill: HelloIVisual.getFill(dataView),
                                    size: HelloIVisual.getSize(dataView)
                                }
                            };
                            instances.push(general);
                            break;
                    }
                    return instances;
                };
                HelloIVisual.prototype.destroy = function () {
                    this.root = null;
                };
                HelloIVisual.capabilities = {
                    dataRoles: [{
                            name: 'Values',
                            kind: powerbi.VisualDataRoleKind.GroupingOrMeasure
                        }],
                    dataViewMappings: [{
                            table: {
                                rows: {
                                    for: { in: 'Values' },
                                    dataReductionAlgorithm: { window: { count: 100 } }
                                },
                                rowCount: { preferred: { min: 1 } }
                            },
                        }],
                    objects: {
                        general: {
                            displayName: powerbi.data.createDisplayNameGetter('Visual_General'),
                            properties: {
                                fill: {
                                    type: { fill: { solid: { color: true } } },
                                    displayName: 'Fill'
                                },
                                size: {
                                    type: { numeric: true },
                                    displayName: 'Size'
                                }
                            },
                        }
                    },
                };
                HelloIVisual.DefaultText = 'Invalid DV';
                return HelloIVisual;
            }());
            samples.HelloIVisual = HelloIVisual;
        })(samples = visuals.samples || (visuals.samples = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * This module only supplies the capabilities for comboCharts.
         * Implementation is in cartesianChart and the various ICartesianVisual implementations.
         */
        var ComboChart;
        (function (ComboChart) {
            ComboChart.capabilities = visuals.comboChartCapabilities;
            /**
             * Handles the case of a column layer in a combo chart. In this case, the column layer is enumearated last.
             */
            function enumerateDataPoints(enumeration, options, layers) {
                if (!layers)
                    return;
                var columnChartLayerIndex;
                var layersLength = layers.length;
                for (var layerIndex = 0; layerIndex < layersLength; layerIndex++) {
                    var layer = layers[layerIndex];
                    if (layer.enumerateObjectInstances) {
                        if (layer instanceof visuals.ColumnChart) {
                            columnChartLayerIndex = layerIndex;
                            continue;
                        }
                        layer.enumerateObjectInstances(enumeration, options);
                    }
                }
                if (columnChartLayerIndex !== undefined)
                    layers[columnChartLayerIndex].enumerateObjectInstances(enumeration, options);
            }
            ComboChart.enumerateDataPoints = enumerateDataPoints;
            function customizeQuery(options) {
                // If there is a dynamic series but no values on the column data view mapping, remove the dynamic series
                var columnMapping = !_.isEmpty(options.dataViewMappings) && options.dataViewMappings[0];
                if (columnMapping) {
                    var columnValuesMapping = columnMapping.categorical && columnMapping.categorical.values;
                    var seriesSelect = columnValuesMapping.group && !_.isEmpty(columnValuesMapping.group.select) && columnValuesMapping.group.select[0];
                    if (_.isEmpty(seriesSelect.for.in.items))
                        columnValuesMapping.group.by.items = undefined;
                }
                if (columnMapping && columnMapping.categorical) {
                    columnMapping.categorical.dataVolume = 4;
                }
                var lineMapping = options.dataViewMappings.length > 1 && options.dataViewMappings[1];
                if (lineMapping && lineMapping.categorical) {
                    lineMapping.categorical.dataVolume = 4;
                }
            }
            ComboChart.customizeQuery = customizeQuery;
            function getSortableRoles(options) {
                if (options && options.dataViewMappings.length > 0) {
                    var dataViewMapping = options.dataViewMappings[0];
                    //TODO: column chart should be sortable by X if it has scalar axis
                    // But currenly it doesn't support this. Return 'category' once
                    // it is supported.
                    if (!visuals.CartesianChart.detectScalarMapping(dataViewMapping))
                        return ['Category', 'Y', 'Y2'];
                }
                return null;
            }
            ComboChart.getSortableRoles = getSortableRoles;
            function isComboChart(chartType) {
                return chartType === 10 /* ComboChart */
                    || chartType === 13 /* LineClusteredColumnCombo */
                    || chartType === 14 /* LineStackedColumnCombo */
                    || chartType === 15 /* DataDotClusteredColumnCombo */
                    || chartType === 16 /* DataDotStackedColumnCombo */;
            }
            ComboChart.isComboChart = isComboChart;
        })(ComboChart = visuals.ComboChart || (visuals.ComboChart = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var ArrayExtensions = jsCommon.ArrayExtensions;
        var DataColorPalette = (function () {
            /**
             * Creates a DataColorPalette using the given theme, or the default theme.
             */
            function DataColorPalette(colors, sentimentcolors) {
                // Hardcoded values for Color Picker.
                this.basePickerColors = [
                    { value: '#FFFFFF' },
                    { value: '#000000' },
                    { value: '#00B8AA' },
                    { value: '#374649' },
                    { value: '#FD625E' },
                    { value: '#F2C811' },
                    { value: '#5F6B6D' },
                    { value: '#8AD4EB' },
                    { value: '#FE9666' },
                    { value: '#A66999' }
                ];
                // TODO: Default theme is currently hardcoded. Theme should eventually come from PV and be added as a parameter in the ctor. 
                this.colors = colors || ThemeManager.getDefaultTheme();
                this.sentimentColors = sentimentcolors || ThemeManager.defaultSentimentColors;
                this.scales = {};
            }
            DataColorPalette.prototype.getColorScaleByKey = function (key) {
                var scale = this.scales[key];
                if (scale === undefined) {
                    scale = this.createScale();
                    this.scales[key] = scale;
                }
                return scale;
            };
            DataColorPalette.prototype.getNewColorScale = function () {
                return this.createScale();
            };
            DataColorPalette.prototype.getColorByIndex = function (index) {
                debug.assert(index >= 0 && index < this.colors.length, 'index is out of bounds');
                return this.colors[index];
            };
            DataColorPalette.prototype.getSentimentColors = function () {
                return this.sentimentColors;
            };
            DataColorPalette.prototype.getBasePickerColors = function () {
                return this.basePickerColors;
            };
            DataColorPalette.prototype.getAllColors = function () {
                return this.colors;
            };
            DataColorPalette.prototype.createScale = function () {
                return D3ColorScale.createFromColors(this.colors);
            };
            return DataColorPalette;
        }());
        visuals.DataColorPalette = DataColorPalette;
        var D3ColorScale = (function () {
            function D3ColorScale(scale) {
                this.scale = scale;
            }
            D3ColorScale.prototype.getColor = function (key) {
                return this.scale(key);
            };
            D3ColorScale.prototype.clearAndRotateScale = function () {
                var offset = this.scale.domain().length;
                var rotatedColors = ArrayExtensions.rotate(this.scale.range(), offset);
                this.scale = d3.scale.ordinal().range(rotatedColors);
            };
            D3ColorScale.prototype.clone = function () {
                return new D3ColorScale(this.scale.copy());
            };
            D3ColorScale.prototype.getDomain = function () {
                return this.scale.domain();
            };
            D3ColorScale.createFromColors = function (colors) {
                return new D3ColorScale(d3.scale.ordinal().range(colors));
            };
            return D3ColorScale;
        }());
        visuals.D3ColorScale = D3ColorScale;
        // TODO: When theming support is added, this should be changed into a fully fledged service. For now though we will
        var ThemeManager = (function () {
            function ThemeManager() {
            }
            ThemeManager.getDefaultTheme = function () {
                if (!ThemeManager.defaultTheme) {
                    // Extend the list of available colors by cycling the base colors
                    ThemeManager.defaultTheme = [];
                    var baseColors = ThemeManager.defaultBaseColors;
                    for (var i = 0; i < ThemeManager.colorSectorCount; ++i) {
                        for (var j = 0, jlen = baseColors.length; j < jlen; ++j) {
                            ThemeManager.defaultTheme.push({
                                value: jsCommon.Color.rotate(baseColors[j].value, i / ThemeManager.colorSectorCount)
                            });
                        }
                    }
                }
                return ThemeManager.defaultTheme;
            };
            ThemeManager.colorSectorCount = 12;
            // declare the Theme code as a private implementation detail inside the DataColorPalette so that the code stays hidden
            // until it's ready for wider use.
            ThemeManager.defaultBaseColors = [
                // First loop
                { value: '#01B8AA' },
                { value: '#374649' },
                { value: '#FD625E' },
                { value: '#F2C80F' },
                { value: '#5F6B6D' },
                { value: '#8AD4EB' },
                { value: '#FE9666' },
                { value: '#A66999' },
                { value: '#3599B8' },
                { value: '#DFBFBF' },
                // Second loop
                { value: '#4AC5BB' },
                { value: '#5F6B6D' },
                { value: '#FB8281' },
                { value: '#F4D25A' },
                { value: '#7F898A' },
                { value: '#A4DDEE' },
                { value: '#FDAB89' },
                { value: '#B687AC' },
                { value: '#28738A' },
                { value: '#A78F8F' },
                // Third loop
                { value: '#168980' },
                { value: '#293537' },
                { value: '#BB4A4A' },
                { value: '#B59525' },
                { value: '#475052' },
                { value: '#6A9FB0' },
                { value: '#BD7150' },
                { value: '#7B4F71' },
                { value: '#1B4D5C' },
                { value: '#706060' },
                // Fourth loop
                { value: '#0F5C55' },
                { value: '#1C2325' },
                { value: '#7D3231' },
                { value: '#796419' },
                { value: '#303637' },
                { value: '#476A75' },
                { value: '#7E4B36' },
                { value: '#52354C' },
                { value: '#0D262E' },
                { value: '#544848' },
            ];
            ThemeManager.defaultSentimentColors = [
                { value: '#C0433A' },
                { value: '#E8D62E' },
                { value: '#79C75B' },
            ];
            return ThemeManager;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
/**
 * IMPORTANT: This chart is not currently enabled in the PBI system and is under development.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        /**
         * The data dot chart shows a set of circles with the data value inside them.
         * The circles are regularly spaced similar to column charts.
         * The radius of all dots is the same across the chart.
         * This is most often combined with a column chart to create the 'chicken pox' chart.
         * If any of the data values do not fit within the circles, then the data values are hidden
         * and the y axis for the dots is displayed instead.
         * This chart only supports a single series of data.
         * This chart does not display a legend.
         */
        var DataDotChart = (function () {
            function DataDotChart(options) {
                this.isScrollable = options.isScrollable;
                this.interactivityService = options.interactivityService;
            }
            DataDotChart.prototype.init = function (options) {
                this.options = options;
                // Common properties
                this.svg = options.svg;
                this.svg.classed(DataDotChart.ClassName, true);
                this.mainGraphicsG = this.svg.append('g')
                    .classed('dataDotChartMainGraphicsContext', true);
                this.mainGraphicsContext = this.mainGraphicsG.append('svg');
                this.currentViewport = options.viewport;
                this.hostService = options.host;
                this.cartesianVisualHost = options.cartesianHost;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                // Interactivity properties
                this.interactivity = options.interactivity;
                this.element = options.element;
            };
            DataDotChart.prototype.setData = function (dataViews) {
                this.data = {
                    series: {
                        data: []
                    },
                    hasHighlights: false,
                    hasDynamicSeries: false,
                };
                if (dataViews.length > 0) {
                    // I only handle a single data view
                    var dataView = dataViews[0];
                    if (dataView && dataView.categorical) {
                        var dataViewCategorical = this.dataViewCategorical = dataView.categorical;
                        var dvCategories = dataViewCategorical.categories;
                        // I default to text unless there is a category type
                        var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                        if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                            categoryType = dvCategories[0].source.type;
                        this.data = DataDotChart.converter(dataView, visuals.valueFormatter.format(null), this.interactivityService);
                    }
                }
            };
            DataDotChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                if (data && data.series && data.series.data)
                    data.series = { data: data.series.data.slice(startIndex, endIndex), xCol: data.series.xCol, yCol: data.series.yCol };
                return data;
            };
            DataDotChart.prototype.calculateAxesProperties = function (options) {
                var _this = this;
                this.currentViewport = options.viewport;
                this.margin = options.margin;
                var data = this.clippedData = this.data;
                var viewport = this.currentViewport;
                var margin = this.margin;
                var series = data ? data.series : null;
                var seriesArray = series && series.data && series.data.length > 0 ? [series] : [];
                var categoryCount = series && series.data ? series.data.length : 0;
                // If there are highlights, then the series is 2x in length and highlights are interwoven.
                if (data.hasHighlights) {
                    categoryCount = categoryCount / 2;
                }
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xMetaDataColumn;
                var yMetaDataColumn;
                if (DataDotChart.hasDataPoint(series)) {
                    xMetaDataColumn = series.xCol;
                    yMetaDataColumn = series.yCol;
                }
                var layout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: false,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                });
                var outerPadding = layout.categoryThickness * visuals.CartesianChart.OuterPaddingRatio;
                // clip data that won't fit
                if (!this.isScrollable) {
                    this.clippedData = DataDotChart.createClippedDataIfOverflowed(data, layout.categoryCount);
                }
                var yDomain = visuals.AxisHelper.createValueDomain(seriesArray, /*includeZero:*/ true) || visuals.emptyDomain;
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, yDomain, options.ensureYDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, DataDotChart.formatStringProp),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false
                });
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({ text: true });
                var xDomain = visuals.AxisHelper.createDomain(seriesArray, axisType, /*isScalar:*/ false, options.forcedXDomain, options.ensureXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, DataDotChart.formatStringProp),
                    outerPadding: outerPadding,
                    isScalar: false,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    categoryThickness: layout.categoryThickness,
                    getValueFn: function (index, type) { return _this.lookupXValue(index, type); },
                    isCategoryAxis: true
                });
                return [this.xAxisProperties, this.yAxisProperties];
            };
            DataDotChart.createClippedDataIfOverflowed = function (data, categoryCount) {
                // If there are highlights, then the series is 2x in length and highlights are interwoven.
                var requiredLength = data.hasHighlights ? Math.min(data.series.data.length, categoryCount * 2) : Math.min(data.series.data.length, categoryCount);
                if (requiredLength >= data.series.data.length) {
                    return data;
                }
                var clipped = powerbi.Prototype.inherit(data);
                clipped.series = powerbi.Prototype.inherit(data.series); // This prevents clipped and data from sharing the series object
                clipped.series.data = clipped.series.data.slice(0, requiredLength);
                return clipped;
            };
            DataDotChart.hasDataPoint = function (series) {
                return (series && series.data && series.data.length > 0);
            };
            DataDotChart.prototype.lookupXValue = function (index, type) {
                var data = this.data;
                var isDateTime = visuals.AxisHelper.isDateTime(type);
                if (isDateTime)
                    return new Date(index);
                if (data && data.series) {
                    var seriesData = data.series.data;
                    if (seriesData) {
                        var dataAtIndex = seriesData[index];
                        if (dataAtIndex) {
                            return dataAtIndex.categoryValue;
                        }
                    }
                }
                return index;
            };
            DataDotChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            DataDotChart.prototype.render = function (suppressAnimations) {
                var _this = this;
                if (!this.clippedData)
                    return;
                var data = this.clippedData;
                var dataPoints = data.series.data;
                var hasHighlights = data.hasHighlights;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var dotWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var dotRadius = dotWidth / 2;
                var dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey);
                var hasSelection = this.interactivityService ? this.interactivityService.hasSelection() : false;
                this.mainGraphicsContext.attr('width', width)
                    .attr('height', height);
                var dots = this.mainGraphicsContext.selectAll(DataDotChart.DotClassSelector).data(dataPoints, function (d) { return d.identity.getKey(); });
                dots.enter()
                    .append('circle')
                    .classed(DataDotChart.DotClassName, true);
                dots
                    .style({ 'fill': dotColor.value })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); })
                    .classed('null-value', function (d) { return d.value === null; })
                    .attr({
                    r: function (d) { return dotRadius; },
                    cx: function (d) { return xScale(d.categoryIndex) + dotRadius; },
                    cy: function (d) { return yScale(d.value); }
                });
                dots.exit().remove();
                var dotLabels = this.mainGraphicsContext.selectAll(DataDotChart.DotLabelClassSelector).data(dataPoints, function (d) { return d.identity.getKey(); });
                dotLabels.enter()
                    .append('text')
                    .classed(DataDotChart.DotLabelClassName, true)
                    .attr({
                    'text-anchor': DataDotChart.DotLabelTextAnchor,
                    dy: DataDotChart.DotLabelVerticalOffset
                });
                dotLabels
                    .classed('null-value', function (d) { return d.value === null; })
                    .classed('overflowed', false)
                    .attr({
                    x: function (d) { return xScale(d.categoryIndex) + dotRadius; },
                    y: function (d) { return yScale(d.value); }
                })
                    .text(function (d) { return _this.yAxisProperties.formatter.format(d.value); });
                var overflowed = false;
                dotLabels
                    .each(function () {
                    // jQuery fails to properly inspect SVG class elements, the $('<div>') notation works around it.
                    if (!overflowed && !$("<div>").addClass($(this).attr("class")).hasClass("null-value")) {
                        var width_1 = powerbi.TextMeasurementService.measureSvgTextElementWidth(this);
                        if (width_1 > dotWidth) {
                            dotLabels.classed('overflowed', true);
                            overflowed = true;
                        }
                    }
                });
                dotLabels.exit().remove();
                var behaviorOptions = undefined;
                if (this.interactivityService) {
                    behaviorOptions = {
                        dots: dots,
                        dotLabels: dotLabels,
                        datapoints: dataPoints
                    };
                }
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                return { dataPoints: dataPoints, behaviorOptions: behaviorOptions, labelDataPoints: [], labelsAreNumeric: true };
            };
            DataDotChart.prototype.calculateLegend = function () {
                return this.createLegendDataPoints(0); // start with index 0
            };
            DataDotChart.prototype.hasLegend = function () {
                return this.data && this.data.hasDynamicSeries;
            };
            DataDotChart.prototype.createLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data)
                    return null;
                var series = data.series;
                var seriesData = series.data;
                var legendDataPoints = [];
                var category;
                var axisType = this.xAxisProperties ? this.xAxisProperties.axisType : powerbi.ValueType.fromDescriptor({ text: true });
                // Category will be the same for all series. This is an optimization.
                if (data.series && data.series.data) {
                    var firstDataPoint = data.series.data[0];
                    category = firstDataPoint && this.lookupXValue(firstDataPoint.categoryValue, axisType);
                }
                // Create a legend data point for the specified column                
                if (series.yCol) {
                    var formatStringProp = DataDotChart.formatStringProp;
                    var lineDataPoint = seriesData[columnIndex];
                    var measure = lineDataPoint && lineDataPoint.value;
                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCategorical.values, formatStringProp);
                    var dotColor = this.cartesianVisualHost.getSharedColors().getNewColorScale().getColor(DataDotChart.DotColorKey);
                    var dataViewCategoricalValues = this.dataViewCategorical.values;
                    var identity = dataViewCategoricalValues && dataViewCategoricalValues.length > columnIndex ?
                        visuals.SelectionId.createWithIdAndMeasure(dataViewCategoricalValues[columnIndex].identity, dataViewCategoricalValues[columnIndex].source.queryName) :
                        visuals.SelectionId.createWithMeasure(dataViewCategoricalValues.source.queryName);
                    legendDataPoints.push({
                        color: dotColor.value,
                        icon: visuals.LegendIcon.Line,
                        label: label,
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: identity,
                        selected: false
                    });
                }
                return { dataPoints: legendDataPoints };
            };
            DataDotChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
                // cartesianChart handles calling render again.
            };
            DataDotChart.converter = function (dataView, blankCategoryValue, interactivityService) {
                var categorical = dataView.categorical;
                var category = categorical.categories && categorical.categories.length > 0
                    ? categorical.categories[0]
                    : {
                        source: undefined,
                        values: [blankCategoryValue],
                        identity: undefined
                    };
                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var categoryValues = category.values;
                // I only handle a single series
                if (!_.isEmpty(categorical.values)) {
                    var measure = categorical.values[0];
                    var hasHighlights = !!measure.highlights;
                    var dataPoints = [];
                    for (var categoryIndex = 0, len = measure.values.length; categoryIndex < len; categoryIndex++) {
                        debug.assert(!category.identity || categoryIndex < category.identity.length, 'Category identities is smaller than category values.');
                        // I create the identity from the category.  If there is no category, then I use the measure name to create identity
                        var identity = category.identity ?
                            visuals.SelectionId.createWithIdAndMeasure(category.identity[categoryIndex], measure.source.queryName) :
                            visuals.SelectionId.createWithMeasure(measure.source.queryName);
                        var categoryValue = categoryValues[categoryIndex];
                        // ignore variant measures
                        if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
                            continue;
                        dataPoints.push({
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: measure.values[categoryIndex],
                            categoryIndex: categoryIndex,
                            seriesIndex: 0,
                            selected: false,
                            identity: identity,
                            highlight: false
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlightValue = measure.highlights[categoryIndex];
                            dataPoints.push({
                                categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                                value: highlightValue,
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: false,
                                identity: highlightIdentity,
                                highlight: true
                            });
                        }
                    }
                    if (interactivityService)
                        interactivityService.applySelectionStateToData(dataPoints);
                    return {
                        series: {
                            xCol: category.source,
                            yCol: measure.source,
                            data: dataPoints
                        },
                        hasHighlights: hasHighlights,
                        hasDynamicSeries: true,
                    };
                }
                return {
                    series: {
                        data: []
                    },
                    hasHighlights: false,
                    hasDynamicSeries: false,
                };
            };
            DataDotChart.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
            DataDotChart.ClassName = 'dataDotChart';
            DataDotChart.DotClassName = 'dot';
            DataDotChart.DotClassSelector = '.dot';
            DataDotChart.DotColorKey = 'dataDot';
            DataDotChart.DotLabelClassName = 'label';
            DataDotChart.DotLabelClassSelector = '.label';
            DataDotChart.DotLabelVerticalOffset = '0.4em';
            DataDotChart.DotLabelTextAnchor = 'middle';
            return DataDotChart;
        }());
        visuals.DataDotChart = DataDotChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        /**
         * Renders a funnel chart.
         */
        var FunnelChart = (function () {
            function FunnelChart(options) {
                this.labelPositionObjects = [visuals.labelPosition.outsideEnd, visuals.labelPosition.insideCenter];
                if (options) {
                    this.tooltipsEnabled = options.tooltipsEnabled;
                    if (options.funnelSmallViewPortProperties) {
                        this.funnelSmallViewPortProperties = options.funnelSmallViewPortProperties;
                    }
                    if (options.animator) {
                        this.animator = options.animator;
                    }
                    if (options.behavior) {
                        this.behavior = options.behavior;
                    }
                }
            }
            FunnelChart.isValidValueColumn = function (valueColumn) {
                debug.assertValue(valueColumn, 'valueColumn');
                return DataRoleHelper.hasRole(valueColumn.source, 'Y');
            };
            FunnelChart.getFirstValidValueColumn = function (values) {
                for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                    var valueColumn = values_1[_i];
                    if (!FunnelChart.isValidValueColumn(valueColumn))
                        continue;
                    return valueColumn;
                }
                return undefined;
            };
            FunnelChart.converter = function (dataView, colors, hostServices, defaultDataPointColor, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var slices = [];
                var formatStringProp = visuals.funnelChartProps.general.formatString;
                var categorical = dataView.categorical;
                var categories = categorical.categories || [];
                var values = categorical.values;
                var valueMetaData = [];
                if (values) {
                    valueMetaData = _.map(values, function (v) { return v.source; });
                }
                var hasHighlights = values && values.length > 0 && values[0] && !!values[0].highlights;
                var highlightsOverflow = false;
                var hasNegativeValues = false;
                var allValuesAreNegative = false;
                var categoryLabels = [];
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultFunnelLabelSettings();
                var percentBarLabelSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true);
                var colorHelper = new visuals.ColorHelper(colors, visuals.funnelChartProps.dataPoint.fill, defaultDataPointColor);
                var firstValue;
                var firstHighlight;
                var previousValue;
                var previousHighlight;
                var gradientMeasureIndex = visuals.GradientUtils.getGradientMeasureIndex(categorical);
                var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(categorical);
                var defaultSeriesIndex = 0;
                var seriesIndexGradientAddedFirst = 1;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var labelsObj = dataView.metadata.objects['labels'];
                    if (labelsObj)
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                    var percentLabelsObj = dataView.metadata.objects['percentBarLabel'];
                    if (percentLabelsObj)
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(percentLabelsObj, percentBarLabelSettings);
                }
                // Always take the first valid value field
                var firstValueColumn = !_.isEmpty(values) && FunnelChart.getFirstValidValueColumn(values);
                // If we don't have a valid value column, just return
                if (!firstValueColumn)
                    return {
                        slices: slices,
                        categoryLabels: categoryLabels,
                        valuesMetadata: valueMetaData,
                        hasHighlights: hasHighlights,
                        highlightsOverflow: highlightsOverflow,
                        canShowDataLabels: true,
                        dataLabelsSettings: dataLabelsSettings,
                        hasNegativeValues: hasNegativeValues,
                        allValuesAreNegative: allValuesAreNegative,
                        percentBarLabelSettings: percentBarLabelSettings,
                    };
                //If Color saturation added before Values
                var seriesIndex = gradientMeasureIndex === defaultSeriesIndex ? seriesIndexGradientAddedFirst : defaultSeriesIndex;
                // Calculate the first value for percent tooltip values
                firstValue = firstValueColumn.values[0];
                if (hasHighlights) {
                    firstHighlight = firstValueColumn.highlights[0];
                }
                if (categories.length === 1) {
                    // Single Category, Value and (optional) Gradient
                    var category = categories[0];
                    var categoryValues = category.values;
                    var categorySourceFormatString = visuals.valueFormatter.getFormatString(category.source, formatStringProp);
                    for (var i = 0, ilen = categoryValues.length; i < ilen; i++) {
                        var measureName = firstValueColumn.source.queryName;
                        var identity = visuals.SelectionIdBuilder.builder()
                            .withCategory(category, i)
                            .withMeasure(measureName)
                            .createSelectionId();
                        var value = firstValueColumn.values[i];
                        var formattedCategoryValue = visuals.valueFormatter.format(categoryValues[i], categorySourceFormatString);
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, null, gradientValueColumn);
                            if (hasHighlights) {
                                var highlight = firstValueColumn.highlights[i];
                                if (highlight !== 0) {
                                    tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlight, gradientValueColumn);
                                }
                            }
                            FunnelChart.addFunnelPercentsToTooltip(tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
                        }
                        // Same color for all bars
                        var color = colorHelper.getColorForMeasure(category.objects && category.objects[i], '');
                        slices.push({
                            label: formattedCategoryValue,
                            value: value,
                            originalValue: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.labelColor,
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlight = firstValueColumn.highlights[i];
                            var highlightedValue = highlight !== 0 ? highlight : undefined;
                            var tooltipInfo_2 = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo_2 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, formattedCategoryValue, value, null, null, seriesIndex, i, highlightedValue, gradientValueColumn);
                                FunnelChart.addFunnelPercentsToTooltip(tooltipInfo_2, hostServices, firstHighlight ? highlight / firstHighlight : null, previousHighlight ? highlight / previousHighlight : null, true);
                            }
                            slices.push({
                                label: formattedCategoryValue,
                                value: value,
                                originalValue: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                selected: false,
                                key: highlightIdentity.getKey(),
                                highlight: true,
                                highlightValue: highlight,
                                originalHighlightValue: highlight,
                                tooltipInfo: tooltipInfo_2,
                                color: color,
                            });
                            previousHighlight = highlight;
                        }
                        previousValue = value;
                    }
                }
                else if (valueMetaData.length > 0 && values && values.length > 0) {
                    // Multi-measures
                    for (var i = 0, len = values.length; i < len; i++) {
                        var valueColumn = values[i];
                        if (!FunnelChart.isValidValueColumn(valueColumn))
                            continue;
                        var value = valueColumn.values[0];
                        var identity = visuals.SelectionId.createWithMeasure(valueColumn.source.queryName);
                        var categoryValue = valueMetaData[i].displayName;
                        var valueIndex = categorical.categories ? null : i;
                        var tooltipInfo = void 0;
                        // Same color for all bars
                        var color = colorHelper.getColorForMeasure(valueColumn.source.objects, '');
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, valueIndex, i);
                            if (hasHighlights) {
                                var highlight = valueColumn.highlights[0];
                                if (highlight !== 0) {
                                    tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, 0, i, highlight);
                                }
                            }
                            FunnelChart.addFunnelPercentsToTooltip(tooltipInfo, hostServices, firstValue ? value / firstValue : null, previousValue ? value / previousValue : null);
                        }
                        slices.push({
                            label: valueMetaData[i].displayName,
                            value: value,
                            originalValue: value,
                            categoryOrMeasureIndex: i,
                            identity: identity,
                            selected: false,
                            key: identity.getKey(),
                            tooltipInfo: tooltipInfo,
                            color: color,
                            labelFill: dataLabelsSettings.labelColor,
                        });
                        if (hasHighlights) {
                            var highlightIdentity = visuals.SelectionId.createWithHighlight(identity);
                            var highlight = valueColumn.highlights[0];
                            if (highlight > value) {
                                highlightsOverflow = true;
                            }
                            var highlightedValue = highlight !== 0 ? highlight : undefined;
                            var tooltipInfo_3 = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo_3 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, 0, i, highlightedValue);
                                FunnelChart.addFunnelPercentsToTooltip(tooltipInfo_3, hostServices, firstHighlight ? highlight / firstHighlight : null, previousHighlight ? highlight / previousHighlight : null, true);
                            }
                            slices.push({
                                label: valueMetaData[i].displayName,
                                value: value,
                                originalValue: value,
                                categoryOrMeasureIndex: i,
                                identity: highlightIdentity,
                                key: highlightIdentity.getKey(),
                                selected: false,
                                highlight: true,
                                originalHighlightValue: highlight,
                                highlightValue: highlight,
                                tooltipInfo: tooltipInfo_3,
                                color: color,
                            });
                            previousHighlight = highlight;
                        }
                        previousValue = value;
                    }
                }
                for (var i = 0; i < slices.length; i += hasHighlights ? 2 : 1) {
                    var slice = slices[i];
                    categoryLabels.push(slice.label);
                }
                // Calculate negative value warning flags
                allValuesAreNegative = slices.length > 0 && _.every(slices, function (slice) { return (slice.highlight ? slice.highlightValue <= 0 : true) && slice.value < 0; });
                for (var _i = 0, slices_1 = slices; _i < slices_1.length; _i++) {
                    var slice = slices_1[_i];
                    if (allValuesAreNegative) {
                        slice.value = Math.abs(slice.value);
                        if (slice.highlight)
                            slice.highlightValue = Math.abs(slice.highlightValue);
                    }
                    else {
                        var value = slice.value;
                        var isValueNegative = value < 0;
                        if (isValueNegative)
                            slice.value = 0;
                        var isHighlightValueNegative = false;
                        if (slice.highlight) {
                            var highlightValue = slice.highlightValue;
                            isHighlightValueNegative = highlightValue < 0;
                            slice.highlightValue = isHighlightValueNegative ? 0 : highlightValue;
                        }
                        if (!hasNegativeValues)
                            hasNegativeValues = isValueNegative || isHighlightValueNegative;
                    }
                    if (slice.highlightValue > slice.value) {
                        highlightsOverflow = true;
                    }
                }
                return {
                    slices: slices,
                    categoryLabels: categoryLabels,
                    valuesMetadata: valueMetaData,
                    hasHighlights: hasHighlights,
                    highlightsOverflow: highlightsOverflow,
                    canShowDataLabels: true,
                    dataLabelsSettings: dataLabelsSettings,
                    hasNegativeValues: hasNegativeValues,
                    allValuesAreNegative: allValuesAreNegative,
                    percentBarLabelSettings: percentBarLabelSettings,
                };
            };
            FunnelChart.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                    case 'dataPoint':
                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
                        var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                        if (!hasGradientRole) {
                            this.enumerateDataPoints(enumeration);
                        }
                        break;
                    case 'labels':
                        var labelSettingsOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.dataLabelsSettings, true, this.labelPositionObjects);
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingsOptions);
                        break;
                    case 'percentBarLabel':
                        var percentLabelSettingOptions = FunnelChart.getLabelSettingsOptions(enumeration, this.data.percentBarLabelSettings, false);
                        visuals.dataLabelUtils.enumerateDataLabels(percentLabelSettingOptions);
                        break;
                }
                return enumeration.complete();
            };
            FunnelChart.getLabelSettingsOptions = function (enumeration, labelSettings, isDataLabels, positionObject) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: true,
                    displayUnits: isDataLabels,
                    precision: isDataLabels,
                    position: isDataLabels,
                    positionObject: positionObject,
                    fontSize: true,
                };
            };
            FunnelChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var slices = data.slices;
                enumeration.pushInstance({
                    objectName: 'dataPoint',
                    selector: null,
                    properties: {
                        defaultColor: { solid: { color: this.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                    },
                });
                for (var i = 0; i < slices.length; i++) {
                    var slice = slices[i];
                    if (slice.highlight)
                        continue;
                    var color = slice.color;
                    var selector = slice.identity.getSelector();
                    var isSingleSeries = !!selector.data;
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        displayName: slice.label,
                        selector: visuals.ColorHelper.normalizeSelector(selector, isSingleSeries),
                        properties: {
                            fill: { solid: { color: color } }
                        },
                    });
                }
            };
            FunnelChart.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                var svg = this.svg = d3.select(element.get(0))
                    .append('svg')
                    .classed(FunnelChart.VisualClassName, true);
                if (this.behavior)
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.currentViewport = options.viewport;
                this.margin = {
                    left: 5,
                    right: 5,
                    top: 0,
                    bottom: 0
                };
                var style = options.style;
                this.colors = style.colorPalette.dataColors;
                this.hostServices = options.host;
                if (this.behavior) {
                    this.interactivityService = visuals.createInteractivityService(this.hostServices);
                }
                this.percentGraphicsContext = svg.append('g').classed(FunnelChart.Selectors.percentBar.root.class, true);
                this.funnelGraphicsContext = svg.append('g');
                this.axisGraphicsContext = svg.append('g');
                this.updateViewportProperties();
            };
            FunnelChart.prototype.updateViewportProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width)
                    .attr('height', viewport.height);
            };
            FunnelChart.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.data = {
                    slices: [],
                    categoryLabels: [],
                    valuesMetadata: [],
                    hasHighlights: false,
                    highlightsOverflow: false,
                    canShowDataLabels: true,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultFunnelLabelSettings(),
                    hasNegativeValues: false,
                    allValuesAreNegative: false,
                    percentBarLabelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true),
                };
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                if (dataViews && dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView.metadata && dataView.metadata.objects) {
                        var defaultColor = powerbi.DataViewObjects.getFillColor(dataView.metadata.objects, visuals.funnelChartProps.dataPoint.defaultColor);
                        if (defaultColor)
                            this.defaultDataPointColor = defaultColor;
                    }
                    if (dataView.categorical) {
                        this.data = FunnelChart.converter(dataView, this.colors, this.hostServices, this.defaultDataPointColor, this.tooltipsEnabled);
                        if (this.interactivityService) {
                            this.interactivityService.applySelectionStateToData(this.data.slices);
                        }
                    }
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                    if (this.data.allValuesAreNegative) {
                        warnings.unshift(new visuals.AllNegativeValuesWarning());
                    }
                    else if (this.data.hasNegativeValues) {
                        warnings.unshift(new visuals.NegativeValuesNotSupportedWarning());
                    }
                    this.hostServices.setWarnings(warnings);
                }
                this.updateViewportProperties();
                this.updateInternal(options.suppressAnimations);
            };
            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
            FunnelChart.prototype.onDataChanged = function (options) {
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            };
            // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
            FunnelChart.prototype.onResizing = function (viewport) {
                this.currentViewport = viewport;
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewport: this.currentViewport
                });
            };
            FunnelChart.prototype.getMaxLabelLength = function (labels, properties) {
                var max = 0;
                var textMeasurer = powerbi.TextMeasurementService.measureSvgTextWidth;
                for (var i = 0, len = labels.length; i < len; i++) {
                    properties.text = labels[i];
                    max = Math.max(max, textMeasurer(properties));
                }
                return max + FunnelChart.LabelFunnelPadding;
            };
            FunnelChart.prototype.updateInternal = function (suppressAnimations) {
                if (this.data == null)
                    return;
                var data = this.data;
                var slices = data.slices;
                var slicesWithoutHighlights = slices.filter(function (d) { return !d.highlight; });
                var isHidingPercentBars = this.isHidingPercentBars();
                var axisOptions = this.setUpAxis();
                var margin = axisOptions.margin;
                var verticalRange = axisOptions.verticalRange;
                var funnelContext = this.funnelGraphicsContext.attr('transform', visuals.SVGUtil.translateAndRotate(margin.left, margin.top, verticalRange / 2, verticalRange / 2, 90));
                this.percentGraphicsContext.attr('transform', visuals.SVGUtil.translate(margin.left, margin.top));
                this.svg.style('font-family', visuals.dataLabelUtils.StandardFontFamily);
                var layout = FunnelChart.getLayout(data, axisOptions);
                var labelLayout = visuals.dataLabelUtils.getFunnelChartLabelLayout(data, axisOptions, FunnelChart.InnerTextMinimumPadding, data.dataLabelsSettings, this.currentViewport);
                var result;
                var shapes;
                var dataLabels;
                if (this.animator && !suppressAnimations) {
                    var animationOptions = {
                        viewModel: data,
                        interactivityService: this.interactivityService,
                        layout: layout,
                        axisGraphicsContext: this.axisGraphicsContext,
                        shapeGraphicsContext: funnelContext,
                        percentGraphicsContext: this.percentGraphicsContext,
                        labelGraphicsContext: this.svg,
                        axisOptions: axisOptions,
                        slicesWithoutHighlights: slicesWithoutHighlights,
                        labelLayout: labelLayout,
                        isHidingPercentBars: isHidingPercentBars,
                        visualInitOptions: this.options,
                    };
                    result = this.animator.animate(animationOptions);
                    shapes = result.shapes;
                    dataLabels = result.dataLabels;
                }
                if (!this.animator || suppressAnimations || result.failed) {
                    FunnelChart.drawDefaultAxis(this.axisGraphicsContext, axisOptions, isHidingPercentBars);
                    shapes = FunnelChart.drawDefaultShapes(data, slices, funnelContext, layout, this.interactivityService && this.interactivityService.hasSelection());
                    FunnelChart.drawPercentBars(data, this.percentGraphicsContext, layout, isHidingPercentBars);
                    if (data.dataLabelsSettings.show && data.canShowDataLabels) {
                        dataLabels = visuals.dataLabelUtils.drawDefaultLabelsForFunnelChart(data.slices, this.svg, labelLayout);
                    }
                    else {
                        visuals.dataLabelUtils.cleanDataLabels(this.svg);
                    }
                }
                if (this.interactivityService) {
                    var interactors = FunnelChart.drawInteractorShapes(slices, funnelContext, layout);
                    var behaviorOptions = {
                        bars: shapes,
                        interactors: interactors,
                        clearCatcher: this.clearCatcher,
                        hasHighlights: data.hasHighlights,
                    };
                    this.interactivityService.bind(slices, this.behavior, behaviorOptions);
                    if (this.tooltipsEnabled) {
                        visuals.TooltipManager.addTooltip(interactors, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    }
                }
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            FunnelChart.prototype.getUsableVerticalSpace = function () {
                var categoryLabels = this.data.categoryLabels;
                var margin = this.margin;
                var verticalSpace = this.currentViewport.height - (margin.top + margin.bottom);
                return verticalSpace - (FunnelChart.MinBarThickness * categoryLabels.length);
            };
            FunnelChart.prototype.isHidingPercentBars = function () {
                var data = this.data;
                if (data.percentBarLabelSettings.show) {
                    var percentBarTextHeight = this.getPercentBarTextHeight();
                    var verticalSpace = this.getUsableVerticalSpace() - (2 * FunnelChart.MinBarThickness * FunnelChart.PercentBarToBarRatio) - (2 * percentBarTextHeight);
                    return verticalSpace <= 0;
                }
                return true;
            };
            FunnelChart.prototype.isSparklines = function () {
                return this.getUsableVerticalSpace() <= 0;
            };
            FunnelChart.prototype.setUpAxis = function () {
                var data = this.data;
                var slices = data.slices;
                var categoryLabels = data.categoryLabels;
                var viewport = this.currentViewport;
                var margin = this.margin;
                var isSparklines = this.isSparklines();
                var isHidingPercentBars = this.isHidingPercentBars();
                var percentBarTextHeight = isHidingPercentBars ? 0 : this.getPercentBarTextHeight();
                var horizontalRange = viewport.height - (margin.top + margin.bottom) - (2 * percentBarTextHeight);
                var maxMarginFactor = FunnelChart.MaxMarginFactor;
                if (categoryLabels.length > 0 && isSparklines) {
                    categoryLabels = [];
                    data.canShowDataLabels = false;
                }
                else if (this.showCategoryLabels()) {
                    var textProperties = FunnelChart.getTextProperties();
                    // Get the amount of space needed for the labels, then add the minimum level of padding for the axis.
                    var longestLabelLength = this.getMaxLabelLength(categoryLabels, textProperties);
                    var maxLabelLength = viewport.width * maxMarginFactor;
                    var labelLength = Math.min(longestLabelLength, maxLabelLength);
                    margin.left = labelLength + FunnelChart.YAxisPadding;
                }
                else {
                    categoryLabels = [];
                }
                var verticalRange = viewport.width - (margin.left + margin.right);
                var barToSpaceRatio = FunnelChart.BarToSpaceRatio;
                var maxScore = d3.max(slices.map(function (d) { return d.value; }));
                if (data.hasHighlights) {
                    var maxHighlight = d3.max(slices.map(function (d) { return d.highlightValue; }));
                    maxScore = d3.max([maxScore, maxHighlight]);
                }
                var minScore = 0;
                var rangeStart = 0;
                var rangeEnd = horizontalRange;
                var delta;
                if (isHidingPercentBars)
                    delta = horizontalRange - (categoryLabels.length * FunnelChart.MaxBarWidth);
                else
                    delta = horizontalRange - (categoryLabels.length * FunnelChart.MaxBarWidth) - (2 * FunnelChart.MaxBarWidth * FunnelChart.PercentBarToBarRatio);
                if (categoryLabels.length > 0 && delta > 0) {
                    rangeStart = Math.ceil(delta / 2);
                    rangeEnd = Math.ceil(horizontalRange - delta / 2);
                }
                // Offset funnel axis start and end by percent bar text height
                if (!isHidingPercentBars) {
                    rangeStart += percentBarTextHeight;
                    rangeEnd += percentBarTextHeight;
                }
                var yScale = d3.scale.linear()
                    .domain([minScore, maxScore])
                    .range([verticalRange, 0]);
                var xScale = d3.scale.ordinal()
                    .domain(d3.range(0, data.categoryLabels.length))
                    .rangeBands([rangeStart, rangeEnd], barToSpaceRatio, isHidingPercentBars ? barToSpaceRatio : FunnelChart.PercentBarToBarRatio);
                return {
                    margin: margin,
                    xScale: xScale,
                    yScale: yScale,
                    maxScore: maxScore,
                    verticalRange: verticalRange,
                    rangeStart: rangeStart,
                    rangeEnd: rangeEnd,
                    barToSpaceRatio: barToSpaceRatio,
                    categoryLabels: categoryLabels,
                };
            };
            FunnelChart.prototype.getPercentBarTextHeight = function () {
                var percentBarTextProperties = FunnelChart.getTextProperties(this.data.percentBarLabelSettings.fontSize);
                return powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties);
            };
            FunnelChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            FunnelChart.getLayout = function (data, axisOptions) {
                var highlightsOverflow = data.highlightsOverflow;
                var yScale = axisOptions.yScale;
                var xScale = axisOptions.xScale;
                var maxScore = axisOptions.maxScore;
                var columnWidth = xScale.rangeBand();
                var halfColumnWidth = Math.ceil(columnWidth / 2);
                var percentBarTickHeight = halfColumnWidth;
                var overFlowHighlightColumnWidth = columnWidth * FunnelChart.OverflowingHighlightWidthRatio;
                var overFlowHighlightOffset = overFlowHighlightColumnWidth / 2;
                var lastCategoryIndex = axisOptions.categoryLabels.length - 1;
                var horizontalDistance = Math.abs(yScale(maxScore) - yScale(0));
                var emptyHorizontalSpace = function (value) { return (horizontalDistance - Math.abs(yScale(value) - yScale(0))) / 2; };
                var getMinimumShapeSize = function (value) { return Math.max(FunnelChart.MinimumInteractorSize, Math.abs(yScale(value) - yScale(0))); };
                var percentBarFontSize = PixelConverter.fromPoint(data.percentBarLabelSettings.fontSize);
                var percentBarTextProperties = FunnelChart.getTextProperties(data.percentBarLabelSettings.fontSize);
                var baselineDelta = powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(percentBarTextProperties);
                var percentBarYOffset = powerbi.TextMeasurementService.estimateSvgTextHeight(percentBarTextProperties) - baselineDelta;
                return {
                    percentBarLayout: {
                        mainLine: {
                            x2: function (d) { return Math.abs(yScale(d.value) - yScale(0)); },
                            transform: function (d) {
                                var xOffset = yScale(d.value) - emptyHorizontalSpace(d.value);
                                var yOffset = d.isTop
                                    ? xScale(0) - halfColumnWidth
                                    : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth;
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            },
                        },
                        leftTick: {
                            y2: function (d) { return percentBarTickHeight; },
                            transform: function (d) {
                                var xOffset = yScale(d.value) - emptyHorizontalSpace(d.value);
                                var yOffset = d.isTop
                                    ? xScale(0) - halfColumnWidth - (percentBarTickHeight / 2)
                                    : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth - (percentBarTickHeight / 2);
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            },
                        },
                        rightTick: {
                            y2: function (d) { return percentBarTickHeight; },
                            transform: function (d) {
                                var columnOffset = yScale(d.value) - emptyHorizontalSpace(d.value);
                                var columnHeight = Math.abs(yScale(d.value) - yScale(0));
                                var xOffset = columnOffset + columnHeight;
                                var yOffset = d.isTop
                                    ? xScale(0) - halfColumnWidth - (percentBarTickHeight / 2)
                                    : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth - (percentBarTickHeight / 2);
                                return visuals.SVGUtil.translate(xOffset, yOffset);
                            },
                        },
                        text: {
                            x: function (d) { return Math.ceil((Math.abs(yScale(maxScore) - yScale(0)) / 2)); },
                            y: function (d) {
                                return d.isTop
                                    ? -percentBarTickHeight / 2 - baselineDelta
                                    : percentBarYOffset + (percentBarTickHeight / 2);
                            },
                            style: function () { return ("font-size: " + percentBarFontSize + ";"); },
                            transform: function (d) {
                                var yOffset = d.isTop
                                    ? xScale(0) - halfColumnWidth
                                    : xScale(lastCategoryIndex) + columnWidth + halfColumnWidth;
                                return visuals.SVGUtil.translate(0, yOffset);
                            },
                            fill: data.percentBarLabelSettings.labelColor,
                            maxWidth: horizontalDistance,
                        },
                    },
                    shapeLayout: {
                        width: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth; }),
                        height: function (d) {
                            return Math.abs(yScale(FunnelChart.getFunnelSliceValue(d)) - yScale(0));
                        },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function (d) {
                            var value = FunnelChart.getFunnelSliceValue(d);
                            return yScale(value) - emptyHorizontalSpace(value);
                        },
                    },
                    shapeLayoutWithoutHighlights: {
                        width: (function (d) { return columnWidth; }),
                        height: function (d) {
                            return Math.abs(yScale(d.value) - yScale(0));
                        },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (0);
                        },
                        y: function (d) {
                            return yScale(d.value) - emptyHorizontalSpace(d.value);
                        },
                    },
                    zeroShapeLayout: {
                        width: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth; }),
                        height: function (d) { return 0; },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function (d) {
                            return yScale((yScale.domain()[0] + yScale.domain()[1]) / 2);
                        },
                    },
                    interactorLayout: {
                        width: (function (d) { return d.highlight && highlightsOverflow ? overFlowHighlightColumnWidth : columnWidth; }),
                        height: function (d) { return getMinimumShapeSize(FunnelChart.getFunnelSliceValue(d)); },
                        x: function (d) {
                            return xScale(d.categoryOrMeasureIndex) + (d.highlight && highlightsOverflow ? overFlowHighlightOffset : 0);
                        },
                        y: function (d) {
                            var size = getMinimumShapeSize(FunnelChart.getFunnelSliceValue(d));
                            return (horizontalDistance - size) / 2;
                        },
                    },
                };
            };
            FunnelChart.drawDefaultAxis = function (graphicsContext, axisOptions, isHidingPercentBars) {
                //Generate ordinal domain
                var indices = d3.range(0, axisOptions.categoryLabels.length);
                var xScaleForAxis = d3.scale.ordinal()
                    .domain(indices)
                    .rangeBands([axisOptions.rangeStart, axisOptions.rangeEnd], axisOptions.barToSpaceRatio, isHidingPercentBars ? axisOptions.barToSpaceRatio : FunnelChart.PercentBarToBarRatio);
                var xAxis = d3.svg.axis()
                    .scale(xScaleForAxis)
                    .orient("right")
                    .tickPadding(FunnelChart.TickPadding)
                    .innerTickSize(FunnelChart.InnerTickSize)
                    .ticks(indices.length)
                    .tickValues(indices)
                    .tickFormat(function (i) { return axisOptions.categoryLabels[i]; }); //To output the category label
                graphicsContext.attr('class', 'axis hideLinesOnAxis')
                    .attr('transform', visuals.SVGUtil.translate(0, axisOptions.margin.top))
                    .call(xAxis);
                graphicsContext.selectAll('.tick')
                    .call(visuals.tooltipUtils.tooltipUpdate, axisOptions.categoryLabels);
                // Subtract the padding from the margin since we can't have text there. Then shorten the labels if necessary.
                var leftRightMarginLimit = axisOptions.margin.left - FunnelChart.LabelFunnelPadding;
                graphicsContext.selectAll('.tick text')
                    .call(visuals.AxisHelper.LabelLayoutStrategy.clip, leftRightMarginLimit, powerbi.TextMeasurementService.svgEllipsis);
            };
            FunnelChart.drawDefaultShapes = function (data, slices, graphicsContext, layout, hasSelection) {
                var hasHighlights = data.hasHighlights;
                var columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.bars.selector).data(slices, function (d) { return d.key; });
                columns.enter()
                    .append('rect')
                    .attr("class", function (d) { return d.highlight ? FunnelChart.FunnelBarHighlightClass : FunnelChart.Selectors.funnel.bars.class; });
                columns
                    .style("fill", function (d) {
                    return d.color;
                })
                    .style("fill-opacity", function (d) { return function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, hasHighlights); }; })
                    .attr(layout.shapeLayout);
                columns.exit().remove();
                return columns;
            };
            FunnelChart.getFunnelSliceValue = function (slice, asOriginal) {
                if (asOriginal === void 0) { asOriginal = false; }
                if (asOriginal)
                    return slice.highlight ? slice.originalHighlightValue : slice.originalValue;
                else
                    return slice.highlight ? slice.highlightValue : slice.value;
            };
            FunnelChart.drawInteractorShapes = function (slices, graphicsContext, layout) {
                // Draw invsible ineractors for just data points which are below threshold
                var needInteractors = slices.filter(function (d) {
                    return !d.highlight && layout.interactorLayout.height(d) === FunnelChart.MinimumInteractorSize;
                });
                var columns = graphicsContext.selectAll(FunnelChart.Selectors.funnel.interactors.selector).data(needInteractors, function (d) { return d.key; });
                columns.enter()
                    .append('rect')
                    .attr("class", FunnelChart.Selectors.funnel.interactors.class);
                columns
                    .style("fill-opacity", 0)
                    .attr(layout.interactorLayout);
                columns.exit().remove();
                return columns;
            };
            FunnelChart.drawPercentBarComponents = function (graphicsContext, data, layout, percentLabelSettings) {
                // Main line
                var mainLine = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.mainLine.selector).data(data);
                mainLine.exit().remove();
                mainLine.enter()
                    .append('line')
                    .classed(FunnelChart.Selectors.percentBar.mainLine.class, true);
                mainLine
                    .attr(layout.percentBarLayout.mainLine);
                // Left tick
                var leftTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.leftTick.selector).data(data);
                leftTick.exit().remove();
                leftTick.enter()
                    .append('line')
                    .classed(FunnelChart.Selectors.percentBar.leftTick.class, true);
                leftTick
                    .attr(layout.percentBarLayout.leftTick);
                // Right tick
                var rightTick = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.rightTick.selector).data(data);
                rightTick.exit().remove();
                rightTick.enter()
                    .append('line')
                    .classed(FunnelChart.Selectors.percentBar.rightTick.class, true);
                rightTick
                    .attr(layout.percentBarLayout.rightTick);
                // Text
                var text = graphicsContext.selectAll(FunnelChart.Selectors.percentBar.text.selector).data(data);
                var localizedString = visuals.valueFormatter.getLocalizedString("Percentage1");
                text.exit().remove();
                text.enter().append('text').classed(FunnelChart.Selectors.percentBar.text.class, true);
                text
                    .attr(layout.percentBarLayout.text)
                    .text(function (fp) {
                    return visuals.dataLabelUtils.getLabelFormattedText({
                        label: fp.percent,
                        format: localizedString,
                        fontSize: percentLabelSettings.fontSize,
                        maxWidth: layout.percentBarLayout.text.maxWidth,
                    });
                })
                    .append('title').text(function (d) { return powerbi.formattingService.formatValue(d.percent, localizedString); });
            };
            FunnelChart.drawPercentBars = function (data, graphicsContext, layout, isHidingPercentBars) {
                if (isHidingPercentBars || !data.slices || (data.hasHighlights ? data.slices.length / 2 : data.slices.length) < 2) {
                    FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
                    return;
                }
                var slices = [data.slices[data.hasHighlights ? 1 : 0], data.slices[data.slices.length - 1]];
                var baseline = FunnelChart.getFunnelSliceValue(slices[0]);
                if (baseline <= 0) {
                    FunnelChart.drawPercentBarComponents(graphicsContext, [], layout, data.percentBarLabelSettings);
                    return;
                }
                var percentData = [
                    {
                        value: FunnelChart.getFunnelSliceValue(slices[0]),
                        percent: 1,
                        isTop: true,
                    },
                    {
                        value: FunnelChart.getFunnelSliceValue(slices[1]),
                        percent: FunnelChart.getFunnelSliceValue(slices[1]) / baseline,
                        isTop: false,
                    },
                ];
                FunnelChart.drawPercentBarComponents(graphicsContext, percentData, layout, data.percentBarLabelSettings);
            };
            FunnelChart.prototype.showCategoryLabels = function () {
                if (this.funnelSmallViewPortProperties) {
                    if ((this.funnelSmallViewPortProperties.hideFunnelCategoryLabelsOnSmallViewPort) && (this.currentViewport.height < this.funnelSmallViewPortProperties.minHeightFunnelCategoryLabelsVisible)) {
                        return false;
                    }
                }
                return true;
            };
            FunnelChart.addFunnelPercentsToTooltip = function (tooltipInfo, hostServices, percentOfFirst, percentOfPrevious, highlight) {
                if (percentOfFirst != null) {
                    tooltipInfo.push({
                        displayName: hostServices.getLocalizedString("Funnel_PercentOfFirst" + (highlight ? "_Highlight" : "")),
                        value: visuals.valueFormatter.format(percentOfFirst, '0.00 %;-0.00 %;0.00 %'),
                    });
                }
                if (percentOfPrevious != null) {
                    tooltipInfo.push({
                        displayName: hostServices.getLocalizedString("Funnel_PercentOfPrevious" + (highlight ? "_Highlight" : "")),
                        value: visuals.valueFormatter.format(percentOfPrevious, '0.00 %;-0.00 %;0.00 %'),
                    });
                }
            };
            FunnelChart.getTextProperties = function (fontSize) {
                return {
                    fontSize: PixelConverter.fromPoint(fontSize || visuals.dataLabelUtils.DefaultFontSizeInPt),
                    fontFamily: FunnelChart.DefaultFontFamily,
                };
            };
            FunnelChart.DefaultBarOpacity = 1;
            FunnelChart.DimmedBarOpacity = 0.4;
            FunnelChart.PercentBarToBarRatio = 0.75;
            FunnelChart.TickPadding = 0;
            FunnelChart.InnerTickSize = 0;
            FunnelChart.MinimumInteractorSize = 15;
            FunnelChart.InnerTextClassName = 'labelSeries';
            FunnelChart.Selectors = {
                funnel: {
                    bars: createClassAndSelector('funnelBar'),
                    highlights: createClassAndSelector('highlight'),
                    interactors: createClassAndSelector('funnelBarInteractor'),
                },
                percentBar: {
                    root: createClassAndSelector('percentBars'),
                    mainLine: createClassAndSelector('mainLine'),
                    leftTick: createClassAndSelector('leftTick'),
                    rightTick: createClassAndSelector('rightTick'),
                    text: createClassAndSelector('value'),
                },
            };
            FunnelChart.FunnelBarHighlightClass = [FunnelChart.Selectors.funnel.bars.class, FunnelChart.Selectors.funnel.highlights.class].join(' ');
            FunnelChart.YAxisPadding = 10;
            FunnelChart.VisualClassName = 'funnelChart';
            FunnelChart.DefaultFontFamily = 'wf_standard-font';
            FunnelChart.BarToSpaceRatio = 0.1;
            FunnelChart.MaxBarWidth = 40;
            FunnelChart.MinBarThickness = 12;
            FunnelChart.LabelFunnelPadding = 6;
            FunnelChart.InnerTextMinimumPadding = 10;
            FunnelChart.OverflowingHighlightWidthRatio = 0.5;
            FunnelChart.MaxMarginFactor = 0.25;
            return FunnelChart;
        }());
        visuals.FunnelChart = FunnelChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        /**
         * Renders a number that can be animate change in value.
         */
        var Gauge = (function () {
            function Gauge(options) {
                this.lastAngle = -Math.PI / 2;
                if (options) {
                    if (options.gaugeSmallViewPortProperties) {
                        this.gaugeSmallViewPortProperties = options.gaugeSmallViewPortProperties;
                    }
                    this.animator = options.animator;
                    this.tooltipsEnabled = options.tooltipsEnabled;
                }
            }
            Gauge.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                    case 'axis':
                        this.enumerateAxis(enumeration);
                        break;
                    case 'labels': {
                        var labelSettings = this.data ? this.data.dataLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                        visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
                        break;
                    }
                    case 'calloutValue': {
                        var labelSettings = this.data ? this.data.calloutValueLabelsSettings : visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                        visuals.dataLabelUtils.enumerateDataLabels(this.getDataLabelSettingsOptions(enumeration, labelSettings));
                        break;
                    }
                    case 'dataPoint': {
                        this.enumerateDataPoint(enumeration);
                        break;
                    }
                }
                return enumeration.complete();
            };
            Gauge.prototype.getDataLabelSettingsOptions = function (enumeration, labelSettings) {
                return {
                    dataLabelsSettings: labelSettings,
                    show: true,
                    precision: true,
                    displayUnits: true,
                    fontSize: true,
                    enumeration: enumeration,
                };
            };
            Gauge.prototype.enumerateAxis = function (enumeration) {
                var dataView = this.dataViews[0];
                if (dataView && dataView.metadata) {
                    var properties = Gauge.getGaugeObjectsProperties(dataView);
                    enumeration.pushInstance({
                        selector: null,
                        objectName: 'axis',
                        properties: properties,
                    });
                }
            };
            Gauge.prototype.enumerateDataPoint = function (enumeration) {
                var dataPointSettings = this.data ? this.data.dataPointSettings : Gauge.DefaultDataPointSettings;
                var properties = {};
                properties.fill = { solid: { color: dataPointSettings.fillColor } };
                if (dataPointSettings.targetColor != null) {
                    properties.target = { solid: { color: dataPointSettings.targetColor } };
                }
                enumeration.pushInstance({
                    selector: null,
                    objectName: visuals.gaugeProps.dataPoint.target.objectName,
                    properties: properties
                });
            };
            Gauge.getGaugeObjectsProperties = function (dataView) {
                var properties = {};
                var objects = dataView.metadata.objects;
                var hasAxisObject = !!objects && !!objects.axis;
                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.minValue))
                    properties.min = hasAxisObject ? objects.axis.min : undefined;
                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.maxValue))
                    properties.max = hasAxisObject ? objects.axis.max : undefined;
                if (!DataRoleHelper.hasRoleInDataView(dataView, visuals.gaugeRoleNames.targetValue))
                    properties.target = hasAxisObject ? objects.axis.target : undefined;
                return properties;
            };
            Gauge.prototype.init = function (options) {
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.options = options;
                this.settings = Gauge.DefaultStyleProperties;
                this.targetSettings = Gauge.DefaultTargetSettings;
                this.setMargins();
                this.color = d3.scale.ordinal().range(this.style.colorPalette.dataColors.getSentimentColors().map(function (color) { return color.value; }));
                this.hostService = options.host;
                var svg = this.svg = d3.select(this.element.get(0)).append('svg');
                svg.classed(Gauge.VisualClassName, true);
                var mainGraphicsContext = this.mainGraphicsContext = svg.append('g');
                mainGraphicsContext.attr('class', Gauge.MainGaugeGroupClassName);
                this.initKpiBands();
                var backgroundArc = this.backgroundArc = d3.svg.arc()
                    .innerRadius(0)
                    .outerRadius(0)
                    .startAngle(-Math.PI / 2)
                    .endAngle(Math.PI / 2);
                var foregroundArc = this.foregroundArc = d3.svg.arc()
                    .innerRadius(0)
                    .outerRadius(0)
                    .startAngle(-Math.PI / 2);
                this.backgroundArcPath = mainGraphicsContext.append('path')
                    .classed('backgroundArc', true)
                    .attr('d', backgroundArc);
                this.foregroundArcPath = mainGraphicsContext.append('path')
                    .datum({ endAngle: -Math.PI / 2 })
                    .classed('foregroundArc', true)
                    .attr('d', foregroundArc);
                var g = this.animatedNumberGrapicsContext = svg.append('g');
                this.animatedNumber = new visuals.AnimatedNumber(g);
                this.animatedNumber.init(options);
                var gaugeDrawingOptions = this.gaugeVisualProperties = this.getGaugeVisualProperties();
                var animatedNumberProperties = this.getAnimatedNumberProperties(gaugeDrawingOptions.radius, gaugeDrawingOptions.innerRadiusFactor, gaugeDrawingOptions.top, gaugeDrawingOptions.left);
                this.animatedNumberGrapicsContext.attr('transform', animatedNumberProperties.transformString);
                this.animatedNumber.onResizing(animatedNumberProperties.viewport);
            };
            Gauge.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (!dataViews || !dataViews[0]) {
                    return;
                }
                this.data = Gauge.converter(dataViews[0], this.tooltipsEnabled);
                this.targetSettings = this.data.targetSettings;
                if (dataViews[0])
                    dataViews[0].single = { value: this.data.total };
                // Only show the target label if:
                //   1. There is a target
                //   2. The viewport width is big enough for a target
                //   3. We're showing label text for side numbers
                //   4. Data label settings specify to show
                this.showTargetLabel = this.targetSettings.target != null
                    && (this.currentViewport.width > Gauge.MinWidthForTargetLabel || !this.showMinMaxLabelsOnBottom())
                    && this.showSideNumbersLabelText()
                    && this.data.dataLabelsSettings.show;
                this.setMargins();
                this.gaugeVisualProperties = this.getGaugeVisualProperties();
                this.drawViewPort(this.gaugeVisualProperties);
                this.updateInternal(options.suppressAnimations);
                this.updateCalloutValue(options.suppressAnimations);
                var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                this.hostService.setWarnings(warnings);
            };
            Gauge.prototype.updateCalloutValue = function (suppressAnimations) {
                if (this.data.calloutValueLabelsSettings.show) {
                    var animatedNumberProperties = this.getAnimatedNumberProperties(this.gaugeVisualProperties.radius, this.gaugeVisualProperties.innerRadiusFactor, this.gaugeVisualProperties.top, this.gaugeVisualProperties.left);
                    this.animatedNumberGrapicsContext.attr('transform', animatedNumberProperties.transformString);
                    this.animatedNumber.setTextColor(this.data.calloutValueLabelsSettings.labelColor);
                    var calloutValue = this.data ? this.data.total : null;
                    var formatter = this.getFormatter(this.data.calloutValueLabelsSettings, calloutValue);
                    this.animatedNumber.setFormatter(formatter);
                    this.animatedNumber.update({
                        viewport: animatedNumberProperties.viewport,
                        dataViews: this.dataViews,
                        suppressAnimations: suppressAnimations,
                    });
                    this.animatedNumberGrapicsContext.selectAll('title').remove();
                    this.animatedNumberGrapicsContext.append('title').text([formatter.format(calloutValue)]);
                }
                else {
                    this.animatedNumber.clear();
                    this.animatedNumberGrapicsContext.selectAll('title').remove();
                }
            };
            Gauge.prototype.onDataChanged = function (options) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport
                });
            };
            Gauge.prototype.onResizing = function (viewport) {
                // TODO: Remove onDataChanged & onResizing once all visuals have implemented update.
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewMode: 0 /* View */,
                    viewport: viewport
                });
            };
            Gauge.getValidSettings = function (targetData) {
                var maxVal = (targetData.max === Gauge.MAX_VALUE) ? Gauge.DEFAULT_MAX : targetData.max;
                var minVal = (targetData.min === Gauge.MIN_VALUE) ? Gauge.DEFAULT_MIN : targetData.min;
                var targetVal = targetData.target;
                return {
                    min: minVal,
                    max: maxVal,
                    target: targetVal
                };
            };
            Gauge.getGaugeData = function (dataView) {
                var settings = {
                    max: Gauge.MAX_VALUE,
                    min: Gauge.MIN_VALUE,
                    target: undefined,
                    total: 0,
                    tooltipItems: []
                };
                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) {
                    var values = dataView.categorical.values;
                    var metadataColumns = dataView.metadata.columns;
                    debug.assert(metadataColumns.length >= values.length, 'length');
                    for (var i = 0; i < values.length; i++) {
                        var col = metadataColumns[i], value = values[i].values[0] || 0;
                        if (col && col.roles) {
                            if (col.roles[visuals.gaugeRoleNames.y]) {
                                settings.total = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                            else if (col.roles[visuals.gaugeRoleNames.minValue]) {
                                settings.min = value;
                            }
                            else if (col.roles[visuals.gaugeRoleNames.maxValue]) {
                                settings.max = value;
                            }
                            else if (col.roles[visuals.gaugeRoleNames.targetValue]) {
                                settings.target = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                        }
                    }
                    // Override settings according to property pane axis values
                    var gaugeObjectsSettings = Gauge.getGaugeObjectsProperties(dataView);
                    if (gaugeObjectsSettings && !$.isEmptyObject(gaugeObjectsSettings))
                        Gauge.overrideGaugeSettings(settings, gaugeObjectsSettings);
                }
                return settings;
            };
            Gauge.overrideGaugeSettings = function (settings, gaugeObjectsSettings) {
                if ($.isNumeric(gaugeObjectsSettings.min))
                    settings.min = gaugeObjectsSettings.min;
                if ($.isNumeric(gaugeObjectsSettings.max))
                    settings.max = gaugeObjectsSettings.max;
                if ($.isNumeric(gaugeObjectsSettings.target))
                    settings.target = gaugeObjectsSettings.target;
            };
            /** Note: Made public for testability */
            Gauge.converter = function (dataView, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var gaugeData = Gauge.getGaugeData(dataView), total = gaugeData.total, formatString = null, hasPercent = false;
                if (dataView.metadata && !_.isEmpty(dataView.metadata.columns)) {
                    formatString = visuals.valueFormatter.getFormatString(dataView.metadata.columns[0], Gauge.formatStringProp, true);
                    if (formatString != null)
                        hasPercent = visuals.valueFormatter.getFormatMetadata(formatString).hasPercent;
                }
                if (total > 0 && gaugeData.max === Gauge.MAX_VALUE) {
                    gaugeData.max = hasPercent ? Gauge.DEFAULT_MAX : total * 2;
                }
                var settings = Gauge.getValidSettings(gaugeData);
                //Checking that the value is plotted inside the gauge boundaries
                var adjustedTotal = Math.max(total, settings.min);
                adjustedTotal = Math.min(adjustedTotal, settings.max);
                var percent = (settings.min !== settings.max)
                    ? (adjustedTotal - settings.min) / (settings.max - settings.min)
                    : 0;
                var tooltipInfo;
                if (tooltipsEnabled && dataView) {
                    if (gaugeData.tooltipItems.length > 0) {
                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, null, null, null, null, gaugeData.tooltipItems);
                    }
                    else {
                        var dataViewCat = dataView.categorical;
                        if (dataViewCat && dataViewCat.values && dataViewCat.values.length > 0) {
                            var categoryValue = dataViewCat.values[0];
                            var value = categoryValue.values[0];
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(Gauge.formatStringProp, dataViewCat, null, value);
                        }
                    }
                }
                return {
                    percent: percent,
                    adjustedTotal: adjustedTotal,
                    total: total,
                    metadataColumn: Gauge.getMetaDataColumn(dataView),
                    targetSettings: settings,
                    tooltipInfo: tooltipInfo,
                    dataLabelsSettings: Gauge.convertDataLabelSettings(dataView, "labels"),
                    calloutValueLabelsSettings: Gauge.convertDataLabelSettings(dataView, "calloutValue"),
                    dataPointSettings: Gauge.convertDataPointSettings(dataView, settings)
                };
            };
            Gauge.convertDataLabelSettings = function (dataview, objectName) {
                var dataViewMetadata = dataview.metadata;
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultGaugeLabelSettings();
                if (dataViewMetadata) {
                    var objects = dataViewMetadata.objects;
                    if (objects) {
                        // Handle label settings
                        var labelsObj = objects[objectName];
                        visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                    }
                }
                return dataLabelsSettings;
            };
            Gauge.convertDataPointSettings = function (dataView, targetSettings) {
                // Default the fill color the the default fill color. Default the target to undefined as it's only used if there's a target.
                var fillColor = Gauge.DefaultDataPointSettings.fillColor;
                var targetColor;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    // If there is saved metadata, use it for the colors
                    var objects = dataView.metadata.objects;
                    fillColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.fill, Gauge.DefaultDataPointSettings.fillColor);
                    if (targetSettings && (targetSettings.target != null)) {
                        targetColor = powerbi.DataViewObjects.getFillColor(objects, visuals.gaugeProps.dataPoint.target, Gauge.DefaultDataPointSettings.targetColor);
                    }
                }
                else if (targetSettings && (targetSettings.target != null)) {
                    // If there isn't metadata, but a target is set, default to the default target color
                    targetColor = Gauge.DefaultDataPointSettings.targetColor;
                }
                return {
                    fillColor: fillColor,
                    targetColor: targetColor
                };
            };
            Gauge.getMetaDataColumn = function (dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var i = 0, ilen = dataView.metadata.columns.length; i < ilen; i++) {
                        var column = dataView.metadata.columns[i];
                        if (column.isMeasure) {
                            return column;
                        }
                    }
                }
                return null;
            };
            Gauge.prototype.initKpiBands = function () {
                if (!this.settings.kpiBands.show)
                    return;
                var kpiArcs = this.kpiArcs = [];
                var kpiArcPaths = this.kpiArcPaths = [];
                var mainGraphicsContext = this.mainGraphicsContext;
                for (var i = 0; i < 3; i++) {
                    var arc = d3.svg.arc()
                        .innerRadius(0)
                        .outerRadius(0)
                        .startAngle(0)
                        .endAngle(0);
                    kpiArcs.push(arc);
                    var arcPath = mainGraphicsContext.append('path')
                        .attr("d", arc);
                    kpiArcPaths.push(arcPath);
                }
            };
            Gauge.prototype.updateKpiBands = function (radius, innerRadiusFactor, tString, kpiAngleAttr) {
                if (!this.settings.kpiBands.show)
                    return;
                for (var i = 0; i < kpiAngleAttr.length; i++) {
                    this.kpiArcs[i]
                        .innerRadius(radius * innerRadiusFactor - (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness))
                        .outerRadius(radius * innerRadiusFactor - Gauge.KpiBandDistanceFromMainArc)
                        .startAngle(kpiAngleAttr[i].start)
                        .endAngle(kpiAngleAttr[i].end);
                    this.kpiArcPaths[i]
                        .attr('fill', kpiAngleAttr[i].fill)
                        .attr('d', this.kpiArcs[i])
                        .attr('transform', tString);
                }
            };
            Gauge.prototype.removeTargetElements = function () {
                if (this.targetLine) {
                    this.targetLine.remove();
                    this.targetText.remove();
                    this.targetConnector.remove();
                    this.targetLine = this.targetConnector = this.targetText = null;
                }
            };
            Gauge.prototype.getTargetRatio = function () {
                var targetSettings = this.targetSettings;
                var range = targetSettings.max - targetSettings.min;
                if (range !== 0)
                    return (targetSettings.target - targetSettings.min) / range;
                return 0;
            };
            Gauge.prototype.updateTargetLine = function (radius, innerRadius, left, top) {
                if (!this.targetLine) {
                    this.targetLine = this.mainGraphicsContext.append('line');
                }
                var angle = this.getTargetRatio() * Math.PI;
                var outY = top - radius * Math.sin(angle);
                var outX = left - radius * Math.cos(angle);
                var inY = top - innerRadius * Math.sin(angle);
                var inX = left - innerRadius * Math.cos(angle);
                this.targetLine.attr({
                    x1: inX,
                    y1: inY,
                    x2: outX,
                    y2: outY
                });
            };
            /** Note: public for testability */
            Gauge.prototype.getAnimatedNumberProperties = function (radius, innerRadiusFactor, top, left) {
                var boxAngle = Math.PI / 4;
                var scale = 1;
                var innerRadiusOfArc = radius * innerRadiusFactor;
                var innerRadiusForTextBoundingBox = innerRadiusOfArc - (this.settings.kpiBands.show
                    ? (Gauge.KpiBandDistanceFromMainArc + this.settings.kpiBands.thickness)
                    : 0);
                var innerRCos = innerRadiusForTextBoundingBox * Math.cos(boxAngle);
                var innerRSin = innerRadiusForTextBoundingBox * Math.sin(boxAngle);
                var innerY = top - innerRSin;
                var innerX = left - innerRCos;
                innerY = innerY * scale;
                innerX = innerX * scale;
                var animatedNumberWidth = innerRCos * 2;
                var properties = {
                    transformString: visuals.SVGUtil.translate(innerX, innerY),
                    viewport: { height: innerRSin, width: animatedNumberWidth }
                };
                return properties;
            };
            /** Note: public for testability */
            Gauge.prototype.getGaugeVisualProperties = function () {
                var viewport = this.currentViewport;
                var margin = this.margin;
                var width = viewport.width - margin.right - margin.left;
                var halfWidth = width / 2;
                var height = viewport.height - margin.top - margin.bottom;
                var radius = Math.min(halfWidth, height);
                var innerRadiusFactor = Gauge.InnerRadiusFactor;
                var left = margin.left + halfWidth;
                var top = radius + (height - radius) / 2 + margin.top;
                var tString = visuals.SVGUtil.translate(left, top);
                var innerRadiusOfArc = radius * innerRadiusFactor;
                var gaugeData = {
                    radius: radius,
                    innerRadiusOfArc: innerRadiusOfArc,
                    left: left,
                    top: top,
                    height: height,
                    width: width,
                    margin: margin,
                    transformString: tString,
                    innerRadiusFactor: innerRadiusFactor
                };
                return gaugeData;
            };
            /** Note: public for testability */
            Gauge.prototype.drawViewPort = function (drawOptions) {
                debug.assertAnyValue(drawOptions, "Gauge options");
                var separation = this.settings.kpiBands.separationRadians;
                var innerRadiusFactor = Gauge.InnerRadiusFactor;
                var backgroudArc = this.backgroundArc;
                var color = this.color;
                var attrs = [{
                        fill: color(0),
                        start: -Math.PI / 2,
                        end: -Math.PI / 2 + Math.PI / 4 - separation
                    }, {
                        fill: color(1),
                        start: -Math.PI / 2 + Math.PI * 1 / 4 + separation,
                        end: -Math.PI / 2 + Math.PI * 3 / 4 - separation
                    }, {
                        fill: color(2),
                        start: -Math.PI / 2 + Math.PI * 3 / 4 + separation,
                        end: Math.PI / 2
                    }];
                var radius = drawOptions.radius;
                var transformString = drawOptions.transformString;
                this.updateKpiBands(radius, innerRadiusFactor, transformString, attrs);
                backgroudArc
                    .innerRadius(radius * innerRadiusFactor)
                    .outerRadius(radius)
                    .startAngle(-Math.PI / 2)
                    .endAngle(Math.PI / 2);
                this.backgroundArcPath
                    .attr("d", backgroudArc)
                    .attr("transform", transformString);
                var foregroundArc = this.foregroundArc;
                foregroundArc
                    .innerRadius(radius * innerRadiusFactor)
                    .outerRadius(radius)
                    .startAngle(-Math.PI / 2);
                this.foregroundArcPath
                    .datum({ endAngle: this.lastAngle })
                    .attr("transform", transformString)
                    .attr("d", foregroundArc);
                var innerRadiusOfArc = drawOptions.innerRadiusOfArc;
                var left = drawOptions.left;
                var top = drawOptions.top;
                var margin = drawOptions.margin;
                var height = drawOptions.height;
                var targetSettings = this.targetSettings;
                if (!this.settings.targetLine.show || targetSettings.target == null) {
                    this.removeTargetElements();
                }
                else {
                    if (targetSettings.min > targetSettings.target || targetSettings.max < targetSettings.target) {
                        this.removeTargetElements();
                    }
                    else {
                        this.updateTargetLine(radius, innerRadiusOfArc, left, top);
                        this.appendTargetTextAlongArc(radius, height, drawOptions.width, margin);
                    }
                }
                this.svg.attr('height', this.currentViewport.height).attr('width', this.currentViewport.width);
            };
            Gauge.prototype.createTicks = function () {
                var settings = this.settings;
                var targetSettings = this.targetSettings;
                var total = targetSettings.max - targetSettings.min;
                var numberOfLabels = settings.labels.count;
                var step = total / numberOfLabels;
                var arr = [];
                var formatter = this.getFormatter(this.data.dataLabelsSettings, targetSettings.max);
                for (var i = 0; i < numberOfLabels + 1; i++) {
                    arr.push(formatter.format(targetSettings.min + (i * step)));
                }
                return arr;
            };
            Gauge.prototype.updateInternal = function (suppressAnimations) {
                var height = this.gaugeVisualProperties.height;
                var width = this.gaugeVisualProperties.width;
                var radius = this.gaugeVisualProperties.radius;
                var margin = this.margin;
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                var data = this.data;
                var lastAngle = this.lastAngle = -Math.PI / 2 + Math.PI * data.percent;
                var ticks = this.createTicks();
                this.foregroundArcPath
                    .transition()
                    .ease(this.settings.transition.ease)
                    .duration(duration)
                    .call(this.arcTween, [lastAngle, this.foregroundArc]);
                this.appendTextAlongArc(ticks, radius, height, width, margin);
                this.updateVisualConfigurations();
                this.updateVisualStyles();
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(this.foregroundArcPath, function (tooltipEvent) { return data.tooltipInfo; });
                    visuals.TooltipManager.addTooltip(this.backgroundArcPath, function (tooltipEvent) { return data.tooltipInfo; });
                }
            };
            Gauge.prototype.updateVisualStyles = function () {
                var fillColor = this.data.dataLabelsSettings.labelColor || this.style.labelText.color.value;
                this.mainGraphicsContext.selectAll('text')
                    .style({
                    'fill': fillColor,
                });
            };
            Gauge.prototype.updateVisualConfigurations = function () {
                var configOptions = this.settings;
                var dataPointSettings = this.data.dataPointSettings;
                this.mainGraphicsContext
                    .select('line')
                    .attr({
                    stroke: dataPointSettings.targetColor,
                    'stroke-width': configOptions.targetLine.thickness,
                });
                this.backgroundArcPath.style('fill', configOptions.arcColors.background);
                this.foregroundArcPath.style('fill', dataPointSettings.fillColor);
            };
            Gauge.prototype.appendTextAlongArc = function (ticks, radius, height, width, margin) {
                this.svg.selectAll(Gauge.LabelText.selector).remove();
                if (!this.data.dataLabelsSettings.show)
                    return;
                var total = ticks.length;
                var divisor = total - 1;
                var top = (radius + (height - radius) / 2 + margin.top);
                var showMinMaxLabelsOnBottom = this.showMinMaxLabelsOnBottom();
                var fontSize = PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
                var padding = this.settings.labels.padding;
                for (var count = 0; count < total; count++) {
                    var textProperties = {
                        text: ticks[count],
                        fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: visuals.dataLabelUtils.LabelTextProperties.fontSize,
                        fontWeight: visuals.dataLabelUtils.LabelTextProperties.fontWeight,
                    };
                    if (Math.floor(total / 2) === count)
                        continue; // Skip Middle label, by design
                    if (this.showSideNumbersLabelText()) {
                        var x = (margin.left + width / 2) - (radius * Math.cos(Math.PI * count / divisor));
                        var y = top - (radius * Math.sin(Math.PI * count / divisor));
                        var anchor = void 0;
                        var onRight = count * 2 > total;
                        var onBottom = false;
                        if (showMinMaxLabelsOnBottom && (count === 0 || count === total - 1)) {
                            // If this is a min or max label and we're showing them on the bottom rather than the sides
                            // Adjust the label display properties to appear under the arc
                            onBottom = true;
                            y += padding / 2;
                            // Align the labels with the outer edge of the arc
                            anchor = onRight ? 'end' : 'start';
                            textProperties.text = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, radius);
                        }
                        else {
                            // For all other labels, display around the arc
                            anchor = onRight ? 'start' : 'end';
                            x += padding * (onRight ? 1 : -1);
                        }
                        var text = this.mainGraphicsContext
                            .append('text')
                            .attr({
                            'x': x,
                            'y': y,
                            'dy': onBottom ? fontSize : 0,
                            'class': Gauge.LabelText.class
                        })
                            .style({
                            'text-anchor': anchor,
                            'font-size': fontSize
                        })
                            .text(textProperties.text)
                            .append('title').text(textProperties.text);
                        if (!onBottom)
                            this.truncateTextIfNeeded(text, x, onRight);
                    }
                }
            };
            Gauge.prototype.truncateTextIfNeeded = function (text, positionX, onRight) {
                var availableSpace = (onRight ? this.currentViewport.width - positionX : positionX);
                text.call(visuals.AxisHelper.LabelLayoutStrategy.clip, availableSpace, powerbi.TextMeasurementService.svgEllipsis);
            };
            Gauge.prototype.getFormatter = function (dataLabelSettings, value2) {
                var realValue2 = dataLabelSettings.displayUnits === 0 ? value2 : null;
                var formatString = visuals.valueFormatter.getFormatString(this.data.metadataColumn, Gauge.formatStringProp);
                var precision = visuals.dataLabelUtils.getLabelPrecision(dataLabelSettings.precision, formatString);
                var valueFormatterOptions = visuals.dataLabelUtils.getOptionsForLabelFormatter(dataLabelSettings, formatString, realValue2, precision);
                valueFormatterOptions.formatSingleValues = dataLabelSettings.displayUnits > 0 ? false : true;
                return visuals.valueFormatter.create(valueFormatterOptions);
            };
            Gauge.prototype.appendTargetTextAlongArc = function (radius, height, width, margin) {
                var targetSettings = this.targetSettings;
                var target = targetSettings.target;
                var tRatio = this.getTargetRatio();
                var top = (radius + (height - radius) / 2 + margin.top);
                var flag = tRatio > 0.5;
                var padding = this.settings.labels.padding;
                var anchor = flag ? 'start' : 'end';
                var formatter = this.getFormatter(this.data.dataLabelsSettings, targetSettings.max);
                var maxRatio = Math.asin(Gauge.MinDistanceFromBottom / radius) / Math.PI;
                var finalRatio = tRatio < maxRatio || tRatio > (1 - maxRatio)
                    ? flag
                        ? 1 - maxRatio
                        : maxRatio
                    : tRatio;
                var targetX = (margin.left + width / 2) - ((radius + padding) * Math.cos(Math.PI * finalRatio));
                var targetY = top - ((radius + padding) * Math.sin(Math.PI * finalRatio));
                if (!this.targetText) {
                    this.targetText = this.mainGraphicsContext
                        .append('text')
                        .classed(Gauge.TargetText.class, true);
                }
                this.targetText
                    .attr({
                    'x': targetX,
                    'y': targetY,
                })
                    .style({
                    'text-anchor': anchor,
                    'display': this.showTargetLabel ? '' : 'none',
                    'font-size': this.style.labelText.fontSize
                })
                    .text(formatter.format(target));
                this.truncateTextIfNeeded(this.targetText, targetX, flag);
                this.targetText.call(visuals.tooltipUtils.tooltipUpdate, [formatter.format(target)]);
                if (!this.targetConnector) {
                    this.targetConnector = this.mainGraphicsContext
                        .append('line')
                        .classed(Gauge.TargetConnector.class, true);
                }
                // Hide the target connector if the text is going to align with the target line in the arc
                // It should only be shown if the target text is displaced (ex. when the target is very close to min/max)
                if (tRatio === finalRatio) {
                    this.targetConnector.style('display', 'none');
                }
                else {
                    this.targetConnector
                        .attr({
                        'x1': (margin.left + width / 2) - (radius * Math.cos(Math.PI * tRatio)),
                        'y1': top - (radius * Math.sin(Math.PI * tRatio)),
                        'x2': targetX,
                        'y2': targetY
                    })
                        .style({
                        'stroke-width': this.settings.targetLine.thickness,
                        'stroke': this.settings.targetLine.color,
                        'display': ''
                    });
                }
            };
            Gauge.prototype.arcTween = function (transition, arr) {
                transition.attrTween('d', function (d) {
                    var interpolate = d3.interpolate(d.endAngle, arr[0]);
                    return function (t) {
                        d.endAngle = interpolate(t);
                        return arr[1](d);
                    };
                });
            };
            Gauge.prototype.showMinMaxLabelsOnBottom = function () {
                // More vertical space, put labels on bottom
                if (this.currentViewport.height > this.currentViewport.width)
                    return true;
                // We want to show the start/end ticks on the bottom when there
                // is insufficient space for the left and right label text
                if (this.data && this.gaugeVisualProperties) {
                    var ticks = this.createTicks();
                    var visualWhitespace = (this.currentViewport.width - (this.gaugeVisualProperties.radius * 2)) / 2;
                    var maxLabelWidth = visualWhitespace - this.settings.labels.padding;
                    var textProperties = powerbi.TextMeasurementService.getMeasurementProperties($(this.svg.node()));
                    textProperties.fontSize = PixelConverter.fromPoint(this.data.dataLabelsSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
                    var width = void 0;
                    for (var _i = 0, _a = [ticks[0], ticks[ticks.length - 1]]; _i < _a.length; _i++) {
                        var tickValue = _a[_i];
                        textProperties.text = tickValue;
                        width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                        if (width > maxLabelWidth)
                            return true;
                    }
                }
                return false;
            };
            Gauge.prototype.setMargins = function () {
                if (this.gaugeSmallViewPortProperties) {
                    if (this.gaugeSmallViewPortProperties.smallGaugeMarginsOnSmallViewPort && (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible)) {
                        var margins = this.gaugeSmallViewPortProperties.GaugeMarginsOnSmallViewPort;
                        this.margin = { top: margins, bottom: margins, left: margins, right: margins };
                        return;
                    }
                }
                this.margin = {
                    top: Gauge.DefaultTopBottomMargin,
                    bottom: Gauge.DefaultTopBottomMargin,
                    left: Gauge.DefaultLeftRightMargin,
                    right: Gauge.DefaultLeftRightMargin
                };
                // If we're not showing side labels, reduce the margin so that the gauge has more room to display
                if (!this.showSideNumbersLabelText() || this.showMinMaxLabelsOnBottom()) {
                    var targetSettings = this.targetSettings;
                    if (this.showTargetLabel) {
                        // If we're showing the target label, only reduce the margin on the side that doesn't have a target label
                        var tRatio = (targetSettings.target - targetSettings.min) / (targetSettings.max - targetSettings.min);
                        if (tRatio > 0.5)
                            this.margin.left = Gauge.ReducedLeftRightMargin;
                        else
                            this.margin.right = Gauge.ReducedLeftRightMargin;
                    }
                    else {
                        // Otherwise, reduce both margins
                        this.margin.left = this.margin.right = Gauge.ReducedLeftRightMargin;
                    }
                }
                var fontSize = 0;
                if (this.data && this.data.dataLabelsSettings && this.data.dataLabelsSettings.fontSize && this.data.dataLabelsSettings.fontSize >= visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt) {
                    fontSize = PixelConverter.fromPointToPixel(this.data.dataLabelsSettings.fontSize - visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt);
                }
                if (fontSize !== 0) {
                    this.margin.bottom += fontSize;
                    this.margin.left += fontSize;
                    this.margin.right += fontSize;
                }
            };
            Gauge.prototype.showSideNumbersLabelText = function () {
                if (this.gaugeSmallViewPortProperties) {
                    if (this.gaugeSmallViewPortProperties.hideGaugeSideNumbersOnSmallViewPort) {
                        if (this.currentViewport.height < this.gaugeSmallViewPortProperties.MinHeightGaugeSideNumbersVisible) {
                            return false;
                        }
                    }
                }
                return true;
            };
            Gauge.MIN_VALUE = -Infinity;
            Gauge.MAX_VALUE = +Infinity;
            Gauge.MinDistanceFromBottom = 10;
            Gauge.MinWidthForTargetLabel = 150;
            Gauge.DefaultTopBottomMargin = 20;
            Gauge.DefaultLeftRightMargin = 45;
            Gauge.ReducedLeftRightMargin = 15;
            Gauge.DEFAULT_MAX = 1;
            Gauge.DEFAULT_MIN = 0;
            Gauge.VisualClassName = 'gauge';
            Gauge.DefaultStyleProperties = {
                transition: {
                    ease: 'bounce'
                },
                arcColors: {
                    background: '#e9e9e9',
                    foreground: '#00B8AA'
                },
                targetLine: {
                    show: true,
                    color: '#666666',
                    thickness: 2
                },
                labels: {
                    count: 2,
                    padding: 5,
                    fontSize: visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                },
                kpiBands: {
                    show: false,
                    separationRadians: Math.PI / 128,
                    thickness: 5
                },
            };
            Gauge.DefaultTargetSettings = {
                min: 0,
                max: 1,
                target: undefined
            };
            Gauge.DefaultDataPointSettings = {
                fillColor: Gauge.DefaultStyleProperties.arcColors.foreground,
                targetColor: Gauge.DefaultStyleProperties.targetLine.color
            };
            Gauge.InnerRadiusFactor = 0.7;
            Gauge.KpiBandDistanceFromMainArc = 2;
            Gauge.MainGaugeGroupClassName = 'mainGroup';
            Gauge.LabelText = createClassAndSelector('labelText');
            Gauge.TargetConnector = createClassAndSelector('targetConnector');
            Gauge.TargetText = createClassAndSelector('targetText');
            /** Note: Public for testability */
            Gauge.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            return Gauge;
        }());
        visuals.Gauge = Gauge;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Utility = jsCommon.Utility;
        var ImageVisual = (function () {
            function ImageVisual() {
                this.scalingType = visuals.imageScalingType.normal;
            }
            ImageVisual.prototype.init = function (options) {
                this.element = options.element;
            };
            ImageVisual.prototype.enumerateObjectInstances = function (options) {
                switch (options.objectName) {
                    case 'imageScaling':
                        return this.enumerateImageScaling();
                }
                return null;
            };
            ImageVisual.prototype.enumerateImageScaling = function () {
                return [{
                        selector: null,
                        objectName: 'imageScaling',
                        properties: {
                            imageScalingType: this.scalingType,
                        }
                    }];
            };
            ImageVisual.prototype.update = function (options) {
                var dataViews = options.dataViews;
                if (!dataViews || dataViews.length === 0)
                    return;
                var objects = dataViews[0].metadata.objects;
                if (!objects || !objects.general)
                    return;
                var div = this.imageBackgroundElement;
                if (!div) {
                    div = $("<div class='imageBackground' />");
                    this.imageBackgroundElement = div;
                    this.imageBackgroundElement.appendTo(this.element);
                }
                var viewport = options.viewport;
                div.css('height', viewport.height);
                if (objects.imageScaling)
                    this.scalingType = objects.imageScaling.imageScalingType.toString();
                else
                    this.scalingType = visuals.imageScalingType.normal;
                var imageUrl = objects.general.imageUrl;
                if (Utility.isValidImageDataUrl(imageUrl))
                    div.css("backgroundImage", "url(" + imageUrl + ")");
                if (this.scalingType === visuals.imageScalingType.fit)
                    div.css("background-size", "100% 100%");
                else if (this.scalingType === visuals.imageScalingType.fill)
                    div.css("background-size", "cover");
                else
                    div.css("background-size", "contain");
            };
            return ImageVisual;
        }());
        visuals.ImageVisual = ImageVisual;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var KPIStatusWithHistory = (function () {
            function KPIStatusWithHistory() {
            }
            KPIStatusWithHistory.prototype.init = function (options) {
                KPIStatusWithHistory.getLocalizedString = options.host.getLocalizedString;
                this.rootElement = d3.select(options.element.get(0)).append('div').attr('text-align', 'center').classed('kpiVisual', true);
                this.svg = this.rootElement.append('svg');
                var mainGroupElement = this.mainGroupElement = this.svg.append('g');
                this.areaFill = mainGroupElement.append("path");
                this.textContainer = this.rootElement.append("div").classed('textContainer', true);
                this.indicatorTextContainer = this.textContainer.append("div").classed('indicatorText', true);
                this.absoluteGoalDistanceText = this.textContainer.append("div").classed('goalText', true);
                this.kpiActualText = this.indicatorTextContainer.append("div").attr('id', 'indicatorText');
                this.initIcons();
                this.host = options.host;
            };
            KPIStatusWithHistory.prototype.update = function (options) {
                if (!options.dataViews || !options.dataViews[0])
                    return;
                var dataView = this.dataView = options.dataViews[0];
                var viewport = options.viewport;
                // We must have at least one measure
                if ((!dataView.categorical || !dataView.categorical.values || dataView.categorical.values.length < 1) &&
                    (!dataView.categorical || !dataView.categorical.categories || dataView.categorical.categories.length < 1)) {
                    this.svg.attr("visibility", "hidden");
                    this.textContainer.attr("style", "display:none");
                    return;
                }
                this.svg.attr("visibility", "visible");
                var kpiViewModel = KPIStatusWithHistory.converter(dataView, viewport, KPIStatusWithHistory.getProp_KPIDirection(dataView));
                this.render(kpiViewModel, viewport);
            };
            KPIStatusWithHistory.prototype.initIcons = function () {
                this.successMarkIcon = this.indicatorTextContainer.append("div").classed('powervisuals-glyph checkmark kpi-visual-green', true);
                this.betweenIcon = this.indicatorTextContainer.append('div').classed('powervisuals-glyph circle-small kpi-visual-yellow', true);
                this.exclamationMarkIcon = this.indicatorTextContainer.append("div").classed('powervisuals-glyph exclamation kpi-visual-red', true);
                this.successMarkIcon.attr('style', 'display:none');
                this.betweenIcon.attr('style', 'display:none');
                this.exclamationMarkIcon.attr('style', 'display:none');
            };
            KPIStatusWithHistory.prototype.render = function (kpiViewModel, viewport) {
                this.setShowDataMissingWarning(!(kpiViewModel.indicatorExists && kpiViewModel.trendExists));
                if (kpiViewModel.dataPoints.length === 0 || !kpiViewModel.indicatorExists || !kpiViewModel.trendExists) {
                    this.areaFill.attr("visibility", "hidden");
                    this.svg.attr("visibility", "hidden");
                    this.textContainer.attr("style", "display:none");
                    return;
                }
                this.svg.attr({
                    'height': viewport.height,
                    'width': viewport.width,
                });
                var status = KPIStatusWithHistory.status.NOGOAL;
                if (kpiViewModel.targetExists && kpiViewModel.indicatorExists && kpiViewModel.trendExists) {
                    status = GetStatus(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType);
                }
                var actualText = kpiViewModel.formattedValue;
                var calculatedHeight = KPIStatusWithHistory.indicatorTextSizeInPx;
                this.textContainer
                    .attr('style', "width:" + viewport.width + "px;" +
                    "top:" + ((viewport.height - calculatedHeight) / 2) + "px");
                this.kpiActualText
                    .classed(KPIStatusWithHistory.allColorClasses, false)
                    .classed(GetTextColorClassByStatus(status), true)
                    .attr("text-anchor", "middle")
                    .text(actualText);
                var icon = null;
                switch (status) {
                    case KPIStatusWithHistory.status.INCREASE:
                        icon = this.successMarkIcon;
                        this.exclamationMarkIcon.attr("style", "display:none");
                        this.betweenIcon.attr("style", "display:none");
                        break;
                    case KPIStatusWithHistory.status.IN_BETWEEN:
                        icon = this.betweenIcon;
                        this.exclamationMarkIcon.attr("style", "display:none");
                        this.successMarkIcon.attr("style", "display:none");
                        break;
                    case KPIStatusWithHistory.status.DROP:
                        icon = this.exclamationMarkIcon;
                        this.successMarkIcon.attr("style", "display:none");
                        this.betweenIcon.attr("style", "display:none");
                        break;
                    default:
                        this.exclamationMarkIcon.attr("style", "display:none");
                        this.successMarkIcon.attr("style", "display:none");
                        this.betweenIcon.attr("style", "display:none");
                }
                if (icon) {
                    icon.attr('style', 'font-size:12px');
                }
                var shownGoalString = kpiViewModel.showGoal ? kpiViewModel.formattedGoalString + " " : "";
                var shownDistanceFromGoalString = kpiViewModel.showDistanceFromGoal ? getDistanceFromGoalInPercentageString(kpiViewModel.actual, kpiViewModel.goals, kpiViewModel.directionType) : "";
                this.absoluteGoalDistanceText
                    .attr("text-anchor", "middle")
                    .text(shownGoalString + shownDistanceFromGoalString);
                if (kpiViewModel.showTrendLine && kpiViewModel.historyExists) {
                    var area = d3.svg.area()
                        .x(function (d) { return d.x; })
                        .y0(viewport.height)
                        .y1(function (d) { return d.y; });
                    this.areaFill
                        .classed(KPIStatusWithHistory.allColorClasses, false)
                        .classed(GetGraphColorClassByStatus(status), true)
                        .attr("d", area(kpiViewModel.dataPoints))
                        .attr("stroke", "none")
                        .attr("visibility", "visible")
                        .attr('fill-opacity', 0.2);
                }
                else {
                    this.areaFill.attr("visibility", "hidden");
                }
            };
            KPIStatusWithHistory.prototype.setShowDataMissingWarning = function (show) {
                this.host.setWarnings(show ? [new visuals.VisualKPIDataMissingWarning()] : []);
            };
            KPIStatusWithHistory.getDefaultFormatSettings = function () {
                return {
                    labelSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, visuals.Card.DefaultStyle.value.color),
                    textSize: 27,
                    wordWrap: false
                };
            };
            KPIStatusWithHistory.getMetaDataColumn = function (dataView) {
                if (dataView && dataView.metadata && dataView.metadata.columns) {
                    for (var _i = 0, _a = dataView.metadata.columns; _i < _a.length; _i++) {
                        var column = _a[_i];
                        if (column.isMeasure) {
                            return column;
                        }
                    }
                }
            };
            KPIStatusWithHistory.getFormatString = function (column) {
                debug.assertAnyValue(column, 'column');
                return visuals.valueFormatter.getFormatString(column, visuals.AnimatedText.formatStringProp);
            };
            KPIStatusWithHistory.getProp_Show_KPIGoal = function (dataView) {
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIGoal, true);
                }
                return true;
            };
            KPIStatusWithHistory.getProp_Show_KPITrendLine = function (dataView) {
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPITrendLine, true);
                }
                return true;
            };
            KPIStatusWithHistory.getProp_Show_KPIDistance = function (dataView) {
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.showKPIDistance, true);
                }
                return true;
            };
            KPIStatusWithHistory.getProp_KPIDirection = function (dataView) {
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.directionTypeStringProp, visuals.kpiDirection.positive);
                }
                return visuals.kpiDirection.positive;
            };
            KPIStatusWithHistory.getProp_Indicator_DisplayUnits = function (dataView) {
                KPIStatusWithHistory.initDefaultLabelSettings();
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorDisplayUnitsProp, KPIStatusWithHistory.defaultLabelSettings.displayUnits);
                }
                return KPIStatusWithHistory.defaultLabelSettings.displayUnits;
            };
            KPIStatusWithHistory.getProp_Indicator_Precision = function (dataView) {
                KPIStatusWithHistory.initDefaultLabelSettings();
                if (dataView && dataView.metadata) {
                    return powerbi.DataViewObjects.getValue(dataView.metadata.objects, KPIStatusWithHistory.indicatorPrecisionProp, KPIStatusWithHistory.defaultLabelSettings.precision);
                }
                return KPIStatusWithHistory.defaultLabelSettings.precision;
            };
            KPIStatusWithHistory.initDefaultLabelSettings = function () {
                if (!KPIStatusWithHistory.defaultCardFormatSetting) {
                    KPIStatusWithHistory.defaultCardFormatSetting = KPIStatusWithHistory.getDefaultFormatSettings();
                    KPIStatusWithHistory.defaultLabelSettings = KPIStatusWithHistory.defaultCardFormatSetting.labelSettings;
                }
            };
            KPIStatusWithHistory.getFormattedValue = function (metaDataColumn, theValue, precision, displayUnits, displayUnitSystemType) {
                if (displayUnitSystemType === void 0) { displayUnitSystemType = powerbi.DisplayUnitSystemType.WholeUnits; }
                var isDefaultDisplayUnit = displayUnits === 0;
                var formatter = visuals.valueFormatter.create({
                    format: KPIStatusWithHistory.getFormatString(metaDataColumn),
                    value: displayUnits,
                    precision: precision,
                    displayUnitSystemType: displayUnitSystemType,
                    formatSingleValues: isDefaultDisplayUnit ? true : false,
                    allowFormatBeautification: true,
                    columnType: metaDataColumn ? metaDataColumn.type : undefined
                });
                return formatter.format(theValue);
            };
            KPIStatusWithHistory.getFormattedGoalString = function (metaDataColumn, goals, precision, displayUnits) {
                if (!goals || goals.length === 0) {
                    return "";
                }
                var goalsString = KPIStatusWithHistory.getLocalizedString('Visual_KPI_Goal_Title') + ": " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[0], precision, displayUnits);
                if (goals.length === 2) {
                    goalsString += ", " + KPIStatusWithHistory.getFormattedValue(metaDataColumn, goals[1], precision, displayUnits);
                }
                return goalsString;
            };
            KPIStatusWithHistory.converter = function (dataView, viewPort, directionType) {
                var dataPoints = [];
                var catDv = dataView.categorical;
                var metaDataColumn = KPIStatusWithHistory.getMetaDataColumn(dataView);
                var formattedGoalString = "";
                var formattedValue = "";
                var targetExists = false;
                var indicatorExists = false;
                var trendExists = false;
                var historyExists = true;
                if (!dataView.categorical.categories) {
                    historyExists = false;
                }
                var values = catDv.values;
                var columns = dataView.metadata.columns;
                for (var _i = 0, columns_1 = columns; _i < columns_1.length; _i++) {
                    var column = columns_1[_i];
                    if (DataRoleHelper.hasRole(column, 'Indicator')) {
                        indicatorExists = true;
                    }
                    if (DataRoleHelper.hasRole(column, 'TrendLine')) {
                        trendExists = true;
                    }
                }
                if (!indicatorExists || !trendExists || !values || values.length === 0 || !values[0].values || !dataView.categorical.values) {
                    return {
                        dataPoints: dataPoints,
                        directionType: directionType,
                        actual: 0,
                        goals: [],
                        formattedGoalString: formattedGoalString,
                        targetExists: targetExists,
                        historyExists: historyExists,
                        indicatorExists: indicatorExists,
                        trendExists: trendExists,
                        formattedValue: formattedValue,
                        showGoal: false,
                        showDistanceFromGoal: false,
                        showTrendLine: false
                    };
                }
                var category, categoryValues;
                if (historyExists) {
                    category = catDv.categories[0]; // This only works if we have a category axis
                    categoryValues = category.values;
                }
                var historyActualData = [];
                var historyGoalData = [];
                var indicatorColumns = KPIStatusWithHistory.getColumnsByRole(values, "Indicator");
                var goalColumns = KPIStatusWithHistory.getColumnsByRole(values, "Goal");
                if (goalColumns.length > 0) {
                    targetExists = true;
                }
                var actualValue;
                for (var i = 0, len = values[0].values.length; i < len; i++) {
                    actualValue = indicatorColumns[0].values[i];
                    var goals_1 = [];
                    for (var goalCnt = 0; goalCnt < goalColumns.length; goalCnt++) {
                        goals_1.push(goalColumns[goalCnt].values[i]);
                    }
                    historyGoalData.push(goals_1);
                    historyActualData.push(actualValue);
                }
                var maxActualData = Math.max.apply(Math, historyActualData);
                var minActualData = Math.min.apply(Math, historyActualData);
                var areaMaxHight = viewPort.height * KPIStatusWithHistory.trendAreaFilePercentage;
                var precision = KPIStatusWithHistory.getProp_Indicator_Precision(dataView);
                var displayUnits = KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView);
                for (var i = 0; i < historyActualData.length; i++) {
                    var yPos = areaMaxHight * (historyActualData[i] - minActualData) / (maxActualData - minActualData);
                    var selectorId = null;
                    if (historyExists) {
                        selectorId = visuals.SelectionId.createWithId(category.identity[i]).getSelector();
                    }
                    dataPoints.push({
                        x: i * viewPort.width / (historyActualData.length - 1),
                        y: viewPort.height - yPos,
                        actual: historyActualData[i],
                        goals: historyGoalData[i],
                    });
                }
                var actual, goals;
                if (dataPoints.length > 0) {
                    actual = dataPoints[dataPoints.length - 1].actual;
                    goals = dataPoints[dataPoints.length - 1].goals;
                }
                if (dataPoints.length === 1) {
                    historyExists = false;
                }
                formattedValue = KPIStatusWithHistory.getFormattedValue(metaDataColumn, actual, precision, displayUnits, powerbi.DisplayUnitSystemType.DataLabels);
                formattedGoalString = KPIStatusWithHistory.getFormattedGoalString(metaDataColumn, goals, precision, displayUnits);
                var showGoal = KPIStatusWithHistory.getProp_Show_KPIGoal(dataView);
                var showDistanceFromGoal = KPIStatusWithHistory.getProp_Show_KPIDistance(dataView);
                var showTrendLine = KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView);
                return {
                    dataPoints: dataPoints,
                    directionType: directionType,
                    actual: actual,
                    goals: goals,
                    formattedGoalString: formattedGoalString,
                    targetExists: targetExists,
                    historyExists: historyExists,
                    indicatorExists: indicatorExists,
                    trendExists: trendExists,
                    formattedValue: formattedValue,
                    showGoal: showGoal,
                    showDistanceFromGoal: showDistanceFromGoal,
                    showTrendLine: showTrendLine
                };
            };
            KPIStatusWithHistory.getColumnsByRole = function (values, roleString) {
                var retval = [];
                for (var i = 0; i < values.length; i++) {
                    if (DataRoleHelper.hasRole(values[i].source, roleString)) {
                        retval.push(values[i]);
                    }
                }
                return retval;
            };
            KPIStatusWithHistory.prototype.enumerateObjectInstances = function (options) {
                var instances = [];
                var dataView = this.dataView;
                switch (options.objectName) {
                    case 'indicator':
                        instances.push({
                            selector: null,
                            objectName: 'indicator',
                            properties: {
                                indicatorDisplayUnits: KPIStatusWithHistory.getProp_Indicator_DisplayUnits(dataView),
                                indicatorPrecision: KPIStatusWithHistory.getProp_Indicator_Precision(dataView)
                            }
                        });
                    case 'trendline':
                        instances.push({
                            selector: null,
                            objectName: 'trendline',
                            properties: {
                                show: KPIStatusWithHistory.getProp_Show_KPITrendLine(dataView)
                            }
                        });
                    case 'goals':
                        instances.push({
                            selector: null,
                            objectName: 'goals',
                            properties: {
                                showGoal: KPIStatusWithHistory.getProp_Show_KPIGoal(dataView),
                                showDistance: KPIStatusWithHistory.getProp_Show_KPIDistance(dataView)
                            }
                        });
                    case 'status':
                        instances.push({
                            selector: null,
                            objectName: 'status',
                            properties: {
                                direction: KPIStatusWithHistory.getProp_KPIDirection(dataView)
                            }
                        });
                }
                return instances;
            };
            KPIStatusWithHistory.prototype.destroy = function () {
                this.svg = null;
            };
            KPIStatusWithHistory.directionTypeStringProp = { objectName: 'status', propertyName: 'direction' };
            KPIStatusWithHistory.showKPIGoal = { objectName: 'goals', propertyName: 'showGoal' };
            KPIStatusWithHistory.showKPIDistance = { objectName: 'goals', propertyName: 'showDistance' };
            KPIStatusWithHistory.showKPITrendLine = { objectName: 'trendline', propertyName: 'show' };
            KPIStatusWithHistory.indicatorDisplayUnitsProp = { objectName: 'indicator', propertyName: 'indicatorDisplayUnits' };
            KPIStatusWithHistory.indicatorPrecisionProp = { objectName: 'indicator', propertyName: 'indicatorPrecision' };
            KPIStatusWithHistory.status = { INCREASE: "increase", DROP: "drop", IN_BETWEEN: "in-between", NOGOAL: "no-goal" };
            KPIStatusWithHistory.statusBandingType = { Below: "BELOW", Above: "ABOVE" };
            KPIStatusWithHistory.actualTextConsts = { VERTICAL_OFFSET_FROM_HALF_HEIGHT: 20, FONT_WIDTH_FACTOR: 14, RIGHT_MARGIN: 10 };
            KPIStatusWithHistory.kpiRedClass = 'kpi-visual-red';
            KPIStatusWithHistory.kpiYellowClass = 'kpi-visual-yellow';
            KPIStatusWithHistory.kpiGreenClass = 'kpi-visual-green';
            KPIStatusWithHistory.kpiTextGreyClass = 'kpi-visual-text-grey';
            KPIStatusWithHistory.kpiGraphGreyClass = 'kpi-visual-graph-grey';
            KPIStatusWithHistory.allColorClasses = KPIStatusWithHistory.kpiRedClass + ' ' + KPIStatusWithHistory.kpiYellowClass + ' ' + KPIStatusWithHistory.kpiGreenClass + ' ' + KPIStatusWithHistory.kpiTextGreyClass + ' ' + KPIStatusWithHistory.kpiGraphGreyClass;
            KPIStatusWithHistory.trendAreaFilePercentage = 1;
            KPIStatusWithHistory.estimatedIconHeightInPx = 9;
            KPIStatusWithHistory.indicatorTextSizeInPx = 60;
            return KPIStatusWithHistory;
        }());
        visuals.KPIStatusWithHistory = KPIStatusWithHistory;
        function GetStatus(actual, goals, directionType) {
            if (!goals || goals.length === 0) {
                return KPIStatusWithHistory.status.NOGOAL;
            }
            var maxGoal, minGoal;
            if (goals.length === 2) {
                maxGoal = Math.max.apply(Math, goals);
                minGoal = Math.min.apply(Math, goals);
                if (actual >= minGoal && actual <= maxGoal) {
                    return KPIStatusWithHistory.status.IN_BETWEEN;
                }
            }
            else {
                maxGoal = goals[0];
                minGoal = goals[0];
            }
            switch (directionType) {
                case visuals.kpiDirection.positive:
                    if (actual < minGoal) {
                        return KPIStatusWithHistory.status.DROP;
                    }
                    break;
                case visuals.kpiDirection.negative:
                    if (actual > maxGoal) {
                        return KPIStatusWithHistory.status.DROP;
                    }
                    break;
                default:
                    break;
            }
            return KPIStatusWithHistory.status.INCREASE;
        }
        function getDistanceFromGoalInPercentageString(actual, goals, directionType) {
            if (!goals || goals.length !== 1 || goals[0] === 0) {
                return "";
            }
            var sign = "+";
            var distance;
            var goal = goals[0];
            distance = Math.abs(actual - goal);
            switch (directionType) {
                case visuals.kpiDirection.positive:
                    if (actual < goal) {
                        sign = "-";
                    }
                    break;
                case visuals.kpiDirection.negative:
                    if (actual > goal) {
                        sign = "-";
                    }
                    break;
            }
            var percent = Number((100 * distance / goal).toFixed(2));
            return "(" + sign + percent + "%)";
        }
        function GetTextColorClassByStatus(status) {
            switch (status) {
                case KPIStatusWithHistory.status.NOGOAL:
                    return KPIStatusWithHistory.kpiTextGreyClass;
                case KPIStatusWithHistory.status.INCREASE:
                    return KPIStatusWithHistory.kpiGreenClass;
                case KPIStatusWithHistory.status.IN_BETWEEN:
                    return KPIStatusWithHistory.kpiYellowClass;
                case KPIStatusWithHistory.status.DROP:
                    return KPIStatusWithHistory.kpiRedClass;
            }
        }
        function GetGraphColorClassByStatus(status) {
            switch (status) {
                case KPIStatusWithHistory.status.NOGOAL:
                    return KPIStatusWithHistory.kpiGraphGreyClass;
                case KPIStatusWithHistory.status.INCREASE:
                    return KPIStatusWithHistory.kpiGreenClass;
                case KPIStatusWithHistory.status.IN_BETWEEN:
                    return KPIStatusWithHistory.kpiYellowClass;
                case KPIStatusWithHistory.status.DROP:
                    return KPIStatusWithHistory.kpiRedClass;
            }
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var EnumExtensions = jsCommon.EnumExtensions;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        ;
        /**
         * Renders a data series as a line visual.
         */
        var LineChart = (function () {
            function LineChart(options) {
                var _this = this;
                this.deferDragMoveOperation = jsCommon.DeferUtility.deferUntilNextFrame(function () {
                    if (_this.lastDragMoveXPosition) {
                        var index = _this.findIndex(_this.lastDragMoveXPosition - _this.margin.left);
                        _this.selectColumn(index);
                        _this.lastDragMoveXPosition = undefined;
                    }
                });
                this.isScrollable = options.isScrollable ? options.isScrollable : false;
                this.tooltipsEnabled = options.tooltipsEnabled;
                this.lineType = options.chartType ? options.chartType : 1 /* default */;
                this.interactivityService = options.interactivityService;
                this.animator = options.animator;
                this.lineChartLabelDensityEnabled = options.lineChartLabelDensityEnabled;
                this.lineClassAndSelector = LineChart.LineClassSelector;
            }
            LineChart.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return;
                dataViewMapping.categorical.dataVolume = 4;
                if (visuals.CartesianChart.detectScalarMapping(dataViewMapping)) {
                    var dataViewCategories = dataViewMapping.categorical.categories;
                    dataViewCategories.dataReductionAlgorithm = { sample: {} };
                }
            };
            LineChart.getSortableRoles = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.categorical || !dataViewMapping.categorical.categories)
                    return null;
                var dataViewCategories = dataViewMapping.categorical.categories;
                var categoryItems = dataViewCategories.for.in.items;
                if (!_.isEmpty(categoryItems)) {
                    var categoryType = categoryItems[0].type;
                    var objects = void 0;
                    if (dataViewMapping.metadata)
                        objects = dataViewMapping.metadata.objects;
                    //TODO: line chart should be sortable by X if it has scalar axis
                    // But currently it doesn't support this. Always return 'category'
                    // once it is supported.
                    if (!visuals.CartesianChart.getIsScalar(objects, visuals.lineChartProps.categoryAxis.axisType, categoryType))
                        return ['Category', 'Y'];
                }
                return null;
            };
            LineChart.converter = function (dataView, blankCategoryValue, colors, isScalar, interactivityService, shouldCalculateStacked, isComboChart, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var categorical = dataView.categorical;
                var category = categorical.categories && categorical.categories.length > 0
                    ? categorical.categories[0]
                    : {
                        source: undefined,
                        values: [blankCategoryValue],
                        identity: undefined,
                    };
                var xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                isScalar = visuals.CartesianHelper.isScalar(isScalar, xAxisCardProperties);
                categorical = visuals.ColumnUtil.applyUserMinMax(isScalar, categorical, xAxisCardProperties);
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var categoryType = visuals.AxisHelper.getCategoryValueType(category.source, isScalar);
                var isDateTime = visuals.AxisHelper.isDateTime(categoryType);
                var categoryValues = category.values;
                var categoryData = [];
                var series = [];
                var seriesLen = categorical.values ? categorical.values.length : 0;
                var hasDynamicSeries = !!(categorical.values && categorical.values.source);
                var values = categorical.values;
                var defaultLabelSettings = visuals.dataLabelUtils.getDefaultLineChartLabelSettings(isComboChart);
                var defaultSeriesColor;
                if (dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    // If the line layer is in a combo chart, the "Default Column Color" slice's value (lineChartProps.dataPoint.defaultColor) will not affect the line series as well
                    defaultSeriesColor = isComboChart ? undefined : powerbi.DataViewObjects.getFillColor(objects, visuals.lineChartProps.dataPoint.defaultColor);
                    var labelsObj = objects['labels'];
                    visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelsObj, defaultLabelSettings);
                }
                var colorHelper = new visuals.ColorHelper(colors, visuals.lineChartProps.dataPoint.fill, defaultSeriesColor);
                var grouped;
                if (dataView.categorical.values)
                    grouped = dataView.categorical.values.grouped();
                var stackedValues;
                if (shouldCalculateStacked) {
                    //initialize array with zeros
                    stackedValues = categorical.values && categorical.values.length > 0 ? _.times(categorical.values[0].values.length, function () { return 0; }) : [];
                }
                for (var seriesIndex = 0; seriesIndex < seriesLen; seriesIndex++) {
                    var column = categorical.values[seriesIndex];
                    var valuesMetadata = column.source;
                    var dataPoints = [];
                    var groupedIdentity = grouped[seriesIndex];
                    var identity = hasDynamicSeries && groupedIdentity
                        ? visuals.SelectionId.createWithIdAndMeasure(groupedIdentity.identity, column.source.queryName)
                        : visuals.SelectionId.createWithMeasure(column.source.queryName);
                    var key = identity.getKey();
                    var color = this.getColor(colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity);
                    var seriesLabelSettings = void 0;
                    if (!hasDynamicSeries) {
                        var labelsSeriesGroup = grouped && grouped.length > 0 && grouped[0].values ? grouped[0].values[seriesIndex] : null;
                        var labelObjects = (labelsSeriesGroup && labelsSeriesGroup.source && labelsSeriesGroup.source.objects) ? labelsSeriesGroup.source.objects['labels'] : null;
                        if (labelObjects) {
                            seriesLabelSettings = powerbi.Prototype.inherit(defaultLabelSettings);
                            visuals.dataLabelUtils.updateLineChartLabelSettingsFromLabelsObject(labelObjects, seriesLabelSettings);
                        }
                    }
                    var dataPointLabelSettings = (seriesLabelSettings) ? seriesLabelSettings : defaultLabelSettings;
                    var useHighlightValues = column.highlights && column.highlights.length > 0;
                    // NOTE: line capabilities don't allow highlights, but comboChart does - so only use highlight values if we are in "combo" mode
                    var valuesArray = useHighlightValues ? column.highlights : column.values;
                    for (var categoryIndex = 0, len = valuesArray.length; categoryIndex < len; categoryIndex++) {
                        var categoryValue = categoryValues[categoryIndex];
                        var value = visuals.AxisHelper.normalizeNonFiniteNumber(valuesArray[categoryIndex]);
                        // When Scalar, skip null categories and null values so we draw connected lines and never draw isolated dots.
                        if (isScalar && (categoryValue == null || value == null))
                            continue;
                        // ignore variant measures
                        if (isDateTime && categoryValue != null && !(categoryValue instanceof Date))
                            continue;
                        var categorical_1 = dataView.categorical;
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical_1, categoryValue, value, null, null, seriesIndex);
                        }
                        var categoryKey = category && !_.isEmpty(category.identity) && category.identity[categoryIndex] ? category.identity[categoryIndex].key : categoryIndex;
                        var dataPoint = {
                            categoryValue: isDateTime && categoryValue ? categoryValue.getTime() : categoryValue,
                            value: value,
                            categoryIndex: categoryIndex,
                            seriesIndex: seriesIndex,
                            tooltipInfo: tooltipInfo,
                            selected: false,
                            identity: identity,
                            key: JSON.stringify({ series: key, category: categoryKey }),
                            labelFill: dataPointLabelSettings.labelColor,
                            labelFormatString: valuesMetadata.format,
                            labelSettings: dataPointLabelSettings
                        };
                        if (shouldCalculateStacked) {
                            stackedValues[categoryIndex] += value;
                            dataPoint.stackedValue = stackedValues[categoryIndex];
                        }
                        if (category.objects && category.objects[categoryIndex]) {
                            dataPoint['pointColor'] = powerbi.DataViewObjects.getFillColor(category.objects[categoryIndex], visuals.lineChartProps.dataPoint.fill);
                        }
                        dataPoints.push(dataPoint);
                        if (!categoryData[categoryIndex]) {
                            categoryData[categoryIndex] = dataPoint;
                        }
                    }
                    if (interactivityService) {
                        interactivityService.applySelectionStateToData(dataPoints);
                    }
                    if (dataPoints.length > 0) {
                        series.push({
                            displayName: valuesMetadata.displayName,
                            key: key,
                            lineIndex: seriesIndex,
                            color: color,
                            xCol: category.source,
                            yCol: column.source,
                            data: dataPoints,
                            identity: identity,
                            selected: false,
                            labelSettings: seriesLabelSettings,
                        });
                    }
                }
                xAxisCardProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                var valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
                // Convert to DataViewMetadataColumn
                var valuesMetadataArray = [];
                if (values) {
                    for (var i = 0; i < values.length; i++) {
                        if (values[i] && values[i].source && values[i].source.displayName) {
                            valuesMetadataArray.push({ displayName: values[i].source.displayName });
                        }
                    }
                }
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisCardProperties, valueAxisProperties, category.source, valuesMetadataArray);
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(series);
                }
                return {
                    series: series,
                    isScalar: isScalar,
                    dataLabelsSettings: defaultLabelSettings,
                    axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
                    hasDynamicSeries: hasDynamicSeries,
                    categoryMetadata: category.source,
                    categories: categoryValues,
                    categoryData: categoryData,
                };
            };
            LineChart.getInteractiveLineChartDomElement = function (element) {
                return element.children("svg").get(0);
            };
            LineChart.getColor = function (colorHelper, hasDynamicSeries, values, grouped, seriesIndex, groupedIdentity) {
                var objects;
                if (hasDynamicSeries) {
                    if (grouped && grouped[seriesIndex])
                        objects = grouped[seriesIndex].objects;
                }
                else if (values[seriesIndex]) {
                    objects = values[seriesIndex].source.objects;
                }
                return hasDynamicSeries && groupedIdentity
                    ? colorHelper.getColorForSeriesValue(objects, values.identityFields, groupedIdentity.name)
                    : colorHelper.getColorForMeasure(objects, values[seriesIndex].source.queryName);
            };
            LineChart.createStackedValueDomain = function (data) {
                debug.assertValue(data, 'data');
                if (data.length === 0)
                    return null;
                var minY = d3.min(data, function (kv) { return d3.min(kv.data, function (d) { return d.stackedValue; }); });
                var maxY = d3.max(data, function (kv) { return d3.max(kv.data, function (d) { return d.stackedValue; }); });
                return [minY, maxY];
            };
            LineChart.prototype.init = function (options) {
                var _this = this;
                this.options = options;
                this.element = options.element;
                this.cartesainSVG = options.svg;
                this.host = options.host;
                this.currentViewport = options.viewport;
                this.colors = options.style.colorPalette.dataColors;
                this.isInteractiveChart = options.interactivity && options.interactivity.isInteractiveLegend;
                this.cartesianVisualHost = options.cartesianHost;
                var chartType = options.chartType;
                this.isComboChart = chartType === 10 /* ComboChart */ || chartType === 13 /* LineClusteredColumnCombo */ || chartType === 14 /* LineStackedColumnCombo */;
                var svg = options.svg;
                svg.classed(LineChart.ClassName, true);
                var graphicsContextParent = this.mainGraphicsSVG = svg.append('svg')
                    .classed('lineChartSVG', true);
                if (!this.isComboChart && !this.isInteractiveChart) {
                    this.overlayRect = graphicsContextParent
                        .append(LineChart.RectOverlayName)
                        .style("opacity", visuals.SVGUtil.AlmostZero);
                }
                this.mainGraphicsContext = graphicsContextParent
                    .append('g')
                    .classed(LineChart.MainGraphicsContextClassName, true);
                this.hoverLineContext = svg.append('g')
                    .classed('hover-line', true);
                this.hoverLineContext.append(LineChart.LineElementName)
                    .attr("x1", 0).attr("x2", 0)
                    .attr("y1", 0).attr("y2", 0);
                var hoverLine = this.hoverLine = this.hoverLineContext.select(LineChart.LineElementName);
                if (this.isInteractiveChart) {
                    hoverLine.classed('interactive', true);
                }
                hoverLine.style('opacity', visuals.SVGUtil.AlmostZero);
                // define circles object - which will hold the handle circles.
                // this object will be populated on render() function, with number of circles which matches the nubmer of lines.
                this.selectionCircles = [];
                this.xAxisProperties = {
                    axis: null,
                    scale: null,
                    isScalar: null,
                    axisType: null,
                    formatter: null,
                    graphicsContext: null,
                    values: null,
                    axisLabel: null,
                    isCategoryAxis: true
                };
                if (this.isInteractiveChart) {
                    var rootSvg_1 = LineChart.getInteractiveLineChartDomElement(this.element);
                    var dragMove = function () {
                        _this.lastDragMoveXPosition = d3.mouse(rootSvg_1)[0];
                        _this.deferDragMoveOperation();
                    };
                    // assign drag and onClick events
                    var drag = d3.behavior.drag()
                        .origin(Object)
                        .on("drag", dragMove);
                    d3.select(rootSvg_1)
                        .style('touch-action', 'none')
                        .call(drag)
                        .on('click', dragMove);
                }
                // Internet Explorer and Edge use the stroke edge, not the path edge for the mouse coordinate's origin.
                //   We need to adjust mouse events on the interactivity lines to account for this.
                this.shouldAdjustMouseCoordsOnPathsForStroke = !jsCommon.BrowserUtils.isChrome();
            };
            LineChart.prototype.setData = function (dataViews) {
                this.data = {
                    series: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLineChartLabelSettings(this.isComboChart),
                    axesLabels: { x: null, y: null },
                    hasDynamicSeries: false,
                    categories: [],
                    categoryMetadata: undefined,
                    categoryData: [],
                };
                if (dataViews.length > 0) {
                    var dataView = dataViews[0];
                    if (dataView) {
                        if (dataView.categorical) {
                            var dataViewCat = this.dataViewCat = dataView.categorical;
                            var dvCategories = dataViewCat.categories;
                            var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                            if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                                categoryType = dvCategories[0].source.type;
                            var convertedData = LineChart.converter(dataView, visuals.valueFormatter.format(null), this.cartesianVisualHost.getSharedColors(), visuals.CartesianChart.getIsScalar(dataView.metadata ? dataView.metadata.objects : null, visuals.lineChartProps.categoryAxis.axisType, categoryType), this.interactivityService, EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */), this.isComboChart);
                            this.data = convertedData;
                        }
                    }
                }
            };
            LineChart.prototype.calculateLegend = function () {
                return this.createLegendDataPoints(0); // start with index 0
            };
            LineChart.prototype.hasLegend = function () {
                return this.data && (this.data.hasDynamicSeries || (this.data.series && this.data.series.length > 1));
            };
            LineChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var catgSize = endIndex - startIndex;
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                data.series = LineChart.sliceSeries(data.series, catgSize, startIndex);
                data.categories = data.categories.slice(startIndex, endIndex);
                return data;
            };
            LineChart.prototype.calculateAxesProperties = function (options) {
                var _this = this;
                var data = this.data;
                var viewport = options.viewport;
                var margin = options.margin;
                this.currentViewport = viewport;
                this.margin = margin;
                var origCatgSize = data.series && data.series.length > 0 ? data.series[0].data.length : 0;
                var categoryWidth = visuals.CartesianChart.MinOrdinalRectThickness;
                var isScalar = this.data.isScalar;
                var trimOrdinalDataOnOverflow = options.trimOrdinalDataOnOverflow;
                var preferredPlotArea = this.getPreferredPlotArea(isScalar, origCatgSize, categoryWidth);
                this.clippedData = undefined;
                if (data && !isScalar && !this.isScrollable && trimOrdinalDataOnOverflow) {
                    // trim data that doesn't fit on dashboard
                    var categoryCount = this.getCategoryCount(origCatgSize);
                    var catgSize = Math.min(origCatgSize, categoryCount);
                    if (catgSize !== origCatgSize) {
                        data = this.clippedData = powerbi.Prototype.inherit(data);
                        this.clippedData.series = LineChart.sliceSeries(data.series, catgSize);
                    }
                }
                var xMetaDataColumn;
                var yMetaDataColumn;
                if (data.series && data.series.length > 0) {
                    xMetaDataColumn = data.series[0].xCol;
                    yMetaDataColumn = data.series[0].yCol;
                }
                var valueDomain = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */) ? LineChart.createStackedValueDomain(data.series) : visuals.AxisHelper.createValueDomain(data.series, false);
                var hasZeroValueInYDomain = options.valueAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(valueDomain);
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, valueDomain, options.ensureYDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.height,
                    dataDomain: combinedDomain,
                    metaDataColumn: yMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(yMetaDataColumn, visuals.lineChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: options.valueAxisScaleType,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision,
                    shouldClamp: false,
                });
                var metaDataColumn = this.data ? this.data.categoryMetadata : undefined;
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(metaDataColumn);
                var xDomain = visuals.AxisHelper.createDomain(data.series, categoryDataType, this.data.isScalar, options.forcedXDomain, options.ensureXDomain);
                var hasZeroValueInXDomain = options.valueAxisScaleType === visuals.axisScale.log && !visuals.AxisHelper.isLogScalePossible(xDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: preferredPlotArea.width,
                    dataDomain: xDomain,
                    metaDataColumn: xMetaDataColumn,
                    formatString: visuals.valueFormatter.getFormatString(xMetaDataColumn, visuals.lineChartProps.general.formatString),
                    outerPadding: this.data.isScalar ? LineChart.ScalarOuterPadding : 0,
                    isScalar: this.data.isScalar,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    getValueFn: function (index, type) { return visuals.CartesianHelper.lookupXValue(_this.data, index, type, _this.data.isScalar); },
                    categoryThickness: visuals.CartesianChart.getCategoryThickness(data.series, origCatgSize, this.getAvailableWidth(), xDomain, isScalar, trimOrdinalDataOnOverflow),
                    isCategoryAxis: true,
                    scaleType: options.categoryAxisScaleType,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                });
                this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null;
                this.xAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInXDomain;
                this.yAxisProperties.hasDisallowedZeroInDomain = hasZeroValueInYDomain;
                return [this.xAxisProperties, this.yAxisProperties];
            };
            LineChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                switch (options.objectName) {
                    case 'dataPoint':
                        this.enumerateDataPoints(enumeration);
                        break;
                    case 'labels':
                        this.enumerateDataLabels(enumeration);
                        break;
                }
            };
            LineChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data || !data.series || data.series.length === 0)
                    return;
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var singleSeriesData = data.series;
                var seriesLength = singleSeriesData.length;
                for (var i = 0; i < seriesLength; i++) {
                    var selector = visuals.ColorHelper.normalizeSelector(singleSeriesData[i].identity.getSelector());
                    var label = visuals.converterHelper.getFormattedLegendLabel(singleSeriesData[i].yCol, this.dataViewCat.values, formatStringProp);
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        displayName: label,
                        selector: selector,
                        properties: {
                            fill: { solid: { color: data.defaultSeriesColor || singleSeriesData[i].color } }
                        },
                    });
                }
            };
            LineChart.prototype.enumerateDataLabels = function (enumeration) {
                var data = this.data, labelSettings = this.data.dataLabelsSettings, seriesCount = data.series.length, showLabelPerSeries = this.showLabelPerSeries();
                //Draw default settings
                visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings, null, showLabelPerSeries));
                if (seriesCount === 0)
                    return;
                //Draw series settings
                if (showLabelPerSeries && labelSettings.showLabelPerSeries) {
                    for (var i = 0; i < seriesCount; i++) {
                        var series = data.series[i], labelSettings_2 = (series.labelSettings) ? series.labelSettings : this.data.dataLabelsSettings;
                        enumeration.pushContainer({ displayName: series.displayName });
                        visuals.dataLabelUtils.enumerateDataLabels(this.getLabelSettingsOptions(enumeration, labelSettings_2, series));
                        enumeration.popContainer();
                    }
                }
            };
            LineChart.prototype.supportsTrendLine = function () {
                var isScalar = this.data ? this.data.isScalar : false;
                return !EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */) && isScalar;
            };
            LineChart.prototype.getLabelSettingsOptions = function (enumeration, labelSettings, series, showAll) {
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: true,
                    displayUnits: true,
                    precision: true,
                    selector: series && series.identity ? series.identity.getSelector() : null,
                    showAll: showAll,
                    fontSize: true,
                    labelDensity: this.lineChartLabelDensityEnabled,
                };
            };
            LineChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            LineChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            LineChart.prototype.render = function (suppressAnimations) {
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (this.data.categoryData.length !== this.previousCategoryCount) {
                    duration = 0;
                }
                this.previousCategoryCount = this.data.categoryData.length;
                var result;
                if (!this.isInteractiveChart)
                    result = this.renderNew(duration);
                else
                    result = this.renderOld(duration);
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                return result;
            };
            LineChart.prototype.renderNew = function (duration) {
                var _this = this;
                var data = this.clippedData ? this.clippedData : this.data;
                if (!data)
                    return;
                var dataPointCount = data.categories.length * data.series.length;
                if (dataPointCount > visuals.AnimatorCommon.MaxDataPointsToAnimate) {
                    // Too many data points to animate.
                    duration = 0;
                }
                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var width = viewport.width - (margin.left + margin.right);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var horizontalOffset = this.getXOfFirstCategory();
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                var renderAreas = EnumExtensions.hasFlag(this.lineType, 2 /* area */) || EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
                var xPosition = function (d) { return xScale(_this.getXValue(d)) + horizontalOffset; };
                var y0Position, yPosition;
                if (isStackedArea) {
                    y0Position = function (d) { return yScale(d.stackedValue - d.value); };
                    yPosition = function (d) { return yScale(d.stackedValue); };
                }
                else {
                    y0Position = yScale(0);
                    yPosition = function (d) { return yScale(d.value); };
                }
                var area;
                if (renderAreas) {
                    area = d3.svg.area()
                        .x(xPosition)
                        .y0(y0Position)
                        .y1(yPosition)
                        .defined(function (d) { return d.value !== null; });
                }
                var line = d3.svg.line()
                    .x(xPosition)
                    .y(yPosition)
                    .defined(function (d) {
                    return d.value !== null;
                });
                if (EnumExtensions.hasFlag(this.lineType, 4 /* smooth */)) {
                    line.interpolate('basis');
                    if (area) {
                        area.interpolate('basis');
                    }
                }
                this.mainGraphicsSVG
                    .attr('height', height)
                    .attr('width', width);
                var areas = undefined;
                // Render Areas
                if (renderAreas) {
                    areas = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector).data(data.series, function (d) { return d.identity.getKey(); });
                    areas.enter()
                        .append(LineChart.PathElementName)
                        .classed(LineChart.CategoryAreaSelector.class, true);
                    areas
                        .style('fill', function (d) { return d.color; })
                        .style('fill-opacity', function (d) { return (hasSelection && !d.selected) ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity; })
                        .transition()
                        .ease('linear')
                        .duration(duration)
                        .attr('d', function (d) { return area(d.data); });
                    areas.exit()
                        .remove();
                }
                // Render Lines
                var lines = this.mainGraphicsContext.selectAll(this.lineClassAndSelector.selector).data(data.series, function (d) { return d.identity.getKey(); });
                lines.enter()
                    .append(LineChart.PathElementName)
                    .classed(this.lineClassAndSelector.class, true);
                lines
                    .style('stroke', function (d) { return d.color; })
                    .style('stroke-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
                    .transition()
                    .ease('linear')
                    .duration(duration)
                    .attr('d', function (d) {
                    return line(d.data);
                });
                lines.exit()
                    .remove();
                // Render extra lines that are wider and invisible used for better interactivity
                var interactivityLines;
                if (this.interactivityService) {
                    interactivityLines = this.mainGraphicsContext.selectAll(".interactivity-line").data(data.series, function (d) { return d.identity.getKey(); });
                    interactivityLines.enter()
                        .append(LineChart.PathElementName)
                        .classed('interactivity-line', true)
                        .style('stroke-width', LineChart.interactivityStrokeWidth);
                    interactivityLines
                        .attr('d', function (d) {
                        return line(d.data);
                    });
                    interactivityLines.exit()
                        .remove();
                }
                // Prepare grouping for dots
                var dotGroups = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector)
                    .data(data.series, function (d) { return d.identity.getKey(); });
                dotGroups.enter()
                    .append('g')
                    .classed(LineChart.CategorySelector.class, true);
                dotGroups.exit()
                    .remove();
                // Render dots
                var dots = dotGroups.selectAll(LineChart.CategoryValuePoint.selector)
                    .data(function (series) {
                    return series.data.filter(function (value, i) {
                        return _this.shouldDrawCircle(series, i);
                    });
                }, function (d) { return d.key; });
                dots.enter()
                    .append(LineChart.CircleElementName)
                    .classed(LineChart.CategoryValuePoint.class, true);
                dots
                    .style('fill', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return lineSeries.color;
                })
                    .style('fill-opacity', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
                })
                    .transition()
                    .duration(duration)
                    .attr({
                    cx: function (d, i) { return xScale(_this.getXValue(d)) + horizontalOffset; },
                    cy: function (d, i) { return yScale(isStackedArea ? d.stackedValue : d.value); },
                    r: LineChart.CircleRadius
                });
                dots.exit()
                    .remove();
                // Render explicit dots
                var explicitDots;
                if (!this.isComboChart) {
                    explicitDots = dotGroups.selectAll(LineChart.CategoryPointSelector.selector)
                        .data(function (series) {
                        return _.filter(series.data, function (value) { return value.pointColor != null; });
                    }, function (d) { return d.key; });
                    explicitDots.enter()
                        .append(LineChart.CircleElementName)
                        .classed(LineChart.CategoryPointSelector.class, true);
                    explicitDots
                        .style('fill', function (d) { return d.pointColor; })
                        .transition()
                        .duration(duration)
                        .attr({
                        cx: function (d) { return xScale(_this.getXValue(d)); },
                        cy: function (d) { return yScale(isStackedArea ? d.stackedValue : d.value); },
                        r: LineChart.PointRadius
                    });
                    explicitDots.exit()
                        .remove();
                }
                // Add data labels
                var labelDataPointsGroups;
                if (data.dataLabelsSettings.show)
                    labelDataPointsGroups = this.createLabelDataPoints();
                if (this.tooltipsEnabled) {
                    if (!this.isComboChart) {
                        this.overlayRect
                            .attr({
                            x: 0,
                            width: width,
                            height: height
                        });
                        var seriesTooltipApplier = function (tooltipEvent) {
                            var pointX = tooltipEvent.elementCoordinates[0];
                            var index = _this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX);
                            var categoryData = _this.selectColumnForTooltip(index);
                            return _this.getSeriesTooltipInfo(categoryData);
                        };
                        var clearHoverLine = function () {
                            _this.hoverLine.style('opacity', visuals.SVGUtil.AlmostZero);
                            _this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).remove();
                        };
                        visuals.TooltipManager.addTooltip(this.mainGraphicsSVG, seriesTooltipApplier, true, clearHoverLine);
                    }
                    else {
                        var seriesTooltipApplier = function (tooltipEvent) {
                            var pointX = tooltipEvent.elementCoordinates[0];
                            return _this.getTooltipInfoForCombo(tooltipEvent, pointX);
                        };
                        if (interactivityLines)
                            visuals.TooltipManager.addTooltip(interactivityLines, seriesTooltipApplier, true);
                        visuals.TooltipManager.addTooltip(dots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                        if (explicitDots)
                            visuals.TooltipManager.addTooltip(explicitDots, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; }, true);
                    }
                }
                var dataPointsToBind = undefined;
                var behaviorOptions = undefined;
                if (this.interactivityService) {
                    // Register interactivity
                    dataPointsToBind = data.series.slice();
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        dataPointsToBind = dataPointsToBind.concat(data.series[i].data);
                    }
                    behaviorOptions = {
                        lines: lines,
                        interactivityLines: interactivityLines,
                        dots: dots,
                        areas: areas,
                        tooltipOverlay: this.overlayRect,
                    };
                }
                return {
                    dataPoints: dataPointsToBind,
                    behaviorOptions: behaviorOptions,
                    labelDataPoints: [],
                    labelsAreNumeric: true,
                    labelDataPointGroups: labelDataPointsGroups,
                };
            };
            LineChart.prototype.renderOld = function (duration) {
                var _this = this;
                var data = this.clippedData ? this.clippedData : this.data;
                if (!data)
                    return;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var height = viewport.height - (margin.top + margin.bottom);
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                var area;
                if (EnumExtensions.hasFlag(this.lineType, 2 /* area */)) {
                    area = d3.svg.area()
                        .x(function (d) { return xScale(_this.getXValue(d)); })
                        .y0(height)
                        .y1(function (d) { return yScale(d.value); })
                        .defined(function (d) { return d.value !== null; });
                }
                var line = d3.svg.line()
                    .x(function (d) {
                    return xScale(_this.getXValue(d));
                })
                    .y(function (d) {
                    return yScale(d.value);
                })
                    .defined(function (d) {
                    return d.value !== null;
                });
                if (EnumExtensions.hasFlag(this.lineType, 4 /* smooth */)) {
                    line.interpolate('basis');
                    if (area) {
                        area.interpolate('basis');
                    }
                }
                var firstCategoryOffset = this.getXOfFirstCategory();
                this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(firstCategoryOffset, 0));
                this.mainGraphicsSVG.attr('height', this.getAvailableHeight())
                    .attr('width', this.getAvailableWidth());
                this.hoverLineContext.attr('transform', visuals.SVGUtil.translate(firstCategoryOffset, 0));
                if (EnumExtensions.hasFlag(this.lineType, 2 /* area */)) {
                    var catAreaSelect = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector)
                        .data(data.series, function (d) { return d.identity.getKey(); });
                    var catAreaEnter = catAreaSelect
                        .enter().append('g')
                        .classed(LineChart.CategoryAreaSelector.class, true);
                    catAreaEnter.append(LineChart.PathElementName);
                    var catAreaUpdate = this.mainGraphicsContext.selectAll(LineChart.CategoryAreaSelector.selector);
                    catAreaUpdate.select(LineChart.PathElementName)
                        .transition()
                        .ease('linear')
                        .duration(duration)
                        .attr('d', function (d) { return area(d.data); })
                        .style('fill', function (d) { return d.color; })
                        .style('fill-opacity', function (d) { return (hasSelection && !d.selected) ? LineChart.DimmedAreaFillOpacity : LineChart.AreaFillOpacity; });
                    catAreaSelect.exit().remove();
                }
                var catSelect = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector)
                    .data(data.series, function (d) { return d.identity.getKey(); });
                var catEnter = catSelect
                    .enter()
                    .append('g')
                    .classed(LineChart.CategorySelector.class, true);
                catEnter.append(LineChart.PathElementName);
                catEnter.selectAll(LineChart.CategoryValuePoint.selector)
                    .data(function (d) { return d.data; })
                    .enter()
                    .append(LineChart.CircleElementName)
                    .classed(LineChart.CategoryValuePoint.class, true);
                // moving this up to avoid using the svg path generator with NaN values
                // do not move this without validating that no errors are thrown in the browser console
                catSelect.exit().remove();
                // add the drag handle, if needed
                if (this.isInteractiveChart && !this.dragHandle) {
                    var handleTop = this.getAvailableHeight();
                    this.dragHandle = this.hoverLineContext.append('circle')
                        .attr('cx', 0)
                        .attr('cy', handleTop)
                        .attr('r', '6px')
                        .classed('drag-handle', true);
                }
                // Create the selection circles
                var linesCount = catSelect.data().length; // number of lines plotted
                while (this.selectionCircles.length < linesCount) {
                    var addedCircle = this.hoverLineContext.append(LineChart.CircleElementName)
                        .classed(LineChart.CircleClassName, true)
                        .attr('r', LineChart.CircleRadius).style('opacity', 0);
                    this.selectionCircles.push(addedCircle);
                }
                while (this.selectionCircles.length > linesCount) {
                    this.selectionCircles.pop().remove();
                }
                var catUpdate = this.mainGraphicsContext.selectAll(LineChart.CategorySelector.selector);
                var lineSelection = catUpdate.select(LineChart.PathElementName)
                    .classed(this.lineClassAndSelector.class, true)
                    .style('stroke', function (d) { return d.color; })
                    .style('stroke-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); });
                lineSelection
                    .transition()
                    .ease('linear')
                    .duration(duration)
                    .attr('d', function (d) {
                    return line(d.data);
                });
                var that = this;
                var updateSelection = catUpdate.selectAll(LineChart.CategoryValuePoint.selector);
                var transitions = updateSelection
                    .style('fill', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return lineSeries.color;
                })
                    .style('fill-opacity', function () {
                    var lineSeries = d3.select(this.parentNode).datum();
                    return visuals.ColumnUtil.getFillOpacity(lineSeries.selected, false, hasSelection, false);
                })
                    .transition()
                    .duration(duration)
                    .attr({
                    'cx': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? xScale(that.getXValue(d)) : 0;
                    },
                    'cy': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? yScale(d.value) : 0;
                    },
                    'r': function (d, i) {
                        var lineSeries = d3.select(this.parentNode).datum();
                        var circleIndex = that.shouldDrawCircle(lineSeries, i);
                        return circleIndex ? LineChart.CircleRadius : 0;
                    }
                });
                if (this.isInteractiveChart && this.hasDataPoint(data.series)) {
                    var selectionSize_1 = updateSelection.size();
                    var endedTransitionCount_1 = 0;
                    transitions.each('end', function () {
                        // When transitions finish, and it's an interactive chart - select the last column (draw the legend and the handle)
                        endedTransitionCount_1++;
                        if (endedTransitionCount_1 === selectionSize_1) {
                            _this.selectColumn(visuals.CartesianHelper.findMaxCategoryIndex(data.series), true);
                        }
                    });
                }
                var dataPoints = null;
                if (data.dataLabelsSettings.show) {
                    dataPoints = [];
                    for (var i = 0, ilen = data.series.length; i < ilen; i++) {
                        Array.prototype.push.apply(dataPoints, data.series[i].data);
                    }
                }
                catSelect.exit().remove();
                // # Code from here is taken from renderNew:
                // Add data labels
                var labelDataPointsGroups;
                if (data.dataLabelsSettings.show)
                    labelDataPointsGroups = this.createLabelDataPoints();
                return dataPoints == null ? null : {
                    dataPoints: dataPoints,
                    behaviorOptions: null,
                    labelDataPoints: null,
                    labelsAreNumeric: null,
                    labelDataPointGroups: labelDataPointsGroups
                };
            };
            /**
             * Note: Public for tests.
             */
            LineChart.prototype.getSeriesTooltipInfo = function (pointData) {
                var tooltipinfo = [];
                var maxNumberOfItems = 10; // to limit the number of rows we display
                // count to the maximum number of rows we can display
                var count = 0;
                for (var _i = 0, pointData_1 = pointData; _i < pointData_1.length; _i++) {
                    var point = pointData_1[_i];
                    if (count >= maxNumberOfItems)
                        break;
                    if (point.value != null) {
                        tooltipinfo.push({
                            header: point.category,
                            color: point.color,
                            displayName: point.label,
                            value: point.measure
                        });
                        count++;
                    }
                }
                if (tooltipinfo.length === 0)
                    return null; //don't draw an empty tooltip container
                return tooltipinfo;
            };
            /**
             * Note: Public for tests.
             */
            LineChart.prototype.getTooltipInfoForCombo = function (tooltipEvent, pointX) {
                // update pointX, the mouse coordinate, with the left-offset of the SVGRect from the x-scale space so we can use the d3.scale to get the index.
                var categoryIndex = this.getCategoryIndexFromTooltipEvent(tooltipEvent, pointX);
                var seriesData = tooltipEvent.data;
                var dataPoint;
                if (seriesData && seriesData.data && seriesData.data.length) {
                    dataPoint = _.find(seriesData.data, function (dp) { return dp.categoryIndex === categoryIndex; });
                }
                if (dataPoint)
                    return dataPoint.tooltipInfo;
                // return undefined so we don't show an empty tooltip
            };
            /**
             * Note: Public for tests.
             */
            LineChart.prototype.getCategoryIndexFromTooltipEvent = function (tooltipEvent, pointX) {
                if (tooltipEvent.data && tooltipEvent.data.categoryIndex != null) {
                    // Tooltip originated with a dot; simply return the categoryIndex from the dot's bound data
                    return tooltipEvent.data.categoryIndex;
                }
                var seriesData = tooltipEvent.data;
                var offsetX = 0; // Offset based on the firstCategoryOffset (since lines don't start at x = 0) as well as the offset due to lines that may not start at the first category
                if (seriesData && !_.isEmpty(seriesData.data) && this.xAxisProperties) {
                    // Tooltip originated from a path; determine series offset from the first point that is part of a path
                    pointX = this.adjustPathXCoordinate(pointX);
                    var firstPathPoint = _.find(seriesData.data, function (dataPoint, index, dataPoints) {
                        var nextDataPoint = dataPoints[index + 1];
                        return dataPoint.value != null && nextDataPoint && nextDataPoint.value != null;
                    });
                    debug.assertValue(firstPathPoint, "If there is data on the tooltipEvent but no categoryIndex, there should always be two consecutive non-null values");
                    offsetX = this.xAxisProperties.scale(this.getXValue(firstPathPoint)) + this.getXOfFirstCategory();
                }
                // else: Tooltip originated from the background; no offsetX is needed
                return this.findIndex(pointX, offsetX);
            };
            LineChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return this.data ? this.data.isScalar : false;
            };
            LineChart.prototype.getSupportedCategoryAxisType = function () {
                var dvCategories = this.dataViewCat ? this.dataViewCat.categories : undefined;
                var categoryType = powerbi.ValueType.fromDescriptor({ text: true });
                if (dvCategories && dvCategories.length > 0 && dvCategories[0].source && dvCategories[0].source.type)
                    categoryType = dvCategories[0].source.type;
                var isOrdinal = visuals.AxisHelper.isOrdinal(categoryType);
                return isOrdinal ? visuals.axisType.categorical : visuals.axisType.both;
            };
            LineChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin, true);
            };
            LineChart.prototype.getCategoryCount = function (origCatgSize) {
                var availableWidth = this.getAvailableWidth();
                var categoryThickness = visuals.CartesianChart.MinOrdinalRectThickness;
                return Math.min(Math.round((availableWidth - categoryThickness * visuals.CartesianChart.OuterPaddingRatio * 2) / categoryThickness), origCatgSize);
            };
            LineChart.prototype.getAvailableWidth = function () {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            };
            LineChart.prototype.getAvailableHeight = function () {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            };
            LineChart.sliceSeries = function (series, newLength, startIndex) {
                if (startIndex === void 0) { startIndex = 0; }
                var newSeries = [];
                if (series && series.length > 0) {
                    debug.assert(series[0].data.length >= newLength, "invalid newLength");
                    for (var i = 0, len = series.length; i < len; i++) {
                        newSeries[i] = powerbi.Prototype.inherit(series[i]);
                        newSeries[i].data = series[i].data.slice(startIndex, startIndex + newLength);
                    }
                }
                return newSeries;
            };
            LineChart.prototype.getXOfFirstCategory = function () {
                if (!this.data.isScalar) {
                    // This will place the line points in the middle of the bands
                    // So they center with Labels when scale is ordinal.
                    var xScale = this.xAxisProperties.scale;
                    if (xScale.rangeBand) {
                        return xScale.rangeBand() / 2;
                    }
                }
                return 0;
            };
            LineChart.prototype.hasDataPoint = function (series) {
                if (series.length === 0)
                    return false;
                for (var i = 0, len = series.length; i < len; i++) {
                    if (series[i].data.length > 0)
                        return true;
                }
                return false;
            };
            LineChart.prototype.getXValue = function (d) {
                return this.data.isScalar ? d.categoryValue : d.categoryIndex;
            };
            /**
              * This checks to see if a data point is isolated, which means
              * the previous and next data point are both null.
              */
            LineChart.prototype.shouldDrawCircle = function (d, i) {
                var dataLength = d.data.length;
                var isLastPoint = i === (dataLength - 1);
                var isFirstPoint = i === 0;
                if (i > dataLength - 1 || d.data[i] === null || d.data[i].value === null)
                    return false;
                if (isFirstPoint && isLastPoint)
                    return true;
                if (isFirstPoint && dataLength > 1 && d.data[i + 1].value === null)
                    return true;
                if (!isFirstPoint && isLastPoint && d.data[i - 1].value === null)
                    return true;
                if (!isFirstPoint && !isLastPoint && d.data[i - 1].value === null && d.data[i + 1].value === null)
                    return true;
                return false;
            };
            LineChart.prototype.selectColumnForTooltip = function (columnIndex, force) {
                if (force === void 0) { force = false; }
                var x = this.getChartX(columnIndex) + this.getXOfFirstCategory();
                var dataPoints = this.createTooltipDataPoints(columnIndex);
                if (dataPoints.length > 0) {
                    this.setHoverLineForTooltip(x);
                }
                this.setDotsForTooltip(x, dataPoints);
                return dataPoints;
            };
            LineChart.prototype.setHoverLineForTooltip = function (chartX) {
                chartX = chartX || 0;
                this.hoverLine
                    .attr('x1', chartX)
                    .attr('x2', chartX)
                    .attr("y1", 0)
                    .attr("y2", this.getAvailableHeight())
                    .style('opacity', 1);
            };
            LineChart.prototype.setDotsForTooltip = function (chartX, dataPoints) {
                var _this = this;
                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
                var dotYPosition = isStackedArea ? function (d) { return _this.yAxisProperties.scale(d.stackedValue); } : function (d) { return _this.yAxisProperties.scale(d.value); };
                var tooltipDots = this.hoverLineContext.selectAll(LineChart.HoverLineCircleDot.selector).data(dataPoints);
                tooltipDots
                    .enter()
                    .append(LineChart.CircleElementName)
                    .classed(LineChart.HoverLineCircleDot.class, true);
                tooltipDots
                    .filter(function (d) { return d.value; })
                    .attr('fill', function (d) { return d.color; })
                    .attr("r", 3)
                    .attr("cx", chartX)
                    .attr("cy", dotYPosition);
                tooltipDots.exit().remove();
            };
            /**
             * Updates the hover line and the legend with the selected colums (given by columnIndex).
             * This is for the Mobile renderer with InteractiveLegend
             */
            LineChart.prototype.selectColumn = function (columnIndex, force) {
                if (force === void 0) { force = false; }
                if (!force && this.lastInteractiveSelectedColumnIndex === columnIndex)
                    return; // same column, nothing to do here
                this.lastInteractiveSelectedColumnIndex = columnIndex;
                var x = this.getChartX(columnIndex);
                this.setHoverLine(x, columnIndex);
                var legendItems = this.createLegendDataPoints(columnIndex);
                if (legendItems)
                    this.options.cartesianHost.updateLegend(legendItems);
            };
            LineChart.prototype.setHoverLine = function (chartX, columnIndex) {
                this.hoverLine
                    .attr('x1', chartX)
                    .attr('x2', chartX)
                    .attr("y1", 0).attr("y2", this.getAvailableHeight())
                    .style('opacity', 1);
                var that = this;
                this.mainGraphicsContext
                    .selectAll(LineChart.CategorySelector.selector)
                    .selectAll(LineChart.PathElementName)
                    .each(function (series) {
                    var _this = this;
                    // Get the item color for the handle dots
                    var color = series.color;
                    var circleToChange = that.selectionCircles[series.lineIndex];
                    circleToChange
                        .attr({
                        'cx': chartX,
                        'cy': function () {
                            var pathElement = d3.select(_this).node();
                            var pos = that.getPosition(chartX, pathElement);
                            return pos.y;
                        }
                    })
                        .style({
                        'opacity': function () { return _.some(series.data, function (value) { return value.categoryIndex === columnIndex; }) ? 1 : 0; },
                        'fill': color
                    });
                    if (that.dragHandle)
                        that.dragHandle.attr('cx', chartX);
                });
            };
            LineChart.prototype.getChartX = function (columnIndex) {
                var x = 0;
                if (this.data.isScalar) {
                    if (columnIndex >= 0 && columnIndex < this.data.categoryData.length)
                        x = Math.max(0, this.xAxisProperties.scale(this.data.categoryData[columnIndex].categoryValue));
                }
                else {
                    x = Math.max(0, this.xAxisProperties.scale(columnIndex));
                }
                var rangeEnd = powerbi.visuals.AxisHelper.extent(this.xAxisProperties.scale)[1];
                x = Math.min(x, rangeEnd);
                if (!isNaN(x))
                    return x;
                return 0;
            };
            /**
             * Finds the index of the category of the given x coordinate given.
             * pointX is in non-scaled screen-space, and offsetX is in render-space.
             * offsetX does not need any scaling adjustment.
             * @param {number} pointX The mouse coordinate in screen-space, without scaling applied
             * @param {number} offsetX Any left offset in d3.scale render-space
             * @return {number}
             */
            LineChart.prototype.findIndex = function (pointX, offsetX) {
                // we are using mouse coordinates that do not know about any potential CSS transform scale
                var svgNode = (this.mainGraphicsSVG.node());
                var ratios = visuals.SVGUtil.getTransformScaleRatios(svgNode);
                if (!powerbi.Double.equalWithPrecision(ratios.x, 1.0, 0.00001)) {
                    pointX = pointX / ratios.x;
                }
                if (offsetX) {
                    pointX += offsetX;
                }
                var scaleX = powerbi.visuals.AxisHelper.invertScale(this.xAxisProperties.scale, pointX);
                if (this.data.isScalar) {
                    scaleX = visuals.AxisHelper.findClosestXAxisIndex(scaleX, this.data.categoryData);
                }
                return scaleX;
            };
            LineChart.prototype.getPosition = function (x, pathElement) {
                var pathLength = pathElement.getTotalLength();
                var pos;
                var beginning = 0, end = pathLength, target;
                while (true) {
                    target = Math.floor((beginning + end) / 2);
                    pos = pathElement.getPointAtLength(target);
                    visuals.SVGUtil.ensureValidSVGPoint(pos);
                    if ((target === end || target === beginning) && pos.x !== x)
                        break;
                    if (pos.x > x)
                        end = target;
                    else if (pos.x < x)
                        beginning = target;
                    else
                        break;
                }
                return pos;
            };
            LineChart.prototype.createTooltipDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data || data.series.length === 0 || !data.categoryData)
                    return [];
                var dataPoints = [];
                var category;
                debug.assert(columnIndex < data.categoryData.length, 'category index out of range');
                var categoryDataPoint = data.categoryData[columnIndex];
                if (this.data.isScalar) {
                    if (categoryDataPoint) {
                        if (visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType)) {
                            category = visuals.CartesianHelper.lookupXValue(this.data, categoryDataPoint.categoryValue, this.xAxisProperties.axisType, this.data.isScalar);
                        }
                        else {
                            category = categoryDataPoint.categoryValue;
                        }
                    }
                }
                else {
                    category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar);
                }
                var formatStringProp = visuals.lineChartProps.general.formatString;
                for (var _i = 0, _a = data.series; _i < _a.length; _i++) {
                    var series = _a[_i];
                    var lineData = series.data;
                    var lineDataPoint = void 0;
                    if (this.data.isScalar) {
                        if (categoryDataPoint) {
                            lineDataPoint = lineData.filter(function (data) {
                                return data.categoryValue === categoryDataPoint.categoryValue;
                            })[0];
                        }
                    }
                    else {
                        lineDataPoint = lineData[columnIndex];
                    }
                    var value = lineDataPoint && lineDataPoint.value;
                    if (value != null) {
                        var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                        dataPoints.push({
                            color: series.color,
                            label: label,
                            category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                            measure: visuals.valueFormatter.format(value, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                            value: value,
                            stackedValue: lineDataPoint.stackedValue
                        });
                    }
                }
                return dataPoints;
            };
            LineChart.prototype.createLegendDataPoints = function (columnIndex) {
                var data = this.data;
                if (!data || !data.series || data.series.length < 1)
                    return;
                var legendDataPoints = [];
                var category;
                // 'category' and 'measure' are only for Mobile interactive legend, Minerva legend does not need them
                var categoryDataPoint = data.categoryData[columnIndex];
                if (this.isInteractiveChart && categoryDataPoint) {
                    if (this.data.isScalar) {
                        category = categoryDataPoint.categoryValue;
                        if (visuals.AxisHelper.isDateTime(this.xAxisProperties.axisType))
                            category = new Date(category);
                    }
                    else {
                        category = visuals.CartesianHelper.lookupXValue(this.data, columnIndex, this.xAxisProperties.axisType, this.data.isScalar);
                    }
                }
                var formatStringProp = visuals.lineChartProps.general.formatString;
                var seriesYCol = null;
                // iterating over the line data (i is for a line)
                for (var i = 0, len = data.series.length; i < len; i++) {
                    var series = data.series[i];
                    var lineData = series.data;
                    // 'category' and 'measure' are only for Mobile interactive legend, Minerva legend does not need them
                    var measure = void 0;
                    if (this.isInteractiveChart) {
                        var lineDataPoint = void 0;
                        if (this.data.isScalar) {
                            // Scalar series skip null values, and therefore do not share the same category index
                            // Search this series for the categoryValue - it may not exist
                            if (categoryDataPoint) {
                                var targetCategoryValue = categoryDataPoint.categoryValue;
                                for (var i_1 = 0; i_1 < lineData.length; i_1++) {
                                    if (lineData[i_1].categoryValue === targetCategoryValue) {
                                        lineDataPoint = lineData[i_1];
                                        break;
                                    }
                                }
                            }
                        }
                        else {
                            // ordinal series all share the same x-indicies
                            lineDataPoint = lineData[columnIndex];
                        }
                        measure = lineDataPoint && lineDataPoint.value;
                    }
                    var label = visuals.converterHelper.getFormattedLegendLabel(series.yCol, this.dataViewCat.values, formatStringProp);
                    seriesYCol = series.yCol;
                    legendDataPoints.push({
                        color: series.color,
                        icon: visuals.LegendIcon.Line,
                        label: label,
                        // TODO: category: CartesianChartInteractiveLegend only needs one category value for part of the Title, we don't need to put it on each point.
                        category: visuals.valueFormatter.format(category, visuals.valueFormatter.getFormatString(series.xCol, formatStringProp)),
                        measure: visuals.valueFormatter.format(measure, visuals.valueFormatter.getFormatString(series.yCol, formatStringProp)),
                        identity: series.identity,
                        selected: series.selected,
                    });
                }
                var dvValues = this.dataViewCat ? this.dataViewCat.values : null;
                var title = dvValues && dvValues.source ? dvValues.source.displayName : "";
                return {
                    title: title,
                    dataPoints: legendDataPoints
                };
            };
            LineChart.prototype.createLabelDataPoints = function () {
                var _this = this;
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var lineshift = this.getXOfFirstCategory();
                var data = this.data;
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var dataLabelsSettings = data.dataLabelsSettings;
                var isStackedArea = EnumExtensions.hasFlag(this.lineType, 16 /* stackedArea */);
                var labelDataPointsGroups = [];
                var labelSettings;
                var axisFormatter;
                var seriesLabelDataPoints;
                var seriesDataPointsCandidates;
                var seriesIndex;
                var seriesCount;
                for (seriesIndex = 0, seriesCount = series.length; seriesIndex < seriesCount; seriesIndex++) {
                    var currentSeries = series[seriesIndex];
                    labelSettings = (currentSeries.labelSettings) ? currentSeries.labelSettings : dataLabelsSettings;
                    if (!labelSettings.show)
                        continue;
                    axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yAxisProperties.formatter, labelSettings);
                    var dataPoints = currentSeries.data;
                    seriesLabelDataPoints = [];
                    seriesDataPointsCandidates = [];
                    var createLabelDataPoint = function (dataPoint) {
                        if (dataPoint.value == null)
                            return null;
                        var formatString = "";
                        formatString = dataPoint.labelFormatString;
                        var formatter = formattersCache.getOrCreate(formatString, labelSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties) + visuals.NewDataLabelUtils.LabelDensityPadding;
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        var parentShape;
                        var isParentRect = false;
                        if (isStackedArea) {
                            var bottomPos = Math.max(dataPoint.stackedValue - dataPoint.value, yScale.domain()[0]); //this is to make sure the bottom position doesn't go below the domain
                            var areaWidth = _this.currentViewport.width; // Conceptually, we allow line labels to fill the full plot area, so the width is equal to the plot area
                            parentShape = {
                                rect: {
                                    left: xScale(_this.getXValue(dataPoint)) - areaWidth / 2,
                                    top: yScale(Math.max(dataPoint.stackedValue, dataPoint.stackedValue - dataPoint.value)),
                                    width: areaWidth,
                                    height: Math.abs(yScale(dataPoint.stackedValue) - yScale(bottomPos))
                                },
                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
                                validPositions: LineChart.validStackedLabelPositions,
                            };
                            isParentRect = true;
                        }
                        else {
                            parentShape = {
                                point: {
                                    x: xScale(_this.getXValue(dataPoint)) + lineshift,
                                    y: yScale(dataPoint.value),
                                },
                                radius: 0,
                                validPositions: _this.lineChartLabelDensityEnabled ? LineChart.validLabelPositions : [1 /* Above */],
                            };
                        }
                        var labelDataPoint = {
                            isPreferred: false,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                            insideFill: labelSettings.labelColor && isStackedArea ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            parentType: isParentRect ? 1 /* Rectangle */ : 0 /* Point */,
                            parentShape: parentShape,
                            fontSize: labelSettings.fontSize,
                            identity: dataPoint.identity,
                            key: dataPoint.key,
                        };
                        return labelDataPoint;
                    };
                    if (!_.isEmpty(dataPoints)) {
                        var categoryCount = dataPoints.length;
                        var lastDataPoint = dataPoints[categoryCount - 1];
                        var lastLabelDataPoint = createLabelDataPoint(lastDataPoint, seriesIndex);
                        if (lastLabelDataPoint)
                            seriesLabelDataPoints.push(lastLabelDataPoint);
                        for (var categoryIndex = 0; categoryIndex < categoryCount - 1; categoryIndex++) {
                            var labelDataPoint = createLabelDataPoint(dataPoints[categoryIndex], seriesIndex);
                            if (labelDataPoint)
                                seriesLabelDataPoints.push(labelDataPoint);
                        }
                    }
                    var maxLabelsToRender = dataPoints.length;
                    labelDataPointsGroups[seriesIndex] = {
                        labelDataPoints: seriesLabelDataPoints,
                        maxNumberOfLabels: maxLabelsToRender,
                    };
                }
                return labelDataPointsGroups;
            };
            /**
             * Adjust a mouse coordinate originating from a path; used to fix
             * an inconsistency between Internet Explorer and other browsers.
             *
             * Internet explorer places the origin for the coordinate system of
             * mouse events based on the stroke, so that the very edge of the stroke
             * is zoro.  Chrome places the 0 on the edge of the path so that the
             * edge of the stroke is -(strokeWidth / 2).  We adjust coordinates
             * to match Chrome.
             *
             * TODO: Firefox is similar to IE, but does a very poor job at it, so
             * the edge is inacurate.
             *
             * @param value The x coordinate to be adjusted
             */
            LineChart.prototype.adjustPathXCoordinate = function (x) {
                if (this.shouldAdjustMouseCoordsOnPathsForStroke) {
                    var svgNode = (this.mainGraphicsSVG.node());
                    var ratios = visuals.SVGUtil.getTransformScaleRatios(svgNode);
                    if (!powerbi.Double.equalWithPrecision(ratios.x, 1.0, 0.00001)) {
                        x -= LineChart.pathXAdjustment * ratios.x;
                    }
                    else {
                        x -= LineChart.pathXAdjustment;
                    }
                }
                return x;
            };
            //private isMinMax(index: number, dataPoints: LineChartDataPoint[]): boolean {
            //    // Check if the point is the start/end point
            //    if (!dataPoints[index - 1] || !dataPoints[index + 1])
            //        return true;
            //    let currentValue = dataPoints[index].value;
            //    let prevValue = dataPoints[index - 1].value;
            //    let nextValue = dataPoints[index + 1].value;
            //    return (prevValue > currentValue && currentValue < nextValue) // Min point
            //        || (prevValue < currentValue && currentValue > nextValue); // Max point
            //}
            //private calculatePointsWeight(labelDataPoints: LabelDataPoint[], dataPointsCandidates: LineChartDataPoint[], minIndex: number, maxIndex: number) {
            //    let previousMinMaxIndex = 0;
            //    labelDataPoints[0].weight = dataPointsCandidates[0].weight = 0;
            //    let previousMinMax: LineChartDataPoint = dataPointsCandidates[0];
            //    let dataPointCount = labelDataPoints.length;
            //    let yScale = this.yAxisProperties.scale;
            //    let totalValueDelta = yScale(dataPointsCandidates[maxIndex].value) - yScale(dataPointsCandidates[minIndex].value);
            //    for (let i = 1; i < dataPointCount; i++) {
            //        let dataPoint = dataPointsCandidates[i];
            //        let weight = (Math.abs(yScale(previousMinMax.value) - yScale(dataPoint.value))) / totalValueDelta + (i - previousMinMaxIndex) / dataPointCount;
            //        labelDataPoints[i].weight = weight;
            //        if (this.isMinMax(i, dataPointsCandidates)) {
            //            previousMinMax.weight += weight;
            //            previousMinMax = dataPoint;
            //            previousMinMaxIndex = i;
            //        }
            //    }
            //}
            //private sortByWeightAndPreferrance(a: LabelDataPoint, b: LabelDataPoint): number {
            //    // Compare by prederrance first
            //    if (!a.isPreferred && b.isPreferred) return 1;
            //    if (a.isPreferred && !b.isPreferred) return -1;
            //    // Compare by weight
            //    if ((!a.weight && b.weight) || (a.weight < b.weight)) return 1;
            //    if ((a.weight && !b.weight) || (a.weight > b.weight)) return -1;
            //    return 0;
            //}
            LineChart.prototype.showLabelPerSeries = function () {
                var data = this.data;
                return !data.hasDynamicSeries && (data.series.length > 1 || !data.categoryMetadata);
            };
            LineChart.ClassName = 'lineChart';
            LineChart.MainGraphicsContextClassName = 'mainGraphicsContext';
            LineChart.CategorySelector = createClassAndSelector('cat');
            LineChart.CategoryValuePoint = createClassAndSelector('dot');
            LineChart.CategoryPointSelector = createClassAndSelector('point');
            LineChart.CategoryAreaSelector = createClassAndSelector('catArea');
            LineChart.HoverLineCircleDot = createClassAndSelector('circle-item');
            LineChart.LineClassSelector = createClassAndSelector('line');
            LineChart.PointRadius = 5;
            LineChart.CircleRadius = 4;
            LineChart.PathElementName = 'path';
            LineChart.CircleElementName = 'circle';
            LineChart.CircleClassName = 'selection-circle';
            LineChart.LineElementName = 'line';
            LineChart.RectOverlayName = 'rect';
            LineChart.ScalarOuterPadding = 10;
            LineChart.interactivityStrokeWidth = 10;
            LineChart.pathXAdjustment = 5; // Based on half the stroke width for taking stroke into account in coordinate transforms
            LineChart.AreaFillOpacity = 0.4;
            LineChart.DimmedAreaFillOpacity = 0.2;
            LineChart.validLabelPositions = [
                1 /* Above */,
                2 /* Below */,
                8 /* Right */,
                4 /* Left */,
                64 /* AboveRight */,
                128 /* AboveLeft */,
                16 /* BelowRight */,
                32 /* BelowLeft */
            ];
            LineChart.validStackedLabelPositions = [1 /* InsideCenter */, 4 /* InsideEnd */, 2 /* InsideBase */];
            return LineChart;
        }());
        visuals.LineChart = LineChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Color = jsCommon.Color;
        var PixelConverter = jsCommon.PixelConverter;
        var Polygon = visuals.shapes.Polygon;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        visuals.MaxLevelOfDetail = 23;
        visuals.MinLevelOfDetail = 1;
        visuals.DefaultFillOpacity = 0.5;
        visuals.DefaultBackgroundColor = "#000000";
        visuals.LeaderLineColor = "#000000";
        var MapBubbleDataPointRenderer = (function () {
            function MapBubbleDataPointRenderer(tooltipsEnabled) {
                this.tooltipsEnabled = tooltipsEnabled;
            }
            MapBubbleDataPointRenderer.prototype.init = function (mapControl, mapDiv, addClearCatcher) {
                /*
                    The layout of the visual would look like :
                    <div class="visual mapControl">
                        <div class="MicrosoftMap">
                            <!-- Bing maps stuff -->
                            <svg>
                                <rect class="clearCatcher"></rect>
                            </svg>
                        </div>
                        <svg>
                            <g class="mapBubbles>
                                <!-- our geometry -->
                            </g>
                            <g class="mapSlices>
                                <!-- our geometry -->
                            </g>
                        </svg>
                    </div>
    
                */
                this.mapControl = mapControl;
                this.root = mapDiv;
                var root = d3.select(mapDiv[0]);
                root.attr("drag-resize-disabled", "true"); // Enable panning within the maps in IE
                var svg = this.svg = root
                    .append('svg')
                    .style("position", "absolute") // Absolute position so that the svg will overlap with the canvas.
                    .style("pointer-events", "none");
                if (addClearCatcher) {
                    var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement())
                        .append('svg')
                        .style('position', 'absolute'); // Absolute position so that the svg will overlap with the canvas.
                    this.clearCatcher = visuals.appendClearCatcher(clearSvg);
                }
                this.bubbleGraphicsContext = svg
                    .append("g")
                    .classed("mapBubbles", true);
                this.sliceGraphicsContext = svg
                    .append("g")
                    .classed("mapSlices", true);
                this.labelBackgroundGraphicsContext = svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
                this.labelGraphicsContext = svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                this.sliceLayout = d3.layout.pie()
                    .sort(null)
                    .value(function (d) {
                    return d.value;
                });
                this.arc = d3.svg.arc();
                this.clearMaxDataPointRadius();
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
            };
            MapBubbleDataPointRenderer.prototype.setData = function (data) {
                this.mapData = data;
            };
            MapBubbleDataPointRenderer.prototype.clearDataPoints = function () {
                this.mapData = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: false,
                    hasSize: false,
                };
            };
            MapBubbleDataPointRenderer.prototype.getDataPointCount = function () {
                if (!this.mapData)
                    return 0;
                // Filter out any data points without a location since those aren't actually being drawn
                return _.filter(this.mapData.dataPoints, function (value) { return !!value.location; }).length;
            };
            MapBubbleDataPointRenderer.prototype.getDataPointPadding = function () {
                return this.maxDataPointRadius * 2;
            };
            MapBubbleDataPointRenderer.prototype.clearMaxDataPointRadius = function () {
                this.maxDataPointRadius = 0;
            };
            MapBubbleDataPointRenderer.prototype.setMaxDataPointRadius = function (dataPointRadius) {
                this.maxDataPointRadius = Math.max(dataPointRadius, this.maxDataPointRadius);
            };
            MapBubbleDataPointRenderer.prototype.getDefaultMap = function (geocodingCategory, dataPointCount) {
                this.clearDataPoints();
            };
            MapBubbleDataPointRenderer.prototype.converter = function (viewport, dataView, labelSettings, interactivityService, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var mapControl = this.mapControl;
                var widthOverTwo = viewport.width / 2;
                var heightOverTwo = viewport.height / 2;
                var strokeWidth = 1;
                //update data label settings
                this.dataLabelsSettings = labelSettings;
                // See MapSeriesPresenter::GetDataPointRadius for the PV behavior
                var radiusScale = Math.min(viewport.width, viewport.height) / 384;
                this.clearMaxDataPointRadius();
                var bubbleData = [];
                var sliceData = [];
                var categorical = dataView ? dataView.categorical : null;
                var grouped;
                var sizeIndex = -1;
                var dataValuesSource;
                if (categorical && categorical.values) {
                    grouped = categorical.values.grouped();
                    sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
                    dataValuesSource = categorical.values.source;
                }
                var dataPoints = this.mapData ? this.mapData.dataPoints : [];
                var hasSize = this.mapData.hasSize;
                for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
                    var dataPoint = dataPoints[categoryIndex];
                    var categoryValue = dataPoint.categoryValue;
                    var location_2 = dataPoint.location;
                    if (location_2) {
                        var xy = mapControl.tryLocationToPixel(new Microsoft.Maps.Location(location_2.latitude, location_2.longitude));
                        var x = xy.x + widthOverTwo;
                        var y = xy.y + heightOverTwo;
                        var radius = dataPoint.radius * radiusScale;
                        this.setMaxDataPointRadius(radius);
                        var subDataPoints = dataPoint.subDataPoints;
                        var seriesCount = subDataPoints.length;
                        if (seriesCount === 1) {
                            var subDataPoint = subDataPoints[0];
                            bubbleData.push({
                                x: x,
                                y: y,
                                labeltext: categoryValue,
                                radius: radius,
                                fill: subDataPoint.fill,
                                stroke: subDataPoint.stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: subDataPoint.tooltipInfo,
                                identity: subDataPoint.identity,
                                selected: false,
                                labelFill: labelSettings.labelColor,
                            });
                        }
                        else {
                            var slices = [];
                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                                var subDataPoint = subDataPoints[seriesIndex];
                                var value = hasSize ? subDataPoint.value : 1; // Normalize values if there is no size in the data
                                slices.push({
                                    x: x,
                                    y: y,
                                    labeltext: categoryValue,
                                    radius: radius,
                                    fill: subDataPoint.fill,
                                    stroke: subDataPoint.stroke,
                                    strokeWidth: strokeWidth,
                                    value: value,
                                    tooltipInfo: subDataPoint.tooltipInfo,
                                    identity: subDataPoint.identity,
                                    selected: false,
                                    labelFill: labelSettings.labelColor,
                                });
                            }
                            if (interactivityService) {
                                interactivityService.applySelectionStateToData(slices);
                            }
                            sliceData.push(slices);
                        }
                    }
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(bubbleData);
                }
                return { bubbleData: bubbleData, sliceData: sliceData };
            };
            MapBubbleDataPointRenderer.prototype.updateInternal = function (data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                debug.assertValue(viewport, "viewport");
                Map.removeTransform3d(this.root);
                this.mapRendererData = data;
                if (this.svg) {
                    this.svg
                        .style("width", viewport.width.toString() + "px")
                        .style("height", viewport.height.toString() + "px");
                }
                if (this.clearSvg) {
                    this.clearSvg
                        .style("width", viewport.width.toString() + "px")
                        .style("height", viewport.height.toString() + "px");
                }
                var arc = this.arc;
                var hasSelection = interactivityService && interactivityService.hasSelection();
                var bubbles = this.bubbleGraphicsContext.selectAll(".bubble").data(data.bubbleData, function (d) { return d.identity.getKey(); });
                bubbles.enter()
                    .append("circle")
                    .classed("bubble", true);
                bubbles
                    .attr("cx", function (d) { return d.x; })
                    .attr("cy", function (d) { return d.y; })
                    .attr("r", function (d) { return d.radius; })
                    .style("fill", function (d) { return d.fill; })
                    .style("stroke", function (d) { return d.stroke; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
                    .style("strokeWidth", function (d) { return d.strokeWidth; })
                    .style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
                    .style("cursor", "default");
                bubbles.exit().remove();
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(bubbles, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    bubbles.style("pointer-events", "all");
                }
                var sliceData = data.sliceData;
                var sliceContainers = this.sliceGraphicsContext.selectAll(".sliceContainer").data(sliceData);
                sliceContainers.enter()
                    .append("g")
                    .classed("sliceContainer", true);
                sliceContainers.exit().remove();
                var sliceLayout = this.sliceLayout;
                var slices = sliceContainers.selectAll(".slice")
                    .data(function (d) {
                    return sliceLayout(d);
                }, function (d) { return d.data.identity.getKey(); });
                slices.enter()
                    .append("path")
                    .classed("slice", true);
                slices
                    .style("fill", function (t) { return t.data.fill; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); })
                    .style("stroke", function (t) { return t.data.stroke; })
                    .style("strokeWidth", function (t) { return t.data.strokeWidth; })
                    .style("stroke-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, false); })
                    .style("cursor", "default")
                    .attr("transform", function (t) { return visuals.SVGUtil.translate(t.data.x, t.data.y); })
                    .attr('d', function (t) {
                    return arc.innerRadius(0).outerRadius(function (t) { return t.data.radius; })(t);
                });
                slices.exit().remove();
                this.updateInternalDataLabels(viewport, redrawDataLabels);
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(slices, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    slices.style("pointer-events", "all");
                }
                var allData = data.bubbleData.slice();
                for (var i = 0, ilen = sliceData.length; i < ilen; i++) {
                    allData.push.apply(allData, sliceData[i]);
                }
                var behaviorOptions = {
                    bubbles: bubbles,
                    slices: this.sliceGraphicsContext.selectAll("path"),
                    clearCatcher: this.clearCatcher,
                    dataPoints: allData,
                };
                return behaviorOptions;
            };
            MapBubbleDataPointRenderer.prototype.updateInternalDataLabels = function (viewport, redrawDataLabels) {
                var labelSettings = this.dataLabelsSettings;
                var dataLabels = [];
                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                    var labelDataPoints = this.createLabelDataPoints();
                    var labelLayout = new powerbi.LabelLayout({
                        maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                        startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                    });
                    var labelDataPointsGroup = {
                        labelDataPoints: labelDataPoints,
                        maxNumberOfLabels: labelDataPoints.length
                    };
                    dataLabels = labelLayout.layout([labelDataPointsGroup], { width: viewport.width, height: viewport.height });
                }
                visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, dataLabels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity);
                visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, dataLabels, false); // Once we properly split up and handle show and showCategory, the false here should change to !labelSettings.showCategory
            };
            MapBubbleDataPointRenderer.prototype.createLabelDataPoints = function () {
                var data = this.mapRendererData;
                var labelDataPoints = [];
                var dataPoints = data.bubbleData;
                dataPoints = dataPoints.concat(_.map(data.sliceData, function (value) { return value[0]; }));
                var labelSettings = this.dataLabelsSettings;
                for (var _i = 0, dataPoints_3 = dataPoints; _i < dataPoints_3.length; _i++) {
                    var dataPoint = dataPoints_3[_i];
                    debug.assertValue(dataPoint, 'dataPoint should never be null/undefined');
                    var text = dataPoint.labeltext;
                    var properties = {
                        text: text,
                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize),
                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                    };
                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    labelDataPoints.push({
                        isPreferred: true,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight,
                        },
                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        parentType: 0 /* Point */,
                        parentShape: {
                            point: {
                                x: dataPoint.x,
                                y: dataPoint.y,
                            },
                            radius: dataPoint.radius,
                            validPositions: MapBubbleDataPointRenderer.validLabelPositions,
                        },
                        fontSize: labelSettings.fontSize,
                        identity: undefined,
                        hasBackground: true,
                    });
                }
                return labelDataPoints;
            };
            MapBubbleDataPointRenderer.validLabelPositions = [1 /* Above */, 2 /* Below */, 4 /* Left */, 8 /* Right */];
            return MapBubbleDataPointRenderer;
        }());
        visuals.MapBubbleDataPointRenderer = MapBubbleDataPointRenderer;
        var MapShapeDataPointRenderer = (function () {
            function MapShapeDataPointRenderer(fillMapDataLabelsEnabled, tooltipsEnabled) {
                this.filledMapDataLabelsEnabled = fillMapDataLabelsEnabled;
                this.tooltipsEnabled = tooltipsEnabled;
            }
            MapShapeDataPointRenderer.getFilledMapParams = function (category, dataCount) {
                switch (category) {
                    case visuals.MapUtil.CategoryTypes.Continent:
                    case visuals.MapUtil.CategoryTypes.CountryRegion:
                        if (dataCount < 10) {
                            return { level: 1, maxPolygons: 50, strokeWidth: 0 };
                        }
                        else if (dataCount < 30) {
                            return { level: 1, maxPolygons: 20, strokeWidth: 0 };
                        }
                        return { level: 1, maxPolygons: 5, strokeWidth: 0 };
                    default:
                        if (dataCount < 100) {
                            return { level: 1, maxPolygons: 5, strokeWidth: 6 };
                        }
                        if (dataCount < 200) {
                            return { level: 0, maxPolygons: 5, strokeWidth: 6 };
                        }
                        return { level: 0, maxPolygons: 5, strokeWidth: 0 };
                }
            };
            MapShapeDataPointRenderer.buildPaths = function (locations) {
                var paths = [];
                for (var i = 0; i < locations.length; i++) {
                    var location_3 = locations[i];
                    var polygon = location_3.geographic;
                    if (polygon.length > 2) {
                        paths.push(location_3);
                    }
                }
                return paths;
            };
            MapShapeDataPointRenderer.prototype.init = function (mapControl, mapDiv, addClearCatcher) {
                /*
                    The layout of the visual would look like :
                    <div class="visual mapControl">
                        <div class="MicrosoftMap">
                            <!-- Bing maps stuff -->
                            <svg>
                                <rect class="clearCatcher"></rect>
                            </svg>
                        </div>
                        <svg>
                            <g class="mapShapes>
                                <!-- our geometry -->
                            </g>
                        </svg>
                    </div>
    
                */
                this.mapControl = mapControl;
                this.polygonInfo = new visuals.MapPolygonInfo();
                this.root = mapDiv;
                var root = d3.select(mapDiv[0]);
                root.attr('drag-resize-disabled', 'true'); // Enable panning within the maps in IE
                var svg = this.svg = root
                    .append('svg')
                    .style('position', 'absolute') // Absolute position so that the svg will overlap with the canvas.
                    .style("pointer-events", "none");
                if (addClearCatcher) {
                    var clearSvg = this.clearSvg = d3.select(this.mapControl.getRootElement())
                        .append('svg')
                        .style('position', 'absolute'); // Absolute position so that the svg will overlap with the canvas.
                    this.clearCatcher = visuals.appendClearCatcher(clearSvg);
                }
                this.shapeGraphicsContext = svg
                    .append('g')
                    .classed('mapShapes', true);
                this.labelBackgroundGraphicsContext = svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelBackgroundGraphicsContextClass.class, true);
                this.labelGraphicsContext = svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                this.clearMaxShapeDimension();
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
            };
            MapShapeDataPointRenderer.prototype.setData = function (data) {
                this.mapData = data;
            };
            MapShapeDataPointRenderer.prototype.clearDataPoints = function () {
                this.mapData = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: false,
                    hasSize: false,
                };
            };
            MapShapeDataPointRenderer.prototype.getDataPointCount = function () {
                if (!this.mapData)
                    return 0;
                // Filter out any data points without a location since those aren't actually being drawn
                return _.filter(this.mapData.dataPoints, function (value) { return !!value.paths; }).length;
            };
            MapShapeDataPointRenderer.prototype.converter = function (viewport, dataView, labelSettings, interactivityService) {
                this.clearMaxShapeDimension();
                this.dataLabelsSettings = labelSettings;
                var strokeWidth = 1;
                var shapeData = [];
                var dataPoints = this.mapData ? this.mapData.dataPoints : [];
                for (var categoryIndex = 0, categoryCount = dataPoints.length; categoryIndex < categoryCount; categoryIndex++) {
                    var categorical = dataView ? dataView.categorical : null;
                    var dataPoint = dataPoints[categoryIndex];
                    var subDataPoint = dataPoint.subDataPoints[0];
                    var paths = dataPoint.paths;
                    var grouped = void 0;
                    var sizeIndex = -1;
                    var dataValuesSource = void 0;
                    if (categorical && categorical.values) {
                        grouped = categorical.values.grouped();
                        sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, "Size");
                        dataValuesSource = categorical.values.source;
                    }
                    if (paths) {
                        var value = dataPoint.value;
                        var categoryValue = dataPoint.categoryValue;
                        var identity = subDataPoint.identity;
                        var idKey = identity.getKey();
                        var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                        //Determine Largest Shape
                        var mainShapeIndex = MapShapeDataPointRenderer.getIndexOfLargestShape(paths);
                        for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
                            var path = paths[pathIndex];
                            var labelFormatString = (dataView && dataView.categorical && !_.isEmpty(dataView.categorical.values)) ? visuals.valueFormatter.getFormatString(dataView.categorical.values[0].source, visuals.filledMapProps.general.formatString) : undefined;
                            this.setMaxShapeDimension(path.absoluteBounds.width, path.absoluteBounds.height);
                            var formatter = formattersCache.getOrCreate(labelFormatString, labelSettings);
                            shapeData.push({
                                absolutePointArray: path.absolute,
                                path: path.absoluteString,
                                fill: subDataPoint.fill,
                                stroke: subDataPoint.stroke,
                                strokeWidth: strokeWidth,
                                tooltipInfo: subDataPoint.tooltipInfo,
                                identity: identity,
                                selected: false,
                                key: JSON.stringify({ id: idKey, pIdx: pathIndex }),
                                displayLabel: pathIndex === mainShapeIndex,
                                labeltext: categoryValue,
                                catagoryLabeltext: (value != null) ? visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(value)) : undefined,
                                labelFormatString: labelFormatString,
                            });
                        }
                    }
                }
                if (interactivityService)
                    interactivityService.applySelectionStateToData(shapeData);
                return { shapeData: shapeData };
            };
            MapShapeDataPointRenderer.prototype.updateInternal = function (data, viewport, dataChanged, interactivityService, redrawDataLabels) {
                debug.assertValue(viewport, "viewport");
                Map.removeTransform3d(this.root);
                this.mapRendererData = data;
                if (this.svg) {
                    this.svg
                        .style("width", viewport.width.toString() + "px")
                        .style("height", viewport.height.toString() + "px");
                }
                if (this.clearSvg) {
                    this.clearSvg
                        .style("width", viewport.width.toString() + "px")
                        .style("height", viewport.height.toString() + "px");
                }
                this.polygonInfo.reCalc(this.mapControl, viewport.width, viewport.height);
                this.shapeGraphicsContext.attr("transform", this.polygonInfo.transformToString(this.polygonInfo.transform));
                var hasSelection = interactivityService && interactivityService.hasSelection();
                var shapes = this.shapeGraphicsContext.selectAll("polygon").data(data.shapeData, function (d) { return d.key; });
                shapes.enter()
                    .append("polygon")
                    .classed("shape", true)
                    .attr("points", function (d) {
                    return d.path;
                });
                shapes
                    .style("fill", function (d) { return d.fill; })
                    .style("fill-opacity", function (d) { return visuals.ColumnUtil.getFillOpacity(d.selected, false, hasSelection, false); })
                    .style("cursor", "default");
                if (dataChanged) {
                    // We only update the paths of existing shapes if we have a change in the data.  Updating the lengthy path
                    // strings every update during resize or zooming/panning is extremely bad for performance.
                    shapes
                        .attr("points", function (d) {
                        return d.path;
                    });
                }
                shapes.exit()
                    .remove();
                this.updateInternalDataLabels(viewport, redrawDataLabels);
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    shapes.style("pointer-events", "all");
                }
                var behaviorOptions = {
                    shapes: shapes,
                    clearCatcher: this.clearCatcher,
                    dataPoints: data.shapeData,
                };
                return behaviorOptions;
            };
            MapShapeDataPointRenderer.prototype.getDataPointPadding = function () {
                return 12;
            };
            MapShapeDataPointRenderer.getIndexOfLargestShape = function (paths) {
                var largestShapeIndex = 0;
                var largestShapeArea = 0;
                for (var pathIndex = 0, pathCount = paths.length; pathIndex < pathCount; pathIndex++) {
                    var path = paths[pathIndex];
                    // Using the area of the polygon (and taking the largest)
                    var polygon = new Polygon(path.absolute);
                    var currentShapeArea = Math.abs(Polygon.calculateAbsolutePolygonArea(polygon.polygonPoints));
                    if (currentShapeArea > largestShapeArea) {
                        largestShapeIndex = pathIndex;
                        largestShapeArea = currentShapeArea;
                    }
                }
                return largestShapeIndex;
            };
            MapShapeDataPointRenderer.prototype.updateInternalDataLabels = function (viewport, redrawDataLabels) {
                var labelSettings = this.dataLabelsSettings;
                var labels;
                if (labelSettings && (labelSettings.show || labelSettings.showCategory)) {
                    var labelDataPoints = this.createLabelDataPoints();
                    if (this.labelLayout === undefined) {
                        this.labelLayout = new powerbi.FilledMapLabelLayout();
                    }
                    labels = this.labelLayout.layout(labelDataPoints, { width: viewport.width, height: viewport.height }, this.polygonInfo.transform, redrawDataLabels);
                }
                this.drawLabelStems(this.labelGraphicsContext, labels, labelSettings.show, labelSettings.showCategory);
                visuals.NewDataLabelUtils.drawLabelBackground(this.labelGraphicsContext, labels, powerbi.visuals.DefaultBackgroundColor, powerbi.visuals.DefaultFillOpacity);
                visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, labelSettings.show && labelSettings.showCategory);
            };
            MapShapeDataPointRenderer.prototype.clearMaxShapeDimension = function () {
                this.maxShapeDimension = 0;
            };
            MapShapeDataPointRenderer.prototype.setMaxShapeDimension = function (width, height) {
                this.maxShapeDimension = Math.max(width, this.maxShapeDimension);
                this.maxShapeDimension = Math.max(height, this.maxShapeDimension);
            };
            MapShapeDataPointRenderer.prototype.createLabelDataPoints = function () {
                var data = this.mapRendererData;
                var labelDataPoints = [];
                if (this.filledMapDataLabelsEnabled) {
                    var dataShapes = data.shapeData;
                    var labelSettings = this.dataLabelsSettings;
                    for (var _i = 0, dataShapes_1 = dataShapes; _i < dataShapes_1.length; _i++) {
                        var dataShape = dataShapes_1[_i];
                        if (!dataShape.displayLabel) {
                            continue;
                        }
                        var text = void 0, secondRowText = void 0;
                        var secondRowTextWidth = 0;
                        var hasSecondRow = false;
                        if (this.dataLabelsSettings.show && !this.dataLabelsSettings.showCategory) {
                            text = dataShape.catagoryLabeltext;
                            if (text === undefined)
                                continue;
                        }
                        else if (this.dataLabelsSettings.showCategory && !this.dataLabelsSettings.show) {
                            text = dataShape.labeltext;
                            if (text === undefined)
                                continue;
                        }
                        else if (this.dataLabelsSettings.showCategory && this.dataLabelsSettings.show) {
                            text = dataShape.catagoryLabeltext;
                            secondRowText = dataShape.labeltext;
                            if (text === undefined && secondRowText === undefined)
                                continue;
                            hasSecondRow = true;
                        }
                        if (hasSecondRow) {
                            var secondRowProperties = {
                                text: secondRowText,
                                fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                                fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                                fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                            };
                            secondRowTextWidth = powerbi.TextMeasurementService.measureSvgTextWidth(secondRowProperties);
                        }
                        var firstRowProperties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: visuals.NewDataLabelUtils.LabelTextProperties.fontSize,
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(firstRowProperties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(firstRowProperties);
                        if (secondRowText && dataShape.labeltext !== undefined && dataShape.catagoryLabeltext !== undefined) {
                            textHeight = textHeight * 2;
                        }
                        var labelDataPoint = {
                            parentType: 2 /* Polygon */,
                            parentShape: {
                                polygon: new Polygon(dataShape.absolutePointArray),
                                validPositions: MapShapeDataPointRenderer.validLabelPolygonPositions,
                            },
                            text: text,
                            secondRowText: secondRowText,
                            textSize: {
                                width: Math.max(textWidth, secondRowTextWidth),
                                height: textHeight,
                            },
                            insideFill: labelSettings.labelColor,
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            isPreferred: false,
                            identity: undefined,
                            hasBackground: true,
                        };
                        labelDataPoints.push(labelDataPoint);
                    }
                }
                return labelDataPoints;
            };
            MapShapeDataPointRenderer.prototype.drawLabelStems = function (labelsContext, dataLabels, showText, showCategory) {
                var filteredLabels = _.filter(dataLabels, function (d) { return d.isVisible; });
                var key = function (d, index) { return d.identity ? d.identity.getKeyWithoutHighlight() : index; };
                visuals.NewDataLabelUtils.drawLabelLeaderLines(labelsContext, filteredLabels, key, visuals.LeaderLineColor);
            };
            MapShapeDataPointRenderer.validLabelPolygonPositions = [256 /* Center */, 2 /* Below */, 1 /* Above */, 8 /* Right */, 4 /* Left */, 16 /* BelowRight */, 32 /* BelowLeft */, 64 /* AboveRight */, 128 /* AboveLeft */];
            return MapShapeDataPointRenderer;
        }());
        visuals.MapShapeDataPointRenderer = MapShapeDataPointRenderer;
        var DefaultLocationZoomLevel = 11;
        var Map = (function () {
            function Map(options) {
                if (options.filledMap) {
                    this.dataPointRenderer = new MapShapeDataPointRenderer(options.filledMapDataLabelsEnabled, options.tooltipsEnabled);
                    this.filledMapDataLabelsEnabled = options.filledMapDataLabelsEnabled;
                    this.isFilledMap = true;
                }
                else {
                    this.dataPointRenderer = new MapBubbleDataPointRenderer(options.tooltipsEnabled);
                    this.isFilledMap = false;
                }
                this.mapControlFactory = options.mapControlFactory ? options.mapControlFactory : this.getDefaultMapControlFactory();
                this.behavior = options.behavior;
                this.tooltipsEnabled = options.tooltipsEnabled;
                this.disableZooming = options.disableZooming;
                this.disablePanning = options.disablePanning;
                this.isLegendScrollable = !!options.behavior;
                this.viewChangeThrottleInterval = options.viewChangeThrottleInterval;
                this.enableCurrentLocation = options.enableCurrentLocation;
                this.boundsHaveBeenUpdated = false;
            }
            Map.prototype.init = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                var element = this.element = options.element;
                this.pendingGeocodingRender = false;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                if (this.behavior)
                    this.interactivityService = visuals.createInteractivityService(options.host);
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
                this.legend = powerbi.visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isLegendScrollable);
                this.legendHeight = 0;
                this.legendData = { dataPoints: [] };
                this.geoTaggingAnalyzerService = powerbi.createGeoTaggingAnalyzerService(options.host.getLocalizedString);
                this.host = options.host;
                if (options.host.locale)
                    this.locale = options.host.locale();
                this.geocoder = options.host.geocoder();
                this.resetBounds();
                this.mapControlFactory.ensureMap(this.locale, function () {
                    Microsoft.Maps.loadModule('Microsoft.Maps.Overlays.Style', {
                        callback: function () {
                            _this.initialize(element[0]);
                            if (_this.enableCurrentLocation) {
                                _this.createCurrentLocation(element);
                            }
                        }
                    });
                });
            };
            Map.prototype.createCurrentLocation = function (element) {
                var _this = this;
                var myLocBtn = InJs.DomFactory.div().addClass("mapCurrentLocation").appendTo(element);
                var pushpin;
                myLocBtn.on('click', function () {
                    if (_this.isCurrentLocation) {
                        // Restore previous map view and remove pushpin
                        if (pushpin) {
                            _this.mapControl.entities.remove(pushpin);
                        }
                        _this.updateInternal(false, false);
                        _this.isCurrentLocation = false;
                    }
                    else {
                        _this.host.geolocation().getCurrentPosition(function (position) {
                            var location = new Microsoft.Maps.Location(position.coords.latitude, position.coords.longitude);
                            if (pushpin) {
                                _this.mapControl.entities.remove(pushpin);
                            }
                            pushpin = visuals.MapUtil.CurrentLocation.createPushpin(location);
                            _this.mapControl.entities.push(pushpin);
                            _this.updateMapView(location, DefaultLocationZoomLevel);
                            _this.isCurrentLocation = true;
                        });
                    }
                });
            };
            Map.prototype.addDataPoint = function (dataPoint) {
                var location = dataPoint.location;
                this.updateBounds(location.latitude, location.longitude);
                this.scheduleRedraw();
            };
            Map.prototype.scheduleRedraw = function () {
                var _this = this;
                if (!this.pendingGeocodingRender && this.mapControl) {
                    this.pendingGeocodingRender = true;
                    // Maintain a 3 second delay between redraws from geocoded geometry
                    setTimeout(function () {
                        _this.updateInternal(true, true);
                        _this.pendingGeocodingRender = false;
                    }, 3000);
                }
            };
            Map.prototype.enqueueGeoCode = function (dataPoint) {
                var _this = this;
                var geocodingContext = this.geocodingContext;
                this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function (location) {
                    if (location && geocodingContext === _this.geocodingContext) {
                        dataPoint.location = location;
                        _this.addDataPoint(dataPoint);
                    }
                });
            };
            Map.prototype.enqueueGeoCodeAndGeoShape = function (dataPoint, params) {
                var _this = this;
                var geocodingContext = this.geocodingContext;
                this.geocoder.geocode(dataPoint.geocodingQuery, this.geocodingCategory).then(function (location) {
                    if (location && geocodingContext === _this.geocodingContext) {
                        dataPoint.location = location;
                        _this.enqueueGeoShape(dataPoint, params);
                    }
                });
            };
            Map.prototype.enqueueGeoShape = function (dataPoint, params) {
                var _this = this;
                debug.assertValue(dataPoint.location, "cachedLocation");
                var geocodingContext = this.geocodingContext;
                this.geocoder.geocodeBoundary(dataPoint.location.latitude, dataPoint.location.longitude, this.geocodingCategory, params.level, params.maxPolygons)
                    .then(function (result) {
                    if (geocodingContext === _this.geocodingContext) {
                        var paths = void 0;
                        if (result.locations.length === 0 || result.locations[0].geographic) {
                            paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                        }
                        else {
                            visuals.MapUtil.calcGeoData(result);
                            paths = MapShapeDataPointRenderer.buildPaths(result.locations);
                        }
                        dataPoint.paths = paths;
                        _this.addDataPoint(dataPoint);
                    }
                });
            };
            Map.prototype.getOptimumLevelOfDetail = function (width, height) {
                var dataPointCount = this.dataPointRenderer.getDataPointCount();
                if (dataPointCount === 0)
                    return visuals.MapUtil.MinLevelOfDetail;
                var threshold = this.dataPointRenderer.getDataPointPadding();
                for (var levelOfDetail = visuals.MapUtil.MaxLevelOfDetail; levelOfDetail >= visuals.MapUtil.MinLevelOfDetail; levelOfDetail--) {
                    var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                    var maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                    if (maxXminY.x - minXmaxY.x + threshold <= width && minXmaxY.y - maxXminY.y + threshold <= height) {
                        // if we have less than 2 data points we should not zoom in "too much"
                        if (dataPointCount < 2)
                            levelOfDetail = Math.min(visuals.MapUtil.MaxAutoZoomLevel, levelOfDetail);
                        return levelOfDetail;
                    }
                }
                return visuals.MapUtil.MinLevelOfDetail;
            };
            Map.prototype.getViewCenter = function (levelOfDetail) {
                var minXmaxY = visuals.MapUtil.latLongToPixelXY(this.minLatitude, this.minLongitude, levelOfDetail);
                var maxXminY = visuals.MapUtil.latLongToPixelXY(this.maxLatitude, this.maxLongitude, levelOfDetail);
                return visuals.MapUtil.pixelXYToLocation((minXmaxY.x + maxXminY.x) / 2.0, (maxXminY.y + minXmaxY.y) / 2.0, levelOfDetail);
            };
            Map.prototype.resetBounds = function () {
                this.boundsHaveBeenUpdated = false;
                this.minLongitude = visuals.MapUtil.MaxAllowedLongitude;
                this.maxLongitude = visuals.MapUtil.MinAllowedLongitude;
                this.minLatitude = visuals.MapUtil.MaxAllowedLatitude;
                this.maxLatitude = visuals.MapUtil.MinAllowedLatitude;
            };
            Map.prototype.updateBounds = function (latitude, longitude) {
                this.boundsHaveBeenUpdated = true;
                if (longitude < this.minLongitude) {
                    this.minLongitude = longitude;
                }
                if (longitude > this.maxLongitude) {
                    this.maxLongitude = longitude;
                }
                if (latitude < this.minLatitude) {
                    this.minLatitude = latitude;
                }
                if (latitude > this.maxLatitude) {
                    this.maxLatitude = latitude;
                }
            };
            Map.legendObject = function (dataView) {
                return dataView &&
                    dataView.metadata &&
                    dataView.metadata.objects &&
                    dataView.metadata.objects['legend'];
            };
            Map.isLegendHidden = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject != null && legendObject[visuals.legendProps.show] === false;
            };
            Map.legendPosition = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && visuals.LegendPosition[legendObject[visuals.legendProps.position]];
            };
            Map.getLegendFontSize = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return (legendObject && legendObject[visuals.legendProps.fontSize]) || visuals.SVGLegend.DefaultFontSizeInPt;
            };
            Map.isShowLegendTitle = function (dataView) {
                var legendObject = Map.legendObject(dataView);
                return legendObject && legendObject[visuals.legendProps.showTitle];
            };
            Map.prototype.legendTitle = function () {
                var legendObject = Map.legendObject(this.dataView);
                return (legendObject && legendObject[visuals.legendProps.titleText]) || this.legendData.title;
            };
            Map.prototype.renderLegend = function (legendData) {
                var hideLegend = Map.isLegendHidden(this.dataView);
                var showTitle = Map.isShowLegendTitle(this.dataView);
                var title = this.legendTitle();
                // Update the legendData based on the hide flag.  Cartesian passes in no-datapoints. OnResize reuses the legendData, so this can't mutate.
                var clonedLegendData = {
                    dataPoints: hideLegend ? [] : legendData.dataPoints,
                    grouped: legendData.grouped,
                    title: showTitle ? title : "",
                    fontSize: Map.getLegendFontSize(this.dataView)
                };
                // Update the orientation to match what's in the dataView
                var targetOrientation = Map.legendPosition(this.dataView);
                if (targetOrientation !== undefined) {
                    this.legend.changeOrientation(targetOrientation);
                }
                else {
                    this.legend.changeOrientation(visuals.LegendPosition.Top);
                }
                this.legend.drawLegend(clonedLegendData, this.currentViewport);
            };
            /** Note: public for UnitTest */
            Map.calculateGroupSizes = function (categorical, grouped, groupSizeTotals, sizeMeasureIndex, currentValueScale) {
                var categoryCount = categorical.values[0].values.length;
                var seriesCount = grouped.length;
                for (var i = 0, len = categoryCount; i < len; ++i) {
                    var groupTotal = null;
                    if (sizeMeasureIndex >= 0) {
                        for (var j = 0; j < seriesCount; ++j) {
                            var value = grouped[j].values[sizeMeasureIndex].values[i];
                            if (value) {
                                if (groupTotal === null) {
                                    groupTotal = value;
                                }
                                else {
                                    groupTotal += value;
                                }
                            }
                        }
                    }
                    groupSizeTotals.push(groupTotal);
                    if (groupTotal) {
                        if (!currentValueScale) {
                            currentValueScale = {
                                min: groupTotal,
                                max: groupTotal
                            };
                        }
                        else {
                            currentValueScale.min = Math.min(currentValueScale.min, groupTotal);
                            currentValueScale.max = Math.max(currentValueScale.max, groupTotal);
                        }
                    }
                }
                return currentValueScale;
            };
            /** Note: public for UnitTest */
            Map.calculateRadius = function (range, value) {
                var rangeDiff = range ? range.max - range.min : 0;
                var radius = 6;
                if (range != null && value != null && rangeDiff !== 0) {
                    radius = (14 * ((value - range.min) / rangeDiff)) + 6;
                }
                return radius;
            };
            /** Note: public for UnitTest */
            Map.getGeocodingCategory = function (categorical, geoTaggingAnalyzerService) {
                if (categorical && categorical.categories && categorical.categories.length > 0 && categorical.categories[0].source) {
                    // Check categoryString for manually specified information in the model
                    var type = categorical.categories[0].source.type;
                    if (type && type.categoryString) {
                        return geoTaggingAnalyzerService.getFieldType(type.categoryString);
                    }
                    // Check the category name
                    var categoryName = categorical.categories[0].source.displayName;
                    var geotaggedResult = geoTaggingAnalyzerService.getFieldType(categoryName);
                    if (geotaggedResult)
                        return geotaggedResult;
                    // Checking roles for VRM backwards compatibility
                    var roles = categorical.categories[0].source.roles;
                    if (roles) {
                        var roleNames = Object.keys(roles);
                        for (var i = 0, len = roleNames.length; i < len; ++i) {
                            var typeFromRoleName = geoTaggingAnalyzerService.getFieldType(roleNames[i]);
                            if (typeFromRoleName)
                                return typeFromRoleName;
                        }
                    }
                }
                return undefined;
            };
            /** Note: public for UnitTest */
            Map.hasSizeField = function (values, defaultIndexIfNoRole) {
                if (_.isEmpty(values))
                    return false;
                for (var i = 0, ilen = values.length; i < ilen; i++) {
                    var roles = values[i].source.roles;
                    // case for Power Q&A since Power Q&A does not assign role to measures.
                    if (!roles && i === defaultIndexIfNoRole && values[i].source.type.numeric)
                        return true;
                    if (roles) {
                        var roleNames = Object.keys(roles);
                        for (var j = 0, jlen = roleNames.length; j < jlen; j++) {
                            var role = roleNames[j];
                            if (role === "Size")
                                return true;
                        }
                    }
                }
                return false;
            };
            Map.shouldEnumerateDataPoints = function (dataView, usesSizeForGradient) {
                var hasSeries = DataRoleHelper.hasRoleInDataView(dataView, 'Series');
                var gradientRole = usesSizeForGradient ? 'Size' : 'Gradient';
                var hasGradientRole = DataRoleHelper.hasRoleInDataView(dataView, gradientRole);
                return hasSeries || !hasGradientRole;
            };
            Map.shouldEnumerateCategoryLabels = function (isFilledMap, filledMapDataLabelsEnabled) {
                return (!isFilledMap || filledMapDataLabelsEnabled);
            };
            Map.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                    case 'dataPoint':
                        if (Map.shouldEnumerateDataPoints(this.dataView, this.isFilledMap)) {
                            var bubbleData = [];
                            //TODO: better way of getting this data
                            var hasDynamicSeries = this.hasDynamicSeries;
                            if (!hasDynamicSeries) {
                                var mapData = this.dataPointRenderer.converter(this.getMapViewPort(), this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled);
                                bubbleData = mapData.bubbleData;
                            }
                            Map.enumerateDataPoints(enumeration, this.dataPointsToEnumerate, this.colors, hasDynamicSeries, this.defaultDataPointColor, this.showAllDataPoints, bubbleData);
                        }
                        break;
                    case 'categoryLabels':
                        if (Map.shouldEnumerateCategoryLabels(this.isFilledMap, this.filledMapDataLabelsEnabled)) {
                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.dataLabelsSettings, true, true);
                        }
                        break;
                    case 'legend':
                        if (this.hasDynamicSeries) {
                            Map.enumerateLegend(enumeration, this.dataView, this.legend, this.legendTitle());
                        }
                        break;
                    case 'labels':
                        if (this.filledMapDataLabelsEnabled) {
                            this.dataLabelsSettings = this.dataLabelsSettings ? this.dataLabelsSettings : visuals.dataLabelUtils.getDefaultMapLabelSettings();
                            var labelSettingOptions = {
                                enumeration: enumeration,
                                dataLabelsSettings: this.dataLabelsSettings,
                                show: true,
                                displayUnits: true,
                                precision: true,
                            };
                            visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        }
                        break;
                }
                return enumeration.complete();
            };
            Map.enumerateDataPoints = function (enumeration, dataPoints, colors, hasDynamicSeries, defaultDataPointColor, showAllDataPoints, bubbleData) {
                var seriesLength = dataPoints && dataPoints.length;
                if (hasDynamicSeries) {
                    for (var i = 0; i < seriesLength; i++) {
                        var dataPoint = dataPoints[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: dataPoint.label,
                            selector: dataPoint.identity.getSelector(),
                            properties: {
                                fill: { solid: { color: dataPoint.color } }
                            },
                        });
                    }
                }
                else {
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: defaultDataPointColor || colors.getColorByIndex(0).value } }
                        },
                    }).pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: !!showAllDataPoints
                        },
                    });
                    if (bubbleData) {
                        for (var i = 0; i < bubbleData.length; i++) {
                            var bubbleDataPoint = bubbleData[i];
                            enumeration.pushInstance({
                                objectName: 'dataPoint',
                                displayName: bubbleDataPoint.labeltext,
                                selector: bubbleDataPoint.identity.getSelector(),
                                properties: {
                                    fill: { solid: { color: Color.normalizeToHexString(bubbleDataPoint.fill) } }
                                },
                            });
                        }
                    }
                }
            };
            Map.enumerateLegend = function (enumeration, dataView, legend, legendTitle) {
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        show: !Map.isLegendHidden(dataView),
                        position: visuals.LegendPosition[legend.getOrientation()],
                        showTitle: Map.isShowLegendTitle(dataView),
                        titleText: legendTitle,
                        fontSize: Map.getLegendFontSize(dataView)
                    },
                    objectName: 'legend'
                });
            };
            Map.prototype.onDataChanged = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                this.resetBounds();
                this.geocodingContext = {};
                if (this.behavior)
                    this.behavior.resetZoomPan();
                this.dataLabelsSettings = visuals.dataLabelUtils.getDefaultMapLabelSettings();
                this.defaultDataPointColor = null;
                this.showAllDataPoints = null;
                var dataView = this.dataView = options.dataViews[0];
                var isFilledMap = this.isFilledMap;
                var warnings = [];
                var data = {
                    dataPoints: [],
                    geocodingCategory: null,
                    hasDynamicSeries: false,
                    hasSize: false,
                };
                if (dataView) {
                    // Handle object-based settings
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        this.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.mapProps.dataPoint.defaultColor);
                        this.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.mapProps.dataPoint.showAllDataPoints);
                        this.dataLabelsSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.categoryLabels.show, this.dataLabelsSettings.showCategory);
                        if (isFilledMap) {
                            this.dataLabelsSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelPrecision, this.dataLabelsSettings.precision);
                            this.dataLabelsSettings.precision = (this.dataLabelsSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && this.dataLabelsSettings.precision < 0) ? 0 : this.dataLabelsSettings.precision;
                            this.dataLabelsSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.filledMapProps.labels.labelDisplayUnits, this.dataLabelsSettings.displayUnits);
                            var datalabelsObj = objects['labels'];
                            if (datalabelsObj) {
                                this.dataLabelsSettings.show = (datalabelsObj['show'] !== undefined) ? datalabelsObj['show'] : this.dataLabelsSettings.show;
                                if (datalabelsObj['color'] !== undefined) {
                                    this.dataLabelsSettings.labelColor = datalabelsObj['color'].solid.color;
                                }
                            }
                        }
                        else {
                            var categoryLabelsObj = objects['categoryLabels'];
                            if (categoryLabelsObj)
                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelsObj, this.dataLabelsSettings);
                        }
                    }
                    // Convert data
                    var colorHelper = new visuals.ColorHelper(this.colors, visuals.mapProps.dataPoint.fill, this.defaultDataPointColor);
                    data = Map.converter(dataView, colorHelper, this.geoTaggingAnalyzerService, isFilledMap);
                    this.hasDynamicSeries = data.hasDynamicSeries;
                    // Create legend
                    this.legendData = Map.createLegendData(dataView, colorHelper);
                    this.dataPointsToEnumerate = this.legendData.dataPoints;
                    this.renderLegend(this.legendData);
                    // Start geocoding or geoshaping
                    if (data != null) {
                        this.geocodingCategory = data.geocodingCategory;
                        this.mapControlFactory.ensureMap(this.locale, function () {
                            var params;
                            if (isFilledMap) {
                                params = MapShapeDataPointRenderer.getFilledMapParams(_this.geocodingCategory, data.dataPoints.length);
                            }
                            for (var _i = 0, _a = data.dataPoints; _i < _a.length; _i++) {
                                var dataPoint = _a[_i];
                                if (!dataPoint.location) {
                                    if (!_.isEmpty(dataPoint.categoryValue)) {
                                        if (isFilledMap)
                                            _this.enqueueGeoCodeAndGeoShape(dataPoint, params);
                                        else
                                            _this.enqueueGeoCode(dataPoint);
                                    }
                                }
                                else if (isFilledMap && !dataPoint.paths) {
                                    _this.enqueueGeoShape(dataPoint, params);
                                }
                                else {
                                    _this.addDataPoint(dataPoint);
                                }
                            }
                        });
                    }
                    else {
                        // No data from conversion, so clear data points
                        this.clearDataPoints();
                    }
                    if (isFilledMap) {
                        if (!this.geocodingCategory || !this.geoTaggingAnalyzerService.isGeoshapable(this.geocodingCategory)) {
                            warnings.push(new visuals.FilledMapWithoutValidGeotagCategoryWarning());
                        }
                    }
                }
                else {
                    this.clearDataPoints();
                    this.renderLegend({
                        dataPoints: [],
                        title: undefined,
                    });
                    this.dataPointsToEnumerate = [];
                }
                if (!_.isEmpty(warnings))
                    this.host.setWarnings(warnings);
                this.dataPointRenderer.setData(data);
                this.updateInternal(true /* dataChanged */, true /* redrawDataLabels */);
            };
            Map.converter = function (dataView, colorHelper, geoTaggingAnalyzerService, isFilledMap) {
                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
                var dataPoints = [];
                var hasDynamicSeries = reader.hasDynamicSeries();
                var seriesColumnIdentifier = reader.getSeriesColumnIdentityFields();
                var sizeQueryName = reader.getMeasureQueryName('Size');
                if (sizeQueryName == null)
                    sizeQueryName = '';
                var hasSize = reader.hasValues('Size');
                var geocodingCategory = null;
                var formatStringProp = visuals.mapProps.general.formatString;
                if (reader.hasCategories()) {
                    // Calculate category totals and range for radius calculation
                    var categoryTotals = [];
                    var categoryTotalRange = void 0;
                    if (hasSize) {
                        var categoryMin = undefined;
                        var categoryMax = undefined;
                        for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
                            var categoryTotal = void 0;
                            for (var seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
                                var currentValue = reader.getValue('Size', categoryIndex, seriesIndex);
                                // Dont initialze categoryTotal to zero until you find a null value so that it remains undefined for categories that have no non-null values (0 is rendered by filled map while null is not)
                                if (categoryTotal == null && currentValue != null)
                                    categoryTotal = 0;
                                if (categoryTotal != null)
                                    categoryTotal += currentValue;
                            }
                            categoryTotals.push(categoryTotal);
                            if (categoryTotal != null) {
                                if (categoryMin === undefined || categoryTotal < categoryMin)
                                    categoryMin = categoryTotal;
                                if (categoryMax === undefined || categoryTotal > categoryMax)
                                    categoryMax = categoryTotal;
                            }
                        }
                        categoryTotalRange = (categoryMin !== undefined && categoryMax !== undefined) ? {
                            max: categoryMax,
                            min: categoryMin,
                        } : undefined;
                    }
                    var hasLatLongGroup = reader.hasCompositeCategories() && reader.hasCategoryWithRole('X') && reader.hasCategoryWithRole('Y');
                    var hasCategoryGroup = reader.hasCategoryWithRole('Category');
                    geocodingCategory = Map.getGeocodingCategory(dataView.categorical, geoTaggingAnalyzerService);
                    if (hasLatLongGroup || hasCategoryGroup) {
                        // Create data points
                        for (var categoryIndex = 0, categoryCount = reader.getCategoryCount(); categoryIndex < categoryCount; categoryIndex++) {
                            // Get category information
                            var categoryValue = undefined;
                            // The category objects should come from whichever category exists; in the case of a composite category, the objects should be the same for
                            //   both categories, so we only need to obtain them from one role.
                            var categoryObjects = hasCategoryGroup ? reader.getCategoryObjects('Category', categoryIndex) : reader.getCategoryObjects('Y', categoryIndex);
                            var location_4 = void 0;
                            var categoryTooltipItem = void 0;
                            var latitudeTooltipItem = void 0;
                            var longitudeTooltipItem = void 0;
                            var seriesTooltipItem = void 0;
                            var sizeTooltipItem = void 0;
                            var gradientTooltipItem = void 0;
                            if (hasCategoryGroup) {
                                // Set category value
                                categoryValue = reader.getCategoryValue('Category', categoryIndex);
                                categoryTooltipItem = {
                                    displayName: reader.getCategoryDisplayName('Category'),
                                    value: visuals.converterHelper.formatFromMetadataColumn(categoryValue, reader.getCategoryMetadataColumn('Category'), formatStringProp),
                                };
                                // Create location from latitude and longitude if they exist as values
                                if (reader.hasValues('Y') && reader.hasValues('X')) {
                                    var latitude = reader.getFirstNonNullValueForCategory('Y', categoryIndex);
                                    var longitude = reader.getFirstNonNullValueForCategory('X', categoryIndex);
                                    if (latitude != null && longitude != null) {
                                        location_4 = { latitude: latitude, longitude: longitude };
                                    }
                                    latitudeTooltipItem = {
                                        displayName: reader.getValueDisplayName('Y'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getValueMetadataColumn('Y'), formatStringProp),
                                    };
                                    longitudeTooltipItem = {
                                        displayName: reader.getValueDisplayName('X'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getValueMetadataColumn('X'), formatStringProp),
                                    };
                                }
                            }
                            else {
                                var latitude = reader.getCategoryValue('Y', categoryIndex);
                                var longitude = reader.getCategoryValue('X', categoryIndex);
                                if (latitude != null && longitude != null) {
                                    // Combine latitude and longitude to create the category value
                                    categoryValue = latitude + ', ' + longitude;
                                    // Create location from latitude and longitude
                                    location_4 = { latitude: latitude, longitude: longitude };
                                    latitudeTooltipItem = {
                                        displayName: reader.getCategoryDisplayName('Y'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(latitude, reader.getCategoryMetadataColumn('Y'), formatStringProp),
                                    };
                                    longitudeTooltipItem = {
                                        displayName: reader.getCategoryDisplayName('X'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(longitude, reader.getCategoryMetadataColumn('X'), formatStringProp),
                                    };
                                }
                            }
                            var value = hasSize ? categoryTotals[categoryIndex] : undefined;
                            // Calculate sub data points by series
                            var subDataPoints = [];
                            var seriesCount = reader.getSeriesCount();
                            if (!hasSize && !hasDynamicSeries) {
                                seriesCount = 1;
                            }
                            for (var seriesIndex = 0; seriesIndex < seriesCount; seriesIndex++) {
                                var color = void 0;
                                if (hasDynamicSeries) {
                                    color = colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, (reader.getSeriesName(seriesIndex)));
                                }
                                else if (reader.hasCategoryWithRole('Series')) {
                                    color = colorHelper.getColorForSeriesValue(reader.getCategoryObjects('Series', categoryIndex), reader.getCategoryColumnIdentityFields('Series'), categoryValue);
                                }
                                else {
                                    color = colorHelper.getColorForMeasure(categoryObjects, sizeQueryName);
                                }
                                var colorRgb = Color.parseColorString(color);
                                var stroke = Color.hexString(Color.darken(colorRgb, Map.StrokeDarkenColorValue));
                                colorRgb.A = 0.6;
                                var fill = Color.rgbString(colorRgb);
                                var identityBuilder = new visuals.SelectionIdBuilder()
                                    .withCategory(reader.getCategoryColumn(hasCategoryGroup ? 'Category' : 'Y'), categoryIndex)
                                    .withMeasure(sizeQueryName);
                                if (hasDynamicSeries) {
                                    identityBuilder = identityBuilder.withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex));
                                }
                                if (hasDynamicSeries) {
                                    seriesTooltipItem = {
                                        displayName: reader.getSeriesDisplayName(),
                                        value: visuals.converterHelper.formatFromMetadataColumn(reader.getSeriesName(seriesIndex), reader.getSeriesMetadataColumn(), formatStringProp),
                                    };
                                }
                                var subsliceValue = void 0;
                                if (hasSize) {
                                    subsliceValue = reader.getValue('Size', categoryIndex, seriesIndex);
                                    sizeTooltipItem = {
                                        displayName: reader.getValueDisplayName('Size'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(subsliceValue, reader.getValueMetadataColumn('Size', seriesIndex), formatStringProp),
                                    };
                                }
                                if (reader.hasValues('Gradient')) {
                                    gradientTooltipItem = {
                                        displayName: reader.getValueDisplayName('Gradient'),
                                        value: visuals.converterHelper.formatFromMetadataColumn(reader.getValue('Gradient', categoryIndex, seriesIndex), reader.getValueMetadataColumn('Gradient', seriesIndex), formatStringProp),
                                    };
                                }
                                // Combine any existing tooltip items
                                var tooltipInfo = [];
                                if (categoryTooltipItem)
                                    tooltipInfo.push(categoryTooltipItem);
                                if (seriesTooltipItem)
                                    tooltipInfo.push(seriesTooltipItem);
                                if (latitudeTooltipItem)
                                    tooltipInfo.push(latitudeTooltipItem);
                                if (longitudeTooltipItem)
                                    tooltipInfo.push(longitudeTooltipItem);
                                if (sizeTooltipItem)
                                    tooltipInfo.push(sizeTooltipItem);
                                if (gradientTooltipItem)
                                    tooltipInfo.push(gradientTooltipItem);
                                // Do not create subslices for data points with null or zero if not filled map
                                if (subsliceValue || !hasSize || (subsliceValue === 0 && isFilledMap)) {
                                    subDataPoints.push({
                                        value: subsliceValue,
                                        fill: fill,
                                        stroke: stroke,
                                        identity: identityBuilder.createSelectionId(),
                                        tooltipInfo: tooltipInfo,
                                    });
                                }
                            }
                            // Skip data points that have a null or zero if not filled map
                            if (value || !hasSize || (value === 0 && isFilledMap)) {
                                dataPoints.push({
                                    geocodingQuery: categoryValue,
                                    value: value,
                                    categoryValue: categoryValue,
                                    subDataPoints: subDataPoints,
                                    radius: Map.calculateRadius(categoryTotalRange, value),
                                    location: location_4,
                                });
                            }
                        }
                    }
                }
                var mapData = {
                    dataPoints: dataPoints,
                    geocodingCategory: geocodingCategory,
                    hasDynamicSeries: hasDynamicSeries,
                    hasSize: hasSize,
                };
                return mapData;
            };
            Map.createLegendData = function (dataView, colorHelper) {
                var reader = powerbi.data.createIDataViewCategoricalReader(dataView);
                var legendDataPoints = [];
                var legendTitle;
                if (reader.hasDynamicSeries()) {
                    legendTitle = reader.getSeriesDisplayName();
                    var seriesColumnIdentifier = reader.getSeriesColumnIdentityFields();
                    for (var seriesIndex = 0, seriesCount = reader.getSeriesCount(); seriesIndex < seriesCount; seriesIndex++) {
                        var color = colorHelper.getColorForSeriesValue(reader.getSeriesObjects(seriesIndex), seriesColumnIdentifier, reader.getSeriesName(seriesIndex));
                        var identity = new visuals.SelectionIdBuilder().withSeries(reader.getSeriesValueColumns(), reader.getSeriesValueColumnGroup(seriesIndex)).createSelectionId();
                        legendDataPoints.push({
                            color: color,
                            label: visuals.valueFormatter.format(reader.getSeriesName(seriesIndex)),
                            icon: visuals.LegendIcon.Circle,
                            identity: identity,
                            selected: false,
                        });
                    }
                }
                var legendData = {
                    dataPoints: legendDataPoints,
                    title: legendTitle,
                };
                return legendData;
            };
            Map.prototype.swapLogoContainerChildElement = function () {
                // This is a workaround that allow maps to be printed from the IE and Edge browsers.
                // For some unknown reason, the presence of an <a> child element in the .LogoContainer
                // prevents dashboard map visuals from showing up when printed.
                // The trick is to swap out the <a> element with a <div> container.
                // There are no user impacts or visual changes.
                var logoContainer = this.element.find('.LogoContainer');
                if (logoContainer) {
                    var aNode = logoContainer.find('a');
                    if (aNode == null)
                        return;
                    var divNode = $('<div>');
                    aNode.children().clone().appendTo(divNode);
                    aNode.remove();
                    divNode.appendTo(logoContainer);
                }
            };
            Map.prototype.onResizing = function (viewport) {
                if (this.currentViewport.width !== viewport.width || this.currentViewport.height !== viewport.height) {
                    this.currentViewport = viewport;
                    this.renderLegend(this.legendData);
                    this.updateInternal(false /* dataChanged */, false);
                }
            };
            Map.prototype.initialize = function (container) {
                var _this = this;
                var mapOptions = {
                    credentials: visuals.MapUtil.Settings.BingKey,
                    showMapTypeSelector: false,
                    enableClickableLogo: false,
                    enableSearchLogo: false,
                    mapTypeId: Microsoft.Maps.MapTypeId.road,
                    customizeOverlays: true,
                    showDashboard: false,
                    showScalebar: false,
                    disableKeyboardInput: true,
                    disableZooming: this.disableZooming,
                    disablePanning: this.disablePanning,
                };
                var divQuery = this.root = InJs.DomFactory.div().addClass(Map.MapContainer.cssClass).appendTo(container);
                this.mapControl = this.mapControlFactory.createMapControl(divQuery[0], mapOptions);
                if (this.viewChangeThrottleInterval !== undefined) {
                    Microsoft.Maps.Events.addThrottledHandler(this.mapControl, 'viewchange', function () { _this.onViewChanged(); }, this.viewChangeThrottleInterval);
                }
                else {
                    Microsoft.Maps.Events.addHandler(this.mapControl, 'viewchange', function () { _this.onViewChanged(); });
                }
                Microsoft.Maps.Events.addHandler(this.mapControl, "viewchangeend", function () { _this.onViewChangeEnded(); });
                this.dataPointRenderer.init(this.mapControl, divQuery, !!this.behavior);
                if (!this.pendingGeocodingRender) {
                    this.updateInternal(true /* dataChanged */, true);
                }
            };
            Map.prototype.onViewChanged = function () {
                this.updateOffsets(false, false /* dataChanged */);
                if (this.behavior)
                    this.behavior.viewChanged();
                this.swapLogoContainerChildElement();
            };
            Map.prototype.onViewChangeEnded = function () {
                this.dataPointRenderer.updateInternalDataLabels(this.currentViewport, true);
            };
            Map.prototype.getMapViewPort = function () {
                var currentViewport = this.currentViewport;
                var legendMargins = this.legend.getMargins();
                var mapViewport = {
                    width: currentViewport.width - legendMargins.width,
                    height: currentViewport.height - legendMargins.height,
                };
                return mapViewport;
            };
            Map.removeTransform3d = function (mapRoot) {
                // don't remove transform3d from bing maps images in safari (using applewebkit engine)
                var userAgent = window.navigator.userAgent.toLowerCase();
                if (mapRoot && userAgent.indexOf('applewebkit') === -1) {
                    var imageTiles = mapRoot.find('img');
                    imageTiles.css('transform', '');
                }
            };
            Map.prototype.updateInternal = function (dataChanged, redrawDataLabels) {
                if (this.mapControl) {
                    var isLegendVisible = this.legend.isVisible();
                    if (!isLegendVisible)
                        this.legendData = { dataPoints: [] };
                    var mapDiv = this.element.children(Map.MapContainer.selector);
                    var mapViewport = this.getMapViewPort();
                    mapDiv.height(mapViewport.height);
                    mapDiv.width(mapViewport.width);
                    // With the risk of double drawing, if the position updates to nearly the same, the map control won't call viewchange, so explicitly update the points
                    this.updateOffsets(dataChanged, redrawDataLabels);
                    // Set zoom level after we rendered that map as we need the max size of the bubbles/ pie slices to calculate it
                    if (this.boundsHaveBeenUpdated && !(this.behavior && this.behavior.hasReceivedZoomOrPanEvent())) {
                        var levelOfDetail = this.getOptimumLevelOfDetail(mapViewport.width, mapViewport.height);
                        var center = this.getViewCenter(levelOfDetail);
                        this.updateMapView(center, levelOfDetail);
                    }
                }
            };
            Map.prototype.updateMapView = function (center, levelOfDetail) {
                this.mapControl.setView({ center: center, zoom: levelOfDetail, animate: true });
            };
            Map.prototype.updateOffsets = function (dataChanged, redrawDataLabels) {
                var dataView = this.dataView;
                var data;
                var viewport = this.getMapViewPort();
                if (dataView && dataView.categorical) {
                    // currentViewport may not exist in UnitTests
                    data = this.dataPointRenderer.converter(viewport, this.dataView, this.dataLabelsSettings, this.interactivityService, this.tooltipsEnabled);
                }
                else {
                    data = {
                        bubbleData: [],
                        shapeData: [],
                        sliceData: [],
                    };
                }
                var behaviorOptions = this.dataPointRenderer.updateInternal(data, viewport, dataChanged, this.interactivityService, redrawDataLabels);
                visuals.Legend.positionChartArea(d3.select(this.root[0]), this.legend);
                if (this.interactivityService && behaviorOptions) {
                    this.interactivityService.bind(behaviorOptions.dataPoints, this.behavior, behaviorOptions);
                }
            };
            Map.prototype.onClearSelection = function () {
                this.interactivityService.clearSelection();
                this.updateOffsets(false, false /* dataChanged */);
            };
            Map.prototype.clearDataPoints = function () {
                this.dataPointRenderer.clearDataPoints();
                this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
            };
            Map.prototype.getDefaultMapControlFactory = function () {
                return {
                    createMapControl: function (element, options) { return new Microsoft.Maps.Map(element, options); },
                    ensureMap: jsCommon.ensureMap,
                };
            };
            Map.MapContainer = {
                cssClass: 'mapControl',
                selector: '.mapControl'
            };
            Map.StrokeDarkenColorValue = 255 * 0.25;
            return Map;
        }());
        visuals.Map = Map;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var UrlUtils = jsCommon.UrlUtils;
        var EdgeSettings = powerbi.visuals.controls.internal.TablixUtils.EdgeSettings;
        var TitleFontFamily = 'wf_segoe-ui_semibold';
        var DefaultFontFamily = 'wf_segoe-ui_normal';
        var DefaultCaptionFontSizeInPt = 10;
        var DefaultTitleFontSizeInPt = 13;
        var DefaultDetailFontSizeInPt = 9;
        var DefaultTitleColor = '#767676';
        var DefaultTextColor = '#333333';
        var DefaultCategoryColor = '#ACACAC';
        var DefaultOutline = visuals.outline.none;
        var DefaultOutlineColor = '#E8E8E8';
        var DefaultOutlineWeight = 1;
        var DefaultBarShow = true;
        var DefaultBarColor = '#A6A6A6';
        var DefaultBarOutline = visuals.outline.leftOnly;
        var DefaultBarWeight = 3;
        var MultiRowCard = (function () {
            function MultiRowCard() {
                this.isInteractivityOverflowHidden = false;
            }
            MultiRowCard.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.options = options;
                this.style = options.style;
                var viewport = this.currentViewport = options.viewport;
                var interactivity = this.interactivity = options.interactivity;
                if (interactivity && interactivity.overflow === 'hidden')
                    this.isInteractivityOverflowHidden = true;
                var multiRowCardDiv = this.element = $('<div/>')
                    .addClass(MultiRowCard.MultiRowCardRoot.class)
                    .css({
                    'height': getPixelString(viewport.height),
                });
                options.element.append(multiRowCardDiv);
                this.initializeCardRowSelection();
            };
            MultiRowCard.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var dataView = this.dataView = dataViews[0];
                    var columnMetadata = dataView.table.columns;
                    var tableRows = dataView.table.rows;
                    var resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append;
                    var data_2 = this.data = MultiRowCard.converter(dataView, columnMetadata.length, tableRows.length, this.isInteractivityOverflowHidden);
                    this.setCardDimensions();
                    this.listView.data(data_2.dataModel, function (d) { return data_2.dataModel.indexOf(d); }, resetScrollbarPosition);
                }
                else {
                    this.data = {
                        dataModel: [],
                        dataColumnCount: 0,
                        cardTitleSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTitleColor, DefaultTitleFontSizeInPt),
                        categoryLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultCategoryColor, DefaultDetailFontSizeInPt),
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTextColor, DefaultCaptionFontSizeInPt),
                        cardSettings: MultiRowCard.getCardSettings(null)
                    };
                }
                this.waitingForData = false;
            };
            MultiRowCard.getCardSettings = function (dataView) {
                var objects = dataView && dataView.metadata && dataView.metadata.objects ? dataView.metadata.objects : null;
                var outlineSettings = {
                    outline: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.outline, DefaultOutline),
                    color: powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.outlineColor, DefaultOutlineColor),
                    weight: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.outlineWeight, DefaultOutlineWeight),
                };
                var barShow = powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.barShow, DefaultBarShow);
                var barSettings = {
                    // If the bar is hidden, set the outline to none
                    outline: barShow ? DefaultBarOutline : visuals.outline.none,
                    color: powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.barColor, DefaultBarColor),
                    weight: powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.barWeight, DefaultBarWeight),
                };
                var cardPadding = powerbi.DataViewObjects.getValue(objects, visuals.multiRowCardProps.card.cardPadding, MultiRowCard.DefaultStyle.row.marginBottom);
                var cardBackground = powerbi.DataViewObjects.getFillColor(objects, visuals.multiRowCardProps.card.cardBackground, MultiRowCard.DefaultStyle.row.background);
                return {
                    outlineSettings: outlineSettings,
                    barSettings: barSettings,
                    cardPadding: cardPadding,
                    cardBackground: cardBackground
                };
            };
            MultiRowCard.prototype.onResizing = function (viewport) {
                var heightNotChanged = (this.currentViewport.height === viewport.height);
                this.currentViewport = viewport;
                this.element.css('height', getPixelString(viewport.height));
                if (!this.dataView)
                    return;
                var previousMaxColPerRow = this.maxColPerRow;
                this.maxColPerRow = this.getMaxColPerRow();
                var widthNotChanged = (previousMaxColPerRow === this.maxColPerRow);
                if (heightNotChanged && widthNotChanged)
                    return;
                this.listView.viewport(viewport);
            };
            MultiRowCard.converter = function (dataView, columnCount, maxCards, isDashboardVisual) {
                if (isDashboardVisual === void 0) { isDashboardVisual = false; }
                var details = [];
                var tableDataRows = dataView.table.rows;
                var columnMetadata = dataView.table.columns;
                var cardTitleSettings, dataLabelsSettings, categoryLabelsSettings;
                cardTitleSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTitleColor, DefaultTitleFontSizeInPt);
                dataLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultTextColor, DefaultCaptionFontSizeInPt);
                categoryLabelsSettings = visuals.dataLabelUtils.getDefaultLabelSettings(true, DefaultCategoryColor, DefaultDetailFontSizeInPt);
                if (dataView.metadata && dataView.metadata.objects) {
                    var cardTitleLabelObjects = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'cardTitle');
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(cardTitleLabelObjects, cardTitleSettings);
                    var dataLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'dataLabels');
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(dataLabelObject, dataLabelsSettings);
                    var categoryLabelObject = powerbi.DataViewObjects.getObject(dataView.metadata.objects, 'categoryLabels');
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(categoryLabelObject, categoryLabelsSettings);
                }
                for (var i = 0, len = maxCards; i < len; i++) {
                    var row = tableDataRows[i];
                    var isValuePromoted = undefined;
                    var title = undefined;
                    var showTitleAsURL = false;
                    var showTitleAsImage = false;
                    var showTitleAsKPI = false;
                    var cardData = [];
                    for (var j = 0; j < columnCount; j++) {
                        var column = columnMetadata[j];
                        var statusGraphicInfo = getKpiImageMetadata(column, row[j]);
                        var columnCaption = void 0;
                        var statusGraphic = void 0;
                        if (statusGraphicInfo) {
                            columnCaption = statusGraphicInfo.class;
                            statusGraphic = statusGraphicInfo.statusGraphic;
                        }
                        //TODO: seems we are duplicating this logic in many places. Consider putting it in KPIUtil
                        if (!columnCaption)
                            columnCaption = visuals.valueFormatter.format(row[j], visuals.valueFormatter.getFormatString(column, MultiRowCard.formatStringProp));
                        var showKPI = statusGraphicInfo !== undefined && statusGraphicInfo.caption !== undefined;
                        // The columnDetail represents column name. In card the column name is shown as details
                        var columnDetail = columnMetadata[j].displayName;
                        //Title is shown only on Canvas and only if there is one Category field.
                        if (!isDashboardVisual && !column.type.numeric) {
                            if (isValuePromoted === undefined) {
                                isValuePromoted = true;
                                title = columnCaption;
                                showTitleAsURL = visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(title);
                                showTitleAsImage = visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption);
                                showTitleAsKPI = showKPI;
                            }
                            else if (isValuePromoted) {
                                isValuePromoted = false;
                            }
                        }
                        cardData.push({
                            caption: columnCaption,
                            details: columnDetail,
                            showURL: visuals.converterHelper.isWebUrlColumn(column) && UrlUtils.isValidUrl(columnCaption),
                            showImage: visuals.converterHelper.isImageUrlColumn(column) && UrlUtils.isValidImageUrl(columnCaption),
                            showKPI: showKPI,
                            columnIndex: j
                        });
                    }
                    details.push({
                        title: isValuePromoted ? title : undefined,
                        showTitleAsURL: showTitleAsURL,
                        showTitleAsImage: showTitleAsImage,
                        showTitleAsKPI: showTitleAsKPI,
                        cardItemsData: isValuePromoted ? cardData.filter(function (d) { return d.caption !== title; }) : cardData
                    });
                }
                return {
                    dataModel: details,
                    dataColumnCount: details[0] ? details[0].cardItemsData.length : 0,
                    cardTitleSettings: cardTitleSettings,
                    categoryLabelsSettings: categoryLabelsSettings,
                    dataLabelsSettings: dataLabelsSettings,
                    cardSettings: MultiRowCard.getCardSettings(dataView)
                };
            };
            MultiRowCard.getSortableRoles = function (options) {
                if (!options || !options.dataViewMappings || _.isEmpty(options.dataViewMappings)) {
                    return;
                }
                for (var _i = 0, _a = options.dataViewMappings; _i < _a.length; _i++) {
                    var dataViewMapping = _a[_i];
                    if (dataViewMapping.table) {
                        var rows = dataViewMapping.table.rows;
                        if (rows && rows.for && rows.for.in && rows.for.in.items) {
                            return [MultiRowCard.ValuesRole];
                        }
                    }
                }
                return;
            };
            MultiRowCard.prototype.initializeCardRowSelection = function () {
                var _this = this;
                var isDashboardVisual = this.isInteractivityOverflowHidden;
                var rowEnter = function (rowSelection) {
                    var cardRow = rowSelection
                        .append("div")
                        .classed(MultiRowCard.Card.class, true);
                    // The card top padding is not needed when card items are wrapped as top padding is added to each carditemcontainer when wrapped
                    if (isDashboardVisual) {
                        cardRow.classed('mrtile', true);
                    }
                    else {
                        if (_this.cardHasTitle) {
                            cardRow.append("div").classed(MultiRowCard.Title.class, true)
                                .each(function (d) {
                                if (d.showTitleAsImage)
                                    appendImage(d3.select(this));
                                else if (d.showTitleAsURL)
                                    d3.select(this).append('a');
                                else if (d.showTitleAsKPI)
                                    d3.select(this).append('div')
                                        .classed(MultiRowCard.KPITitle.class, true)
                                        .classed(d.title, true)
                                        .style({
                                        display: 'inline-block',
                                        verticalAlign: 'sub'
                                    });
                            });
                        }
                    }
                    var cardItem = cardRow
                        .selectAll(MultiRowCard.CardItemContainer.selector)
                        .data(function (d) { return d.cardItemsData; })
                        .enter()
                        .append('div')
                        .classed(MultiRowCard.CardItemContainer.class, true);
                    cardItem
                        .append('div')
                        .classed(MultiRowCard.Caption.class, true)
                        .each(function (d) {
                        if (d.showURL) {
                            d3.select(this).append('a');
                        }
                        else if (d.showImage) {
                            appendImage(d3.select(this));
                        }
                        else if (d.showKPI) {
                            d3.select(this).append('div')
                                .classed(d.caption, true)
                                .style({
                                display: 'inline-block',
                                verticalAlign: 'sub'
                            });
                        }
                    });
                    cardItem
                        .append('div')
                        .classed(MultiRowCard.Details.class, true);
                };
                /**
                * Row update should:
                * 1. bind Data
                * 2. Manipulate DOM (likely just updating CSS properties) affected by data
                */
                var rowUpdate = function (rowSelection) {
                    var style = _this.getStyle();
                    var dataLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(false, style.caption.fontSize));
                    var categoryLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(false, style.details.fontSize));
                    var titleLabelHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(MultiRowCard.getTextProperties(true, style.title.fontSize));
                    var rowBorderStyle = _this.getBorderStyles(style.row.border);
                    rowSelection
                        .style(rowBorderStyle)
                        .style({
                        'margin-bottom': isDashboardVisual ? '0px' : (_this.isSingleRowCard ? '0px' : getPixelString(style.row.marginBottom)),
                        'background': style.row.background
                    });
                    if (!isDashboardVisual && _this.cardHasTitle) {
                        rowSelection.selectAll(MultiRowCard.Title.selector)
                            .filter(function (d) { return !d.showTitleAsImage && !d.showTitleAsKPI; })
                            .style({
                            'font-size': PixelConverter.fromPoint(style.title.fontSize),
                            'line-height': PixelConverter.toString(titleLabelHeight),
                            'color': style.title.color,
                        });
                        rowSelection.selectAll(MultiRowCard.Title.selector)
                            .filter(function (d) { return !d.showTitleAsURL && !d.showTitleAsImage && !d.showTitleAsKPI; })
                            .text(function (d) { return d.title; })
                            .attr('title', function (d) { return d.title; });
                        rowSelection
                            .selectAll(MultiRowCard.TitleUrlSelector)
                            .text(function (d) { return d.title; })
                            .attr({
                            'href': function (d) { return d.title; },
                            'target': '_blank',
                        });
                        rowSelection
                            .selectAll(MultiRowCard.TitleImageSelector)
                            .attr('src', function (d) { return d.title; });
                        setImageStyle(rowSelection.selectAll(MultiRowCard.Title.selector), style.imageTitle);
                        rowSelection
                            .selectAll(MultiRowCard.KPITitle.selector)
                            .each(function (d) {
                            var element = d3.select(this);
                            element.classed(d.title);
                        });
                    }
                    var cardSelection = rowSelection.selectAll(MultiRowCard.Card.selector);
                    var cardBorderStyle = _this.getBorderStyles(style.card.border);
                    cardSelection.style(cardBorderStyle);
                    cardSelection
                        .selectAll(MultiRowCard.Caption.selector)
                        .filter(function (d) { return !d.showImage; })
                        .style({
                        'line-height': PixelConverter.toString(dataLabelHeight),
                        'font-size': PixelConverter.fromPoint(style.caption.fontSize),
                    })
                        .filter(function (d) { return !d.showKPI; })
                        .style({
                        'color': style.caption.color,
                    })
                        .filter(function (d) { return !d.showURL; })
                        .text(function (d) { return d.caption; })
                        .attr('title', function (d) { return d.caption; });
                    cardSelection
                        .selectAll(MultiRowCard.CaptionImageSelector)
                        .attr('src', function (d) { return d.caption; })
                        .style(style.imageCaption);
                    cardSelection
                        .selectAll(MultiRowCard.CardItemContainer.selector)
                        .style({
                        'padding-right': function (d) {
                            return _this.isLastRowItem(d.columnIndex, _this.dataView.metadata.columns.length) ? '0px' : getPixelString(style.cardItemContainer.paddingRight);
                        },
                        'width': function (d) {
                            return _this.getColumnWidth(d.columnIndex, _this.data.dataColumnCount);
                        },
                        'display': function (d) {
                            return (_this.hideColumn(d.columnIndex) ? 'none' : 'inline-block');
                        },
                    });
                    setImageStyle(cardSelection.selectAll(MultiRowCard.Caption.selector), style.imageCaption);
                    cardSelection
                        .selectAll(MultiRowCard.CaptionUrlSelector)
                        .attr({
                        'href': function (d) { return d.caption; },
                        'target': '_blank',
                    })
                        .text(function (d) { return d.caption; });
                    if (style.details.isVisible) {
                        cardSelection
                            .selectAll(MultiRowCard.Details.selector)
                            .text(function (d) { return d.details; })
                            .style({
                            'font-size': PixelConverter.fromPoint(style.details.fontSize),
                            'line-height': PixelConverter.toString(categoryLabelHeight),
                            'color': style.details.color
                        })
                            .attr('title', function (d) { return d.details; });
                    }
                };
                var rowExit = function (rowSelection) {
                    rowSelection.remove();
                };
                var listViewOptions = {
                    rowHeight: undefined,
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function () { return _this.onLoadMoreData(); },
                    viewport: this.currentViewport,
                    baseContainer: d3.select(this.element.get(0)),
                    scrollEnabled: !this.isInteractivityOverflowHidden,
                    isReadMode: function () {
                        return (_this.options.host.getViewMode() !== 1 /* Edit */);
                    }
                };
                this.listView = visuals.ListViewFactory.createListView(listViewOptions);
            };
            MultiRowCard.prototype.getBorderStyles = function (border) {
                return {
                    'border-top': border && border.top ? border.top.getCSS() : '',
                    'border-right': border && border.right ? border.right.getCSS() : '',
                    'border-bottom': border && border.bottom ? border.bottom.getCSS() : '',
                    'border-left': border && border.left ? border.left.getCSS() : ''
                };
            };
            MultiRowCard.prototype.getMaxColPerRow = function () {
                var rowWidth = this.currentViewport.width;
                var minColumnWidth = this.getStyle().cardItemContainer.minWidth;
                var columnCount = this.data.dataColumnCount;
                //atleast one column fits in a row
                var maxColumnPerRow = Math.floor(rowWidth / minColumnWidth) || 1;
                return Math.min(columnCount, maxColumnPerRow);
            };
            MultiRowCard.prototype.getRowIndex = function (fieldIndex) {
                return Math.floor((fieldIndex * 1.0) / this.getMaxColPerRow());
            };
            MultiRowCard.prototype.getStyle = function () {
                var defaultStyles = MultiRowCard.DefaultStyle;
                var customStyles = this.getCustomStyles();
                if (!this.isInteractivityOverflowHidden)
                    return $.extend(true, {}, defaultStyles, customStyles);
                var viewportWidth = this.currentViewport.width;
                var overrideStyle = {};
                for (var _i = 0, _a = MultiRowCard.tileMediaQueries; _i < _a.length; _i++) {
                    var currentQuery = _a[_i];
                    if (viewportWidth <= currentQuery.maxWidth) {
                        overrideStyle = currentQuery.style;
                        break;
                    }
                }
                return $.extend(true, {}, defaultStyles, customStyles, overrideStyle);
            };
            MultiRowCard.prototype.getSurroundSettings = function (outlineSettings) {
                var edge = new EdgeSettings(outlineSettings.weight, outlineSettings.color);
                var outlineProp = outlineSettings.outline;
                return {
                    top: visuals.outline.showTop(outlineProp) ? edge : null,
                    right: visuals.outline.showRight(outlineProp) ? edge : null,
                    bottom: visuals.outline.showBottom(outlineProp) ? edge : null,
                    left: visuals.outline.showLeft(outlineProp) ? edge : null,
                };
            };
            MultiRowCard.prototype.getCustomStyles = function () {
                var dataLabelsSettings = this.data.dataLabelsSettings;
                var categoryLabelSettings = this.data.categoryLabelsSettings;
                var titleLabelSettings = this.data.cardTitleSettings;
                var cardSettings = this.data.cardSettings;
                var customStyle = {
                    row: {
                        border: this.getSurroundSettings(cardSettings.outlineSettings),
                        marginBottom: cardSettings.cardPadding,
                        background: cardSettings.cardBackground
                    },
                    card: {
                        border: this.getSurroundSettings(cardSettings.barSettings)
                    },
                    details: {
                        fontSize: categoryLabelSettings.fontSize,
                        color: categoryLabelSettings.labelColor,
                        isVisible: categoryLabelSettings.show,
                    },
                    caption: {
                        fontSize: dataLabelsSettings.fontSize,
                        color: dataLabelsSettings.labelColor,
                    },
                    title: {
                        fontSize: titleLabelSettings.fontSize,
                        color: titleLabelSettings.labelColor,
                    }
                };
                return customStyle;
            };
            MultiRowCard.getTextProperties = function (isTitle, fontSizeInPt) {
                return {
                    fontFamily: isTitle ? TitleFontFamily : DefaultFontFamily,
                    fontSize: PixelConverter.fromPoint(fontSizeInPt),
                };
            };
            MultiRowCard.prototype.hideColumn = function (fieldIndex) {
                //calculate the number of items apearing in the same row as the columnIndex
                var rowIndex = this.getRowIndex(fieldIndex);
                // when interactivity is disabled (pinned tile), don't wrap the row
                var maxRows = this.getStyle().card.maxRows;
                return (maxRows && rowIndex >= maxRows);
            };
            MultiRowCard.prototype.getColumnWidth = function (fieldIndex, columnCount) {
                //atleast one column fits in a row
                var maxColumnPerRow = this.getMaxColPerRow();
                if (maxColumnPerRow >= columnCount)
                    //all columns fit in the same row, divide the space equaly
                    return (100.0 / columnCount) + '%';
                //calculate the number of items apearing in the same row as the columnIndex
                var rowIndex = this.getRowIndex(fieldIndex);
                var totalRows = Math.ceil((columnCount * 1.0) / maxColumnPerRow);
                var lastRowCount = columnCount % maxColumnPerRow;
                if (rowIndex < totalRows || lastRowCount === 0)
                    // items is not on the last row or last row contains max columns allowed per row
                    return (100.0 / maxColumnPerRow) + '%';
                // items is on the last row
                return (100.0 / lastRowCount) + '%';
            };
            MultiRowCard.prototype.isLastRowItem = function (fieldIndex, columnCount) {
                if (fieldIndex + 1 === columnCount)
                    return true;
                var maxColumnPerRow = this.getMaxColPerRow();
                if (maxColumnPerRow - (fieldIndex % maxColumnPerRow) === 1)
                    return true;
                return false;
            };
            /**
             * This contains the card column wrapping logic.
             * Determines how many columns can be shown per each row inside a Card.
             * To place the fields evenly along the card,
             * the width of each card item is calculated based on the available viewport width.
             */
            MultiRowCard.prototype.setCardDimensions = function () {
                this.cardHasTitle = false;
                var dataModel = this.data.dataModel;
                if (!this.isInteractivityOverflowHidden && dataModel && dataModel.length > 0) {
                    this.cardHasTitle = dataModel[0].title !== undefined;
                    this.isSingleRowCard = dataModel.length === 1 ? true : false;
                }
            };
            MultiRowCard.prototype.onLoadMoreData = function () {
                if (!this.waitingForData && this.dataView.metadata && this.dataView.metadata.segment) {
                    this.options.host.loadMoreData();
                    this.waitingForData = true;
                }
            };
            MultiRowCard.getDataLabelSettingsOptions = function (enumeration, labelSettings, show) {
                if (show === void 0) { show = false; }
                return {
                    enumeration: enumeration,
                    dataLabelsSettings: labelSettings,
                    show: show,
                    fontSize: true,
                };
            };
            MultiRowCard.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                var cardTitleSettings = this.data.cardTitleSettings;
                var dataLabelsSettings = this.data.dataLabelsSettings;
                var categoryLabelsSettings = this.data.categoryLabelsSettings;
                switch (options.objectName) {
                    case 'cardTitle':
                        //display title options only if title visible
                        if (!this.isInteractivityOverflowHidden && this.cardHasTitle)
                            visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, cardTitleSettings));
                        break;
                    case 'dataLabels':
                        visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, dataLabelsSettings));
                        break;
                    case 'categoryLabels':
                        visuals.dataLabelUtils.enumerateDataLabels(MultiRowCard.getDataLabelSettingsOptions(enumeration, categoryLabelsSettings, true));
                        break;
                    case visuals.multiRowCardProps.card.outline.objectName:
                        this.enumerateCard(enumeration);
                        break;
                }
                return enumeration.complete();
            };
            MultiRowCard.prototype.enumerateCard = function (enumeration) {
                var cardSettings = this.data.cardSettings;
                var propNames = visuals.multiRowCardProps.card;
                var properties = {};
                var outlineSettings = cardSettings.outlineSettings;
                properties[propNames.outline.propertyName] = outlineSettings.outline;
                if (outlineSettings.outline !== visuals.outline.none) {
                    properties[propNames.outlineColor.propertyName] = outlineSettings.color;
                    properties[propNames.outlineWeight.propertyName] = outlineSettings.weight;
                }
                var barSettings = cardSettings.barSettings;
                // The bar is shown if the outline value is not none
                var barShow = barSettings.outline !== visuals.outline.none;
                properties[propNames.barShow.propertyName] = barShow;
                if (barShow) {
                    properties[propNames.barColor.propertyName] = barSettings.color;
                    properties[propNames.barWeight.propertyName] = barSettings.weight;
                }
                properties[propNames.cardPadding.propertyName] = cardSettings.cardPadding;
                properties[propNames.cardBackground.propertyName] = cardSettings.cardBackground;
                enumeration.pushInstance({
                    selector: null,
                    objectName: propNames.outline.objectName,
                    properties: properties
                });
            };
            /**
             * Note: Public for testability.
             */
            MultiRowCard.formatStringProp = {
                objectName: 'general',
                propertyName: 'formatString',
            };
            MultiRowCard.MultiRowCardRoot = createClassAndSelector('multiRowCard');
            MultiRowCard.Card = createClassAndSelector('card');
            MultiRowCard.Title = createClassAndSelector('title');
            MultiRowCard.CardItemContainer = createClassAndSelector('cardItemContainer');
            MultiRowCard.Caption = createClassAndSelector('caption');
            MultiRowCard.Details = createClassAndSelector('details');
            MultiRowCard.TitleUrlSelector = MultiRowCard.Title.selector + ' a';
            MultiRowCard.CaptionUrlSelector = MultiRowCard.Caption.selector + ' a';
            MultiRowCard.TitleImageSelector = MultiRowCard.Title.selector + ' img';
            MultiRowCard.CaptionImageSelector = MultiRowCard.Caption.selector + ' img';
            MultiRowCard.KPITitle = createClassAndSelector('kpiTitle');
            MultiRowCard.ValuesRole = 'Values';
            /**
             * Cards have specific styling so defined inline styles and also to support theming and improve performance.
             */
            MultiRowCard.DefaultStyle = {
                row: {
                    border: null,
                    marginBottom: 20,
                    background: undefined
                },
                card: {
                    border: null
                },
                cardItemContainer: {
                    paddingRight: 20,
                    minWidth: 120,
                },
                imageCaption: {
                    maxHeight: 75,
                    maxWidth: 100,
                },
                imageTitle: {
                    maxHeight: 75,
                    maxWidth: 100,
                }
            };
            // queries should be ordered by maxWidth in ascending order
            MultiRowCard.tileMediaQueries = [
                {
                    maxWidth: 250,
                    style: {
                        card: {
                            maxRows: 2,
                        },
                        cardItemContainer: {
                            minWidth: 110,
                        },
                        imageCaption: {
                            maxHeight: 45,
                        }
                    }
                },
                {
                    maxWidth: 490,
                    style: {
                        card: {
                            maxRows: 2,
                        },
                        cardItemContainer: {
                            minWidth: 130,
                        },
                        imageCaption: {
                            maxHeight: 52,
                        }
                    }
                },
                {
                    maxWidth: 750,
                    style: {
                        card: {
                            maxRows: 1,
                        },
                        cardItemContainer: {
                            minWidth: 120,
                        },
                        imageCaption: {
                            maxHeight: 53,
                        }
                    }
                }
            ];
            return MultiRowCard;
        }());
        visuals.MultiRowCard = MultiRowCard;
        function appendImage(selection) {
            selection
                .append('div')
                .classed('imgCon', true)
                .append('img');
        }
        function setImageStyle(selection, imageStyle) {
            selection
                .selectAll('.imgCon')
                .style({
                'height': getPixelString(imageStyle.maxHeight),
            })
                .selectAll('img')
                .style({
                'max-height': getPixelString(imageStyle.maxHeight),
                'max-width': getPixelString(imageStyle.maxWidth),
            });
        }
        function getPixelString(value) {
            return value + "px";
        }
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var StringExtensions = jsCommon.StringExtensions;
        var UrlUtils = jsCommon.UrlUtils;
        /** Represents a rich text box that supports view & edit mode. */
        var Textbox = (function () {
            function Textbox() {
            }
            Textbox.prototype.init = function (options) {
                this.element = options.element;
                this.host = options.host;
                this.viewport = options.viewport;
                this.readOnly = (this.host.getViewMode() === 0 /* View */);
                this.paragraphs = [];
                this.refreshView();
            };
            Textbox.prototype.onResizing = function (viewport) {
                this.viewport = viewport;
                this.updateSize();
            };
            Textbox.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                this.paragraphs = [];
                if (dataViews && dataViews.length > 0) {
                    var objects = dataViews[0].metadata.objects;
                    if (objects && objects.general)
                        this.paragraphs = objects.general.paragraphs;
                }
                this.refreshView();
            };
            Textbox.prototype.destroy = function () {
            };
            Textbox.prototype.focus = function () {
                if (!this.editor)
                    return;
                this.editor.focus();
                return true;
            };
            Textbox.prototype.onViewModeChanged = function (viewMode) {
                this.readOnly = (viewMode === 0 /* View */);
                this.refreshView();
            };
            Textbox.prototype.setSelection = function (start, end) {
                debug.assertValue(this.editor, 'editor');
                if (this.editor)
                    this.editor.setSelection(start, end);
            };
            Textbox.prototype.refreshView = function () {
                var _this = this;
                if (this.readOnly) {
                    // Showing just HTML, no editor.
                    // If we are in view-mode and we have an editor, we can remove it (after saving).
                    if (this.editor) {
                        this.saveContents();
                        this.editor.destroy();
                        this.editor = null;
                    }
                    this.element.empty();
                    var htmlContent = RichTextConversion.convertParagraphsToHtml(this.paragraphs);
                    htmlContent.addClass(Textbox.ClassName);
                    htmlContent.css({
                        'font-family': RichText.defaultFont,
                        'font-size': RichText.defaultFontSize,
                    });
                    this.element.append(htmlContent);
                }
                else {
                    // Showing the Quill editor.
                    // If we are in edit-mode and we don't have an editor we need to create it.
                    if (!this.editor) {
                        this.editor = new RichText.QuillWrapper(this.readOnly, this.host);
                        this.editor.textChanged = function (delta, source) { return _this.saveContents(); };
                        this.element.empty();
                        var editorElement = this.editor.getElement();
                        editorElement.addClass(Textbox.ClassName);
                        editorElement.css({
                            'font-family': RichText.defaultFont,
                            'font-size': RichText.defaultFontSize,
                        });
                        this.element.append(editorElement);
                    }
                    this.editor.setContents(RichTextConversion.convertParagraphsToOps(this.paragraphs));
                }
                this.updateSize();
            };
            Textbox.prototype.saveContents = function () {
                // It's possible to get here via a throttled text-changed event after a view-mode change has occured and
                // we are now in view mode. Since we save changes on view-mode change it is safe to ignore this call.
                if (!this.editor)
                    return;
                var contents = this.editor.getContents();
                this.paragraphs = RichTextConversion.convertDeltaToParagraphs(contents);
                var changes = [{
                        objectName: 'general',
                        properties: {
                            paragraphs: this.paragraphs
                        },
                        selector: null,
                    }];
                this.host.persistProperties(changes);
            };
            Textbox.prototype.updateSize = function () {
                if (this.editor)
                    this.editor.resize(this.viewport);
            };
            Textbox.ClassName = 'textbox';
            return Textbox;
        }());
        visuals.Textbox = Textbox;
        var RichTextConversion;
        (function (RichTextConversion) {
            function convertDeltaToParagraphs(contents) {
                var paragraphs = [];
                var paragraph = { textRuns: [] };
                for (var i = 0, len = contents.ops.length; i < len; i++) {
                    var insertOp = contents.ops[i];
                    debug.assertValue(insertOp, "operation should be an insert");
                    if (typeof insertOp.insert === "string") {
                        // string insert values represent text.
                        var text = insertOp.insert;
                        var attributes = insertOp.attributes;
                        if (attributes && attributes.align) {
                            // Sometimes horizontal alignment is set after the first "insert" of the paragraph, which is likely a bug
                            // in Quill. In any case we should never see different horizontal alignments in a single paragraph.
                            debug.assert(paragraph.horizontalTextAlignment === undefined || paragraph.horizontalTextAlignment === attributes.align, 'paragraph should not have more than one horizontal alignment');
                            paragraph.horizontalTextAlignment = attributes.align;
                        }
                        // Quill gives us back text runs that may have \n's in them. We want to create a new paragraph for each \n we see.
                        var start = 0;
                        var end = 0;
                        var newParagraph = void 0;
                        do {
                            end = text.indexOf('\n', start);
                            if (end < 0) {
                                newParagraph = false;
                                end = text.length;
                            }
                            else {
                                newParagraph = true;
                            }
                            if (end - start > 0) {
                                var span = text.substring(start, end);
                                var textRun = { value: span };
                                if (attributes) {
                                    if (attributes.link !== undefined && UrlUtils.isValidUrl(attributes.link))
                                        textRun.url = attributes.link;
                                    var textStyle = convertFormatAttributesToTextStyle(attributes);
                                    if (textStyle)
                                        textRun.textStyle = textStyle;
                                }
                                paragraph.textRuns.push(textRun);
                            }
                            // If we actually saw a '\n' then create a new paragraph
                            if (newParagraph) {
                                if (paragraph.textRuns.length === 0)
                                    paragraph.textRuns.push({ value: '' });
                                paragraphs.push(paragraph);
                                paragraph = { textRuns: [] };
                            }
                            start = end + 1;
                        } while (start < text.length);
                    }
                    else {
                        // numeric insert values represent embeds.
                        debug.assertFail("embeds not supported");
                    }
                }
                if (paragraph.textRuns.length > 0) {
                    // Quill appears to always insert an extra '\n' at the end of the text, skip it
                    if (paragraph.textRuns[0].value.length > 0)
                        paragraphs.push(paragraph);
                }
                return paragraphs;
            }
            RichTextConversion.convertDeltaToParagraphs = convertDeltaToParagraphs;
            function convertParagraphsToHtml(paragraphs) {
                var $paragraphs = $();
                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex];
                    var isParagraphEmpty = true;
                    var $paragraph = $('<div>');
                    if (paragraphDef.horizontalTextAlignment)
                        $paragraph.css('text-align', paragraphDef.horizontalTextAlignment);
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex];
                        var $textRun = $('<span>');
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            var css = {};
                            if (styleDef.fontFamily) {
                                css['font-family'] = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily));
                            }
                            if (styleDef.fontSize) {
                                css['font-size'] = styleDef.fontSize;
                            }
                            if (styleDef.fontStyle) {
                                css['font-style'] = styleDef.fontStyle;
                            }
                            if (styleDef.fontWeight) {
                                css['font-weight'] = styleDef.fontWeight;
                            }
                            if (styleDef.textDecoration) {
                                css['text-decoration'] = styleDef.textDecoration;
                            }
                            $textRun.css(css);
                        }
                        var text = textRunDef.value;
                        if (!_.isEmpty(text))
                            isParagraphEmpty = false;
                        if (textRunDef.url !== undefined) {
                            var $link = void 0;
                            if (UrlUtils.isValidUrl(textRunDef.url)) {
                                $link = $('<a>')
                                    .attr('href', textRunDef.url)
                                    .attr('target', '_blank')
                                    .text(text);
                            }
                            else {
                                $link = $('<span>').text(text);
                            }
                            $textRun.append($link);
                        }
                        else {
                            $textRun.text(text);
                        }
                        $paragraph.append($textRun);
                    }
                    // If the entire paragraph is empty we need to make sure we enforce a line-break.
                    if (isParagraphEmpty)
                        $paragraph.append($('<br>'));
                    $paragraphs = $paragraphs.add($paragraph);
                }
                return $paragraphs;
            }
            RichTextConversion.convertParagraphsToHtml = convertParagraphsToHtml;
            function convertParagraphsToOps(paragraphs) {
                var ops = [];
                for (var paragraphIndex = 0, len = paragraphs.length; paragraphIndex < len; ++paragraphIndex) {
                    var paragraphDef = paragraphs[paragraphIndex];
                    for (var textRunIndex = 0, jlen = paragraphDef.textRuns.length; textRunIndex < jlen; ++textRunIndex) {
                        var textRunDef = paragraphDef.textRuns[textRunIndex];
                        var formats = {};
                        if (paragraphDef.horizontalTextAlignment)
                            formats.align = paragraphDef.horizontalTextAlignment;
                        var styleDef = textRunDef.textStyle;
                        if (styleDef) {
                            if (styleDef.fontFamily) {
                                formats.font = RichText.getCssFontFamily(removeQuotes(styleDef.fontFamily));
                            }
                            if (styleDef.fontSize) {
                                formats.size = styleDef.fontSize;
                            }
                            formats.italic = (styleDef.fontStyle === 'italic');
                            formats.bold = (styleDef.fontWeight === 'bold');
                            formats.underline = (styleDef.textDecoration === 'underline');
                        }
                        var text = textRunDef.value;
                        if (textRunDef.url && UrlUtils.isValidUrl(textRunDef.url))
                            formats.link = textRunDef.url;
                        var op = {
                            insert: text,
                            attributes: formats,
                        };
                        ops.push(op);
                        // The last text run of the paragraph needs to end with '\n' to get Quill to handle the text alignment correctly.
                        if (textRunIndex === (jlen - 1) && !StringExtensions.endsWith(text, '\n')) {
                            ops.push({
                                insert: '\n',
                                attributes: formats,
                            });
                        }
                    }
                }
                return ops;
            }
            RichTextConversion.convertParagraphsToOps = convertParagraphsToOps;
            function convertFormatAttributesToTextStyle(attributes) {
                var style = {};
                // NOTE: Align is taken care of when converting to paragraphs.
                if (attributes.bold) {
                    style.fontWeight = 'bold';
                }
                if (attributes.font) {
                    // We should always save font names without any quotes.
                    var font = removeQuotes(attributes.font);
                    // Convert built-in font families back into their proper font families (e.g. wf_segoe-ui_normal -> Segoe UI)
                    font = RichText.getFontFamilyForBuiltInFont(font);
                    style.fontFamily = font;
                }
                if (attributes.italic) {
                    style.fontStyle = 'italic';
                }
                if (attributes.size) {
                    style.fontSize = attributes.size;
                }
                if (attributes.underline) {
                    style.textDecoration = 'underline';
                }
                /*
                TODO:
                if (attributes.background) {
                }
                if (attributes.color) {
                }
                */
                return style;
            }
            function removeQuotes(text) {
                if (!StringExtensions.startsWith(text, "'"))
                    return text;
                debug.assert(StringExtensions.endsWith(text, "'"), "mismatched quotes");
                return text.slice(1, text.length - 1);
            }
        })(RichTextConversion || (RichTextConversion = {}));
        var RichText;
        (function (RichText) {
            /**
             * These fonts are embedded using CSS, or are aliases to other fonts.
             */
            var fontMap = {
                'Segoe (Bold)': 'wf_segoe-ui_bold',
                'Segoe UI': 'wf_segoe-ui_normal',
                'Segoe UI Light': 'wf_segoe-ui_light',
                'Heading': 'wf_segoe-ui_light',
                'Body': 'wf_segoe-ui_normal',
            };
            var fonts = [
                'Arial',
                'Arial Black',
                'Arial Unicode MS',
                'Calibri',
                'Cambria',
                'Cambria Math',
                'Candara',
                'Comic Sans MS',
                'Consolas',
                'Constantia',
                'Corbel',
                'Courier New',
                'Georgia',
                'Lucida Sans Unicode',
                'Segoe (Bold)',
                'Segoe UI',
                'Segoe UI Light',
                'Symbol',
                'Tahoma',
                'Times New Roman',
                'Trebuchet MS',
                'Verdana',
                'Wingdings',
            ].map(function (font) { return { label: font, value: getCssFontFamily(font) }; });
            RichText.defaultFont = getCssFontFamily('Segoe UI Light');
            var fontSizes = [
                '8', '9', '10', '10.5', '11', '12', '14', '16', '18', '20', '24', '28', '32', '36', '40', '42', '44', '54', '60', '66', '72', '80', '88', '96'
            ].map(function (size) { return { label: size, value: size + 'px' }; });
            RichText.defaultFontSize = '14px';
            var textAlignments = [
                'Left',
                'Center',
                'Right',
            ].map(function (alignment) { return { label: alignment, value: alignment.toLowerCase() }; });
            /**
             * Given a font family returns the value we should use for the font-family css property.
             */
            function getCssFontFamily(font) {
                var family = fontMap[font];
                if (family == null)
                    family = font;
                return family;
            }
            RichText.getCssFontFamily = getCssFontFamily;
            /**
             * Convert built-in font families back into their proper font families (e.g. wf_segoe-ui_normal -> Segoe UI)
             */
            function getFontFamilyForBuiltInFont(font) {
                var fontFamily = _.findKey(fontMap, function (value) { return value === font; });
                return fontFamily || font;
            }
            RichText.getFontFamilyForBuiltInFont = getFontFamilyForBuiltInFont;
            var QuillWrapper = (function () {
                /**
                 * JavaScript and CSS resources are typically resolved asynchronously.
                 * This means we potentially defer certain events which typically occur
                 * synchronously until resources are loaded.
                 * Setting the global loadQuillResources flag to true will override
                 * this behavior and cause the wrapper to assume these resources are already loaded
                 * and not try to load them asynchronously (e.g. for use in unit tests).
                 */
                function QuillWrapper(readOnly, host) {
                    var _this = this;
                    this.QuillPackage = {
                        javaScriptFiles: QuillWrapper.quillJsFiles,
                        cssFiles: QuillWrapper.quillCssFiles,
                    };
                    this.textChanged = function (d, s) { };
                    this.host = host;
                    this.$container = $('<div>');
                    this.readOnly = readOnly;
                    this.localizationProvider = {
                        get: function (stringId) { return _this.host.getLocalizedString(stringId); },
                        getOptional: function (stringId) { return _this.host.getLocalizedString(stringId); }
                    };
                    this.dependenciesLoaded = $.Deferred();
                    if (QuillWrapper.loadQuillResources) {
                        // Defer creation of the editor until after resources are loaded.
                        this.initialized = false;
                        // Note that these are called in the order registered so this will always be called before other callbacks.
                        this.dependenciesLoaded.done(function () {
                            _this.rebuildQuillEditor();
                            _this.initialized = true;
                        });
                        jsCommon.requires(this.QuillPackage, function () { return _this.dependenciesLoaded.resolve(); });
                    }
                    else {
                        this.rebuildQuillEditor();
                        this.initialized = true;
                        this.dependenciesLoaded.resolve();
                    }
                }
                QuillWrapper.prototype.addModule = function (name, options) {
                    if (this.editor)
                        return this.editor.addModule(name, options);
                };
                QuillWrapper.prototype.getElement = function () {
                    return this.$container;
                };
                QuillWrapper.prototype.getContents = function () {
                    if (this.initialized)
                        return this.editor.getContents();
                };
                QuillWrapper.prototype.setContents = function (contents) {
                    var _this = this;
                    // If we haven't loaded the editor yet, defer this call until we do
                    // TODO: prevent these from stacking up?
                    if (!this.initialized) {
                        this.dependenciesLoaded.done(function () { return _this.setContents(contents); });
                        return;
                    }
                    this.editor.setHTML('', 'api'); // Clear contents
                    if (contents)
                        this.editor.setContents(contents, 'api');
                };
                QuillWrapper.prototype.resize = function (viewport) {
                    this.$container.width(viewport.width);
                    this.$container.height(viewport.height);
                };
                QuillWrapper.prototype.setReadOnly = function (readOnly) {
                    var readOnlyChanged = readOnly !== this.readOnly;
                    this.readOnly = readOnly;
                    if (this.initialized && readOnlyChanged) {
                        this.rebuildQuillEditor();
                    }
                };
                QuillWrapper.prototype.setSelection = function (start, end) {
                    if (this.editor)
                        this.editor.setSelection(start, end, 'api');
                };
                QuillWrapper.prototype.getSelection = function () {
                    if (this.editor)
                        return this.editor.getSelection();
                };
                QuillWrapper.prototype.focus = function () {
                    if (!this.editor)
                        return;
                    if ($(document.activeElement).closest(this.$container).length === 0)
                        this.editor.focus();
                };
                QuillWrapper.prototype.destroy = function () {
                    this.host.setToolbar(null);
                    this.$container.remove();
                    this.$container = null;
                    this.$toolbarDiv = null;
                    this.$editorDiv = null;
                    this.editor = null;
                };
                QuillWrapper.prototype.getSelectionAtCursor = function () {
                    var text = this.getTextWithoutTrailingBreak();
                    // Ensure editor has focus before selection interactions
                    this.editor.focus();
                    var selection = this.getSelection();
                    if (selection && selection.start === selection.end) {
                        return jsCommon.WordBreaker.find(selection.start, text);
                    }
                    return selection;
                };
                QuillWrapper.prototype.getWord = function () {
                    var selection = this.getSelectionAtCursor();
                    return this.getTextWithoutTrailingBreak().slice(selection.start, selection.end);
                };
                QuillWrapper.prototype.insertLinkAtCursor = function (link, index) {
                    var endIndex = index + link.length;
                    this.editor.insertText(index, link, 'api');
                    this.editor.formatText(index, endIndex, 'link', link, 'api');
                    this.setSelection(index, endIndex);
                    this.onTextChanged(null, null);
                    return endIndex;
                };
                QuillWrapper.prototype.getEditorContainer = function () {
                    if (this.editor)
                        return $(this.editor.container);
                };
                ;
                QuillWrapper.prototype.getTextWithoutTrailingBreak = function () {
                    return this.editor.getText().slice(0, -1);
                };
                QuillWrapper.prototype.rebuildQuillEditor = function () {
                    var _this = this;
                    // Preserve contents if we already have an editor.
                    var contents = null;
                    if (this.editor) {
                        this.editor.removeAllListeners();
                        contents = this.editor.getContents();
                    }
                    this.$container.empty();
                    // Prevent parent elements from handling keyboard shortcuts (e.g. ctrl+a) that have special meaning for textboxes.
                    // Quill will also capture and prevent bubbling of some keyboard shortcuts, such as ctrl+c, ctrl+b, etc.
                    this.$container.keydown(function (e) {
                        if (e.ctrlKey && _.contains(QuillWrapper.preventDefaultKeys, e.which))
                            e.stopPropagation();
                    });
                    var $editorDiv = this.$editorDiv = $('<div>');
                    // HACK: Quill does not apply the correct default styling if you clear all the content and add new content.
                    $editorDiv.css('font-family', RichText.defaultFont);
                    $editorDiv.css('font-size', RichText.defaultFontSize);
                    var configs = {
                        readOnly: this.readOnly,
                        formats: ['bold', 'italic', 'underline', 'font', 'size', 'link', 'align',],
                        styles: false,
                    };
                    this.editor = new Quill($editorDiv.get(0), configs);
                    // If not readonly we add a toolbar and disable drag/resize
                    if (!this.readOnly) {
                        var $toolbarDiv = this.$toolbarDiv;
                        if (!$toolbarDiv) {
                            this.$toolbarDiv = $toolbarDiv = Toolbar.buildToolbar(this, this.localizationProvider);
                        }
                        $toolbarDiv.addClass('unselectable');
                        this.host.setToolbar($toolbarDiv);
                        this.editor.addModule('toolbar', { container: $toolbarDiv.get(0) });
                        // Disable this so we can select text in the editor.
                        $editorDiv.attr('drag-resize-disabled', 'true');
                    }
                    this.$container.append($editorDiv);
                    if (contents)
                        this.setContents(contents);
                    // Throttle text-changed events to not more frequent than once per 200ms
                    var textChangeThrottler = new jsCommon.ThrottleUtility(QuillWrapper.textChangeThrottle);
                    this.editor.on('text-change', function (delta, source) {
                        if (source !== 'api')
                            textChangeThrottler.run(function () { return _this.onTextChanged(delta, source); });
                    });
                    /*
                        Webkit browsers have a bug with regard to focus on div elements
                        with the contenteditable attribute:
    
                        https://bugs.webkit.org/show_bug.cgi?id=38696
    
                        When we blur our rich text box editor the focus remains with the selection
                        instead of the focused element. This allows the user to continue typing as
                        if focus remains within the RichTextbox.
    
                        To fix this issue we add an event listener to the contenteditable div
                        which listens for the 'blur' event and will properly blur our quill
                        editor as well.
    
                        http://quilljs.com/docs/api/#quillprototypesetselection
    
                        Verified in Chrome 43.0.2357.130 m
    
                        In IE10+ the setSelection method explicitly sets focus to the body which
                        causes a bug where the user must click twice when attempting to interact
                        with a <select> element. To prevent this issue we explicitly do not call
                        setSelection to blur if the user is changing focus to a <select> element.
                        This issue is also present for link tooltips from the Quill module which
                        will cause a blur onto the tooltip.
                    */
                    this.editor.root.addEventListener('blur', function (event) {
                        var target = (event.relatedTarget || document.activeElement);
                        // The browser will handle moving the cursor and setting focus properly for these types of elements.
                        if (target &&
                            target.tagName === 'SELECT' || target.tagName === 'INPUT' || target.getAttribute('contentEditable')) {
                            return;
                        }
                        _this.setSelection(null, null);
                    }, false);
                };
                QuillWrapper.prototype.onTextChanged = function (delta, source) {
                    this.textChanged(delta, source);
                };
                QuillWrapper.textChangeThrottle = 200; // ms
                QuillWrapper.preventDefaultKeys = [
                    jsCommon.DOMConstants.aKeyCode,
                    jsCommon.DOMConstants.cKeyCode,
                    jsCommon.DOMConstants.xKeyCode,
                    jsCommon.DOMConstants.vKeyCode,
                ];
                QuillWrapper.loadQuillResources = true;
                // TODO: How to choose between minified/unminified?
                // TODO: Consider loading this from the CDN.
                QuillWrapper.quillJsFiles = [powerbi.build + '/externals/quill.min.js'];
                QuillWrapper.quillCssFiles = [powerbi.build + '/externals/quill.base.css'];
                return QuillWrapper;
            }());
            RichText.QuillWrapper = QuillWrapper;
            var Toolbar;
            (function (Toolbar) {
                var DefaultLinkInputValue = 'http://';
                Toolbar.selectors = {
                    linkTooltip: createClassAndSelector('ql-link-tooltip'),
                    toolbarUrlInput: createClassAndSelector('toolbar-url-input'),
                };
                function buildToolbar(quillWrapper, localizationProvider) {
                    // Module for adding custom hyperlinks
                    var linkTooltipTemplate = buildToolbarLinkInputTemplate(localizationProvider);
                    quillWrapper.addModule('link-tooltip', { template: linkTooltipTemplate });
                    var toolbarLinkInput = buildToolbarLinkInput(quillWrapper, getTooltip('Link', localizationProvider), localizationProvider.get('RichTextbox_Link_DefaultText'));
                    var fontPicker = picker(getTooltip('Font', localizationProvider), fonts, 'font', RichText.defaultFont, 
                    // Show the fonts in their own font face.
                    function ($option, option) { $option.css('font-family', option.value); return $option; });
                    var $container = div()
                        .addClass('toolbar ql-toolbar')
                        .append(formatGroup()
                        .append(label(localizationProvider.get('RichTextbox_Font_Label')))
                        .append(fontPicker)
                        .append(picker(getTooltip('Size', localizationProvider), fontSizes, 'size', RichText.defaultFontSize)))
                        .append(formatGroup()
                        .append(formatButton(getTooltip('Bold', localizationProvider), 'bold'))
                        .append(formatButton(getTooltip('Italic', localizationProvider), 'italic'))
                        .append(formatButton(getTooltip('Underline', localizationProvider), 'underline')))
                        .append(formatGroup()
                        .append(toggleGroup('Text Alignment', textAlignments, 'align', 'Left', localizationProvider)))
                        .append(toolbarLinkInput);
                    // Prevent mousedown from triggering subsequent blur on editor
                    $container.on('mousedown', function (event) {
                        var target = (event.target || document.activeElement);
                        if (target.tagName !== 'INPUT' && target.tagName !== 'SELECT')
                            event.preventDefault();
                    });
                    return $container;
                }
                Toolbar.buildToolbar = buildToolbar;
                function setSelectValue($select, value) {
                    $select.val(value);
                    // NOTE: The 'change' event is not raised when the value of the SELECT element is changed programatically,
                    // and Quill uses it's own, non-JQuery, method to hook up to the 'change' event, therefore, we need to dispatch
                    // this event manually on the SELECT element.
                    var evt = document.createEvent('UIEvent');
                    evt.initUIEvent('change', false, false, null, 0);
                    $select.get(0).dispatchEvent(evt);
                }
                Toolbar.setSelectValue = setSelectValue;
                function linkTooltipTemplateGenerator(removeText, doneText) {
                    return $("\n                        <a href=\"#\" class=\"url\" target=\"_blank\"></a>\n                        <input class=\"input\" type=\"text\">\n                        <span class=\"bar\">&nbsp;|&nbsp;</span>\n                        <a class=\"change\"></a>\n                        <a class=\"remove\">" + removeText + "</a>\n                        <a class=\"done\">" + doneText + "</a>\n                    ");
                }
                ;
                function buildToolbarLinkInputTemplate(localizationProvider) {
                    var template = div();
                    var doneText = localizationProvider.get('RichTextbox_Link_Done');
                    var removeText = localizationProvider.get('RichTextbox_Link_Remove');
                    template.append(linkTooltipTemplateGenerator(removeText, doneText));
                    return template.html();
                }
                function formatGroup() {
                    return span()
                        .addClass('ql-format-group')
                        .attr('drag-resize-disabled', 'true');
                }
                function label(text) {
                    return $('<label>').text(text);
                }
                function div() {
                    return $('<div>');
                }
                function span() {
                    return $('<span>');
                }
                function toggleGroup(title, list, format, defaultValue, localizationProvider) {
                    var tooltip = getTooltip(title, localizationProvider);
                    var $group = span()
                        .attr('title', tooltip)
                        .addClass('ql-toggle-group');
                    // Hidden selector that Quill will use to hook up change listeners.
                    var $select = selector(tooltip, list, defaultValue)
                        .addClass('ql-picker ql-' + format)
                        .css('display', 'none');
                    var $buttons = list.map(function (option) {
                        var $button = formatButton(getTooltip(option.label, localizationProvider), 'align' + option.value)
                            .attr('data-value', option.value)
                            .click(function (e) { return setSelectValue($select, option.value); });
                        return $button;
                    });
                    // Quill will change the value of the selector when the text selection changes, so we need to set the state of the buttons to match.
                    $select.change(function (e) {
                        var newValue = $select.val();
                        for (var i = 0; i < $buttons.length; i++) {
                            $buttons[i].toggleClass('ql-active', $buttons[i].attr('data-value') === newValue);
                        }
                    });
                    $group.append($select);
                    $group.append($buttons);
                    return $group;
                }
                function picker(tooltip, list, format, defaultValue, optionModifier) {
                    var $selector = selector(tooltip, list, defaultValue, optionModifier)
                        .addClass('ql-picker ql-' + format);
                    return $selector;
                }
                function selector(tooltip, list, defaultValue, optionModifier) {
                    var $selector = $('<select>')
                        .attr('title', tooltip);
                    for (var i = 0; i < list.length; i++) {
                        var option = list[i];
                        var $option = $('<option>')
                            .attr('value', option.value)
                            .text(option.label);
                        if (option.value === defaultValue)
                            $option.attr('selected', 'selected');
                        if (optionModifier !== undefined)
                            $option = optionModifier($option, option);
                        $selector.append($option);
                    }
                    return $selector;
                }
                function formatButton(tooltip, format) {
                    var $button = span()
                        .addClass('ql-format-button');
                    if (tooltip != null)
                        $button.attr('title', tooltip);
                    if (format != null) {
                        $button.addClass('ql-' + format);
                        $button.addClass('powervisuals-glyph ' + format);
                    }
                    return $button;
                }
                function getTooltip(name, localizationProvider) {
                    return localizationProvider.get('RichTextbox_' + name + '_ToolTip');
                }
                function clearLinkInput(linkTooltip) {
                    linkTooltip.removeClass('editing');
                    linkTooltip.removeClass('blank-editing');
                    linkTooltip.find('.input').val(DefaultLinkInputValue);
                }
                function buildToolbarLinkInput(quillWrapper, buttonTooltip, defaultLinkText) {
                    // Pull out link tooltip
                    var linkTooltip = quillWrapper.getEditorContainer().find(Toolbar.selectors.linkTooltip.selector);
                    // Append link tooltip to a new toolbar format group
                    var toolbarLinkInput = formatGroup()
                        .addClass(Toolbar.selectors.toolbarUrlInput.class)
                        .append(formatButton(buttonTooltip, 'link').append('<div>'))
                        .append(linkTooltip);
                    // Special case for blank selection (no text near cursor) when enter key or done button clicked
                    toolbarLinkInput.on('keydown mousedown', function (event) {
                        if (event.keyCode === jsCommon.DOMConstants.enterKeyCode || event.target.classList.contains('done')) {
                            if (!linkTooltip.hasClass('blank-editing'))
                                return true;
                            // Only perform these steps if tooltip was not in editing mode (special case for blank)
                            var link = toolbarLinkInput.find('.input').val();
                            var selection = quillWrapper.getSelectionAtCursor();
                            var word = quillWrapper.getWord();
                            if (!word) {
                                // Insert the input text as a link
                                var endCursor = quillWrapper.insertLinkAtCursor(link, selection.start);
                                clearLinkInput(linkTooltip);
                                quillWrapper.setSelection(endCursor, endCursor);
                                return false;
                            }
                        }
                    });
                    toolbarLinkInput.find('.input').blur(function (event) {
                        var blurTarget = event.relatedTarget;
                        // Remove editing class from insert link tooltip (to hide via CSS)
                        // only when we are not blurring to the 'done' button (tab from input field)
                        if (blurTarget === null || blurTarget && !blurTarget.classList.contains('done'))
                            clearLinkInput(linkTooltip);
                    });
                    toolbarLinkInput.find('.ql-link div')
                        .click(function (event) {
                        // Handle click on button before Quill removes link (default behavior)
                        var target = event.target.parentElement;
                        if (target && target.classList.contains('ql-active')) {
                            toolbarLinkInput.find('.change')[0].click();
                            return false;
                        }
                        // If blank selection (no text near cursor), special case for link button
                        var word = quillWrapper.getWord();
                        if (!word) {
                            linkTooltip.addClass('editing blank-editing');
                            var inputElem = toolbarLinkInput.find('.input').get(0);
                            inputElem.value = DefaultLinkInputValue;
                            inputElem.selectionStart = inputElem.selectionEnd = DefaultLinkInputValue.length;
                            inputElem.focus();
                            return false;
                        }
                    })
                        .mousedown(function (event) {
                        // Properly set selection before we handle the click
                        var linkButton = event.target.parentElement;
                        if (linkButton && !linkButton.classList.contains('ql-active')) {
                            var selection = quillWrapper.getSelectionAtCursor();
                            quillWrapper.setSelection(selection.start, selection.end);
                        }
                    });
                    return toolbarLinkInput;
                }
            })(Toolbar || (Toolbar = {}));
        })(RichText = visuals.RichText || (visuals.RichText = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
*  Power BI Visualizations
*
*  Copyright (c) Microsoft Corporation
*  All rights reserved.
*  MIT License
*
*  Permission is hereby granted, free of charge, to any person obtaining a copy
*  of this software and associated documentation files (the ""Software""), to deal
*  in the Software without restriction, including without limitation the rights
*  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
*  copies of the Software, and to permit persons to whom the Software is
*  furnished to do so, subject to the following conditions:
*
*  The above copyright notice and this permission notice shall be included in
*  all copies or substantial portions of the Software.
*
*  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
*  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
*  THE SOFTWARE.
*/
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var SelectionManager = visuals.utility.SelectionManager;
        visuals.cheerMeterProps = {
            dataPoint: {
                defaultColor: {
                    objectName: 'dataPoint',
                    propertyName: 'defaultColor'
                },
                fill: {
                    objectName: 'dataPoint',
                    propertyName: 'fill'
                },
            },
        };
        var CheerMeter = (function () {
            function CheerMeter() {
                this.isFirstTime = true;
            }
            CheerMeter.converter = function (dataView) {
                if (!dataView.categorical || !dataView.categorical.categories)
                    return null;
                var cat = dataView.categorical.categories[0];
                if (!cat)
                    return null;
                var catValues = cat.values;
                if (!catValues || _.isEmpty(dataView.categorical.values))
                    return null;
                var values = dataView.categorical.values[0].values;
                var objects = dataView.categorical.categories[0].objects;
                var object1 = objects && objects.length > 0 ? objects[0] : undefined;
                var object2 = objects && objects.length > 1 ? objects[1] : undefined;
                var metadataObjects = dataView.metadata.objects;
                var backgroundColor = CheerMeter.DefaultBackgroundColor;
                if (metadataObjects) {
                    var general = metadataObjects['general'];
                    if (general) {
                        var fill = general['fill'];
                        if (fill) {
                            backgroundColor = fill.solid.color;
                        }
                    }
                }
                var color1 = powerbi.DataViewObjects.getFillColor(object1, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var color2 = powerbi.DataViewObjects.getFillColor(object2, visuals.cheerMeterProps.dataPoint.fill, CheerMeter.DefaultFontColor);
                var idn1 = visuals.SelectionIdBuilder.builder()
                    .withCategory(cat, 0)
                    .createSelectionId();
                var idn2 = visuals.SelectionIdBuilder.builder()
                    .withCategory(cat, 1)
                    .createSelectionId();
                var data = {
                    teamA: {
                        name: catValues[0],
                        value: values[0],
                        color: color1,
                        identity: idn1
                    },
                    teamB: {
                        name: catValues[1],
                        value: values[1],
                        color: color2,
                        identity: idn2
                    },
                    background: backgroundColor
                };
                return data;
            };
            CheerMeter.prototype.init = function (options) {
                this.selectionManager = new SelectionManager({ hostServices: options.host });
                var svg = this.svg = d3.select(options.element.get(0)).append('svg');
                this.textOne = svg.append('text')
                    .style('font-family', CheerMeter.DefaultFontFamily);
                this.textTwo = svg.append('text')
                    .style('font-family', CheerMeter.DefaultFontFamily);
            };
            CheerMeter.prototype.update = function (options) {
                if (!options.dataViews[0]) {
                    return;
                }
                var data = this.data = CheerMeter.converter(options.dataViews[0]);
                if (!data)
                    return;
                var duration = options.suppressAnimations ? 0 : visuals.AnimatorCommon.MinervaAnimationDuration;
                this.draw(data, duration, options.viewport);
            };
            CheerMeter.prototype.getRecomendedFontProperties = function (text1, text2, parentViewport) {
                var textProperties = {
                    fontSize: '',
                    fontFamily: CheerMeter.DefaultFontFamily,
                    text: text1 + text2
                };
                var min = 1;
                var max = 1000;
                var i;
                var maxWidth = parentViewport.width;
                var width = 0;
                while (min <= max) {
                    i = (min + max) / 2 | 0;
                    textProperties.fontSize = i + 'px';
                    width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                    if (maxWidth > width)
                        min = i + 1;
                    else if (maxWidth < width)
                        max = i - 1;
                    else
                        break;
                }
                textProperties.fontSize = i + 'px';
                width = powerbi.TextMeasurementService.measureSvgTextWidth(textProperties);
                if (width > maxWidth) {
                    i--;
                    textProperties.fontSize = i + 'px';
                }
                return textProperties;
            };
            CheerMeter.prototype.calculateLayout = function (data, viewport) {
                var text1 = data.teamA.name;
                var text2 = data.teamB.name;
                var avaliableViewport = {
                    height: viewport.height,
                    width: viewport.width - CheerMeter.PaddingBetweenText
                };
                var recomendedFontProperties = this.getRecomendedFontProperties(text1, text2, avaliableViewport);
                recomendedFontProperties.text = text1;
                var width1 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                recomendedFontProperties.text = text2;
                var width2 = powerbi.TextMeasurementService.measureSvgTextWidth(recomendedFontProperties) | 0;
                var padding = ((viewport.width - width1 - width2 - CheerMeter.PaddingBetweenText) / 2) | 0;
                recomendedFontProperties.text = text1 + text2;
                var offsetHeight = (powerbi.TextMeasurementService.measureSvgTextHeight(recomendedFontProperties)) | 0;
                var max = data.teamA.value + data.teamB.value;
                var availableHeight = viewport.height - offsetHeight;
                var y1 = (((max - data.teamA.value) / max) * availableHeight + offsetHeight / 2) | 0;
                var y2 = (((max - data.teamB.value) / max) * availableHeight + offsetHeight / 2) | 0;
                return {
                    x1: padding,
                    x2: padding + width1 + CheerMeter.PaddingBetweenText,
                    y1: y1,
                    y2: y2,
                    fontSize: recomendedFontProperties.fontSize
                };
            };
            CheerMeter.prototype.ensureStartState = function (layout, viewport) {
                if (this.isFirstTime) {
                    this.isFirstTime = false;
                    var startY = viewport.height / 2;
                    this.textOne.attr({
                        'x': layout.x1,
                        'y': startY
                    });
                    this.textTwo.attr({
                        'x': layout.x2,
                        'y': startY
                    });
                }
            };
            CheerMeter.prototype.clearSelection = function () {
                var _this = this;
                this.selectionManager.clear().then(function () {
                    _this.clearSelectionUI();
                });
            };
            CheerMeter.prototype.clearSelectionUI = function () {
                this.textOne.style('stroke', '#FFF').style('stroke-width', 0);
                this.textTwo.style('stroke', '#FFF').style('stroke-width', 0);
            };
            CheerMeter.prototype.updateSelectionUI = function (ids) {
                this.textOne.style('stroke', '#FFF').style('stroke-width', SelectionManager.containsSelection(ids, this.data.teamA.identity) ? '2px' : '0px');
                this.textTwo.style('stroke', '#FFF').style('stroke-width', SelectionManager.containsSelection(ids, this.data.teamB.identity) ? '2px' : '0px');
            };
            CheerMeter.prototype.draw = function (data, duration, viewport) {
                var _this = this;
                var easeName = 'back';
                var textOne = this.textOne;
                var textTwo = this.textTwo;
                this.svg
                    .attr({
                    'height': viewport.height,
                    'width': viewport.width
                })
                    .on('click', function () {
                    _this.clearSelection();
                })
                    .style('background-color', data.background);
                var layout = this.calculateLayout(data, viewport);
                this.ensureStartState(layout, viewport);
                textOne
                    .style('font-size', layout.fontSize)
                    .style('fill', data.teamA.color)
                    .on('click', function () {
                    _this.selectionManager.select(data.teamA.identity, d3.event.ctrlKey).then(function (ids) {
                        _this.updateSelectionUI(ids);
                    });
                    d3.event.stopPropagation();
                })
                    .text(data.teamA.name);
                textTwo
                    .style('font-size', layout.fontSize)
                    .style('fill', data.teamB.color)
                    .on('click', function () {
                    _this.selectionManager.select(data.teamB.identity, d3.event.ctrlKey).then(function (ids) {
                        _this.updateSelectionUI(ids);
                    });
                    d3.event.stopPropagation();
                })
                    .text(data.teamB.name);
                textOne.transition()
                    .duration(duration)
                    .ease(easeName)
                    .attr({
                    y: layout.y1,
                    x: layout.x1
                });
                textTwo.transition()
                    .duration(duration)
                    .ease(easeName)
                    .attr({
                    y: layout.y2,
                    x: layout.x2
                });
            };
            CheerMeter.prototype.destroy = function () {
                this.svg = null;
                this.textOne = this.textTwo = null;
            };
            CheerMeter.prototype.enumerateObjectInstances = function (options) {
                var instances = [];
                var data = this.data;
                switch (options.objectName) {
                    case 'dataPoint':
                        if (data) {
                            var teams = [data.teamA, data.teamB];
                            for (var i = 0; i < teams.length; i++) {
                                var slice = teams[i];
                                var color = slice.color;
                                var selector = slice.identity;
                                var dataPointInstance = {
                                    objectName: 'dataPoint',
                                    displayName: slice.name,
                                    selector: selector,
                                    properties: {
                                        fill: { solid: { color: color } }
                                    },
                                };
                                instances.push(dataPointInstance);
                            }
                            ;
                        }
                        break;
                    case 'general':
                        var general = {
                            objectName: 'general',
                            displayName: 'General',
                            selector: null,
                            properties: {
                                fill: { solid: { color: data ? data.background : CheerMeter.DefaultBackgroundColor } }
                            }
                        };
                        instances.push(general);
                        break;
                }
                return instances;
            };
            CheerMeter.capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                    },
                    {
                        displayName: 'Noise Measure',
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                    },
                ],
                dataViewMappings: [{
                        categorical: {
                            categories: {
                                for: { in: 'Category' },
                            },
                            values: {
                                select: [{ bind: { to: 'Y' } }]
                            },
                        },
                    }],
                objects: {
                    dataPoint: {
                        displayName: powerbi.data.createDisplayNameGetter('Visual_DataPoint'),
                        description: powerbi.data.createDisplayNameGetter('Visual_DataPointDescription'),
                        properties: {
                            fill: {
                                displayName: powerbi.data.createDisplayNameGetter('Visual_Fill'),
                                type: { fill: { solid: { color: true } } }
                            },
                            width: {
                                displayName: '',
                                type: { numeric: true }
                            }
                        }
                    },
                    general: {
                        displayName: 'General',
                        properties: {
                            fill: {
                                displayName: 'Background color',
                                type: { fill: { solid: { color: true } } }
                            },
                        }
                    }
                }
            };
            CheerMeter.DefaultFontFamily = 'cursive';
            CheerMeter.DefaultFontColor = 'rgb(165, 172, 175)';
            CheerMeter.DefaultBackgroundColor = '#243C18';
            CheerMeter.PaddingBetweenText = 15;
            return CheerMeter;
        }());
        visuals.CheerMeter = CheerMeter;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Color = jsCommon.Color;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var PixelConverter = jsCommon.PixelConverter;
        var DataRoleHelper = powerbi.data.DataRoleHelper;
        var ScatterChart = (function () {
            function ScatterChart(options) {
                if (options) {
                    this.tooltipsEnabled = options.tooltipsEnabled;
                    this.interactivityService = options.interactivityService;
                    this.animator = options.animator;
                }
                this.renderer = new SvgRenderer();
            }
            ScatterChart.prototype.init = function (options) {
                this.options = options;
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.style = options.style;
                this.host = options.host;
                this.colors = this.style.colorPalette.dataColors;
                this.interactivity = options.interactivity;
                this.cartesianVisualHost = options.cartesianHost;
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
                var svg = this.svg = options.svg;
                // TODO: should we always be adding the playchart class name?
                svg.classed(ScatterChart.ClassName + ' ' + visuals.PlayChart.ClassName, true);
                this.renderer.init(svg, options.labelsContext, this.isMobileChart, this.tooltipsEnabled);
            };
            ScatterChart.getAdditionalTelemetry = function (dataView) {
                var telemetry = {
                    hasSize: DataRoleHelper.hasRoleInDataView(dataView, 'Size'),
                    hasPlayAxis: DataRoleHelper.hasRoleInDataView(dataView, 'Play'),
                };
                return telemetry;
            };
            ScatterChart.getObjectProperties = function (dataView, dataLabelsSettings) {
                var objects;
                if (dataView && dataView.metadata && dataView.metadata.objects)
                    objects = dataView.metadata.objects;
                else
                    objects = {};
                var objectProperties = {};
                objectProperties.defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.columnChartProps.dataPoint.defaultColor);
                objectProperties.showAllDataPoints = powerbi.DataViewObjects.getValue(objects, visuals.columnChartProps.dataPoint.showAllDataPoints, false);
                var labelsObj = objects['categoryLabels'];
                if (labelsObj && dataLabelsSettings)
                    visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                // NOTE: "fill point" defaults to on when we have a gradient role.
                var hasGradient = dataView && visuals.GradientUtils.hasGradientRole(dataView.categorical);
                objectProperties.fillPoint = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.fillPoint.show, hasGradient);
                objectProperties.colorBorder = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorBorder.show, false);
                objectProperties.colorByCategory = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.colorByCategory.show, false);
                return objectProperties;
            };
            ScatterChart.converter = function (dataView, options, playFrameInfo, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var categoryValues, categoryFormatter, categoryObjects, categoryIdentities, categoryQueryName;
                var currentViewport = options.viewport;
                var colorPalette = options.colors;
                var interactivityService = options.interactivityService;
                var categoryAxisProperties = options.categoryAxisProperties;
                var valueAxisProperties = options.valueAxisProperties;
                var dataViewCategorical = dataView.categorical;
                var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(dataViewCategorical);
                if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                    categoryValues = dataViewCategorical.categories[0].values;
                    categoryFormatter = visuals.valueFormatter.create({ format: visuals.valueFormatter.getFormatString(dataViewCategorical.categories[0].source, visuals.scatterChartProps.general.formatString), value: categoryValues[0], value2: categoryValues[categoryValues.length - 1] });
                    categoryIdentities = dataViewCategorical.categories[0].identity;
                    categoryObjects = dataViewCategorical.categories[0].objects;
                    categoryQueryName = dataViewCategorical.categories[0].source.queryName;
                }
                else {
                    categoryValues = [null];
                    // creating default formatter for null value (to get the right string of empty value from the locale)
                    categoryFormatter = visuals.valueFormatter.createDefaultFormatter(null);
                }
                var categories = dataViewCategorical.categories;
                var dataValues = dataViewCategorical.values;
                var hasDynamicSeries = !!dataValues.source;
                var grouped = dataValues.grouped();
                var dvSource = dataValues.source;
                var scatterMetadata = ScatterChart.getMetadata(grouped, dvSource);
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                var sizeRange = ScatterChart.getSizeRangeForGroups(grouped, scatterMetadata.idx.size);
                var objProps = ScatterChart.getObjectProperties(dataView, dataLabelsSettings);
                var dataPointSeries = ScatterChart.createDataPointSeries(dataValues, scatterMetadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, currentViewport, hasDynamicSeries, dataLabelsSettings, gradientValueColumn, objProps.defaultDataPointColor, categoryQueryName, objProps.colorByCategory, playFrameInfo, tooltipsEnabled);
                var dataPoints = _.reduce(dataPointSeries, function (a, s) { return a.concat(s.dataPoints); }, []);
                var legendItems = hasDynamicSeries
                    ? ScatterChart.createSeriesLegend(dataValues, colorPalette, dataValues, visuals.valueFormatter.getFormatString(dvSource, visuals.scatterChartProps.general.formatString), objProps.defaultDataPointColor)
                    : [];
                var legendTitle = dataValues && dvSource ? dvSource.displayName : "";
                if (!legendTitle) {
                    legendTitle = categories && categories.length > 0 && categories[0].source.displayName ? categories[0].source.displayName : "";
                }
                if (categoryAxisProperties && categoryAxisProperties["showAxisTitle"] !== null && categoryAxisProperties["showAxisTitle"] === false) {
                    scatterMetadata.axesLabels.x = null;
                }
                if (valueAxisProperties && valueAxisProperties["showAxisTitle"] !== null && valueAxisProperties["showAxisTitle"] === false) {
                    scatterMetadata.axesLabels.y = null;
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(dataPoints);
                    interactivityService.applySelectionStateToData(legendItems);
                }
                return {
                    xCol: scatterMetadata.cols.x,
                    yCol: scatterMetadata.cols.y,
                    dataPoints: dataPoints,
                    dataPointSeries: dataPointSeries,
                    legendData: { title: legendTitle, dataPoints: legendItems },
                    axesLabels: scatterMetadata.axesLabels,
                    size: scatterMetadata.cols.size,
                    sizeRange: sizeRange,
                    dataLabelsSettings: dataLabelsSettings,
                    defaultDataPointColor: objProps.defaultDataPointColor,
                    hasDynamicSeries: hasDynamicSeries,
                    showAllDataPoints: objProps.showAllDataPoints,
                    fillPoint: objProps.fillPoint,
                    colorBorder: objProps.colorBorder,
                    colorByCategory: objProps.colorByCategory,
                };
            };
            ScatterChart.getSizeRangeForGroups = function (dataViewValueGroups, sizeColumnIndex) {
                var result = {};
                if (dataViewValueGroups) {
                    dataViewValueGroups.forEach(function (group) {
                        var sizeColumn = ScatterChart.getMeasureValue(sizeColumnIndex, group.values);
                        var currentRange = visuals.AxisHelper.getRangeForColumn(sizeColumn);
                        if (result.min == null || result.min > currentRange.min) {
                            result.min = currentRange.min;
                        }
                        if (result.max == null || result.max < currentRange.max) {
                            result.max = currentRange.max;
                        }
                    });
                }
                return result;
            };
            ScatterChart.createDataPointSeries = function (dataValues, metadata, categories, categoryValues, categoryFormatter, categoryIdentities, categoryObjects, colorPalette, viewport, hasDynamicSeries, labelSettings, gradientValueColumn, defaultDataPointColor, categoryQueryName, colorByCategory, playFrameInfo, tooltipsEnabled) {
                var dataPointSeries = [], indicies = metadata.idx, formatStringProp = visuals.scatterChartProps.general.formatString, dataValueSource = dataValues.source, grouped = dataValues.grouped();
                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                for (var seriesIdx = 0, len = grouped.length; seriesIdx < len; seriesIdx++) {
                    var grouping = grouped[seriesIdx];
                    var seriesValues = grouping.values;
                    var measureX = ScatterChart.getMeasureValue(indicies.x, seriesValues);
                    var measureY = ScatterChart.getMeasureValue(indicies.y, seriesValues);
                    var measureSize = ScatterChart.getMeasureValue(indicies.size, seriesValues);
                    var seriesColor = void 0;
                    if (hasDynamicSeries) {
                        seriesColor = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                    }
                    else if (!colorByCategory && !categoryObjects) {
                        // If we have no Size measure then use a blank query name
                        var measureSource = (measureSize != null)
                            ? measureSize.source.queryName
                            : '';
                        seriesColor = colorHelper.getColorForMeasure(null, measureSource);
                    }
                    var series = {
                        identityKey: (grouping && grouping.identity && grouping.identity.key) || "",
                        dataPoints: [],
                        hasSize: !!(measureSize && measureSize.values),
                        fill: seriesColor,
                    };
                    dataPointSeries.push(series);
                    for (var categoryIdx = 0, ilen = categoryValues.length; categoryIdx < ilen; categoryIdx++) {
                        var categoryValue = categoryValues[categoryIdx];
                        var xVal = visuals.AxisHelper.normalizeNonFiniteNumber(measureX && measureX.values ? measureX.values[categoryIdx] : null);
                        var yVal = visuals.AxisHelper.normalizeNonFiniteNumber(measureY && measureY.values ? measureY.values[categoryIdx] : 0);
                        var size = visuals.AxisHelper.normalizeNonFiniteNumber(measureSize && measureSize.values ? measureSize.values[categoryIdx] : null);
                        var hasNullValue = (xVal == null) || (yVal == null);
                        if (hasNullValue)
                            continue;
                        var color = void 0;
                        if (hasDynamicSeries) {
                            color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                        }
                        else if (colorByCategory) {
                            color = colorHelper.getColorForSeriesValue(categoryObjects && categoryObjects[categoryIdx], dataValues.identityFields, categoryValue);
                        }
                        else {
                            // If we have no Size measure then use a blank query name
                            var measureSource = (measureSize != null)
                                ? measureSize.source.queryName
                                : '';
                            color = colorHelper.getColorForMeasure(categoryObjects && categoryObjects[categoryIdx], measureSource);
                        }
                        var category = categories && categories.length > 0 ? categories[0] : null;
                        var identity = visuals.SelectionIdBuilder.builder()
                            .withCategory(category, categoryIdx)
                            .withSeries(dataValues, grouping)
                            .createSelectionId();
                        var seriesData = [];
                        if (dataValueSource) {
                            // Dynamic series
                            seriesData.push({ value: grouping.name, metadata: { source: dataValueSource, values: [] } });
                        }
                        if (measureX) {
                            seriesData.push({ value: xVal, metadata: measureX });
                        }
                        if (measureY) {
                            seriesData.push({ value: yVal, metadata: measureY });
                        }
                        if (measureSize && measureSize.values && measureSize.values.length > 0) {
                            seriesData.push({ value: measureSize.values[categoryIdx], metadata: measureSize });
                        }
                        if (playFrameInfo) {
                            seriesData.push({ value: playFrameInfo.label, metadata: { source: playFrameInfo.column, values: [] } });
                        }
                        // check for gradient tooltip data
                        var gradientToolTipData = visuals.TooltipBuilder.createGradientToolTipData(gradientValueColumn, categoryIdx);
                        if (gradientToolTipData != null)
                            seriesData.push(gradientToolTipData);
                        var tooltipInfo = void 0;
                        if (tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, null, categoryValue, null, categories, seriesData);
                        }
                        var dataPoint = {
                            x: xVal,
                            y: yVal,
                            size: size,
                            radius: { sizeMeasure: measureSize, index: categoryIdx },
                            fill: color,
                            formattedCategory: ScatterChart.createLazyFormattedCategory(categoryFormatter, categories != null ? categoryValue : grouping.name),
                            selected: false,
                            identity: identity,
                            tooltipInfo: tooltipInfo,
                            labelFill: labelSettings.labelColor,
                        };
                        series.dataPoints.push(dataPoint);
                    }
                }
                return dataPointSeries;
            };
            ScatterChart.createLazyFormattedCategory = function (formatter, value) {
                return new jsCommon.Lazy(function () { return formatter.format(value); });
            };
            ScatterChart.createSeriesLegend = function (dataValues, colorPalette, categorical, formatString, defaultDataPointColor) {
                var grouped = dataValues.grouped();
                var colorHelper = new visuals.ColorHelper(colorPalette, visuals.scatterChartProps.dataPoint.fill, defaultDataPointColor);
                var legendItems = [];
                for (var i = 0, len = grouped.length; i < len; i++) {
                    var grouping = grouped[i];
                    var color = colorHelper.getColorForSeriesValue(grouping.objects, dataValues.identityFields, grouping.name);
                    legendItems.push({
                        color: color,
                        icon: visuals.LegendIcon.Circle,
                        label: visuals.valueFormatter.format(grouping.name, formatString),
                        identity: grouping.identity ? visuals.SelectionId.createWithId(grouping.identity) : visuals.SelectionId.createNull(),
                        selected: false
                    });
                }
                return legendItems;
            };
            ScatterChart.getBubbleRadius = function (radiusData, sizeRange, viewport) {
                var actualSizeDataRange = null;
                var bubblePixelAreaSizeRange = null;
                var measureSize = radiusData.sizeMeasure;
                if (!measureSize)
                    return ScatterChart.BubbleRadius;
                var minSize = sizeRange.min ? sizeRange.min : 0;
                var maxSize = sizeRange.max ? sizeRange.max : 0;
                var min = Math.min(minSize, 0);
                var max = Math.max(maxSize, 0);
                actualSizeDataRange = {
                    minRange: min,
                    maxRange: max,
                    delta: max - min
                };
                bubblePixelAreaSizeRange = ScatterChart.getBubblePixelAreaSizeRange(viewport, ScatterChart.MinSizeRange, ScatterChart.MaxSizeRange);
                if (measureSize.values) {
                    var sizeValue = measureSize.values[radiusData.index];
                    if (sizeValue != null) {
                        return ScatterChart.projectSizeToPixels(sizeValue, actualSizeDataRange, bubblePixelAreaSizeRange) / 2;
                    }
                }
                return ScatterChart.BubbleRadius;
            };
            ScatterChart.getMeasureValue = function (measureIndex, seriesValues) {
                if (measureIndex >= 0)
                    return seriesValues[measureIndex];
                return null;
            };
            ScatterChart.getMetadata = function (grouped, source) {
                var xIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'X');
                var yIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Y');
                var sizeIndex = DataRoleHelper.getMeasureIndexOfRole(grouped, 'Size');
                var xCol;
                var yCol;
                var sizeCol;
                var xAxisLabel = "";
                var yAxisLabel = "";
                if (grouped && grouped.length) {
                    var firstGroup = grouped[0];
                    if (xIndex >= 0) {
                        xCol = firstGroup.values[xIndex].source;
                        xAxisLabel = firstGroup.values[xIndex].source.displayName;
                    }
                    if (yIndex >= 0) {
                        yCol = firstGroup.values[yIndex].source;
                        yAxisLabel = firstGroup.values[yIndex].source.displayName;
                    }
                    if (sizeIndex >= 0) {
                        sizeCol = firstGroup.values[sizeIndex].source;
                    }
                }
                return {
                    idx: {
                        x: xIndex,
                        y: yIndex,
                        size: sizeIndex,
                    },
                    cols: {
                        x: xCol,
                        y: yCol,
                        size: sizeCol,
                    },
                    axesLabels: {
                        x: xAxisLabel,
                        y: yAxisLabel
                    }
                };
            };
            /** Create a new viewmodel with default data. */
            ScatterChart.getDefaultData = function () {
                return {
                    xCol: undefined,
                    yCol: undefined,
                    dataPoints: [],
                    dataPointSeries: [],
                    legendData: { dataPoints: [] },
                    axesLabels: { x: '', y: '' },
                    sizeRange: [],
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultPointLabelSettings(),
                    defaultDataPointColor: null,
                    hasDynamicSeries: false,
                };
            };
            ScatterChart.prototype.renderAtFrame = function (data) {
                this.data = data;
                this.cartesianVisualHost.triggerRender(false);
            };
            ScatterChart.prototype.setData = function (dataViews) {
                var _this = this;
                this.data = ScatterChart.getDefaultData();
                if (dataViews.length > 0) {
                    var dataView = dataViews[0] || dataViews[1];
                    if (dataView) {
                        this.categoryAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata, true);
                        this.valueAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata, true);
                        this.dataView = dataView;
                        var converterOptions_1 = {
                            viewport: this.currentViewport,
                            colors: this.colors,
                            interactivityService: this.interactivityService,
                            categoryAxisProperties: this.categoryAxisProperties,
                            valueAxisProperties: this.valueAxisProperties,
                        };
                        if (visuals.PlayChart.isDataViewPlayable(dataView)) {
                            if (!this.playAxis) {
                                this.playAxis = new visuals.PlayAxis({
                                    animator: this.animator,
                                    interactivityService: this.interactivityService,
                                    isScrollable: false,
                                });
                                this.playAxis.init(this.options);
                            }
                            var playData = this.playAxis.setData(dataView, function (dataView, playFrameInfo) {
                                return ScatterChart.converter(dataView, converterOptions_1, playFrameInfo, _this.tooltipsEnabled);
                            });
                            this.mergeSizeRanges(playData);
                            this.data = playData.currentViewModel;
                            this.playAxis.setRenderFunction(function (data) { return _this.renderAtFrame(data); });
                        }
                        else {
                            if (this.playAxis) {
                                this.playAxis.remove();
                                this.playAxis = null;
                            }
                            if (dataView.categorical && dataView.categorical.values) {
                                this.data = ScatterChart.converter(dataView, converterOptions_1, undefined, this.tooltipsEnabled);
                            }
                        }
                    }
                }
                else if (this.playAxis) {
                    this.playAxis.remove();
                    this.playAxis = null;
                }
            };
            ScatterChart.prototype.mergeSizeRanges = function (playData) {
                if (playData && playData.currentViewModel) {
                    var mergedSizeRange = playData.currentViewModel.sizeRange;
                    for (var _i = 0, _a = playData.allViewModels; _i < _a.length; _i++) {
                        var data_3 = _a[_i];
                        var sizeRange = data_3.sizeRange;
                        if (sizeRange.min != null)
                            mergedSizeRange.min = Math.min(mergedSizeRange.min, sizeRange.min);
                        if (sizeRange.max != null)
                            mergedSizeRange.max = Math.max(mergedSizeRange.max, sizeRange.max);
                    }
                    for (var _b = 0, _c = playData.allViewModels; _b < _c.length; _b++) {
                        var data_4 = _c[_b];
                        data_4.sizeRange = mergedSizeRange;
                    }
                }
            };
            ScatterChart.prototype.calculateLegend = function () {
                return this.data && this.data.legendData;
            };
            ScatterChart.prototype.hasLegend = function () {
                return this.data && this.data.hasDynamicSeries;
            };
            ScatterChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                switch (options.objectName) {
                    case 'colorByCategory':
                        if (this.data) {
                            // Color by Legend takes precedent during render. Hide the slice but keep the colorByCategory value unchanged in case they remove the Legend field.
                            if (!this.data.hasDynamicSeries) {
                                enumeration.pushInstance({
                                    objectName: 'colorByCategory',
                                    selector: null,
                                    properties: {
                                        show: this.data.colorByCategory,
                                    },
                                });
                            }
                        }
                        break;
                    case 'dataPoint':
                        // TODO: DataViewMatix (for PlayAxis) doesn't support category- or series-specific properties yet.
                        if (!this.playAxis) {
                            var categoricalDataView = this.dataView && this.dataView.categorical ? this.dataView.categorical : null;
                            if (!visuals.GradientUtils.hasGradientRole(categoricalDataView))
                                return this.enumerateDataPoints(enumeration);
                        }
                        break;
                    case 'categoryAxis':
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                showAxisTitle: !this.categoryAxisProperties || this.categoryAxisProperties["showAxisTitle"] == null ? true : this.categoryAxisProperties["showAxisTitle"]
                            },
                            objectName: 'categoryAxis'
                        });
                        break;
                    case 'valueAxis':
                        enumeration.pushInstance({
                            selector: null,
                            properties: {
                                showAxisTitle: !this.valueAxisProperties || this.valueAxisProperties["showAxisTitle"] == null ? true : this.valueAxisProperties["showAxisTitle"]
                            },
                            objectName: 'valueAxis'
                        });
                        break;
                    case 'categoryLabels':
                        if (this.data)
                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, this.data.dataLabelsSettings, true);
                        else
                            visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, null, true);
                        break;
                    case 'fillPoint':
                        // Check if the card should be shown or not based on the existence of size measure
                        if (this.hasSizeMeasure())
                            return;
                        enumeration.pushInstance({
                            objectName: 'fillPoint',
                            selector: null,
                            properties: {
                                show: this.data.fillPoint,
                            },
                        });
                        break;
                    case 'colorBorder':
                        // Check if the card should be shown or not based on the existence of size measure
                        if (this.hasSizeMeasure())
                            enumeration.pushInstance({
                                objectName: 'colorBorder',
                                selector: null,
                                properties: {
                                    show: this.data.colorBorder,
                                },
                            });
                        break;
                }
            };
            ScatterChart.prototype.hasSizeMeasure = function () {
                var sizeRange = this.data.sizeRange;
                return sizeRange && sizeRange.min !== undefined;
            };
            ScatterChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var seriesCount = data.dataPoints.length;
                if (!data.hasDynamicSeries) {
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            defaultColor: { solid: { color: data.defaultDataPointColor || this.colors.getColorByIndex(0).value } }
                        }
                    }).pushInstance({
                        objectName: 'dataPoint',
                        selector: null,
                        properties: {
                            showAllDataPoints: !!data.showAllDataPoints
                        }
                    });
                    for (var i = 0; i < seriesCount; i++) {
                        var seriesDataPoints = data.dataPoints[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: seriesDataPoints.formattedCategory.getValue(),
                            selector: visuals.ColorHelper.normalizeSelector(seriesDataPoints.identity.getSelector(), /*isSingleSeries*/ true),
                            properties: {
                                fill: { solid: { color: seriesDataPoints.fill } }
                            },
                        });
                    }
                }
                else {
                    var legendDataPointLength = data.legendData.dataPoints.length;
                    for (var i = 0; i < legendDataPointLength; i++) {
                        var series = data.legendData.dataPoints[i];
                        enumeration.pushInstance({
                            objectName: 'dataPoint',
                            displayName: series.label,
                            selector: visuals.ColorHelper.normalizeSelector(series.identity.getSelector()),
                            properties: {
                                fill: { solid: { color: series.color } }
                            },
                        });
                    }
                }
            };
            ScatterChart.prototype.supportsTrendLine = function () {
                var data = this.data;
                if (!data)
                    return false;
                return !this.hasSizeMeasure() && data.dataPointSeries.length > 0;
            };
            ScatterChart.getExtents = function (data) {
                var dps = data.dataPoints;
                if (_.isEmpty(dps)) {
                    return {
                        minY: 0,
                        maxY: 0,
                        minX: 0,
                        maxX: 0,
                    };
                }
                return {
                    minY: d3.min(dps, function (d) { return d.y; }),
                    maxY: d3.max(dps, function (d) { return d.y; }),
                    minX: d3.min(dps, function (d) { return d.x; }),
                    maxX: d3.max(dps, function (d) { return d.x; }),
                };
            };
            ScatterChart.prototype.calculateAxesProperties = function (options) {
                var data = this.data;
                var viewport = this.currentViewport = options.viewport;
                var margin = options.margin;
                this.currentViewport = viewport;
                this.margin = margin;
                var width = viewport.width - (margin.left + margin.right);
                var height = viewport.height - (margin.top + margin.bottom);
                var extents = {
                    minY: 0,
                    maxY: 10,
                    minX: 0,
                    maxX: 10
                };
                if (this.playAxis) {
                    extents = this.playAxis.getCartesianExtents(extents, ScatterChart.getExtents);
                    this.playAxis.setPlayControlPosition(options.playAxisControlLayout);
                }
                else if (!_.isEmpty(data.dataPoints)) {
                    extents = ScatterChart.getExtents(data);
                }
                var xDomain = [extents.minX, extents.maxX];
                var combinedXDomain = visuals.AxisHelper.combineDomain(options.forcedXDomain, xDomain, options.ensureXDomain);
                this.xAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: width,
                    dataDomain: combinedXDomain,
                    metaDataColumn: data.xCol,
                    formatString: visuals.valueFormatter.getFormatString(data.xCol, visuals.scatterChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: false,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: true,
                    scaleType: options.categoryAxisScaleType,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                });
                this.xAxisProperties.axis.tickSize(-height, 0);
                this.xAxisProperties.axisLabel = this.data.axesLabels.x;
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [extents.minY, extents.maxY], options.ensureYDomain);
                this.yAxisProperties = visuals.AxisHelper.createAxis({
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    metaDataColumn: data.yCol,
                    formatString: visuals.valueFormatter.getFormatString(data.yCol, visuals.scatterChartProps.general.formatString),
                    outerPadding: 0,
                    isScalar: true,
                    isVertical: true,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    scaleType: options.valueAxisScaleType,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision
                });
                this.yAxisProperties.axisLabel = this.data.axesLabels.y;
                // TODO: these should be passed into the render method.
                return [this.xAxisProperties, this.yAxisProperties];
            };
            ScatterChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            ScatterChart.prototype.render = function (suppressAnimations, resizeMode) {
                if (!this.data)
                    return;
                var data = this.data;
                var margin = this.margin;
                var viewport = this.currentViewport;
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                var plotArea = {
                    width: viewport.width - (margin.left + margin.right),
                    height: viewport.height - (margin.top + margin.bottom)
                };
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (this.playAxis && (this.isMobileChart || duration > 0)) {
                    duration = visuals.PlayChart.FrameAnimationDuration;
                }
                var easeType = this.playAxis ? 'linear' : 'cubic-in-out'; // cubic-in-out is the d3.ease default
                var fillMarkers = (!data.sizeRange || !data.sizeRange.min) && data.fillPoint;
                var drawBubbles = this.hasSizeMeasure();
                var suppressDataPointRendering = resizeMode === 1 /* Resizing */ && data.dataPoints && data.dataPoints.length > ScatterChart.NoRenderResizeThreshold;
                var viewModel = {
                    data: data,
                    drawBubbles: drawBubbles,
                    isPlay: !!this.playAxis,
                    xAxisProperties: this.xAxisProperties,
                    yAxisProperties: this.yAxisProperties,
                    viewport: plotArea,
                    hasSelection: hasSelection,
                    animationDuration: duration,
                    animationOptions: this.options.animation,
                    fillMarkers: fillMarkers,
                    easeType: easeType,
                    suppressDataPointRendering: suppressDataPointRendering,
                };
                if (drawBubbles) {
                    // Bubbles must be drawn from largest to smallest.
                    var sortedData = data.dataPoints.sort(ScatterChart.sortBubbles);
                    viewModel.data = powerbi.Prototype.inherit(viewModel.data);
                    viewModel.data.dataPoints = sortedData;
                }
                var labelDataPoints = [];
                if (data.dataLabelsSettings && data.dataLabelsSettings.show || data.dataLabelsSettings.showCategory) {
                    labelDataPoints = ScatterChartDataLabels.createLabelDataPoints(viewModel);
                }
                var behaviorOptions = this.renderer.render(viewModel, this.interactivityService);
                if (this.isMobileChart) {
                    behaviorOptions = {
                        data: behaviorOptions.data,
                        dataPointsSelection: behaviorOptions.dataPointsSelection,
                        eventGroup: behaviorOptions.eventGroup,
                        plotContext: behaviorOptions.plotContext,
                        host: this.cartesianVisualHost,
                        root: this.svg,
                        visualInitOptions: this.options,
                        xAxisProperties: this.xAxisProperties,
                        yAxisProperties: this.yAxisProperties,
                        background: d3.select(this.element.get(0)),
                    };
                }
                var playRenderResult;
                if (this.playAxis) {
                    playRenderResult = this.playAxis.render(suppressAnimations, viewModel, viewport, margin);
                    if (this.interactivityService) {
                        var playBehaviorOptions = {
                            traceLineRenderer: this.renderer.createTraceLineRenderer(playRenderResult.viewModel),
                        };
                        if (hasSelection) {
                            visuals.PlayChart.renderTraceLines(playRenderResult.allDataPoints, playBehaviorOptions.traceLineRenderer, !suppressAnimations);
                        }
                        behaviorOptions.playOptions = playBehaviorOptions;
                    }
                }
                return {
                    dataPoints: playRenderResult ? playRenderResult.allDataPoints : data.dataPoints,
                    behaviorOptions: behaviorOptions,
                    labelDataPoints: labelDataPoints,
                    labelsAreNumeric: false,
                };
            };
            ScatterChart.getStrokeFill = function (d, colorBorder) {
                if (d.size != null && colorBorder) {
                    var colorRgb = Color.parseColorString(d.fill);
                    return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
                }
                return d.fill;
            };
            ScatterChart.getBubblePixelAreaSizeRange = function (viewPort, minSizeRange, maxSizeRange) {
                var ratio = 1.0;
                if (viewPort.height > 0 && viewPort.width > 0) {
                    var minSize = Math.min(viewPort.height, viewPort.width);
                    ratio = (minSize * minSize) / ScatterChart.AreaOf300By300Chart;
                }
                var minRange = Math.round(minSizeRange * ratio);
                var maxRange = Math.round(maxSizeRange * ratio);
                return {
                    minRange: minRange,
                    maxRange: maxRange,
                    delta: maxRange - minRange
                };
            };
            ScatterChart.project = function (value, actualSizeDataRange, bubblePixelAreaSizeRange) {
                if (actualSizeDataRange.delta === 0 || bubblePixelAreaSizeRange.delta === 0) {
                    return (ScatterChart.rangeContains(actualSizeDataRange, value)) ? bubblePixelAreaSizeRange.minRange : null;
                }
                var relativeX = (value - actualSizeDataRange.minRange) / actualSizeDataRange.delta;
                return bubblePixelAreaSizeRange.minRange + relativeX * bubblePixelAreaSizeRange.delta;
            };
            ScatterChart.projectSizeToPixels = function (size, actualSizeDataRange, bubblePixelAreaSizeRange) {
                var projectedSize = 0;
                if (actualSizeDataRange) {
                    // Project value on the required range of bubble area sizes
                    projectedSize = bubblePixelAreaSizeRange.maxRange;
                    if (actualSizeDataRange.delta !== 0) {
                        var value = Math.min(Math.max(size, actualSizeDataRange.minRange), actualSizeDataRange.maxRange);
                        projectedSize = ScatterChart.project(value, actualSizeDataRange, bubblePixelAreaSizeRange);
                    }
                    projectedSize = Math.sqrt(projectedSize / Math.PI) * 2;
                }
                return Math.round(projectedSize);
            };
            ScatterChart.rangeContains = function (range, value) {
                return range.minRange <= value && value <= range.maxRange;
            };
            ScatterChart.getMarkerFillOpacity = function (hasSize, shouldEnableFill, hasSelection, isSelected) {
                if (hasSize || shouldEnableFill) {
                    if (hasSelection && !isSelected) {
                        return ScatterChart.DimmedBubbleOpacity;
                    }
                    return ScatterChart.DefaultBubbleOpacity;
                }
                else {
                    return 0;
                }
            };
            ScatterChart.getMarkerStrokeOpacity = function (hasSize, colorBorder, hasSelection, isSelected) {
                if (hasSize && colorBorder) {
                    return 1;
                }
                else {
                    if (hasSelection && !isSelected) {
                        return ScatterChart.DimmedBubbleOpacity;
                    }
                    return ScatterChart.DefaultBubbleOpacity;
                }
            };
            ScatterChart.getMarkerStrokeFill = function (hasSize, colorBorder, fill) {
                if (hasSize && colorBorder) {
                    var colorRgb = Color.parseColorString(fill);
                    return Color.hexString(Color.darken(colorRgb, ScatterChart.StrokeDarkenColorValue));
                }
                return fill;
            };
            ScatterChart.getMarkerStyle = function (d, colorBorder, hasSelection, fillMarkers) {
                return {
                    'stroke-opacity': ScatterChart.getMarkerStrokeOpacity(d.size != null, colorBorder, hasSelection, d.selected),
                    stroke: ScatterChart.getMarkerStrokeFill(d.size != null, colorBorder, d.fill),
                    fill: d.fill,
                    'fill-opacity': ScatterChart.getMarkerFillOpacity(d.size != null, fillMarkers, hasSelection, d.selected),
                };
            };
            ScatterChart.getSeriesStyle = function (hasSize, colorBorder, hasSelection, fillMarkers, fill) {
                return {
                    'stroke-opacity': ScatterChart.getMarkerStrokeOpacity(hasSize, colorBorder, hasSelection, false),
                    stroke: ScatterChart.getMarkerStrokeFill(hasSize, colorBorder, fill),
                    fill: fill,
                    'fill-opacity': ScatterChart.getMarkerFillOpacity(hasSize, fillMarkers, hasSelection, false),
                };
            };
            ScatterChart.getBubbleOpacity = function (d, hasSelection) {
                if (hasSelection && !d.selected) {
                    return ScatterChart.DimmedBubbleOpacity;
                }
                return ScatterChart.DefaultBubbleOpacity;
            };
            ScatterChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            ScatterChart.prototype.getSupportedCategoryAxisType = function () {
                return visuals.axisType.scalar;
            };
            ScatterChart.sortBubbles = function (a, b) {
                var diff = (b.radius.sizeMeasure.values[b.radius.index] - a.radius.sizeMeasure.values[a.radius.index]);
                if (diff !== 0)
                    return diff;
                // Tie-break equal size bubbles using identity.
                return b.identity.getKey().localeCompare(a.identity.getKey());
            };
            ScatterChart.BubbleRadius = 3 * 2;
            ScatterChart.DefaultBubbleOpacity = 0.85;
            ScatterChart.DimmedBubbleOpacity = 0.4;
            ScatterChart.StrokeDarkenColorValue = 255 * 0.25;
            //label layout settings
            ScatterChart.dataLabelLayoutStartingOffset = 2;
            ScatterChart.dataLabelLayoutOffsetIterationDelta = 6;
            ScatterChart.dataLabelLayoutMaximumOffset = ScatterChart.dataLabelLayoutStartingOffset + (2 * ScatterChart.dataLabelLayoutOffsetIterationDelta);
            // Chart Area and size range values as defined by PV charts
            ScatterChart.AreaOf300By300Chart = 90000;
            ScatterChart.MinSizeRange = 200;
            ScatterChart.MaxSizeRange = 3000;
            ScatterChart.ClassName = 'scatterChart';
            // Animated rendering threshold - if more than this number of data points, rendering is grouped by series and not animated
            ScatterChart.NoAnimationThreshold = 1000;
            // No render resize threshold - if more than this number of data points, rendering is suppressed during resize
            ScatterChart.NoRenderResizeThreshold = 1000;
            return ScatterChart;
        }());
        visuals.ScatterChart = ScatterChart;
        var SvgRenderer = (function () {
            function SvgRenderer() {
            }
            SvgRenderer.prototype.init = function (element, labelsContext, isMobileChart, tooltipsEnabled) {
                this.mainGraphicsG = element.append('g')
                    .classed(SvgRenderer.MainGraphicsContext.class, true);
                this.isMobileChart = isMobileChart;
                if (isMobileChart) {
                    // The backgroundRect catch user interactions when clicking/dragging on the background of the chart.
                    this.mainGraphicsBackgroundRect = this.mainGraphicsG
                        .append("rect")
                        .classed("backgroundRect", true)
                        .attr({ width: "100%", height: "100%" });
                }
                this.mainGraphicsContext = this.mainGraphicsG.append('svg');
                this.labelGraphicsContext = labelsContext;
                this.tooltipsEnabled = tooltipsEnabled;
                // common rendering attributes
                this.mainGraphicsContext.attr('stroke-width', "1");
            };
            SvgRenderer.prototype.render = function (viewModel, interactivityService) {
                var viewport = viewModel.viewport;
                this.mainGraphicsContext
                    .attr({
                    'width': viewport.width,
                    'height': viewport.height
                });
                var scatterMarkers;
                if (viewModel.suppressDataPointRendering) {
                    scatterMarkers = this.removeScatterMarkers();
                }
                else if (viewModel.animationDuration > 0 && viewModel.data.dataPoints.length <= ScatterChart.NoAnimationThreshold) {
                    scatterMarkers = this.drawScatterMarkers(viewModel);
                }
                else {
                    scatterMarkers = this.drawScatterMarkersNoAnimation(viewModel, viewModel.drawBubbles);
                }
                if (viewModel.drawBubbles)
                    scatterMarkers.order();
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(this.mainGraphicsContext, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(viewModel.animationOptions);
                return {
                    dataPointsSelection: scatterMarkers,
                    eventGroup: this.mainGraphicsG,
                    data: viewModel.data,
                    plotContext: this.mainGraphicsContext,
                };
            };
            SvgRenderer.prototype.createTraceLineRenderer = function (viewModel) {
                return new ScatterTraceLineRenderer(viewModel, this.mainGraphicsContext, this.tooltipsEnabled);
            };
            SvgRenderer.prototype.removeScatterMarkers = function () {
                this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
                    .remove();
                return this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
            };
            SvgRenderer.prototype.drawScatterMarkers = function (viewModel) {
                var data = viewModel.data;
                var xScale = viewModel.xAxisProperties.scale;
                var yScale = viewModel.yAxisProperties.scale;
                // put all the markers in a single fake group. keeps the dom structure consistent between
                // drawScatterMarkers and drawScatterMarkersGrouped.
                var fakeDataPointSeries = [
                    {
                        identityKey: "",
                        dataPoints: data.dataPoints,
                    },
                ];
                var fakeSeriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
                    .data(fakeDataPointSeries, function (s) { return s.identityKey; });
                fakeSeriesGroups.enter()
                    .append('g')
                    .classed(SvgRenderer.ScatterMarkerSeriesGroup.class, true);
                // groups for real series may have been inserted by drawScatterMarkersGrouped, remove them
                fakeSeriesGroups.exit()
                    .remove();
                var markers = fakeSeriesGroups.selectAll(SvgRenderer.DotClass.selector)
                    .data(function (s) { return s.dataPoints; }, function (d) { return d.identity.getKey(); });
                markers.enter().append('circle')
                    .classed(SvgRenderer.DotClass.class, true)
                    .style('opacity', 0) // Fade new bubbles into visibility
                    .attr('r', 0);
                markers
                    .style({
                    'stroke-opacity': function (d) { return ScatterChart.getMarkerStrokeOpacity(d.size != null, data.colorBorder, viewModel.hasSelection, d.selected); },
                    'stroke': function (d) { return ScatterChart.getStrokeFill(d, data.colorBorder); },
                    'fill': function (d) { return d.fill; },
                    'fill-opacity': function (d) { return ScatterChart.getMarkerFillOpacity(d.size != null, viewModel.fillMarkers, viewModel.hasSelection, d.selected); },
                })
                    .transition()
                    .ease(viewModel.easeType)
                    .duration(viewModel.animationDuration)
                    .style('opacity', 1) // Fill-opacity is used for selected / highlight changes, opacity is for enter/exit fadein/fadeout
                    .attr({
                    r: function (d) { return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport); },
                    cx: function (d) { return xScale(d.x); },
                    cy: function (d) { return yScale(d.y); },
                });
                markers
                    .exit()
                    .transition()
                    .ease(viewModel.easeType)
                    .duration(viewModel.animationDuration)
                    .style('opacity', 0) // Fade out bubbles that are removed
                    .attr('r', 0)
                    .remove();
                return markers;
            };
            SvgRenderer.prototype.drawScatterMarkersNoAnimation = function (viewModel, isBubble) {
                var data = viewModel.data;
                var xScale = viewModel.xAxisProperties.scale;
                var yScale = viewModel.yAxisProperties.scale;
                var seriesGroups;
                if (isBubble) {
                    var fakeDataPointSeries = [
                        {
                            identityKey: "",
                            dataPoints: data.dataPoints,
                        },
                    ];
                    seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector)
                        .data(fakeDataPointSeries, function (s) { return s.identityKey; });
                }
                else {
                    seriesGroups = this.mainGraphicsContext.selectAll(SvgRenderer.ScatterMarkerSeriesGroup.selector).data(data.dataPointSeries, function (s) { return s.identityKey; });
                }
                // a group for each series
                seriesGroups.enter()
                    .append('g')
                    .classed(SvgRenderer.ScatterMarkerSeriesGroup.class, true);
                // this will also remove the fake group that might have been created by drawScatterMarkers
                seriesGroups.exit()
                    .remove();
                seriesGroups
                    .each(function (s) {
                    var seriesStyle = ScatterChart.getSeriesStyle(s.hasSize, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers, s.fill);
                    var g = d3.select(this);
                    SvgRenderer.applyStyle(this, seriesStyle);
                    var markers = g.selectAll(SvgRenderer.DotClass.selector).data(s.dataPoints, function (m) { return m.identity.getKey(); });
                    markers.enter()
                        .append('circle')
                        .classed(SvgRenderer.DotClass.class, true);
                    markers.exit()
                        .remove();
                    markers.each(function (d) {
                        var style = ScatterChart.getMarkerStyle(d, data.colorBorder, viewModel.hasSelection, viewModel.fillMarkers);
                        SvgRenderer.styleException(style, seriesStyle);
                        SvgRenderer.applyStyle(this, style);
                    });
                    markers.attr({
                        r: function (d) { return ScatterChart.getBubbleRadius(d.radius, data.sizeRange, viewModel.viewport); },
                        cx: function (d) { return xScale(d.x); },
                        cy: function (d) { return yScale(d.y); },
                    });
                });
                return this.mainGraphicsContext.selectAll(SvgRenderer.DotClass.selector);
            };
            SvgRenderer.styleException = function (elementStyle, seriesStyle) {
                if (seriesStyle) {
                    for (var name_1 in elementStyle) {
                        if (elementStyle[name_1] === seriesStyle[name_1]) {
                            elementStyle[name_1] = null;
                        }
                    }
                }
            };
            SvgRenderer.applyStyle = function (element, style) {
                for (var name_2 in style) {
                    var elementValue = element.style[name_2];
                    var styleValue = style[name_2];
                    if (styleValue == null) {
                        if (elementValue === "")
                            continue;
                    }
                    else {
                        styleValue = styleValue.toString();
                        if (styleValue === elementValue)
                            continue;
                    }
                    element.style[name_2] = styleValue;
                }
            };
            SvgRenderer.DotClass = createClassAndSelector('dot');
            SvgRenderer.MainGraphicsContext = createClassAndSelector('mainGraphicsContext');
            SvgRenderer.ScatterMarkerSeriesGroup = createClassAndSelector('scatterMarkerSeriesGroup');
            return SvgRenderer;
        }());
        var ScatterChartDataLabels;
        (function (ScatterChartDataLabels) {
            var validLabelPositions = [
                2 /* Below */,
                1 /* Above */,
                8 /* Right */,
                4 /* Left */,
                16 /* BelowRight */,
                32 /* BelowLeft */,
                64 /* AboveRight */,
                128 /* AboveLeft */
            ];
            function createLabelDataPoints(viewModel) {
                var xScale = viewModel.xAxisProperties.scale;
                var yScale = viewModel.yAxisProperties.scale;
                var sizeRange = viewModel.data.sizeRange;
                var labelDataPoints = [];
                var dataPoints = viewModel.data.dataPoints;
                var labelSettings = viewModel.data.dataLabelsSettings;
                var preferredLabelsKeys = getPreferredLabelsKeys(viewModel);
                for (var _i = 0, dataPoints_4 = dataPoints; _i < dataPoints_4.length; _i++) {
                    var dataPoint = dataPoints_4[_i];
                    var text = dataPoint.formattedCategory.getValue();
                    var properties = {
                        text: text,
                        fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                        fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                        fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                    };
                    var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                    var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties);
                    labelDataPoints.push({
                        isPreferred: preferredLabelsKeys ? isLabelPreferred(dataPoint.identity.getKey(), preferredLabelsKeys) : false,
                        text: text,
                        textSize: {
                            width: textWidth,
                            height: textHeight,
                        },
                        outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                        insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                        parentType: 0 /* Point */,
                        parentShape: {
                            point: {
                                x: xScale(dataPoint.x),
                                y: yScale(dataPoint.y),
                            },
                            radius: ScatterChart.getBubbleRadius(dataPoint.radius, sizeRange, viewModel.viewport),
                            validPositions: validLabelPositions,
                        },
                        identity: dataPoint.identity,
                        fontSize: labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt,
                    });
                }
                return labelDataPoints;
            }
            ScatterChartDataLabels.createLabelDataPoints = createLabelDataPoints;
            function getPreferredLabelsKeys(viewModel) {
                var width = viewModel.viewport.width;
                var height = viewModel.viewport.height;
                var visualCenter = new visuals.Point(width / 2, height / 2);
                var quadrantsCenters = getQuadrantsCenters(width, height);
                return getCandidateLabels(visualCenter, quadrantsCenters, viewModel);
            }
            function getQuadrantsCenters(visualWidth, visualHeight) {
                var quadrantsCenters = [];
                var quarterWidth = visualWidth / 4;
                var quarterHeight = visualHeight / 4;
                quadrantsCenters.push(new visuals.Point(quarterWidth, quarterHeight));
                quadrantsCenters.push(new visuals.Point(quarterWidth * 3, quarterHeight));
                quadrantsCenters.push(new visuals.Point(quarterWidth, quarterHeight * 3));
                quadrantsCenters.push(new visuals.Point(quarterWidth * 3, quarterHeight * 3));
                return quadrantsCenters;
            }
            function getCandidateLabels(visualCenter, quadrantsCenters, viewModel) {
                var minDistances = [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE];
                var ids = [];
                var xScale = viewModel.xAxisProperties.scale;
                var yScale = viewModel.yAxisProperties.scale;
                var distance;
                for (var _i = 0, _a = viewModel.data.dataPoints; _i < _a.length; _i++) {
                    var dp = _a[_i];
                    var x = xScale(dp.x);
                    var y = yScale(dp.y);
                    var quadrantNumber = getPointQuadrantNumber(x, y, visualCenter);
                    if (viewModel.drawBubbles) {
                        // Since the array is sorted by size the preferred label will be the first label in the quadrant
                        if (!ids[quadrantNumber])
                            ids[quadrantNumber] = dp.identity;
                    }
                    else {
                        distance = getDistanceBetweenPoints(quadrantsCenters[quadrantNumber].x, quadrantsCenters[quadrantNumber].y, x, y);
                        if (distance < minDistances[quadrantNumber]) {
                            ids[quadrantNumber] = dp.identity;
                            minDistances[quadrantNumber] = distance;
                        }
                    }
                }
                var preferredLabelsKeys = [];
                for (var _b = 0, ids_1 = ids; _b < ids_1.length; _b++) {
                    var id = ids_1[_b];
                    if (id)
                        preferredLabelsKeys.push(id.getKey());
                }
                return preferredLabelsKeys;
            }
            function getPointQuadrantNumber(x, y, centerPoint) {
                if (x > centerPoint.x && y <= centerPoint.y)
                    return 0 /* First */;
                if (x <= centerPoint.x && y <= centerPoint.y)
                    return 1 /* Second */;
                if (x <= centerPoint.x && y > centerPoint.y)
                    return 2 /* Third */;
                else
                    return 3 /* Fourth */;
            }
            function getDistanceBetweenPoints(x1, y1, x2, y2) {
                return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));
            }
            function isLabelPreferred(key, preferredLabelsKeys) {
                for (var _i = 0, preferredLabelsKeys_1 = preferredLabelsKeys; _i < preferredLabelsKeys_1.length; _i++) {
                    var preferredLabel = preferredLabelsKeys_1[_i];
                    if (key.localeCompare(preferredLabel) === 0)
                        return true;
                }
                return false;
            }
        })(ScatterChartDataLabels || (ScatterChartDataLabels = {}));
        var ScatterTraceLineRenderer = (function () {
            function ScatterTraceLineRenderer(viewModel, element, tooltipsEnabled) {
                this.viewModel = viewModel;
                this.element = element;
                this.tooltipsEnabled = tooltipsEnabled;
            }
            ScatterTraceLineRenderer.prototype.remove = function () {
                this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector).remove();
                this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector).remove();
            };
            ScatterTraceLineRenderer.prototype.render = function (selectedPoints, shouldAnimate) {
                var viewModel = this.viewModel;
                var scatterViewModel = viewModel.viewModel;
                var seriesPoints = [];
                if (!_.isEmpty(selectedPoints) && !scatterViewModel.suppressDataPointRendering) {
                    var currentFrameIndex_1 = viewModel.data.currentFrameIndex;
                    // filter to the selected identity, only up to and including the current frame. Add frames during play.
                    var hasBubbleAtCurrentFrame = [];
                    for (var selectedIndex = 0, selectedLen = selectedPoints.length; selectedIndex < selectedLen; selectedIndex++) {
                        seriesPoints[selectedIndex] = [];
                        hasBubbleAtCurrentFrame[selectedIndex] = false;
                        for (var frameIndex = 0, frameLen = viewModel.data.allViewModels.length; frameIndex < frameLen && frameIndex <= currentFrameIndex_1; frameIndex++) {
                            var value = _.find(viewModel.data.allViewModels[frameIndex].dataPoints, function (value, index) {
                                return value.identity.getKey() === selectedPoints[selectedIndex].identity.getKey();
                            });
                            if (value != null) {
                                // TODO: Revisit this, we should be able to keep track without modifying Scatter's data points.
                                value.frameIndex = frameIndex;
                                seriesPoints[selectedIndex].push(value);
                                if (frameIndex === currentFrameIndex_1)
                                    hasBubbleAtCurrentFrame[selectedIndex] = true;
                            }
                        }
                    }
                    var xScale_1 = scatterViewModel.xAxisProperties.scale;
                    var yScale_1 = scatterViewModel.yAxisProperties.scale;
                    var line_1 = d3.svg.line()
                        .x(function (d) { return xScale_1(d.x); })
                        .y(function (d) { return yScale_1(d.y); })
                        .defined(function (d) { return d.x !== null && d.y !== null; });
                    // Render Lines
                    var traceLines = this.element.selectAll(ScatterTraceLineRenderer.TraceLine.selector)
                        .data(selectedPoints, function (sp) { return sp.identity.getKey(); });
                    traceLines.enter()
                        .append('path')
                        .classed(ScatterTraceLineRenderer.TraceLine.class, true);
                    // prepare array of new/previous lengths
                    // NOTE: can't use lambda because we need the "this" context to be the DOM Element associated with the .each()
                    var previousLengths_1 = [], newLengths_1 = [];
                    var reverse_1 = false;
                    traceLines.each(function (d, i) {
                        var existingPath = this;
                        var previousLength = existingPath.hasAttribute('d') ? existingPath.getTotalLength() : 0;
                        previousLengths_1.push(previousLength);
                        // create offline SVG for new path measurement
                        var tempSvgPath = $('<svg><path></path></svg>');
                        var tempPath = $('path', tempSvgPath);
                        tempPath.attr('d', line_1(seriesPoints[i]));
                        var newLength = seriesPoints[i].length > 0 ? tempPath.get()[0].getTotalLength() : 0;
                        newLengths_1.push(newLength);
                        reverse_1 = reverse_1 || (newLength < previousLength);
                    });
                    // animate using stroke-dash* trick
                    if (!reverse_1) {
                        // growing line
                        traceLines
                            .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
                            .attr({
                            'd': function (d, i) {
                                return line_1(seriesPoints[i]);
                            },
                            'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
                            'stroke-dashoffset': function (d, i) { return newLengths_1[i] - previousLengths_1[i]; },
                        });
                        if (shouldAnimate) {
                            traceLines
                                .transition()
                                .ease('linear')
                                .duration(visuals.PlayChart.FrameAnimationDuration)
                                .attr('stroke-dashoffset', 0);
                        }
                        else {
                            traceLines.attr('stroke-dashoffset', 0);
                        }
                    }
                    else {
                        // shrinking line
                        if (shouldAnimate) {
                            traceLines
                                .transition()
                                .ease('linear')
                                .duration(visuals.PlayChart.FrameAnimationDuration)
                                .attr('stroke-dashoffset', function (d, i) { return previousLengths_1[i] - newLengths_1[i]; })
                                .transition()
                                .ease('linear')
                                .duration(1) // animate the shrink first, then update with new line properties
                                .delay(visuals.PlayChart.FrameAnimationDuration)
                                .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
                                .attr({
                                'd': function (d, i) {
                                    return line_1(seriesPoints[i]);
                                },
                                'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
                                'stroke-dashoffset': 0,
                            });
                        }
                        else {
                            traceLines
                                .style('stroke', function (d) { return ScatterChart.getStrokeFill(d, true); })
                                .attr({
                                'd': function (d, i) {
                                    return line_1(seriesPoints[i]);
                                },
                                'stroke-dasharray': function (d, i) { return newLengths_1[i] + " " + newLengths_1[i]; },
                                'stroke-dashoffset': 0,
                            });
                        }
                    }
                    traceLines.exit()
                        .remove();
                    // Render circles
                    var circlePoints = [];
                    for (var selectedIndex_1 = 0; selectedIndex_1 < seriesPoints.length; selectedIndex_1++) {
                        var points = seriesPoints[selectedIndex_1];
                        // slice to length-1 because we draw lines to the current bubble but we don't need to draw the current frame's bubble
                        var newPoints = hasBubbleAtCurrentFrame[selectedIndex_1] ? points.slice(0, points.length - 1) : points;
                        circlePoints = circlePoints.concat(newPoints);
                    }
                    var circles = this.element.selectAll(ScatterTraceLineRenderer.TraceBubble.selector)
                        .data(circlePoints, function (d) { return d.identity.getKey() + d.x + d.y + d.size; });
                    circles.enter()
                        .append('circle')
                        .style('opacity', 0) //fade new bubbles into visibility
                        .classed(ScatterTraceLineRenderer.TraceBubble.class, true);
                    circles
                        .attr('cx', function (d) { return xScale_1(d.x); })
                        .attr('cy', function (d) { return yScale_1(d.y); })
                        .attr('r', function (d) { return ScatterChart.getBubbleRadius(d.radius, viewModel.data.currentViewModel.sizeRange, viewModel.viewport); })
                        .style({
                        'stroke-opacity': function (d) { return ScatterChart.getBubbleOpacity(d, true); },
                        'stroke': function (d) { return ScatterChart.getStrokeFill(d, viewModel.data.currentViewModel.colorBorder); },
                        'fill': function (d) { return d.fill; },
                        // vary the opacity along the traceline from 0.20 to 0.80, with 0.85 left for the circle already drawn by scatterChart
                        'fill-opacity': function (d) { return d.size != null ? 0.20 + (d.frameIndex / currentFrameIndex_1) * 0.60 : 0; },
                    })
                        .transition()
                        .ease('linear')
                        .duration(visuals.PlayChart.FrameAnimationDuration)
                        .style('opacity', 1);
                    circles.exit()
                        .transition()
                        .ease('linear')
                        .duration(visuals.PlayChart.FrameAnimationDuration)
                        .style('opacity', 0) // fade exiting bubbles out
                        .remove();
                    if (this.tooltipsEnabled) {
                        visuals.TooltipManager.addTooltip(circles, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                    }
                    // sort the z-order, smallest size on top
                    circles.sort(function (d1, d2) { return d2.size - d1.size; });
                }
                else {
                    this.remove();
                }
            };
            ScatterTraceLineRenderer.TraceLine = createClassAndSelector('traceLine');
            ScatterTraceLineRenderer.TraceBubble = createClassAndSelector('traceBubble');
            return ScatterTraceLineRenderer;
        }());
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var createDataViewScopeIdentity = powerbi.data.createDataViewScopeIdentity;
        var DataViewConcatenateCategoricalColumns = powerbi.data.DataViewConcatenateCategoricalColumns;
        var DataViewMatrixUtils = powerbi.data.utils.DataViewMatrixUtils;
        var SQExprBuilder = powerbi.data.SQExprBuilder;
        ;
        var PlayAxis = (function () {
            function PlayAxis(options) {
                if (options) {
                    this.interactivityService = options.interactivityService;
                }
            }
            PlayAxis.prototype.init = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                this.element = options.element;
                this.svg = options.svg;
                this.host = options.host;
                this.isMobileChart = options.interactivity && options.interactivity.isInteractiveLegend;
                if (this.interactivityService) {
                    this.playControl = new PlayControl(this.element, function (frameIndex) { return _this.moveToFrameAndRender(frameIndex); }, this.isMobileChart);
                    this.playControl.onPlay(function () { return _this.play(); });
                }
            };
            PlayAxis.prototype.setData = function (dataView, visualConverter) {
                if (dataView) {
                    if (this.ridiculousFlagForPersistProperties && dataView.metadata) {
                        // BUG FIX: customer feedback has been strong that we should always default to show the last frame.
                        // This is essential for dashboard tiles to refresh properly.
                        //  Only copy frameIndex since it is the only property using persistProperties
                        //let objectProps = getObjectProperties(dataView.metadata);
                        //playData.currentFrameIndex = objectProps.currentFrameIndex;
                        //  Turn off the flag that was set by our persistProperties call
                        this.ridiculousFlagForPersistProperties = false;
                        return this.playData;
                    }
                    else if (dataView.matrix || dataView.categorical) {
                        this.playData = PlayChart.converter(dataView, visualConverter);
                    }
                    else {
                        this.playData = PlayChart.getDefaultPlayData();
                    }
                }
                else {
                    this.playData = PlayChart.getDefaultPlayData();
                }
                // Next render should be a full one.
                this.lastViewport = undefined;
                return this.playData;
            };
            PlayAxis.prototype.render = function (suppressAnimations, viewModel, viewport, margin) {
                var playData = this.playData;
                var resized = !this.lastViewport || (this.lastViewport.height !== viewport.height || this.lastViewport.width !== viewport.width);
                this.lastViewport = viewport;
                if (resized)
                    this.stop();
                if (!playData)
                    return;
                var playViewModel = {
                    data: this.playData,
                    viewModel: viewModel,
                    viewport: viewport,
                };
                var hasSelection = false;
                if (this.interactivityService) {
                    var data_5 = playData.currentViewModel;
                    this.interactivityService.applySelectionStateToData(data_5.dataPoints);
                    hasSelection = this.interactivityService.hasSelection();
                }
                this.updateCallout(viewport, margin);
                if (this.playControl && resized) {
                    this.playControl.rebuild(playData, viewport);
                }
                var allDataPoints = playData.allViewModels.map(function (vm) { return vm.dataPoints; });
                var flatAllDataPoints = _.flatten(allDataPoints);
                // NOTE: Return data points to keep track of current selected bubble even if it drops out for a few frames
                return {
                    allDataPoints: flatAllDataPoints,
                    viewModel: playViewModel,
                };
            };
            PlayAxis.prototype.updateCallout = function (viewport, margin) {
                var playData = this.playData;
                var frameKeys = playData.frameKeys;
                var currentFrameIndex = playData.currentFrameIndex;
                var height = viewport.height;
                var plotAreaHeight = height - margin.top - margin.bottom;
                var width = viewport.width;
                var plotAreaWidth = width - margin.left - margin.right;
                var calloutDimension = Math.min(height, width * 1.3); //1.3 to compensate for tall, narrow-width viewport
                var fontSize = Math.max(12, Math.round(calloutDimension / 7));
                fontSize = Math.min(fontSize, 70);
                var textProperties = {
                    fontSize: jsCommon.PixelConverter.toString(fontSize),
                    text: frameKeys[currentFrameIndex] || "",
                    fontFamily: "wf_segoe-ui_normal",
                };
                var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(textProperties) - powerbi.TextMeasurementService.estimateSvgTextBaselineDelta(textProperties);
                var calloutData = [];
                if (currentFrameIndex < frameKeys.length && currentFrameIndex >= 0 && textHeight < plotAreaHeight) {
                    var maxTextWidth = plotAreaWidth - (2 * PlayAxis.calloutOffsetMultiplier * textHeight);
                    var calloutText = powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, maxTextWidth);
                    calloutData = [calloutText];
                }
                var callout = this.svg.selectAll(PlayAxis.PlayCallout.selector).data(calloutData);
                callout.enter()
                    .append('text')
                    .classed(PlayAxis.PlayCallout.class, true);
                callout
                    .text(function (d) { return d; })
                    .attr({
                    x: plotAreaWidth - PlayAxis.calloutOffsetMultiplier * textHeight,
                    y: function () { return textHeight; },
                })
                    .style({
                    'font-size': fontSize + 'px',
                    'text-anchor': 'end',
                });
                callout.exit().remove();
            };
            PlayAxis.prototype.play = function () {
                var playData = this.playData;
                if (this.isPlaying) {
                    this.stop();
                }
                else if (this.playControl) {
                    this.isPlaying = true;
                    this.playControl.play();
                    var indexToShow = Math.round(this.playControl.getCurrentIndex());
                    if (indexToShow >= playData.allViewModels.length - 1) {
                        playData.currentFrameIndex = -1;
                    }
                    else {
                        playData.currentFrameIndex = indexToShow - 1;
                    }
                    this.playNextFrame(playData);
                }
            };
            PlayAxis.prototype.playNextFrame = function (playData, startFrame, endFrame) {
                var _this = this;
                if (!this.isPlaying) {
                    this.stop();
                    return;
                }
                var nextFrame = playData.currentFrameIndex + 1;
                if (startFrame != null && endFrame != null) {
                    nextFrame = Math.abs(endFrame - startFrame + 1);
                    startFrame = nextFrame;
                }
                if (nextFrame < playData.allViewModels.length && nextFrame > -1) {
                    playData.currentFrameIndex = nextFrame;
                    playData.currentViewModel = playData.allViewModels[nextFrame];
                    this.renderDelegate(playData.currentViewModel);
                    this.playControl.setFrame(nextFrame);
                    if (nextFrame < playData.allViewModels.length) {
                        window.setTimeout(function () {
                            _this.playNextFrame(playData, startFrame, endFrame);
                        }, PlayChart.FrameStepDuration);
                    }
                }
                else {
                    this.stop();
                }
            };
            PlayAxis.prototype.stop = function () {
                if (this.playControl)
                    this.playControl.pause();
                this.isPlaying = false;
            };
            PlayAxis.prototype.remove = function () {
                if (this.playControl)
                    this.playControl.remove();
                d3.selectAll(PlayAxis.PlayCallout.selector).remove();
                // TODO: remove any tracelines
            };
            PlayAxis.prototype.setRenderFunction = function (fn) {
                this.renderDelegate = fn;
            };
            PlayAxis.prototype.getCartesianExtents = function (existingExtents, getExtents) {
                if (this.playData && this.playData.allViewModels && this.playData.allViewModels.length > 0) {
                    return PlayChart.getMinMaxForAllFrames(this.playData, getExtents);
                }
                return existingExtents;
            };
            PlayAxis.prototype.setPlayControlPosition = function (playControlLayout) {
                if (this.playControl) {
                    var container = this.playControl.getContainer();
                    container.css('left', playControlLayout.left ? playControlLayout.left + 'px' : '');
                    container.css('top', playControlLayout.top ? playControlLayout.top + 'px' : '');
                }
            };
            PlayAxis.prototype.moveToFrameAndRender = function (frameIndex) {
                var playData = this.playData;
                this.isPlaying = false;
                if (playData && frameIndex >= 0 && frameIndex < playData.allViewModels.length && frameIndex !== playData.currentFrameIndex) {
                    playData.currentFrameIndex = frameIndex;
                    var data_6 = playData.allViewModels[frameIndex];
                    playData.currentViewModel = data_6;
                    this.renderDelegate(data_6);
                }
            };
            PlayAxis.PlayCallout = createClassAndSelector('play-callout');
            PlayAxis.calloutOffsetMultiplier = 0.3;
            return PlayAxis;
        }());
        visuals.PlayAxis = PlayAxis;
        var PlayControl = (function () {
            function PlayControl(element, renderDelegate, isMobileChart) {
                this.isMobileChart = isMobileChart;
                this.createSliderDOM(element);
                this.renderDelegate = renderDelegate;
            }
            PlayControl.prototype.getContainer = function () {
                return this.playAxisContainer;
            };
            PlayControl.prototype.remove = function () {
                if (this.playAxisContainer)
                    this.playAxisContainer.remove();
            };
            PlayControl.prototype.pause = function () {
                this.playButton.removeClass('pause').addClass('play');
            };
            PlayControl.prototype.play = function () {
                this.playButton.removeClass('play').addClass('pause');
            };
            PlayControl.prototype.getCurrentIndex = function () {
                // TODO: round() necessary?
                return Math.round(this.noUiSlider.get());
            };
            PlayControl.prototype.onPlay = function (handler) {
                this.playButtonCircle.off('click');
                this.playButtonCircle.on('click', handler);
            };
            PlayControl.calculateSliderWidth = function (labelData, viewportWidth) {
                var leftMargin = 0, rightMargin = 0;
                if (!_.isEmpty(labelData.labelInfo)) {
                    leftMargin = _.first(labelData.labelInfo).labelWidth / 2;
                    rightMargin = _.last(labelData.labelInfo).labelWidth / 2;
                }
                var sliderLeftMargin = Math.max(leftMargin, PlayControl.SliderMarginLeft);
                var sliderRightMargin = Math.max(rightMargin, PlayControl.SliderMarginRight);
                sliderLeftMargin = Math.min(PlayControl.SliderMaxMargin, sliderLeftMargin);
                sliderRightMargin = Math.min(PlayControl.SliderMaxMargin, sliderRightMargin);
                var sliderWidth = Math.max((viewportWidth - sliderLeftMargin - sliderRightMargin), 1);
                return sliderWidth;
            };
            PlayControl.prototype.createSliderDOM = function (element) {
                this.playAxisContainer = $('<div class="play-axis-container"></div>')
                    .appendTo(element)
                    .css('height', PlayControl.PlayControlHeight + 'px');
                this.playButtonCircle = $('<div class="button-container"></div>')
                    .appendTo(this.playAxisContainer);
                if (this.isMobileChart) {
                    this.playButtonCircle.addClass('mobile-button-container');
                }
                this.playButton = $('<div class="play"></div>')
                    .appendTo(this.playButtonCircle);
                this.slider = $('<div class="sliders"></div>')
                    .appendTo(this.playAxisContainer);
            };
            PlayControl.prototype.rebuild = function (playData, viewport) {
                var _this = this;
                var slider = this.slider;
                // re-create the slider
                if (this.noUiSlider)
                    this.noUiSlider.destroy();
                var sliderElement = this.slider.get(0);
                var labelData = playData.labelData;
                var sliderWidth = PlayControl.calculateSliderWidth(labelData, viewport.width);
                this.slider.css('width', sliderWidth + 'px');
                var numFrames = playData.frameKeys.length;
                if (numFrames > 0) {
                    var filterPipLabels = PlayChart.createPipsFilterFn(playData, sliderWidth, labelData);
                    var lastIndex = numFrames - 1;
                    noUiSlider.create(sliderElement, {
                        step: 1,
                        start: [playData.currentFrameIndex],
                        range: {
                            min: [0],
                            max: [lastIndex],
                        },
                        pips: {
                            mode: 'steps',
                            density: Math.round(100 / numFrames),
                            format: {
                                to: function (index) { return playData.frameKeys[index]; },
                                from: function (value) { return playData.frameKeys.indexOf(value); },
                            },
                            filter: filterPipLabels,
                        },
                    });
                }
                else {
                    noUiSlider.create(sliderElement, {
                        step: 1,
                        start: [0],
                        range: {
                            min: [0],
                            max: [0],
                        },
                    });
                }
                this.noUiSlider = sliderElement.noUiSlider;
                this.noUiSlider.on('slide', function () {
                    var indexToShow = _this.getCurrentIndex();
                    _this.renderDelegate(indexToShow);
                });
                // update the width and margin-left to center up each label
                $('.noUi-value', slider).each(function (idx, elem) {
                    // TODO: better way to get the label info for an element?
                    var actualWidth = labelData.labelInfo.filter(function (l) { return l.label === $(elem).text(); })[0].labelWidth;
                    $(elem).width(actualWidth);
                    $(elem).css('margin-left', -actualWidth / 2 + 'px');
                });
                if (this.isMobileChart) {
                    $('.noUi-handle').addClass('mobile-noUi-handle');
                }
            };
            PlayControl.prototype.setFrame = function (frameIndex) {
                this.noUiSlider.set([frameIndex]);
            };
            ;
            PlayControl.SliderMarginLeft = 24 + 10 * 2; // playButton width + playButton margin * 2
            PlayControl.SliderMarginRight = 20;
            PlayControl.SliderMaxMargin = 100;
            PlayControl.PlayControlHeight = 80; //tuned for two rows of label text to be perfectly clipped before the third row. Dependent on current font sizes in noui-pips.css
            return PlayControl;
        }());
        var PlayChart;
        (function (PlayChart) {
            // TODO: add speed control to property pane
            // NOTE: current noUiSlider speed is a CSS property of the class .noUi-state-tap, and also is hard-coded in noUiSlider.js. We'll need to add a new create param for transition time.
            // 800ms matches Silverlight frame speed
            PlayChart.FrameStepDuration = 800;
            PlayChart.FrameAnimationDuration = 750; //leave 50ms for the traceline animation - to avoid being cancelled. TODO: add a proper wait impl.
            PlayChart.ClassName = 'playChart';
            function convertMatrixToCategorical(sourceDataView, frame) {
                debug.assert(sourceDataView && sourceDataView.metadata && !!sourceDataView.matrix, 'sourceDataView && sourceDataView.metadata && !!sourceDataView.matrix');
                var matrix = sourceDataView.matrix;
                var categorical = {
                    categories: [],
                    values: powerbi.data.DataViewTransform.createValueColumns()
                };
                // If we don't have enough fields, just return early. We need at least:
                // 2 rows and 1 column:  (play->category, measures)
                // or:
                // 1 row and 2 columns:  (play, series->measures)
                if ((_.isEmpty(matrix.columns.levels)) || (matrix.rows.levels.length < 2 && matrix.columns.levels.length < 2)) {
                    return { metadata: sourceDataView.metadata, categorical: categorical };
                }
                var CategoryRowLevelsStartingIndex = 1;
                var categories = [];
                // Ignore the play field (first row level); the Category field(s) starts from the second row group (play->category) or we don't use this variable (categories)
                // Note related to VSTS 6986788 and 6885783: there are multiple levels for category during drilldown and expand.
                for (var i_2 = CategoryRowLevelsStartingIndex, ilen = matrix.rows.levels.length; i_2 < ilen; i_2++) {
                    // Consider: Change the following debug.assert() to retail.assert() when the infrastructure is ready.
                    debug.assert(matrix.rows.levels[i_2].sources.length > 0, 'The sources is always expected to contain at least one metadata column.');
                    var sourceColumn = matrix.rows.levels[i_2].sources[0];
                    categories.push({
                        source: sourceColumn,
                        values: [],
                        identity: [],
                        objects: undefined,
                    });
                }
                // Matrix shape for Play:
                //
                //                   Series1 | Series2 | ...
                //                  --------- --------  
                // Play1 | Category1 | values  | values
                //       | Category2 | values  | values
                //       | ...
                // Play2 | Category1 | values  | values
                //       | Category2 | values  | values
                // ...
                // Or, with drilldown / expand on Category (e.g. expand Country -> Region):
                //                             Series1 | Series2 | ...
                //                           --------- --------  
                // Play1 | Country1 | Region1 | values  | values
                //       |          | Region2 | values  | values
                //       | Country2 | Region3 | values  | values
                //       |          | Region4 | values  | values
                //       | ...
                // Play2 | Country1 | Region1 | values  | values
                //       |          | Region2 | values  | values
                //       | Country2 | Region3 | values  | values
                //       |          | Region4 | values  | values
                // we are guaranteed at least one row (it will be the Play field)
                var hasRowChildren = !_.isEmpty(matrix.rows.root.children);
                var hasColChildren = !_.isEmpty(matrix.columns.root.children);
                var hasSeries = matrix.columns.levels.length > 1 && hasColChildren;
                var hasPlayAndCategory = matrix.rows.levels.length > 1 && hasRowChildren;
                if (hasSeries && !hasPlayAndCategory) {
                    // set categories to undefined
                    categorical.categories = undefined;
                    var node = matrix.columns.root;
                    categorical.values.source = matrix.columns.levels[0].sources[0];
                    var columnLength_1 = matrix.valueSources.length;
                    for (var i_3 = 0, len_1 = node.children.length; i_3 < len_1; i_3++) {
                        // add all the value sources for each series
                        var columnNode = node.children[i_3];
                        for (var j = 0; j < columnLength_1; j++) {
                            // DEFECT 6547170: groupName must be null to turn into (Blank), undefined will use the field name
                            var source = _.create(matrix.valueSources[j], { groupName: columnNode.value === undefined ? null : columnNode.value });
                            var dataViewColumn = {
                                identity: columnNode.identity,
                                values: [],
                                source: source
                            };
                            categorical.values.push(dataViewColumn);
                        }
                    }
                    // Copying the values from matrix intersection to the categorical values columns...
                    // Given that this is the case without category levels, the matrix intersection values are stored in playFrameNode.values
                    var playFrameNode = matrix.rows.root.children[frame];
                    var matrixIntersectionValues = playFrameNode.values;
                    for (var i = 0, len = node.children.length; i < len; i++) {
                        for (var j = 0; j < columnLength_1; j++) {
                            categorical.values[i * columnLength_1 + j].values.push(matrixIntersectionValues[i * columnLength_1 + j].value);
                        }
                    }
                }
                else if (hasSeries && hasRowChildren) {
                    // series and categories
                    var playFrameNode = matrix.rows.root.children[frame];
                    // create the categories first
                    DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function (categoryGroupLeafNode, index, categoryHierarchicalGroupNodes) {
                        addMatrixHierarchicalGroupToCategories(categoryHierarchicalGroupNodes, categories);
                    });
                    categorical.categories = categories;
                    // now add the series info
                    categorical.values.source = matrix.columns.levels[0].sources[0];
                    var nodeQueue = [];
                    var columnNode = matrix.columns.root;
                    var seriesIndex_1 = -1;
                    while (columnNode) {
                        if (columnNode.children && columnNode.children[0].children) {
                            for (var j = 0, jlen = columnNode.children.length; j < jlen; j++) {
                                // each of these is a "series"
                                nodeQueue.push(columnNode.children[j]);
                            }
                        }
                        else if (columnNode.children && playFrameNode.children) {
                            // Processing a single series under here, push all the value sources for every series.
                            var columnLength = columnNode.children.length;
                            for (var j = 0; j < columnLength; j++) {
                                var source = _.create(matrix.valueSources[j], { groupName: columnNode.value });
                                var dataViewColumn = {
                                    identity: columnNode.identity,
                                    values: [],
                                    source: source,
                                };
                                categorical.values.push(dataViewColumn);
                            }
                            // Copying the values from matrix intersection to the categorical values columns...
                            DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function (leafNode) {
                                for (var j = 0; j < columnLength; j++) {
                                    categorical.values[seriesIndex_1 * columnLength + j].values.push(leafNode.values[seriesIndex_1 * columnLength + j].value);
                                }
                            });
                        }
                        if (nodeQueue.length > 0) {
                            columnNode = nodeQueue[0];
                            nodeQueue = nodeQueue.splice(1);
                            seriesIndex_1++;
                        }
                        else
                            columnNode = undefined;
                    }
                }
                else if (hasPlayAndCategory) {
                    // no series, just play and category
                    var playFrameNode = matrix.rows.root.children[frame];
                    var measureLength_1 = matrix.valueSources.length;
                    for (var j = 0; j < measureLength_1; j++) {
                        var dataViewColumn = {
                            identity: undefined,
                            values: [],
                            source: matrix.valueSources[j]
                        };
                        categorical.values.push(dataViewColumn);
                    }
                    DataViewMatrixUtils.forEachLeafNode(playFrameNode.children, function (categoryGroupLeafNode, index, categoryHierarchicalGroupNodes) {
                        addMatrixHierarchicalGroupToCategories(categoryHierarchicalGroupNodes, categories);
                        // Copying the values from matrix intersection to the categorical values columns...
                        for (var j = 0; j < measureLength_1; j++) {
                            categorical.values[j].values.push(categoryGroupLeafNode.values[j].value);
                        }
                    });
                    categorical.categories = categories;
                }
                // the visual code today expects only 1 category column, hence apply DataViewConcatenateCategoricalColumns
                return DataViewConcatenateCategoricalColumns.applyToPlayChartCategorical(sourceDataView.metadata, visuals.scatterChartCapabilities.objects, 'Category', categorical);
            }
            PlayChart.convertMatrixToCategorical = convertMatrixToCategorical;
            function addMatrixHierarchicalGroupToCategories(sourceCategoryHierarchicalGroupNodes, destinationCategories) {
                debug.assertNonEmpty(sourceCategoryHierarchicalGroupNodes, 'sourceCategoryHierarchicalGroupNodes');
                debug.assertNonEmpty(destinationCategories, 'destinationCategories');
                debug.assert(sourceCategoryHierarchicalGroupNodes.length === destinationCategories.length, 'pre-condition: there should be one category column per matrix row level for Category.');
                // Note: Before the Categorical concatenation logic got added to this playChart logic, the code did NOT populate
                // the ***DataViewCategoryColumn.identityFields*** property, and the playChart visual code does not seem to need it.
                // If we do want to populate that property, we might want to do reuse data.ISQExpr[] across nodes as much as possible 
                // because all the child nodes under a given parent will have the exact same identityFields value, and a lot of 
                // DataViewCategory objects can get created for a given playChart.
                var identity = sourceCategoryHierarchicalGroupNodes[0].identity;
                if (sourceCategoryHierarchicalGroupNodes.length > 1) {
                    // if the hierarchical group has more than 1 level, create a composite identity from the nodes
                    var identityExpr = identity.expr;
                    for (var i = 1, ilen = sourceCategoryHierarchicalGroupNodes.length; i < ilen; i++) {
                        var identityExprToAdd = sourceCategoryHierarchicalGroupNodes[i].identity.expr;
                        identityExpr = SQExprBuilder.and(identityExpr, identityExprToAdd);
                    }
                    identity = createDataViewScopeIdentity(identityExpr);
                }
                // add the Category value of each matrix node into its respective category column
                for (var j = 0, jlen = destinationCategories.length; j < jlen; j++) {
                    destinationCategories[j].identity.push(identity);
                    var node = sourceCategoryHierarchicalGroupNodes[j];
                    destinationCategories[j].values.push(node.value);
                }
            }
            function getObjectProperties(dataViewMetadata, dataLabelsSettings) {
                var objectProperties = {};
                if (dataViewMetadata && dataViewMetadata.objects) {
                    var objects = dataViewMetadata.objects;
                    // TODO: remove?
                    objectProperties.currentFrameIndex = powerbi.DataViewObjects.getValue(objects, visuals.scatterChartProps.currentFrameIndex.index, null);
                }
                return objectProperties;
            }
            function converter(dataView, visualConverter) {
                var dataViewMetadata = dataView.metadata;
                var dataLabelsSettings = visuals.dataLabelUtils.getDefaultPointLabelSettings();
                var objectProperties = getObjectProperties(dataViewMetadata, dataLabelsSettings);
                var allViewModels = [];
                var frameKeys = [];
                var convertedData = undefined;
                var matrixRows = dataView.matrix.rows;
                var rowChildrenLength = matrixRows.root.children ? matrixRows.root.children.length : 0;
                var keySourceColumn;
                if (dataView.matrix && rowChildrenLength > 0 && !_.isEmpty(matrixRows.levels) && !_.isEmpty(matrixRows.levels[0].sources)) {
                    keySourceColumn = matrixRows.levels[0].sources[0];
                    // TODO: this should probably defer to the visual which knows how to format the categories.
                    var formatString = visuals.valueFormatter.getFormatString(keySourceColumn, visuals.scatterChartProps.general.formatString);
                    var keyFormatter = void 0;
                    if (keySourceColumn.type.numeric) {
                        // use value range, not actual values
                        var valueRange = Math.abs(matrixRows.root.children[rowChildrenLength - 1].value - matrixRows.root.children[0].value);
                        keyFormatter = visuals.valueFormatter.create({
                            format: formatString,
                            value: valueRange,
                            value2: 0,
                        });
                    }
                    else {
                        keyFormatter = visuals.valueFormatter.createDefaultFormatter(formatString, true);
                    }
                    for (var i = 0, len = rowChildrenLength; i < len; i++) {
                        var key = matrixRows.root.children[i];
                        var frameLabel = keyFormatter.format(key.value);
                        frameKeys.push(frameLabel);
                        var dataViewCategorical = convertMatrixToCategorical(dataView, i);
                        var frameInfo = { label: frameLabel, column: keySourceColumn };
                        convertedData = visualConverter(dataViewCategorical, frameInfo);
                        allViewModels.push(convertedData);
                    }
                }
                else {
                    var dataViewCategorical = convertMatrixToCategorical(dataView, 0);
                    convertedData = visualConverter(dataViewCategorical);
                    allViewModels.push(convertedData);
                }
                // NOTE: currentViewModel is already set to the last frame
                objectProperties.currentFrameIndex = frameKeys.length - 1;
                return {
                    allViewModels: allViewModels,
                    currentViewModel: convertedData,
                    frameKeys: frameKeys,
                    currentFrameIndex: objectProperties.currentFrameIndex,
                    labelData: getLabelData(frameKeys, keySourceColumn),
                };
            }
            PlayChart.converter = converter;
            function getDefaultPlayData() {
                var defaultData = {
                    frameKeys: [],
                    allViewModels: [],
                    currentFrameIndex: 0,
                    currentViewModel: undefined,
                    labelData: {
                        anyWordBreaks: false,
                        labelInfo: [],
                    },
                };
                return defaultData;
            }
            PlayChart.getDefaultPlayData = getDefaultPlayData;
            function getMinMaxForAllFrames(playData, getExtents) {
                var extents = {
                    minY: 0,
                    maxY: 10,
                    minX: 0,
                    maxX: 10,
                };
                if (playData.allViewModels && playData.allViewModels.length > 0) {
                    extents.minY = extents.minX = Number.MAX_VALUE;
                    extents.maxY = extents.maxX = Number.MIN_VALUE;
                    for (var i = 0, len = playData.allViewModels.length; i < len; i++) {
                        var data_7 = playData.allViewModels[i];
                        var e = getExtents(data_7);
                        // NOTE: D3.min/max handle undefined and NaN nicely, as opposed to Math.min/max
                        extents = {
                            minY: d3.min([e.minY, extents.minY]),
                            maxY: d3.max([e.maxY, extents.maxY]),
                            minX: d3.min([e.minX, extents.minX]),
                            maxX: d3.max([e.maxX, extents.maxX]),
                        };
                    }
                }
                return extents;
            }
            PlayChart.getMinMaxForAllFrames = getMinMaxForAllFrames;
            function getLabelData(keys, keyColumn) {
                var textProperties = {
                    fontFamily: 'wf_segoe-ui_normal',
                    fontSize: jsCommon.PixelConverter.toString(14),
                };
                var labelInfo = [];
                var anyWordBreaks = false;
                for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {
                    var key = keys_1[_i];
                    var labelWidth = jsCommon.WordBreaker.getMaxWordWidth(key, powerbi.TextMeasurementService.measureSvgTextWidth, textProperties);
                    anyWordBreaks = anyWordBreaks || jsCommon.WordBreaker.hasBreakers(key) || (key).indexOf('-') > -1; // TODO: Why isn't this last part included in hasBreakers()?
                    labelInfo.push({ label: key, labelWidth: labelWidth });
                }
                return {
                    labelInfo: labelInfo,
                    anyWordBreaks: anyWordBreaks,
                    labelFieldName: keyColumn && keyColumn.displayName,
                };
            }
            function createPipsFilterFn(playData, sliderWidth, labelData) {
                var maxLabelWidth = _.max(_.map(labelData.labelInfo, function (l) { return l.labelWidth; }));
                var pipSize = 1; //0=hide, 1=large, 2=small
                var skipMod = 1;
                var maxAllowedLabelWidth = playData.frameKeys.length > 1 ? sliderWidth / (playData.frameKeys.length - 1) : sliderWidth;
                var widthRatio = maxLabelWidth / maxAllowedLabelWidth;
                if (widthRatio > 1.25) {
                    skipMod = Math.ceil(widthRatio);
                    pipSize = 2;
                }
                else if (widthRatio > 1.0 || labelData.anyWordBreaks) {
                    // wordbreak line wrapping is automatic, and we don't reserve enough space to show two lines of text with the larger font
                    pipSize = 2;
                }
                var filterPipLabels = function (index, type) {
                    // noUiSlider will word break / wrap to new lines, so max width is the max word length
                    if (index % skipMod === 0) {
                        return pipSize;
                    }
                    return 0; //hide
                };
                return filterPipLabels;
            }
            PlayChart.createPipsFilterFn = createPipsFilterFn;
            function isDataViewPlayable(dataView, playRole) {
                if (playRole === void 0) { playRole = 'Play'; }
                debug.assertValue(dataView, 'dataView');
                var firstRowSourceRoles = dataView.matrix &&
                    dataView.matrix.rows &&
                    dataView.matrix.rows.levels &&
                    dataView.matrix.rows.levels[0] &&
                    dataView.matrix.rows.levels[0].sources &&
                    dataView.matrix.rows.levels[0].sources[0] &&
                    dataView.matrix.rows.levels[0].sources[0].roles;
                return firstRowSourceRoles && firstRowSourceRoles[playRole];
            }
            PlayChart.isDataViewPlayable = isDataViewPlayable;
            /** Render trace-lines for selected data points. */
            function renderTraceLines(allDataPoints, traceLineRenderer, shouldAnimate) {
                var selectedDataPoints = _.filter(allDataPoints, function (d) { return d.selected; });
                selectedDataPoints = _.uniq(selectedDataPoints, function (d) { return d.identity.getKey(); });
                traceLineRenderer.render(selectedDataPoints, shouldAnimate);
            }
            PlayChart.renderTraceLines = renderTraceLines;
        })(PlayChart = visuals.PlayChart || (visuals.PlayChart = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var VerticalSlicerRenderer = (function () {
            function VerticalSlicerRenderer(options) {
                this.textProperties = {
                    'fontFamily': 'wf_segoe-ui_normal, helvetica, arial, sans-serif',
                    'fontSize': '14px',
                };
                if (options) {
                    this.behavior = options.behavior;
                }
                this.domHelper = options.domHelper;
            }
            // SlicerDefaultValueHandler
            VerticalSlicerRenderer.prototype.getDefaultValue = function () {
                if (this.data && this.data.defaultValue)
                    return this.data.defaultValue.value;
            };
            VerticalSlicerRenderer.prototype.getIdentityFields = function () {
                return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
            };
            VerticalSlicerRenderer.prototype.init = function (slicerInitOptions) {
                var _this = this;
                this.element = slicerInitOptions.visualInitOptions.element;
                this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
                var settings = this.settings = visuals.Slicer.DefaultStyleProperties();
                var domHelper = this.domHelper;
                var bodyViewport = domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties);
                var interactivityService;
                if (this.behavior)
                    interactivityService = visuals.createInteractivityService(hostServices);
                var containerDiv = document.createElement('div');
                containerDiv.className = Selectors.Container.class;
                var container = this.container = d3.select(containerDiv);
                var header = domHelper.createSlicerHeader(hostServices);
                containerDiv.appendChild(header);
                this.header = d3.select(header);
                this.body = container.append('div').classed(visuals.SlicerUtil.Selectors.Body.class, true)
                    .style({
                    'height': PixelConverter.toString(bodyViewport.height),
                    'width': PixelConverter.toString(bodyViewport.width),
                });
                var rowEnter = function (rowSelection) {
                    _this.onEnterSelection(rowSelection);
                };
                var rowUpdate = function (rowSelection) {
                    _this.onUpdateSelection(rowSelection, interactivityService);
                };
                var rowExit = function (rowSelection) {
                    rowSelection.remove();
                };
                var listViewOptions = {
                    rowHeight: domHelper.getRowHeight(settings, this.textProperties),
                    enter: rowEnter,
                    exit: rowExit,
                    update: rowUpdate,
                    loadMoreData: function () { return slicerInitOptions.loadMoreData(); },
                    scrollEnabled: true,
                    viewport: domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties),
                    baseContainer: this.body,
                    isReadMode: function () {
                        return (_this.hostServices.getViewMode() !== 1 /* Edit */);
                    }
                };
                this.listView = visuals.ListViewFactory.createListView(listViewOptions);
                // Append container to DOM
                this.element.get(0).appendChild(containerDiv);
                return interactivityService;
            };
            VerticalSlicerRenderer.prototype.render = function (options) {
                var data = this.data = options.data;
                this.currentViewport = options.viewport;
                var dataView = options.dataView;
                if (!dataView || !data) {
                    this.listView.empty();
                    return;
                }
                this.dataView = dataView;
                var settings = this.settings = data.slicerSettings;
                var domHelper = this.domHelper;
                domHelper.updateSlicerBodyDimensions(this.currentViewport, this.body, settings);
                this.updateSelectionStyle();
                this.listView
                    .viewport(domHelper.getSlicerBodyViewport(this.currentViewport, settings, this.textProperties))
                    .rowHeight(domHelper.getRowHeight(settings, this.textProperties))
                    .data(data.slicerDataPoints, function (d) { return $.inArray(d, data.slicerDataPoints); }, options.resetScrollbarPosition);
            };
            VerticalSlicerRenderer.prototype.updateSelectionStyle = function () {
                var settings = this.settings;
                this.container.classed('isMultiSelectEnabled', settings && settings.selection && !settings.selection.singleSelect);
            };
            VerticalSlicerRenderer.prototype.onEnterSelection = function (rowSelection) {
                var settings = this.settings;
                var listItemElement = rowSelection.append('li')
                    .classed(Selectors.ItemContainer.class, true);
                var labelElement = listItemElement.append('div')
                    .classed(Selectors.Input.class, true);
                labelElement.append('input')
                    .attr('type', 'checkbox');
                labelElement.append('span')
                    .classed(Selectors.Checkbox.class, true);
                listItemElement.each(function (d, i) {
                    var item = d3.select(this);
                    if (d.isImage) {
                        item.append('img')
                            .classed(visuals.SlicerUtil.Selectors.LabelImage.class, true);
                    }
                    else {
                        item.append('span')
                            .classed(visuals.SlicerUtil.Selectors.LabelText.class, true);
                    }
                    if (d.count != null) {
                        item.append('span')
                            .classed(visuals.SlicerUtil.Selectors.CountText.class, true)
                            .style('font-size', PixelConverter.fromPoint(settings.slicerText.textSize));
                    }
                });
            };
            VerticalSlicerRenderer.prototype.onUpdateSelection = function (rowSelection, interactivityService) {
                var settings = this.settings;
                var data = this.data;
                if (data && settings) {
                    // Style Slicer Header
                    var domHelper = this.domHelper;
                    domHelper.styleSlicerHeader(this.header, settings, data.categorySourceName);
                    this.header.attr('title', data.categorySourceName);
                    var labelText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
                    labelText.text(function (d) {
                        return d.value;
                    }).attr('title', function (d) {
                        return d.tooltip;
                    });
                    domHelper.setSlicerTextStyle(labelText, settings);
                    var labelImage = rowSelection.selectAll(visuals.SlicerUtil.Selectors.LabelImage.selector);
                    if (!labelImage.empty()) {
                        labelImage.attr('src', function (d) {
                            return d.value;
                        });
                    }
                    var countText = rowSelection.selectAll(visuals.SlicerUtil.Selectors.CountText.selector);
                    if (!countText.empty()) {
                        countText.text(function (d) { return d.count; });
                        domHelper.setSlicerTextStyle(countText, settings);
                    }
                    if (interactivityService && this.body) {
                        var body = this.body.attr('width', this.currentViewport.width);
                        var slicerItemContainers = body.selectAll(Selectors.ItemContainer.selector);
                        var slicerItemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
                        var slicerItemInputs = body.selectAll(Selectors.Input.selector);
                        var slicerClear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector);
                        var behaviorOptions = {
                            dataPoints: data.slicerDataPoints,
                            slicerContainer: this.container,
                            itemContainers: slicerItemContainers,
                            itemLabels: slicerItemLabels,
                            itemInputs: slicerItemInputs,
                            clear: slicerClear,
                            interactivityService: interactivityService,
                            settings: data.slicerSettings,
                        };
                        var orientationBehaviorOptions = {
                            behaviorOptions: behaviorOptions,
                            orientation: 0 /* Vertical */,
                        };
                        interactivityService.bind(data.slicerDataPoints, this.behavior, orientationBehaviorOptions, { overrideSelectionFromData: true, hasSelectionOverride: data.hasSelectionOverride, slicerDefaultValueHandler: this });
                        visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), data.hasSelectionOverride, interactivityService.isSelectionModeInverted());
                    }
                    else {
                        visuals.SlicerWebBehavior.styleSlicerItems(rowSelection.select(Selectors.Input.selector), false, false);
                    }
                }
            };
            return VerticalSlicerRenderer;
        }());
        visuals.VerticalSlicerRenderer = VerticalSlicerRenderer;
        var Selectors;
        (function (Selectors) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            Selectors.Container = createClassAndSelector('slicerContainer');
            Selectors.ItemContainer = createClassAndSelector('slicerItemContainer');
            Selectors.Input = createClassAndSelector('slicerCheckbox');
            Selectors.Checkbox = createClassAndSelector('checkbox');
        })(Selectors || (Selectors = {}));
        var CheckboxSprite;
        (function (CheckboxSprite) {
            CheckboxSprite.MinimumSize = 8;
            CheckboxSprite.Size = 13;
            CheckboxSprite.SizeRange = CheckboxSprite.Size - CheckboxSprite.MinimumSize;
        })(CheckboxSprite || (CheckboxSprite = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var ItemWidthSampleSize = 50;
        var MinTextWidth = 80;
        var LoadMoreDataThreshold = 0.8; // The value indicates the percentage of data already shown that triggers a loadMoreData call.
        var DefaultStyleProperties = {
            labelText: {
                marginRight: 2,
                paddingLeft: 8,
                paddingRight: 8,
            },
        };
        var HorizontalSlicerRenderer = (function () {
            function HorizontalSlicerRenderer(options) {
                this.textProperties = {
                    fontFamily: 'wf_segoe-ui_normal',
                    fontSize: '14px'
                };
                if (options) {
                    this.behavior = options.behavior;
                }
                this.domHelper = options.domHelper;
                this.dataStartIndex = 0;
            }
            // SlicerDefaultValueHandler
            HorizontalSlicerRenderer.prototype.getDefaultValue = function () {
                if (this.data && this.data.defaultValue)
                    return this.data.defaultValue.value;
            };
            HorizontalSlicerRenderer.prototype.getIdentityFields = function () {
                return visuals.SlicerUtil.DefaultValueHandler.getIdentityFields(this.dataView);
            };
            HorizontalSlicerRenderer.prototype.init = function (slicerInitOptions) {
                this.element = slicerInitOptions.visualInitOptions.element;
                this.currentViewport = slicerInitOptions.visualInitOptions.viewport;
                var hostServices = this.hostServices = slicerInitOptions.visualInitOptions.host;
                if (this.behavior) {
                    this.interactivityService = visuals.createInteractivityService(hostServices);
                }
                this.loadMoreData = function () { return slicerInitOptions.loadMoreData(); };
                var containerDiv = document.createElement('div');
                containerDiv.className = Selectors.container.class;
                var container = this.container = d3.select(containerDiv);
                var header = this.domHelper.createSlicerHeader(this.hostServices);
                containerDiv.appendChild(header);
                this.header = d3.select(header);
                var body = this.body = container.append('div').classed(visuals.SlicerUtil.Selectors.Body.class + " " + Selectors.FlexDisplay.class, true);
                this.leftNavigationArrow = body.append("button")
                    .classed(Selectors.NavigationArrow.class + " " + Selectors.LeftNavigationArrow.class, true);
                this.itemsContainer = body.append("div")
                    .classed(Selectors.ItemsContainer.class + " " + Selectors.FlexDisplay.class, true);
                this.rightNavigationArrow = body.append("button")
                    .classed(Selectors.NavigationArrow.class + " " + Selectors.RightNavigationArrow.class, true);
                // Append container to DOM
                this.element.get(0).appendChild(containerDiv);
                this.bindNavigationEvents();
                return this.interactivityService;
            };
            HorizontalSlicerRenderer.prototype.render = function (options) {
                var data = options.data;
                var dataView = options.dataView;
                if (!dataView || !data) {
                    this.itemsContainer.selectAll("*").remove();
                    return;
                }
                this.data = data;
                this.dataView = dataView;
                var resized = this.currentViewport && options.viewport
                    && (this.currentViewport.height !== options.viewport.height || this.currentViewport.width !== options.viewport.width);
                if (!(this.isMaxWidthCalculated() && resized)) {
                    // Max width calculation is not required during resize, but required on data changes like changes to formatting properties fontSize, outline, outline weight, etc...
                    // So calculating only on data updates
                    this.calculateAndSetMaxItemWidth();
                    this.calculateAndSetTotalItemWidth();
                }
                this.currentViewport = options.viewport;
                this.updateStyle();
                var availableWidthForItemsContainer = this.element.find(Selectors.ItemsContainer.selector).width();
                this.itemsToDisplay = this.getNumberOfItemsToDisplay(availableWidthForItemsContainer);
                if (this.itemsToDisplay === 0)
                    return;
                this.renderCore();
            };
            HorizontalSlicerRenderer.prototype.renderCore = function () {
                var data = this.data;
                if (!data || !data.slicerDataPoints)
                    return;
                this.normalizePosition(data.slicerDataPoints);
                var itemsToDisplay = this.itemsToDisplay;
                var dataStartIndex = this.dataStartIndex;
                // Update Navigation Arrows
                this.container.classed(Selectors.CanScrollRight.class, dataStartIndex + this.itemsToDisplay <= data.slicerDataPoints.length - 1);
                this.container.classed(Selectors.CanScrollLeft.class, dataStartIndex > 0);
                // Manipulate DOM
                this.renderItems(data.slicerSettings);
                // Bind Interactivity Service
                this.bindInteractivityService();
                // Load More Data
                if (dataStartIndex + itemsToDisplay >= data.slicerDataPoints.length * LoadMoreDataThreshold) {
                    this.loadMoreData();
                }
            };
            HorizontalSlicerRenderer.prototype.updateStyle = function () {
                var viewport = this.currentViewport;
                var data = this.data;
                var defaultSettings = data.slicerSettings;
                var domHelper = this.domHelper;
                this.container
                    .classed(Selectors.MultiSelectEnabled.class, !defaultSettings.selection.singleSelect)
                    .style({
                    "width": PixelConverter.toString(viewport.width),
                    "height": PixelConverter.toString(viewport.height),
                });
                // Style Slicer Header
                domHelper.styleSlicerHeader(this.header, defaultSettings, data.categorySourceName);
                var headerTextProperties = domHelper.getHeaderTextProperties(defaultSettings);
                this.header.attr('title', data.categorySourceName);
                // Update body width and height
                var bodyViewport = this.bodyViewport = domHelper.getSlicerBodyViewport(viewport, defaultSettings, headerTextProperties);
                this.body.style({
                    "height": PixelConverter.toString(bodyViewport.height),
                    "width": PixelConverter.toString(bodyViewport.width),
                });
            };
            HorizontalSlicerRenderer.prototype.renderItems = function (defaultSettings) {
                var _this = this;
                var itemsToDisplay = this.itemsToDisplay;
                debug.assert(itemsToDisplay > 0, 'items to display should be greater than zero');
                var dataStartIndex = this.dataStartIndex;
                var materializedDataPoints = this.data.slicerDataPoints.slice(dataStartIndex, dataStartIndex + itemsToDisplay);
                var items = this.itemsContainer
                    .selectAll(visuals.SlicerUtil.Selectors.LabelText.selector)
                    .data(materializedDataPoints, function (d) { return _.indexOf(_this.data.slicerDataPoints, d); });
                items
                    .enter()
                    .append("div")
                    .classed(visuals.SlicerUtil.Selectors.LabelText.class + " " + Selectors.FlexDisplay.class, true);
                items.order();
                items
                    .style({
                    "font-family": this.textProperties.fontFamily,
                    "padding-left": PixelConverter.toString(DefaultStyleProperties.labelText.paddingLeft),
                    "padding-right": PixelConverter.toString(DefaultStyleProperties.labelText.paddingRight),
                    "margin-right": function (d, i) { return _this.isLastRowItem(i, itemsToDisplay) ? "0px" : PixelConverter.toString(DefaultStyleProperties.labelText.marginRight); },
                });
                // Default style settings from formatting pane settings
                this.domHelper.setSlicerTextStyle(items, defaultSettings);
                items.exit().remove();
                window.setTimeout(function () {
                    items
                        .attr("title", function (d) { return d.tooltip; })
                        .text(function (d) { return d.value; });
                    // Wrap long text into multiple columns based on height availbale
                    var labels = _this.element.find(visuals.SlicerUtil.Selectors.LabelText.selector);
                    var item = labels.first();
                    var itemWidth = item.width();
                    var itemHeight = item.height();
                    labels.each(function (i, element) {
                        powerbi.TextMeasurementService.wordBreakOverflowingText(element, itemWidth, itemHeight);
                    });
                });
            };
            HorizontalSlicerRenderer.prototype.bindInteractivityService = function () {
                if (this.interactivityService && this.body) {
                    var body = this.body;
                    var itemsContainer = body.selectAll(Selectors.ItemsContainer.selector);
                    var itemLabels = body.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector);
                    var clear = this.header.select(visuals.SlicerUtil.Selectors.Clear.selector);
                    var data_8 = this.data;
                    var behaviorOptions = {
                        dataPoints: data_8.slicerDataPoints,
                        slicerContainer: this.container,
                        itemsContainer: itemsContainer,
                        itemLabels: itemLabels,
                        clear: clear,
                        interactivityService: this.interactivityService,
                        settings: data_8.slicerSettings,
                    };
                    var orientationBehaviorOptions = {
                        behaviorOptions: behaviorOptions,
                        orientation: 1 /* Horizontal */,
                    };
                    this.interactivityService.bind(data_8.slicerDataPoints, this.behavior, orientationBehaviorOptions, { overrideSelectionFromData: true, hasSelectionOverride: data_8.hasSelectionOverride });
                    visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), this.interactivityService.hasSelection(), this.interactivityService.isSelectionModeInverted());
                }
                else {
                    visuals.SlicerWebBehavior.styleSlicerItems(this.itemsContainer.selectAll(visuals.SlicerUtil.Selectors.LabelText.selector), false, false);
                }
            };
            HorizontalSlicerRenderer.prototype.normalizePosition = function (points) {
                var dataStartIndex = this.dataStartIndex;
                // if dataStartIndex >= points.length
                dataStartIndex = Math.min(dataStartIndex, points.length - 1);
                // if dataStartIndex < 0 
                this.dataStartIndex = Math.max(dataStartIndex, 0);
            };
            HorizontalSlicerRenderer.prototype.bindNavigationEvents = function () {
                this.registerMouseWheelScrollEvents();
                this.registerMouseClickEvents();
            };
            HorizontalSlicerRenderer.prototype.registerMouseClickEvents = function () {
                var _this = this;
                var rightNavigationArrow = this.container.selectAll(Selectors.RightNavigationArrow.selector);
                var leftNavigationArrow = this.container.selectAll(Selectors.LeftNavigationArrow.selector);
                rightNavigationArrow
                    .on("click", function () {
                    _this.scrollRight();
                });
                leftNavigationArrow
                    .on("click", function () {
                    _this.scrollLeft();
                });
            };
            // Register for mouse wheel scroll events
            HorizontalSlicerRenderer.prototype.registerMouseWheelScrollEvents = function () {
                var _this = this;
                var scrollableElement = this.body.node();
                scrollableElement.addEventListener("mousewheel", function (e) {
                    _this.onMouseWheel(e.wheelDelta);
                });
                scrollableElement.addEventListener("DOMMouseScroll", function (e) {
                    _this.onMouseWheel(e.detail);
                });
            };
            HorizontalSlicerRenderer.prototype.onMouseWheel = function (wheelDelta) {
                if (wheelDelta < 0) {
                    this.scrollRight();
                }
                else if (wheelDelta > 0) {
                    this.scrollLeft();
                }
            };
            /* If there is only one item being displayed, we show the next item when navigation arrows are clicked
            * But when there are more than 1 item, n-1 items are shown say we have 10 items in total , in initial page if we show 1 to 5 items when right button is clicked we will show items from 5 to 10
            */
            HorizontalSlicerRenderer.prototype.scrollRight = function () {
                var itemsToDisplay = this.itemsToDisplay;
                var startIndex = this.dataStartIndex;
                var dataPointsLength = this.data.slicerDataPoints.length;
                var lastItemIndex = dataPointsLength - 1;
                // If it is the last page stay on the same page and don't navigate
                if (itemsToDisplay + startIndex > lastItemIndex) {
                    return;
                }
                if (itemsToDisplay === 1) {
                    startIndex += itemsToDisplay;
                }
                else {
                    startIndex += itemsToDisplay - 1;
                }
                // Adjust the startIndex to show last n items if startIndex + itemsToDisplay is greater than total datapoints
                if (itemsToDisplay + startIndex > lastItemIndex) {
                    startIndex = lastItemIndex - itemsToDisplay + 1;
                }
                this.dataStartIndex = startIndex;
                this.renderCore();
            };
            /* If there is only one item being displayed, we show the next item when navigation arrows are clicked
            * But when there are more than 1 item, n-1 items are shown
            */
            HorizontalSlicerRenderer.prototype.scrollLeft = function () {
                var itemsToDisplay = this.itemsToDisplay;
                var startIndex = this.dataStartIndex;
                var firstItemIndex = 0;
                // If it is the first page stay on the same page and don't navigate
                if (startIndex === 0) {
                    return;
                }
                // If there is only item shown when left navigation button is clicked we want to navigate back to show previous item
                if (itemsToDisplay === 1) {
                    startIndex -= itemsToDisplay;
                }
                if (startIndex - itemsToDisplay < firstItemIndex) {
                    startIndex = firstItemIndex;
                }
                else {
                    startIndex = startIndex - itemsToDisplay + 1;
                }
                this.dataStartIndex = startIndex;
                this.renderCore();
            };
            HorizontalSlicerRenderer.prototype.isLastRowItem = function (fieldIndex, columnsToDisplay) {
                return fieldIndex === columnsToDisplay - 1;
            };
            HorizontalSlicerRenderer.prototype.getScaledTextWidth = function (textSize) {
                return (textSize / jsCommon.TextSizeDefaults.TextSizeMin) * MinTextWidth;
            };
            HorizontalSlicerRenderer.prototype.isMaxWidthCalculated = function () {
                return this.maxItemWidth !== undefined;
            };
            // Sampling a subset of total datapoints to calculate max item width
            HorizontalSlicerRenderer.prototype.calculateAndSetMaxItemWidth = function () {
                var dataPointsLength = this.getDataPointsCount();
                var maxItemWidth = 0;
                if (dataPointsLength === 0) {
                    this.maxItemWidth = maxItemWidth;
                    return;
                }
                var data = this.data;
                var dataPoints = data.slicerDataPoints;
                var sampleSize = Math.min(dataPointsLength, ItemWidthSampleSize);
                var properties = jQuery.extend(true, {}, this.textProperties);
                var textSize = data.slicerSettings.slicerText.textSize;
                // Update text properties from formatting pane values
                properties.fontSize = PixelConverter.fromPoint(textSize);
                var getMaxWordWidth = jsCommon.WordBreaker.getMaxWordWidth;
                for (var i = 0; i < sampleSize; i++) {
                    var itemText = dataPoints[i].value;
                    properties.text = itemText;
                    maxItemWidth = Math.max(maxItemWidth, getMaxWordWidth(itemText, powerbi.TextMeasurementService.measureSvgTextWidth, properties));
                }
                this.maxItemWidth = Math.min(maxItemWidth, this.getScaledTextWidth(textSize));
            };
            HorizontalSlicerRenderer.prototype.calculateAndSetTotalItemWidth = function () {
                var data = this.data;
                var itemPadding = DefaultStyleProperties.labelText.paddingLeft + DefaultStyleProperties.labelText.paddingRight + DefaultStyleProperties.labelText.marginRight;
                var borderWidth = this.domHelper.getRowsOutlineWidth(data.slicerSettings.slicerText.outline, data.slicerSettings.general.outlineWeight);
                this.totalItemWidth = this.maxItemWidth + itemPadding + borderWidth;
            };
            HorizontalSlicerRenderer.prototype.getNumberOfItemsToDisplay = function (widthAvailable) {
                var totalItemWidth = this.totalItemWidth;
                if (totalItemWidth === 0)
                    return 0;
                var dataPointsLength = this.getDataPointsCount();
                var numberOfItems = Math.min(dataPointsLength, Math.round(widthAvailable / totalItemWidth));
                // Show atleast 1 item by default 
                return Math.max(numberOfItems, 1);
            };
            HorizontalSlicerRenderer.prototype.getDataPointsCount = function () {
                return _.size(this.data.slicerDataPoints);
            };
            return HorizontalSlicerRenderer;
        }());
        visuals.HorizontalSlicerRenderer = HorizontalSlicerRenderer;
        var Selectors;
        (function (Selectors) {
            var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
            Selectors.container = createClassAndSelector('horizontalSlicerContainer');
            Selectors.ItemsContainer = createClassAndSelector('slicerItemsContainer');
            Selectors.NavigationArrow = createClassAndSelector('navigationArrow');
            Selectors.LeftNavigationArrow = createClassAndSelector('left');
            Selectors.RightNavigationArrow = createClassAndSelector('right');
            Selectors.MultiSelectEnabled = createClassAndSelector('isMultiSelectEnabled');
            Selectors.FlexDisplay = createClassAndSelector('flexDisplay');
            Selectors.CanScrollRight = createClassAndSelector('canScrollRight');
            Selectors.CanScrollLeft = createClassAndSelector('canScrollLeft');
        })(Selectors || (Selectors = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var DisplayNameKeys = visuals.SlicerUtil.DisplayNameKeys;
        var DOMHelper = visuals.SlicerUtil.DOMHelper;
        var SettingsHelper = visuals.SlicerUtil.SettingsHelper;
        var Slicer = (function () {
            function Slicer(options) {
                if (options) {
                    this.behavior = options.behavior;
                }
                this.domHelper = new DOMHelper();
            }
            Slicer.DefaultStyleProperties = function () {
                return {
                    general: {
                        outlineColor: '#808080',
                        outlineWeight: 1,
                        orientation: 0 /* Vertical */,
                    },
                    header: {
                        borderBottomWidth: 1,
                        show: true,
                        outline: visuals.outline.bottomOnly,
                        fontColor: '#000000',
                        textSize: 10,
                    },
                    slicerText: {
                        color: '#666666',
                        outline: visuals.outline.none,
                        textSize: 10,
                    },
                    selection: {
                        selectAllCheckboxEnabled: false,
                        singleSelect: true,
                    },
                };
            };
            Slicer.prototype.init = function (options) {
                this.initOptions = options;
                this.element = options.element;
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                var settings = this.settings = Slicer.DefaultStyleProperties();
                this.slicerOrientation = settings.general.orientation;
                this.waitingForData = false;
                this.initializeSlicerRenderer(this.slicerOrientation);
            };
            Slicer.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                debug.assertValue(dataViews, 'dataViews');
                if (_.isEmpty(dataViews)) {
                    return;
                }
                var existingDataView = this.dataView;
                this.dataView = dataViews[0];
                // Reset scrollbar by default, unless it's an Append operation or Selecting an item
                var resetScrollbarPosition = options.operationKind !== powerbi.VisualDataChangeOperationKind.Append
                    && !powerbi.DataViewAnalysis.hasSameCategoryIdentity(existingDataView, this.dataView);
                this.render(resetScrollbarPosition, true);
            };
            Slicer.prototype.onResizing = function (finalViewport) {
                this.currentViewport = finalViewport;
                this.render(false /* resetScrollbarPosition */);
            };
            Slicer.prototype.enumerateObjectInstances = function (options) {
                return ObjectEnumerator.enumerateObjectInstances(options, this.slicerData, this.settings, this.dataView);
            };
            // public for testability
            Slicer.prototype.loadMoreData = function () {
                var dataView = this.dataView;
                if (!dataView)
                    return;
                var dataViewMetadata = dataView.metadata;
                // Making sure that hostservices.loadMoreData is not invoked when waiting for server to load the next segment of data
                if (!this.waitingForData && dataViewMetadata && dataViewMetadata.segment) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Slicer.prototype.onClearSelection = function () {
                if (this.interactivityService) {
                    this.interactivityService.clearSelection();
                    // calls render so that default behavior can be applied after clear selection.
                    this.render(false /* resetScrollbarPosition */);
                }
            };
            Slicer.prototype.render = function (resetScrollbarPosition, stopWaitingForData) {
                var localizedSelectAllText = this.hostServices.getLocalizedString(DisplayNameKeys.SelectAll);
                this.slicerData = visuals.DataConversion.convert(this.dataView, localizedSelectAllText, this.interactivityService, this.hostServices);
                if (this.slicerData) {
                    this.slicerData.slicerSettings.general.outlineWeight = Math.max(this.slicerData.slicerSettings.general.outlineWeight, 0);
                    this.settings = this.slicerData.slicerSettings;
                    // TODO: Do we need to check SettingsHelper.areSettingsDefined(), etc. here? Can we just do value validation and coercion in the same place that we create the slicerSettings?
                    var slicerOrientation_1 = SettingsHelper.areSettingsDefined(this.slicerData) && this.slicerData.slicerSettings.general && this.slicerData.slicerSettings.general.orientation ?
                        this.slicerData.slicerSettings.general.orientation : Slicer.DefaultStyleProperties().general.orientation;
                    var orientationHasChanged = this.orientationHasChanged(slicerOrientation_1);
                    if (orientationHasChanged) {
                        this.slicerOrientation = slicerOrientation_1;
                        // Clear the previous slicer type when rendering the new slicer type
                        this.element.empty();
                        this.initializeSlicerRenderer(slicerOrientation_1);
                    }
                }
                this.slicerRenderer.render({ dataView: this.dataView, data: this.slicerData, viewport: this.currentViewport, resetScrollbarPosition: resetScrollbarPosition });
                if (stopWaitingForData)
                    this.waitingForData = false;
            };
            Slicer.prototype.orientationHasChanged = function (slicerOrientation) {
                return this.slicerOrientation !== slicerOrientation;
            };
            Slicer.prototype.initializeSlicerRenderer = function (slicerOrientation) {
                switch (slicerOrientation) {
                    case 1 /* Horizontal */:
                        this.initializeHorizontalSlicer();
                        break;
                    case 0 /* Vertical */:
                        this.initializeVerticalSlicer();
                        break;
                }
            };
            Slicer.prototype.initializeVerticalSlicer = function () {
                var verticalSlicerRenderer = this.slicerRenderer = new visuals.VerticalSlicerRenderer({ domHelper: this.domHelper, behavior: this.behavior });
                var options = this.createInitOptions();
                this.interactivityService = verticalSlicerRenderer.init(options);
            };
            Slicer.prototype.initializeHorizontalSlicer = function () {
                var horizontalSlicerRenderer = this.slicerRenderer = new visuals.HorizontalSlicerRenderer({ domHelper: this.domHelper, behavior: this.behavior });
                var options = this.createInitOptions();
                this.interactivityService = horizontalSlicerRenderer.init(options);
            };
            Slicer.prototype.createInitOptions = function () {
                var _this = this;
                return {
                    visualInitOptions: this.initOptions,
                    loadMoreData: function () { return _this.loadMoreData(); }
                };
            };
            return Slicer;
        }());
        visuals.Slicer = Slicer;
        /** Helper class for calculating the current slicer settings. */
        var ObjectEnumerator;
        (function (ObjectEnumerator) {
            function enumerateObjectInstances(options, data, settings, dataView) {
                if (!data)
                    return;
                switch (options.objectName) {
                    case 'items':
                        return enumerateItems(data, settings);
                    case 'header':
                        return enumerateHeader(data, settings);
                    case 'general':
                        return enumerateGeneral(data, settings);
                    case 'selection':
                        if (shouldShowSelectionOption(dataView))
                            return enumerateSelection(data, settings);
                }
            }
            ObjectEnumerator.enumerateObjectInstances = enumerateObjectInstances;
            function shouldShowSelectionOption(dataView) {
                return !(dataView &&
                    dataView.metadata &&
                    dataView.metadata.columns &&
                    _.some(dataView.metadata.columns, function (column) { return column.discourageAggregationAcrossGroups; }));
            }
            function enumerateSelection(data, settings) {
                var slicerSettings = settings;
                var areSelectionSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.selection;
                var selectAllCheckboxEnabled = areSelectionSettingsDefined && data.slicerSettings.selection.selectAllCheckboxEnabled ?
                    data.slicerSettings.selection.selectAllCheckboxEnabled : slicerSettings.selection.selectAllCheckboxEnabled;
                var singleSelect = data && data.slicerSettings && data.slicerSettings.selection && data.slicerSettings.selection.singleSelect !== undefined ?
                    data.slicerSettings.selection.singleSelect : slicerSettings.selection.singleSelect;
                return [{
                        selector: null,
                        objectName: 'selection',
                        properties: {
                            selectAllCheckboxEnabled: selectAllCheckboxEnabled,
                            singleSelect: singleSelect,
                        }
                    }];
            }
            function enumerateHeader(data, settings) {
                var slicerSettings = settings;
                var areHeaderSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.header;
                var fontColor = areHeaderSettingsDefined && data.slicerSettings.header.fontColor ?
                    data.slicerSettings.header.fontColor : slicerSettings.header.fontColor;
                var background = areHeaderSettingsDefined && data.slicerSettings.header.background ?
                    data.slicerSettings.header.background : slicerSettings.header.background;
                return [{
                        selector: null,
                        objectName: 'header',
                        properties: {
                            show: slicerSettings.header.show,
                            fontColor: fontColor,
                            background: background,
                            outline: slicerSettings.header.outline,
                            textSize: slicerSettings.header.textSize,
                        }
                    }];
            }
            function enumerateItems(data, settings) {
                var slicerSettings = settings;
                var areTextSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.slicerText;
                var fontColor = areTextSettingsDefined && data.slicerSettings.slicerText.color ?
                    data.slicerSettings.slicerText.color : slicerSettings.slicerText.color;
                var background = areTextSettingsDefined && data.slicerSettings.slicerText.background ?
                    data.slicerSettings.slicerText.background : slicerSettings.slicerText.background;
                return [{
                        selector: null,
                        objectName: 'items',
                        properties: {
                            fontColor: fontColor,
                            background: background,
                            outline: slicerSettings.slicerText.outline,
                            textSize: slicerSettings.slicerText.textSize,
                        }
                    }];
            }
            function enumerateGeneral(data, settings) {
                var slicerSettings = settings;
                var areGeneralSettingsDefined = SettingsHelper.areSettingsDefined(data) && data.slicerSettings.general != null;
                var outlineColor = areGeneralSettingsDefined && data.slicerSettings.general.outlineColor ?
                    data.slicerSettings.general.outlineColor : slicerSettings.general.outlineColor;
                var outlineWeight = areGeneralSettingsDefined && data.slicerSettings.general.outlineWeight ?
                    data.slicerSettings.general.outlineWeight : slicerSettings.general.outlineWeight;
                var orientation = areGeneralSettingsDefined && data.slicerSettings.general.orientation != null ?
                    data.slicerSettings.general.orientation : slicerSettings.general.orientation;
                return [{
                        selector: null,
                        objectName: 'general',
                        properties: {
                            outlineColor: outlineColor,
                            outlineWeight: outlineWeight,
                            orientation: orientation,
                        }
                    }];
            }
        })(ObjectEnumerator || (ObjectEnumerator = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TablixUtils = visuals.controls.internal.TablixUtils;
        var TablixObjects = visuals.controls.internal.TablixObjects;
        var TableHierarchyNavigator = (function () {
            function TableHierarchyNavigator(tableDataView, formatter) {
                debug.assertValue(tableDataView, 'tableDataView');
                debug.assertValue(formatter, 'formatter');
                this.tableDataView = tableDataView;
                this.formatter = formatter;
            }
            /**
            * Returns the depth of the Columnm hierarchy.
            */
            TableHierarchyNavigator.prototype.getColumnHierarchyDepth = function () {
                return 1;
            };
            /**
            * Returns the depth of the Row hierarchy.
            */
            TableHierarchyNavigator.prototype.getRowHierarchyDepth = function () {
                return 1;
            };
            /**
             * Returns the leaf count of a hierarchy.
             */
            TableHierarchyNavigator.prototype.getLeafCount = function (hierarchy) {
                return hierarchy.length;
            };
            /**
             * Returns the leaf member of a hierarchy at a specified index.
             */
            TableHierarchyNavigator.prototype.getLeafAt = function (hierarchy, index) {
                return hierarchy[index];
            };
            /**
             * Returns the specified hierarchy member parent.
             */
            TableHierarchyNavigator.prototype.getParent = function (item) {
                return null;
            };
            /**
             * Returns the index of the hierarchy member relative to its parent.
             */
            TableHierarchyNavigator.prototype.getIndex = function (item) {
                if (!item)
                    return -1;
                if (this.isRow(item))
                    return item.index;
                return this.getColumnIndex(item);
            };
            TableHierarchyNavigator.prototype.isRow = function (item) {
                if (!item)
                    return false;
                var row = item;
                return row.index !== undefined && row.values !== undefined;
            };
            TableHierarchyNavigator.prototype.getColumnIndex = function (item) {
                return TableHierarchyNavigator.getIndex(this.tableDataView.columns, item);
            };
            /**
             * Checks whether a hierarchy member is a leaf.
             */
            TableHierarchyNavigator.prototype.isLeaf = function (item) {
                return true;
            };
            TableHierarchyNavigator.prototype.isRowHierarchyLeaf = function (cornerItem) {
                return false;
            };
            TableHierarchyNavigator.prototype.isColumnHierarchyLeaf = function (cornerItem) {
                return true;
            };
            TableHierarchyNavigator.prototype.isFirstItem = function (item, items) {
                // checking for item.index is unreliable because reordering the columns would cause a mismatch between index and items order
                return item === items[0];
            };
            TableHierarchyNavigator.prototype.areAllParentsFirst = function (item, items) {
                return this.isFirstItem(item, items);
            };
            /**
             * Checks whether a hierarchy member is the last item within its parent.
             */
            TableHierarchyNavigator.prototype.isLastItem = function (item, items) {
                debug.assertValue(item, 'item');
                return items[items.length - 1] === item;
            };
            TableHierarchyNavigator.prototype.areAllParentsLast = function (item, items) {
                return this.isLastItem(item, items);
            };
            /**
             * Gets the children members of a hierarchy member.
             */
            TableHierarchyNavigator.prototype.getChildren = function (item) {
                return null;
            };
            TableHierarchyNavigator.prototype.getChildrenLevelDifference = function (item) {
                return Infinity;
            };
            /**
             * Gets the members count in a specified collection.
             */
            TableHierarchyNavigator.prototype.getCount = function (items) {
                return items.length;
            };
            /**
             * Gets the member at the specified index.
             */
            TableHierarchyNavigator.prototype.getAt = function (items, index) {
                return items[index];
            };
            /**
             * Gets the hierarchy member level.
             */
            TableHierarchyNavigator.prototype.getLevel = function (item) {
                return 0;
            };
            /**
             * Returns the intersection between a row and a column item.
             */
            TableHierarchyNavigator.prototype.getIntersection = function (rowItem, columnItem) {
                var value;
                var isTotal = false;
                var position = new TablixUtils.CellPosition();
                var columnIndex = TableHierarchyNavigator.getIndex(this.tableDataView.columns, columnItem);
                ;
                position.column.index = columnIndex;
                position.column.isFirst = columnIndex === 0 ? true : false;
                position.column.isLast = columnIndex === this.tableDataView.columns.length - 1;
                var totalRow = rowItem;
                if (totalRow.totalCells != null) {
                    isTotal = true;
                    value = totalRow.totalCells[columnIndex];
                }
                else {
                    var row = rowItem;
                    var rowIndex = row.index;
                    position.row.index = rowIndex;
                    position.row.isFirst = rowIndex === 0;
                    position.row.isLast = rowIndex === this.tableDataView.rows.length - 1;
                    value = row.values[columnIndex];
                }
                var cellItem = new TablixUtils.TablixVisualCell(value, isTotal, columnItem, this.formatter);
                cellItem.position = position;
                // VSTS 7167767: Remove temporary code for product demo.
                var tableRow = rowItem;
                if (tableRow && tableRow.values) {
                    var rowObjects = tableRow.values.objects;
                    if (rowObjects) {
                        var cellObject = rowObjects[columnIndex];
                        if (cellObject) {
                            cellItem.backColorCustomFormatting = TablixObjects.PropValuesBackColorPrimary.getValue(cellObject);
                        }
                    }
                }
                return cellItem;
            };
            /**
             * Returns the corner cell between a row and a column level.
             */
            TableHierarchyNavigator.prototype.getCorner = function (rowLevel, columnLevel) {
                return null;
            };
            TableHierarchyNavigator.prototype.headerItemEquals = function (item1, item2) {
                if (item1 === item2)
                    return true;
                // Typechecking does not work with interfaces nor at runtime. We need to explicitly check for 
                // properties of DataViewMetadataColumn to determine if we can use the column equivalency check.
                // We expect this method to handle either VisualTableRows or DataViewMetadataColumns so checking
                // for displayName should be sufficient.
                if (item1.displayName && item2.displayName) {
                    var column1 = item1;
                    var column2 = item2;
                    return powerbi.DataViewAnalysis.areMetadataColumnsEquivalent(column1, column2);
                }
                if (this.isRow(item1) && this.isRow(item2))
                    return item1.index === item2.index;
                return false;
            };
            TableHierarchyNavigator.prototype.bodyCellItemEquals = function (item1, item2) {
                //return (item1.dataPoint === item2.dataPoint);
                return (item1.isMatch(item2));
            };
            TableHierarchyNavigator.prototype.cornerCellItemEquals = function (item1, item2) {
                // Should not be called as we don't return any corner items for table
                return true;
            };
            TableHierarchyNavigator.prototype.update = function (table) {
                this.tableDataView = table;
            };
            TableHierarchyNavigator.getIndex = function (items, item) {
                for (var index = 0, len = items.length; index < len; index++) {
                    // For cases when the item was re-created during the DataTransformation phase,
                    // we check for the item's index to verify equality.
                    var arrayItem = items[index];
                    if (arrayItem.index != null && item.index != null && arrayItem.index === item.index) {
                        return index;
                    }
                    else {
                        if (item === items[index])
                            return index;
                    }
                }
                return -1;
            };
            return TableHierarchyNavigator;
        }());
        visuals.TableHierarchyNavigator = TableHierarchyNavigator;
        /**
         * Note: Public for testability.
         */
        var TableBinder = (function () {
            function TableBinder(options) {
                this.options = options;
            }
            TableBinder.prototype.onDataViewChanged = function (dataView) {
                this.tableDataView = dataView;
                this.formattingProperties = dataView.formattingProperties;
                this.updateTextHeights();
            };
            TableBinder.prototype.updateTextHeights = function () {
                var textProps = {
                    fontFamily: '',
                    fontSize: TablixObjects.getTextSizeInPx(this.formattingProperties.general.textSize),
                    text: 'a',
                };
                textProps.fontFamily = TablixUtils.FontFamilyHeader;
                this.textHeightHeader = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(textProps));
                textProps.fontFamily = TablixUtils.FontFamilyCell;
                this.textHeightValue = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(textProps));
                textProps.fontFamily = TablixUtils.FontFamilyTotal;
                this.textHeightTotal = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(textProps));
            };
            TableBinder.prototype.onStartRenderingSession = function () {
            };
            TableBinder.prototype.onEndRenderingSession = function () {
            };
            /**
             * Row Header.
             */
            TableBinder.prototype.bindRowHeader = function (item, cell) {
                cell.contentHeight = this.textHeightValue;
                // To clear the CSS classes that adds paddings
                TablixUtils.clearCellStyle(cell);
                if (this.options.onBindRowHeader)
                    this.options.onBindRowHeader(item);
            };
            TableBinder.prototype.unbindRowHeader = function (item, cell) {
            };
            /**
             * Column Header.
             */
            TableBinder.prototype.bindColumnHeader = function (item, cell) {
                var _this = this;
                cell.extension.disableDragResize();
                TablixUtils.resetCellCssClass(cell);
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
                var cellStyle = new TablixUtils.CellStyle();
                // Set default style
                cellStyle.fontFamily = TablixUtils.FontFamilyHeader;
                cellStyle.fontColor = TablixUtils.FontColorHeaders;
                cellStyle.borders.bottom = new TablixUtils.EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
                cell.contentHeight = this.textHeightHeader;
                if (this.sortIconsEnabled())
                    TablixUtils.createColumnHeaderWithSortIcon(item, cell);
                else
                    TablixUtils.setCellTextAndTooltip(cell, item.displayName);
                if (this.options.onColumnHeaderClick) {
                    var handler = function (e) {
                        if (TablixUtils.isValidSortClick(e)) {
                            var sortDirection = TablixUtils.reverseSort(item.sort);
                            _this.options.onColumnHeaderClick(item.queryName ? item.queryName : item.displayName, sortDirection);
                        }
                    };
                    cell.extension.registerClickHandler(handler);
                }
                this.setColumnHeaderStyle(cell, cellStyle);
                cell.applyStyle(cellStyle);
            };
            TableBinder.prototype.setColumnHeaderStyle = function (cell, style) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.columnHeaders;
                var propsTotal = this.formattingProperties.total;
                var propsValues = this.formattingProperties.values;
                style.borders.top = new TablixUtils.EdgeSettings();
                style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                style.borders.bottom = new TablixUtils.EdgeSettings();
                style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but Footer or Body has, we need to apply extra padding
                    if (!visuals.outline.showLeft(props.outline) && (visuals.outline.showLeft(propsTotal.outline) || visuals.outline.showLeft(propsValues.outline)))
                        style.paddings.left += propsGrid.outlineWeight;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have right border, but Footer or Body has, we need to apply extra padding
                    if (!visuals.outline.showRight(props.outline) && (visuals.outline.showRight(propsTotal.outline) || visuals.outline.showRight(propsValues.outline)))
                        style.paddings.right += propsGrid.outlineWeight;
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = props.fontColor;
                style.backColor = props.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
            };
            TableBinder.prototype.unbindColumnHeader = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
                if (this.sortIconsEnabled())
                    TablixUtils.removeSortIcons(cell);
                if (this.options.onColumnHeaderClick) {
                    cell.extension.unregisterClickHandler();
                }
            };
            /**
             * Body Cell.
             */
            TableBinder.prototype.bindBodyCell = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                var imgHeight;
                imgHeight = this.formattingProperties.grid.imageHeight;
                var cellStyle = new TablixUtils.CellStyle();
                if (item.isImage) {
                    cell.contentHeight = imgHeight;
                }
                else {
                    cell.contentHeight = this.textHeightValue;
                }
                if (item.isUrl && item.isValidUrl) {
                    TablixUtils.appendATagToBodyCell(item.textContent, cell, this.formattingProperties.values.urlIcon);
                }
                else if (item.isImage && item.isValidUrl) {
                    TablixUtils.appendImgTagToBodyCell(item.textContent, cell, imgHeight);
                    cellStyle.hasImage = true;
                }
                else if (item.domContent) {
                    $(cell.extension.contentHost).append(item.domContent);
                }
                else if (item.textContent) {
                    TablixUtils.setCellTextAndTooltip(cell, item.textContent);
                }
                else {
                    TablixUtils.setCellTextAndTooltip(cell, " ");
                }
                if (item.isTotal) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableFooter);
                    cellStyle.fontFamily = TablixUtils.FontFamilyTotal;
                    cellStyle.borders.top = new TablixUtils.EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
                    cell.contentHeight = this.textHeightTotal;
                }
                else if (item.position.row.isLast) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCellBottom);
                }
                else {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTableBodyCell);
                    cellStyle.borders.bottom = new TablixUtils.EdgeSettings(TablixObjects.PropGridHorizontalWeight.defaultValue, TablixObjects.PropGridHorizontalColor.defaultValue);
                }
                if (item.isNumeric)
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
                if (item.isTotal)
                    this.setFooterStyle(cell, cellStyle);
                else
                    this.setBodyStyle(item, cell, cellStyle);
                cell.applyStyle(cellStyle);
            };
            TableBinder.prototype.setBodyStyle = function (item, cell, style) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.values;
                var propsTotal = this.formattingProperties.total;
                var propsColumns = this.formattingProperties.columnHeaders;
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but Footer or Header has, we need to apply extra padding
                    if (!visuals.outline.showLeft(props.outline) && (visuals.outline.showLeft(propsTotal.outline) || visuals.outline.showLeft(propsColumns.outline)))
                        style.paddings.left += propsGrid.outlineWeight;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have right border, but Footer has, we need to apply extra padding
                    if (!visuals.outline.showRight(props.outline) && (visuals.outline.showRight(propsTotal.outline) || visuals.outline.showRight(propsColumns.outline)))
                        style.paddings.right += propsGrid.outlineWeight;
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = cell.position.row.index % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary;
                // TODO: VSTS 7167767: Remove temporary code for product demo.
                if (this.formattingProperties.isConditionalFormattingEnabled && this.formattingProperties.values.conditionalFormatting && item.backColorCustomFormatting)
                    style.backColor = item.backColorCustomFormatting;
                else
                    style.backColor = cell.position.row.index % 2 === 0 ? props.backColorPrimary : props.backColorSecondary;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
            };
            TableBinder.prototype.setFooterStyle = function (cell, style) {
                var props = this.formattingProperties.total;
                var propsGrid = this.formattingProperties.grid;
                var propsValues = this.formattingProperties.values;
                var propsColumns = this.formattingProperties.columnHeaders;
                style.borders.top = new TablixUtils.EdgeSettings();
                style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                style.borders.bottom = new TablixUtils.EdgeSettings();
                style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but values or column headers have, we need to apply padding
                    if (!visuals.outline.showLeft(props.outline) && (visuals.outline.showLeft(propsValues.outline) || visuals.outline.showLeft(propsColumns.outline)))
                        style.paddings.left += propsGrid.outlineWeight;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but values or column headers have, we need to apply padding
                    if (!visuals.outline.showRight(props.outline) && (visuals.outline.showRight(propsValues.outline) || visuals.outline.showRight(propsColumns.outline)))
                        style.paddings.right += propsGrid.outlineWeight;
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = props.fontColor;
                style.backColor = props.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
            };
            TableBinder.prototype.unbindBodyCell = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
            };
            /**
             * Corner Cell.
             */
            TableBinder.prototype.bindCornerCell = function (item, cell) {
            };
            TableBinder.prototype.unbindCornerCell = function (item, cell) {
            };
            TableBinder.prototype.bindEmptySpaceHeaderCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.unbindEmptySpaceHeaderCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.bindEmptySpaceFooterCell = function (cell) {
                // Not needed for Table
            };
            TableBinder.prototype.unbindEmptySpaceFooterCell = function (cell) {
                // Not needed for Table
            };
            /**
             * Measurement Helper.
             */
            TableBinder.prototype.getHeaderLabel = function (item) {
                return item.displayName;
            };
            TableBinder.prototype.getCellContent = function (item) {
                return item;
            };
            TableBinder.prototype.hasRowGroups = function () {
                return false;
            };
            TableBinder.prototype.sortIconsEnabled = function () {
                return this.options.layoutKind === 0 /* Canvas */;
            };
            return TableBinder;
        }());
        visuals.TableBinder = TableBinder;
        var Table = (function () {
            function Table(options) {
                if (options) {
                    // TODO: VSTS 7167767: Remove temporary code for product demo.
                    this.isConditionalFormattingEnabled = options.isConditionalFormattingEnabled;
                    this.isTouchEnabled = options.isTouchEnabled;
                }
            }
            Table.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.table || !dataViewMapping.metadata)
                    return;
                var dataViewTableRows = dataViewMapping.table.rows;
                var objects = dataViewMapping.metadata.objects;
                dataViewTableRows.for.in.subtotalType = TablixObjects.shouldShowTableTotals(objects) ? 1 /* Before */ : 0 /* None */;
            };
            Table.getSortableRoles = function () {
                return ['Values'];
            };
            Table.prototype.init = function (options) {
                this.element = options.element;
                this.style = options.style;
                this.updateViewport(options.viewport);
                this.formatter = visuals.valueFormatter.formatValueColumn;
                this.isInteractive = options.interactivity && options.interactivity.selection != null;
                this.getLocalizedString = options.host.getLocalizedString;
                this.hostServices = options.host;
                this.persistingObjects = false;
                this.waitingForData = false;
                this.lastAllowHeaderResize = true;
                this.waitingForSort = false;
            };
            /**
             * Note: Public for testability.
             */
            // TODO: VSTS 7167767: Remove temporary code for product demo.
            Table.converter = function (dataView, isConditionalFormattingEnabled) {
                var table = dataView.table;
                debug.assertValue(table, 'table');
                debug.assertValue(table.rows, 'table.rows');
                var visualTable = powerbi.Prototype.inherit(table);
                visualTable.visualRows = [];
                for (var i = 0; i < table.rows.length; i++) {
                    var visualRow = {
                        index: i,
                        values: table.rows[i]
                    };
                    visualTable.visualRows.push(visualRow);
                }
                // TODO: VSTS 7167767: Remove temporary code for product demo.
                visualTable.formattingProperties = TablixObjects.getTableObjects(dataView, isConditionalFormattingEnabled);
                return visualTable;
            };
            Table.prototype.onResizing = function (finalViewport) {
                this.updateViewport(finalViewport);
            };
            // Public for testability
            Table.prototype.getColumnWidthManager = function () {
                return this.columnWidthManager;
            };
            Table.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var previousDataView = this.dataView;
                    this.dataView = dataViews[0];
                    /* To avoid OnDataChanged being called every time we persist Objects. If:
                    * AutoSizeColumns options was flipped
                    * A Column was resized manually
                    * A Column was auto-sized
                    */
                    if (this.persistingObjects) {
                        this.persistingObjects = false;
                        return;
                    }
                    // TODO: VSTS 7167767: Remove temporary code for product demo.
                    var visualTable = Table.converter(this.dataView, this.isConditionalFormattingEnabled);
                    var textSize = visualTable.formattingProperties.general.textSize;
                    if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) {
                        this.hierarchyNavigator.update(visualTable);
                        this.tablixControl.updateModels(/*resetScrollOffsets*/ false, visualTable.visualRows, visualTable.columns);
                        this.refreshControl(/*clear*/ false);
                    }
                    else {
                        this.createOrUpdateHierarchyNavigator(visualTable);
                        this.createColumnWidthManager();
                        this.createTablixControl(textSize);
                        var binder = this.tablixControl.getBinder();
                        binder.onDataViewChanged(visualTable);
                        this.updateInternal(textSize, previousDataView, visualTable);
                    }
                }
                this.waitingForData = false;
                this.waitingForSort = false;
            };
            Table.prototype.createColumnWidthManager = function () {
                var _this = this;
                if (!this.columnWidthManager) {
                    this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, false /* isMatrix */, function (objectInstances) { return _this.persistColumnWidths(objectInstances); });
                }
                else {
                    this.columnWidthManager.updateDataView(this.dataView);
                }
            };
            Table.prototype.persistColumnWidths = function (objectInstances) {
                this.persistingObjects = true;
                this.hostServices.persistProperties(objectInstances);
            };
            Table.prototype.updateViewport = function (newViewport) {
                this.currentViewport = newViewport;
                if (this.tablixControl) {
                    this.tablixControl.viewport = this.currentViewport;
                    this.verifyHeaderResize();
                    this.refreshControl(false);
                }
            };
            Table.prototype.refreshControl = function (clear) {
                if (visuals.visibilityHelper.partiallyVisible(this.element) || this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.refresh(clear);
                }
            };
            Table.prototype.getLayoutKind = function () {
                return this.isInteractive ? 0 /* Canvas */ : 1 /* DashboardTile */;
            };
            Table.prototype.createOrUpdateHierarchyNavigator = function (visualTable) {
                if (!this.tablixControl) {
                    var dataNavigator = new TableHierarchyNavigator(visualTable, this.formatter);
                    this.hierarchyNavigator = dataNavigator;
                }
                else {
                    this.hierarchyNavigator.update(visualTable);
                }
            };
            Table.prototype.createTablixControl = function (textSize) {
                if (!this.tablixControl) {
                    // Create the control
                    this.tablixControl = this.createControl(this.hierarchyNavigator, textSize);
                }
            };
            Table.prototype.createControl = function (dataNavigator, textSize) {
                var _this = this;
                var layoutKind = this.getLayoutKind();
                var tableBinderOptions = {
                    onBindRowHeader: function (item) { return _this.onBindRowHeader(item); },
                    onColumnHeaderClick: function (queryName, sortDirection) { return _this.onColumnHeaderClick(queryName, sortDirection); },
                    layoutKind: layoutKind
                };
                var tableBinder = new TableBinder(tableBinderOptions);
                var layoutManager = layoutKind === 1 /* DashboardTile */
                    ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(tableBinder)
                    : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(tableBinder, this.columnWidthManager);
                // Create Host element
                var tablixContainer = document.createElement('div');
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: this.isTouchEnabled,
                    layoutKind: layoutKind,
                    fontSize: TablixObjects.getTextSizeInPx(textSize),
                };
                return new visuals.controls.TablixControl(dataNavigator, layoutManager, tableBinder, tablixContainer, tablixOptions);
            };
            Table.prototype.updateInternal = function (textSize, previousDataView, visualTable) {
                var _this = this;
                if (this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView));
                }
                this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize);
                this.verifyHeaderResize();
                // Update models before the viewport to make sure column widths are computed correctly
                this.tablixControl.updateModels(/*resetScrollOffsets*/ true, visualTable.visualRows, visualTable.columns);
                var totals = this.createTotalsRow(this.dataView);
                this.tablixControl.rowDimension.setFooter(totals);
                this.tablixControl.viewport = this.currentViewport;
                var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
                // Render
                // We need the layout for the DIV to be done so that the control can measure items correctly.
                setTimeout(function () {
                    // Render
                    _this.refreshControl(shouldClearControl);
                    //Persist actual widths if autoSize flipped to true
                    if (_this.columnWidthManager.shouldPersistAllColumnWidths()) {
                        _this.columnWidthManager.persistAllColumnWidths(_this.tablixControl.layoutManager.columnWidthsToPersist);
                    }
                }, 0);
            };
            Table.prototype.shouldClearControl = function (previousDataView, newDataView) {
                if (!this.waitingForSort || !previousDataView || !newDataView)
                    return true;
                return !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata);
            };
            Table.prototype.createTotalsRow = function (dataView) {
                if (!TablixObjects.shouldShowTableTotals(dataView.metadata.objects))
                    return null;
                var totals = dataView.table.totals;
                if (!totals || totals.length === 0)
                    return null;
                var totalRow = [];
                var columns = dataView.table.columns;
                // Add totals for measure columns, blank for non-measure columns unless it's the first column
                for (var i = 0, len = columns.length; i < len; ++i) {
                    var column = columns[i];
                    var totalValue = totals[column.index];
                    if (totalValue != null) {
                        totalRow.push(totalValue);
                    }
                    else {
                        // If the first column is a non-measure column, we put 'Total' as the text similar to PV.
                        // Note that if the first column is a measure column we don't render any Total text at
                        // all, once again similar to PV.
                        totalRow.push((i === 0) ? this.getLocalizedString('TableTotalLabel') : '');
                    }
                }
                return { totalCells: totalRow };
            };
            Table.prototype.onBindRowHeader = function (item) {
                if (this.needsMoreData(item)) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Table.prototype.onColumnHeaderClick = function (queryName, sortDirection) {
                this.waitingForSort = true;
                this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
            };
            /**
             * Note: Public for testability.
             */
            Table.prototype.needsMoreData = function (item) {
                if (this.waitingForData || !this.dataView.metadata || !this.dataView.metadata.segment)
                    return false;
                var leafCount = this.tablixControl.rowDimension.getItemsCount();
                var loadMoreThreshold = leafCount * Table.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getIndex(item) >= loadMoreThreshold;
            };
            Table.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                // Visuals are initialized with an empty data view before queries are run, therefore we need to make sure that
                // we are resilient here when we do not have data view.
                if (this.dataView) {
                    TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, this.isConditionalFormattingEnabled, visuals.controls.TablixType.Table);
                }
                return enumeration.complete();
            };
            Table.prototype.shouldAllowHeaderResize = function () {
                return this.hostServices.getViewMode() === 1 /* Edit */;
            };
            Table.prototype.onViewModeChanged = function (viewMode) {
                /* Refreshes the column headers to enable/disable Column resizing */
                this.updateViewport(this.currentViewport);
            };
            Table.prototype.verifyHeaderResize = function () {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
                    this.lastAllowHeaderResize = currentAllowHeaderResize;
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
                }
            };
            Table.preferredLoadMoreThreshold = 0.8;
            return Table;
        }());
        visuals.Table = Table;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TablixUtils = visuals.controls.internal.TablixUtils;
        var TablixObjects = visuals.controls.internal.TablixObjects;
        var UrlUtils = jsCommon.UrlUtils;
        var MatrixVisualBodyItem = (function (_super) {
            __extends(MatrixVisualBodyItem, _super);
            function MatrixVisualBodyItem() {
                _super.apply(this, arguments);
            }
            Object.defineProperty(MatrixVisualBodyItem.prototype, "isMeasure", {
                get: function () {
                    return true;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidUrl", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            ;
            Object.defineProperty(MatrixVisualBodyItem.prototype, "isValidImage", {
                get: function () {
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            ;
            return MatrixVisualBodyItem;
        }(TablixUtils.TablixVisualCell));
        visuals.MatrixVisualBodyItem = MatrixVisualBodyItem;
        /**
         * Factory method used by unit tests.
         */
        function createMatrixHierarchyNavigator(matrix, formatter) {
            return new MatrixHierarchyNavigator(matrix, formatter);
        }
        visuals.createMatrixHierarchyNavigator = createMatrixHierarchyNavigator;
        var MatrixHierarchyNavigator = (function () {
            function MatrixHierarchyNavigator(matrix, formatter) {
                this.matrix = matrix;
                this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.rows);
                this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(matrix.columns);
                this.formatter = formatter;
                this.update();
            }
            /**
             * Returns the data view matrix.
             */
            MatrixHierarchyNavigator.prototype.getDataViewMatrix = function () {
                return this.matrix;
            };
            /**
            * Returns the depth of the column hierarchy.
             */
            MatrixHierarchyNavigator.prototype.getColumnHierarchyDepth = function () {
                return Math.max(this.columnHierarchy.levels.length, 1);
            };
            /**
            * Returns the depth of the Row hierarchy.
            */
            MatrixHierarchyNavigator.prototype.getRowHierarchyDepth = function () {
                return Math.max(this.rowHierarchy.levels.length, 1);
            };
            /**
             * Returns the leaf count of a hierarchy.
             */
            MatrixHierarchyNavigator.prototype.getLeafCount = function (hierarchy) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy)
                    return matrixHierarchy.leafNodes.length;
                return 0;
            };
            /**
             * Returns the leaf member of a hierarchy at a specified index.
             */
            MatrixHierarchyNavigator.prototype.getLeafAt = function (hierarchy, index) {
                var matrixHierarchy = this.getMatrixHierarchy(hierarchy);
                if (matrixHierarchy)
                    return matrixHierarchy.leafNodes[index];
                return null;
            };
            /**
             * Returns the leaf index of the visual node.
             */
            MatrixHierarchyNavigator.prototype.getLeafIndex = function (item) {
                debug.assertValue(item, 'item');
                return item.leafIndex;
            };
            /**
             * Returns the specified hierarchy member parent.
             */
            MatrixHierarchyNavigator.prototype.getParent = function (item) {
                debug.assertValue(item, 'item');
                // Return null for outermost nodes
                if (item.level === 0)
                    return null;
                return item.parent;
            };
            /**
             * Returns the index of the hierarchy member relative to its parent.
             */
            MatrixHierarchyNavigator.prototype.getIndex = function (item) {
                debug.assertValue(item, 'item');
                return item.index;
            };
            /**
             * Checks whether a hierarchy member is a leaf.
             */
            MatrixHierarchyNavigator.prototype.isLeaf = function (item) {
                debug.assertValue(item, 'item');
                return !item.children || item.children.length === 0;
            };
            MatrixHierarchyNavigator.prototype.isRowHierarchyLeaf = function (item) {
                return true;
            };
            MatrixHierarchyNavigator.prototype.isColumnHierarchyLeaf = function (item) {
                return false;
            };
            MatrixHierarchyNavigator.prototype.isFirstItem = function (item, items) {
                return item === _.first(items);
            };
            MatrixHierarchyNavigator.prototype.areAllParentsFirst = function (item, items) {
                if (!item)
                    return false;
                var parent = this.getParent(item);
                if (!parent) {
                    return this.isFirstItem(item, item.siblings);
                }
                else {
                    return this.isFirstItem(item, item.siblings) && this.areAllParentsFirst(parent, parent.siblings);
                }
            };
            /**
             * Checks whether a hierarchy member is the last item within its parent.
             */
            MatrixHierarchyNavigator.prototype.isLastItem = function (item, items) {
                debug.assertValue(item, 'item');
                return item === _.last(items);
            };
            MatrixHierarchyNavigator.prototype.areAllParentsLast = function (item, items) {
                if (!item)
                    return false;
                var parent = this.getParent(item);
                if (!parent) {
                    return this.isLastItem(item, item.siblings);
                }
                else {
                    return this.isLastItem(item, item.siblings) && this.areAllParentsLast(parent, parent.siblings);
                }
            };
            /**
             * Gets the children members of a hierarchy member.
             */
            MatrixHierarchyNavigator.prototype.getChildren = function (item) {
                debug.assertValue(item, 'item');
                return item.children;
            };
            /**
             * Gets the difference between current level and highest child's level. Can be > 1 if there are multiple values
             * @param {MatrixVisualNode} item
             * @returns
             */
            MatrixHierarchyNavigator.prototype.getChildrenLevelDifference = function (item) {
                var diff = Infinity;
                var children = this.getChildren(item);
                for (var i = 0, ilen = children.length; i < ilen; i++) {
                    diff = Math.min(diff, children[i].level - item.level);
                }
                return diff;
            };
            /**
             * Gets the members count in a specified collection.
             */
            MatrixHierarchyNavigator.prototype.getCount = function (items) {
                debug.assertValue(items, 'items');
                return items.length;
            };
            /**
             * Gets the member at the specified index.
             */
            MatrixHierarchyNavigator.prototype.getAt = function (items, index) {
                debug.assertValue(items, 'items');
                return items[index];
            };
            /**
             * Gets the hierarchy member level.
             */
            MatrixHierarchyNavigator.prototype.getLevel = function (item) {
                debug.assertValue(item, 'item');
                return item.level;
            };
            /**
             * Returns the intersection between a row and a column item.
             */
            MatrixHierarchyNavigator.prototype.getIntersection = function (rowItem, columnItem) {
                debug.assertValue(rowItem, 'rowItem');
                debug.assertValue(columnItem, 'columnItem');
                var isSubtotalItem = rowItem.isSubtotal === true || columnItem.isSubtotal === true;
                var node;
                var valueSource;
                var rowIndex = rowItem.leafIndex;
                var colIndex = columnItem.leafIndex;
                var bodyCell;
                if (!rowItem.values) {
                    node = undefined;
                }
                else {
                    node = (rowItem.values[columnItem.leafIndex]);
                }
                if (node) {
                    valueSource = this.matrix.valueSources[node.valueSourceIndex || 0];
                    bodyCell = new MatrixVisualBodyItem(node.value, isSubtotalItem, valueSource, this.formatter);
                }
                else {
                    bodyCell = new MatrixVisualBodyItem(undefined, isSubtotalItem, undefined, this.formatter);
                }
                bodyCell.position.row.index = rowIndex;
                bodyCell.position.row.indexInSiblings = rowItem.siblings.indexOf(rowItem);
                bodyCell.position.row.isFirst = rowIndex === 0;
                bodyCell.position.row.isLast = rowIndex === this.rowHierarchy.leafNodes.length - 1;
                bodyCell.position.column.index = colIndex;
                bodyCell.position.column.indexInSiblings = columnItem.siblings.indexOf(columnItem);
                bodyCell.position.column.isFirst = colIndex === 0;
                bodyCell.position.column.isLast = colIndex === this.columnHierarchy.leafNodes.length - 1;
                return bodyCell;
            };
            /**
             * Returns the corner cell between a row and a column level.
             */
            MatrixHierarchyNavigator.prototype.getCorner = function (rowLevel, columnLevel) {
                debug.assert(rowLevel >= 0, 'rowLevel');
                debug.assert(columnLevel >= 0, 'columnLevel');
                var columnLevels = this.columnHierarchy.levels;
                var rowLevels = this.rowHierarchy.levels;
                if (columnLevel === columnLevels.length - 1 || columnLevels.length === 0) {
                    var levelSource = rowLevels[rowLevel];
                    if (levelSource)
                        return {
                            metadata: levelSource.sources[0],
                            isColumnHeaderLeaf: true,
                            isRowHeaderLeaf: rowLevel === rowLevels.length - 1,
                        };
                }
                if (rowLevel === rowLevels.length - 1) {
                    var levelSource = columnLevels[columnLevel];
                    if (levelSource)
                        return {
                            metadata: levelSource.sources[0],
                            isColumnHeaderLeaf: false,
                            isRowHeaderLeaf: true,
                        };
                }
                return {
                    metadata: null,
                    isColumnHeaderLeaf: false,
                    isRowHeaderLeaf: false,
                };
            };
            MatrixHierarchyNavigator.prototype.headerItemEquals = function (item1, item2) {
                if (item1 && item2)
                    return (item1 === item2);
                else
                    return false;
            };
            MatrixHierarchyNavigator.prototype.bodyCellItemEquals = function (item1, item2) {
                return (item1.position.isMatch(item2.position));
            };
            MatrixHierarchyNavigator.prototype.cornerCellItemEquals = function (item1, item2) {
                return item1 === item2;
            };
            MatrixHierarchyNavigator.prototype.getMatrixColumnHierarchy = function () {
                return this.columnHierarchy;
            };
            MatrixHierarchyNavigator.prototype.getMatrixRowHierarchy = function () {
                return this.rowHierarchy;
            };
            /**
             * Implementation for MatrixDataAdapter interface.
             */
            MatrixHierarchyNavigator.prototype.update = function (dataViewMatrix, updateColumns) {
                if (updateColumns === void 0) { updateColumns = true; }
                if (dataViewMatrix) {
                    this.matrix = dataViewMatrix;
                    this.rowHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.rows);
                    if (updateColumns)
                        this.columnHierarchy = MatrixHierarchyNavigator.wrapMatrixHierarchy(dataViewMatrix.columns);
                }
                this.updateHierarchy(this.rowHierarchy);
                if (updateColumns) {
                    this.updateHierarchy(this.columnHierarchy);
                    MatrixHierarchyNavigator.updateStaticColumnHeaders(this.columnHierarchy);
                }
            };
            MatrixHierarchyNavigator.wrapMatrixHierarchy = function (hierarchy) {
                var matrixHierarchy = powerbi.Prototype.inherit(hierarchy);
                matrixHierarchy.leafNodes = [];
                return matrixHierarchy;
            };
            MatrixHierarchyNavigator.prototype.updateHierarchy = function (hierarchy) {
                if (hierarchy.leafNodes.length > 0)
                    hierarchy.leafNodes.length = 0;
                if (hierarchy.root.children)
                    this.updateRecursive(hierarchy, hierarchy.root.children, null, hierarchy.leafNodes);
            };
            MatrixHierarchyNavigator.prototype.updateRecursive = function (hierarchy, nodes, parent, cache) {
                var level;
                for (var i = 0, ilen = nodes.length; i < ilen; i++) {
                    var node = nodes[i];
                    node.siblings = nodes;
                    if (parent)
                        node.parent = parent;
                    if (!level)
                        level = hierarchy.levels[node.level];
                    if (level) {
                        var source = level.sources[node.levelSourceIndex ? node.levelSourceIndex : 0];
                        var formatString = visuals.valueFormatter.getFormatString(source, TablixObjects.PropColumnFormatString.getPropertyID());
                        if (formatString)
                            node.name = this.formatter(node.value, source, TablixObjects.PropColumnFormatString.getPropertyID());
                        node.queryName = source.queryName;
                    }
                    node.index = i;
                    if (node.children && node.children.length > 0) {
                        this.updateRecursive(hierarchy, node.children, node, cache);
                    }
                    else {
                        node.leafIndex = cache.length;
                        cache.push(node);
                    }
                }
            };
            MatrixHierarchyNavigator.updateStaticColumnHeaders = function (columnHierarchy) {
                var columnLeafNodes = columnHierarchy.leafNodes;
                if (columnLeafNodes && columnLeafNodes.length > 0) {
                    var columnLeafSources = columnHierarchy.levels[columnLeafNodes[0].level].sources;
                    for (var i = 0, ilen = columnLeafNodes.length; i < ilen; i++) {
                        var columnLeafNode = columnLeafNodes[i];
                        // Static leaf may need to get label from it's definition
                        if (!columnLeafNode.identity && columnLeafNode.value === undefined) {
                            // We make distincion between null and undefined. Null can be considered as legit value, undefined means we need to fall back to metadata
                            var source = columnLeafSources[columnLeafNode.levelSourceIndex ? columnLeafNode.levelSourceIndex : 0];
                            if (source)
                                columnLeafNode.name = source.displayName;
                        }
                    }
                }
            };
            MatrixHierarchyNavigator.prototype.getMatrixHierarchy = function (rootNodes) {
                var rowHierarchyRootNodes = this.rowHierarchy.root.children;
                if (rowHierarchyRootNodes && rootNodes === rowHierarchyRootNodes)
                    return this.rowHierarchy;
                var columnHierarchyRootNodes = this.columnHierarchy.root.children;
                if (columnHierarchyRootNodes && rootNodes === columnHierarchyRootNodes)
                    return this.columnHierarchy;
                return null;
            };
            return MatrixHierarchyNavigator;
        }());
        var MatrixBinder = (function () {
            function MatrixBinder(hierarchyNavigator, options) {
                // We pass the hierarchy navigator in here because it is the object that will
                // survive data changes and gets updated with the latest data view.
                this.hierarchyNavigator = hierarchyNavigator;
                this.options = options;
            }
            MatrixBinder.prototype.onDataViewChanged = function (formattingProperties) {
                this.formattingProperties = formattingProperties;
                this.updateTextHeights();
            };
            MatrixBinder.prototype.updateTextHeights = function () {
                var textProps = {
                    fontFamily: '',
                    fontSize: TablixObjects.getTextSizeInPx(this.formattingProperties.general.textSize),
                    text: 'a',
                };
                textProps.fontFamily = TablixUtils.FontFamilyHeader;
                this.textHeightHeader = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(textProps));
                textProps.fontFamily = TablixUtils.FontFamilyCell;
                this.textHeightValue = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(textProps));
                textProps.fontFamily = TablixUtils.FontFamilyTotal;
                this.textHeightTotal = Math.ceil(powerbi.TextMeasurementService.measureSvgTextHeight(textProps));
            };
            MatrixBinder.prototype.onStartRenderingSession = function () {
            };
            MatrixBinder.prototype.onEndRenderingSession = function () {
            };
            /**
             * Row Header.
             */
            MatrixBinder.prototype.bindRowHeader = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                var cellStyle = new TablixUtils.CellStyle();
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf);
                    cellStyle.borders.right = new TablixUtils.EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
                }
                if (item.isSubtotal) {
                    cellStyle.paddings.left = TablixUtils.CellPaddingLeftMatrixTotal;
                }
                this.bindHeader(item, cell, this.getRowHeaderMetadata(item), cellStyle);
                if (this.options.onBindRowHeader)
                    this.options.onBindRowHeader(item);
                this.setRowHeaderStyle(cell, cellStyle);
                cell.applyStyle(cellStyle);
            };
            MatrixBinder.prototype.setRowHeaderStyle = function (cell, style) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.rowHeaders;
                var propsValues = this.formattingProperties.values;
                var propsCols = this.formattingProperties.columnHeaders;
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have top border, but Values have, we need to apply extra padding
                    if (!visuals.outline.showTop(props.outline) && visuals.outline.showTop(propsValues.outline))
                        style.paddings.top += propsGrid.outlineWeight;
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have bottom border, but Values have, we need to apply extra padding
                    if (!visuals.outline.showBottom(props.outline) && visuals.outline.showBottom(propsValues.outline))
                        style.paddings.bottom += propsGrid.outlineWeight;
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but Column Headers have, we need to apply extra padding
                    if (!visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsCols.outline))
                        style.paddings.left += propsGrid.outlineWeight;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                style.fontColor = props.fontColor;
                style.backColor = props.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
            };
            MatrixBinder.prototype.unbindRowHeader = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
            };
            /**
             * Column Header.
             */
            MatrixBinder.prototype.bindColumnHeader = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                // Set default style
                var cellStyle = new TablixUtils.CellStyle();
                var overwriteTotalLabel = false;
                var isLeaf = this.hierarchyNavigator && this.hierarchyNavigator.isLeaf(item);
                if (isLeaf) {
                    cellStyle.borders.bottom = new TablixUtils.EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
                    var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                    if (sortableHeaderColumnMetadata && this.options.showSortIcons) {
                        this.registerColumnHeaderClickHandler(sortableHeaderColumnMetadata, cell);
                        TablixUtils.createColumnHeaderWithSortIcon(sortableHeaderColumnMetadata, cell);
                    }
                    // Overwrite only if the there are subtotal siblings (like in the multimeasure case), which means ALL siblings are subtotals.
                    if (item.isSubtotal && item.parent && item.parent.children.length > 1 && item.parent.children[0].isSubtotal)
                        overwriteTotalLabel = true;
                }
                cell.extension.disableDragResize();
                this.bindHeader(item, cell, this.getColumnHeaderMetadata(item), cellStyle, overwriteTotalLabel);
                this.setColumnHeaderStyle(cell, cellStyle);
                cell.applyStyle(cellStyle);
            };
            MatrixBinder.prototype.setColumnHeaderStyle = function (cell, style) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.columnHeaders;
                var propsValues = this.formattingProperties.values;
                style.fontColor = props.fontColor;
                style.backColor = props.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    // If we dont have left border, but Values have, we need to apply extra padding
                    if (!visuals.outline.showLeft(props.outline) && visuals.outline.showLeft(propsValues.outline))
                        style.paddings.left += propsGrid.outlineWeight;
                }
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have right border, but Values have, we need to apply extra padding
                    if (!visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsValues.outline))
                        style.paddings.right += propsGrid.outlineWeight;
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
            };
            MatrixBinder.prototype.unbindColumnHeader = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
                var sortableHeaderColumnMetadata = this.getSortableHeaderColumnMetadata(item);
                if (sortableHeaderColumnMetadata) {
                    this.unregisterColumnHeaderClickHandler(cell);
                }
                if (this.options.showSortIcons)
                    TablixUtils.removeSortIcons(cell);
            };
            MatrixBinder.prototype.bindHeader = function (item, cell, metadata, style, overwriteSubtotalLabel) {
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
                style.fontFamily = TablixUtils.FontFamilyHeader;
                style.fontColor = TablixUtils.FontColorHeaders;
                var imgHeight = this.formattingProperties.grid.imageHeight;
                if (visuals.converterHelper.isImageUrlColumn(metadata))
                    cell.contentHeight = imgHeight;
                else if (item.isSubtotal)
                    cell.contentHeight = this.textHeightTotal;
                else
                    cell.contentHeight = this.textHeightValue;
                if (item.isSubtotal) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
                    style.fontFamily = TablixUtils.FontFamilyTotal;
                    if (!overwriteSubtotalLabel) {
                        TablixUtils.setCellTextAndTooltip(cell, this.options.totalLabel);
                        return;
                    }
                }
                var value = MatrixBinder.getNodeLabel(item);
                if (!value) {
                    // just to maintain the height of the row in case all realized cells are nulls
                    cell.extension.contentHost.innerHTML = TablixUtils.StringNonBreakingSpace;
                }
                else if (visuals.converterHelper.isWebUrlColumn(metadata) && UrlUtils.isValidUrl(value)) {
                    TablixUtils.appendATagToBodyCell(item.value, cell);
                }
                else if (visuals.converterHelper.isImageUrlColumn(metadata)) {
                    style.hasImage = true;
                    if (UrlUtils.isValidImageUrl(value)) {
                        TablixUtils.appendImgTagToBodyCell(item.value, cell, imgHeight);
                    }
                    else {
                        TablixUtils.setCellTextAndTooltip(cell, value);
                    }
                }
                else {
                    TablixUtils.setCellTextAndTooltip(cell, value);
                }
            };
            MatrixBinder.prototype.registerColumnHeaderClickHandler = function (columnMetadata, cell) {
                var _this = this;
                if (this.options.onColumnHeaderClick) {
                    var handler = function (e) {
                        if (TablixUtils.isValidSortClick(e)) {
                            var sortDirection = TablixUtils.reverseSort(columnMetadata.sort);
                            _this.options.onColumnHeaderClick(columnMetadata.queryName ? columnMetadata.queryName : columnMetadata.displayName, sortDirection);
                        }
                    };
                    cell.extension.registerClickHandler(handler);
                }
            };
            MatrixBinder.prototype.unregisterColumnHeaderClickHandler = function (cell) {
                if (this.options.onColumnHeaderClick) {
                    cell.extension.unregisterClickHandler();
                }
            };
            /**
             * Body Cell.
             */
            MatrixBinder.prototype.bindBodyCell = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                var cellStyle = new TablixUtils.CellStyle();
                cell.contentHeight = this.textHeightValue;
                if (item.domContent) {
                    $(cell.extension.contentHost).append(item.domContent);
                }
                else {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueNumeric);
                    if (item.isTotal) {
                        TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixValueTotal);
                        cellStyle.fontFamily = TablixUtils.FontFamilyTotal;
                        cell.contentHeight = this.textHeightTotal;
                    }
                    if (item.textContent) {
                        TablixUtils.setCellTextAndTooltip(cell, item.textContent);
                    }
                }
                this.setBodyCellStyle(cell, item, cellStyle);
                cell.applyStyle(cellStyle);
            };
            MatrixBinder.prototype.setBodyCellStyle = function (cell, item, style) {
                var propsGrid = this.formattingProperties.grid;
                var props = this.formattingProperties.values;
                var propsTotal = this.formattingProperties.subtotals;
                var propsRows = this.formattingProperties.rowHeaders;
                var propsColumns = this.formattingProperties.columnHeaders;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have top border, but Row Headers have, we need to apply extra padding
                    if (!visuals.outline.showTop(props.outline) && visuals.outline.showTop(propsRows.outline))
                        style.paddings.top += propsGrid.outlineWeight;
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have bottom border, but Row Headers have, we need to apply extra padding
                    if (!visuals.outline.showBottom(props.outline) && visuals.outline.showBottom(propsRows.outline))
                        style.paddings.bottom += propsGrid.outlineWeight;
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                if (cell.position.column.isLast) {
                    style.borders.right.applyParams(visuals.outline.showRight(props.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have right border, but Column Headers have, we need to apply extra padding
                    if (!visuals.outline.showRight(props.outline) && visuals.outline.showRight(propsColumns.outline))
                        style.paddings.right += propsGrid.outlineWeight;
                }
                else {
                    style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
                }
                var rowBandingIndex;
                if (this.formattingProperties.general.rowSubtotals && propsTotal.backColor)
                    rowBandingIndex = item.position.row.indexInSiblings;
                else
                    rowBandingIndex = item.position.row.index;
                if (item.isTotal && propsTotal.fontColor) {
                    style.fontColor = propsTotal.fontColor;
                }
                else {
                    style.fontColor = rowBandingIndex % 2 === 0 ? props.fontColorPrimary : props.fontColorSecondary;
                }
                if (item.isTotal && propsTotal.backColor) {
                    style.backColor = propsTotal.backColor;
                }
                else {
                    style.backColor = rowBandingIndex % 2 === 0 ? props.backColorPrimary : props.backColorSecondary;
                }
            };
            MatrixBinder.prototype.unbindBodyCell = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
            };
            /**
             * Corner Cell.
             */
            MatrixBinder.prototype.bindCornerCell = function (item, cell) {
                TablixUtils.resetCellCssClass(cell);
                var cellStyle = new TablixUtils.CellStyle();
                cellStyle.fontFamily = TablixUtils.FontFamilyHeader;
                cellStyle.fontColor = TablixUtils.FontColorHeaders;
                cell.contentHeight = this.textHeightHeader;
                if (item.isColumnHeaderLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixColumnHeaderLeaf);
                    cellStyle.borders.bottom = new TablixUtils.EdgeSettings(TablixObjects.PropGridOutlineWeight.defaultValue, TablixObjects.PropGridOutlineColor.defaultValue);
                    var cornerHeaderMetadata = this.getSortableCornerColumnMetadata(item);
                    if (cornerHeaderMetadata)
                        this.registerColumnHeaderClickHandler(cornerHeaderMetadata, cell);
                    if (this.options.showSortIcons)
                        TablixUtils.createColumnHeaderWithSortIcon(cornerHeaderMetadata, cell);
                    else
                        TablixUtils.setCellTextAndTooltip(cell, cornerHeaderMetadata.displayName);
                }
                else {
                    var itemText = item.metadata ? item.metadata.displayName : '';
                    TablixUtils.setCellTextAndTooltip(cell, itemText);
                }
                if (item.isRowHeaderLeaf) {
                    TablixUtils.addCellCssClass(cell, TablixUtils.CssClassMatrixRowHeaderLeaf);
                }
                TablixUtils.addCellCssClass(cell, TablixUtils.CssClassTablixHeader);
                this.setCornerCellsStyle(cell, cellStyle);
                cell.applyStyle(cellStyle);
                cell.extension.disableDragResize();
            };
            MatrixBinder.prototype.setCornerCellsStyle = function (cell, style) {
                var propsGrid = this.formattingProperties.grid;
                var propsCol = this.formattingProperties.columnHeaders;
                var propsRow = this.formattingProperties.rowHeaders;
                style.fontColor = propsCol.fontColor || propsRow.fontColor;
                style.backColor = propsCol.backColor || propsRow.backColor;
                style.paddings.top = style.paddings.bottom = propsGrid.rowPadding;
                style.borders.top = new TablixUtils.EdgeSettings();
                if (cell.position.row.isFirst) {
                    style.borders.top.applyParams(visuals.outline.showTop(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                } // else: do nothing
                style.borders.bottom = new TablixUtils.EdgeSettings();
                if (cell.position.row.isLast) {
                    style.borders.bottom.applyParams(visuals.outline.showBottom(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                }
                else {
                    style.borders.bottom.applyParams(propsGrid.gridHorizontal, propsGrid.gridHorizontalWeight, propsGrid.gridHorizontalColor);
                }
                style.borders.left = new TablixUtils.EdgeSettings();
                if (cell.position.column.isFirst) {
                    style.borders.left.applyParams(visuals.outline.showLeft(propsCol.outline), propsGrid.outlineWeight, propsGrid.outlineColor);
                    // If we dont have left border, but Row Headers have, we need to apply extra padding
                    if (!visuals.outline.showLeft(propsCol.outline) && visuals.outline.showLeft(propsRow.outline))
                        style.paddings.left += propsGrid.outlineWeight;
                } // else: do nothing
                style.borders.right = new TablixUtils.EdgeSettings();
                style.borders.right.applyParams(propsGrid.gridVertical, propsGrid.gridVerticalWeight, propsGrid.gridVerticalColor);
            };
            MatrixBinder.prototype.unbindCornerCell = function (item, cell) {
                TablixUtils.clearCellStyle(cell);
                TablixUtils.clearCellTextAndTooltip(cell);
                if (this.options.showSortIcons)
                    TablixUtils.removeSortIcons(cell);
                if (item.isColumnHeaderLeaf) {
                    this.unregisterColumnHeaderClickHandler(cell);
                }
            };
            MatrixBinder.prototype.bindEmptySpaceHeaderCell = function (cell) {
            };
            MatrixBinder.prototype.unbindEmptySpaceHeaderCell = function (cell) {
            };
            MatrixBinder.prototype.bindEmptySpaceFooterCell = function (cell) {
            };
            MatrixBinder.prototype.unbindEmptySpaceFooterCell = function (cell) {
            };
            /**
             * Measurement Helper.
             */
            MatrixBinder.prototype.getHeaderLabel = function (item) {
                return MatrixBinder.getNodeLabel(item);
            };
            MatrixBinder.prototype.getCellContent = function (item) {
                return item.textContent || '';
            };
            MatrixBinder.prototype.hasRowGroups = function () {
                // Figure out whether we have a static row header, i.e., not row groups
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0)
                    return false;
                return true;
            };
            MatrixBinder.getNodeLabel = function (node) {
                // Return formatted value
                if (node.name)
                    return node.name;
                // Return unformatted value (fallback case)
                if (node.value != null)
                    return node.value.toString();
                return '';
            };
            /**
             * Returns the column metadata of the column that needs to be sorted for the specified matrix corner node.
             *
             * @return Column metadata or null if the specified corner node does not represent a sortable header.
             */
            MatrixBinder.prototype.getSortableCornerColumnMetadata = function (item) {
                if (item.isColumnHeaderLeaf)
                    return item.metadata;
            };
            MatrixBinder.prototype.getRowHeaderMetadata = function (item) {
                if (!this.hierarchyNavigator || !item)
                    return;
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.rows)
                    return;
                return this.getHierarchyMetadata(dataView.rows, item.level);
            };
            MatrixBinder.prototype.getColumnHeaderMetadata = function (item) {
                if (!this.hierarchyNavigator || !item)
                    return;
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                if (!dataView || !dataView.columns)
                    return;
                return this.getHierarchyMetadata(dataView.columns, item.level);
            };
            MatrixBinder.prototype.getHierarchyMetadata = function (hierarchy, level) {
                if (!hierarchy || !hierarchy.levels || hierarchy.levels.length < level)
                    return;
                var levelInfo = hierarchy.levels[level];
                if (!levelInfo || !levelInfo.sources || levelInfo.sources.length === 0)
                    return;
                // This assumes the source will always be the first item in the array of sources.
                return levelInfo.sources[0];
            };
            /**
             * Returns the column metadata of the column that needs to be sorted for the specified header node.
             *
             * @return Column metadata or null if the specified header node does not represent a sortable header.
             */
            MatrixBinder.prototype.getSortableHeaderColumnMetadata = function (item) {
                var dataView = this.hierarchyNavigator.getDataViewMatrix();
                // If there are no row groups, sorting is not supported (as it does not make sense).
                if (!dataView.rows || !dataView.rows.levels || dataView.rows.levels.length === 0)
                    return null;
                var isMultiMeasure = dataView.valueSources && dataView.valueSources.length > 1;
                var columnGroupCount = dataView.columns ? dataView.columns.levels.length : 0;
                // If we have multiple values, they establish an extra level, so need to subtract 1
                if (isMultiMeasure) {
                    columnGroupCount--;
                }
                else if (columnGroupCount === 1 &&
                    dataView.columns.levels[0] &&
                    dataView.columns.levels[0].sources && dataView.columns.levels[0].sources[0] &&
                    dataView.columns.levels[0].sources[0].roles && dataView.columns.levels[0].sources[0].roles["Values"]) {
                    columnGroupCount = 0;
                }
                var valueIndex = -1;
                if (columnGroupCount === 0) {
                    // Matrices without column groups, support sorting on all columns (which are then measure columns).
                    valueIndex = item.levelSourceIndex;
                }
                else if (item.isSubtotal) {
                    // Matrices with column groups support sorting only on the column grand total.
                    if (isMultiMeasure) {
                        // In the multi-measure case we need to check if the parent's level is 0 in order
                        // to determine whether this is the column grand total.  The cells are layed out such
                        // that the clickable cells are at the innermost level, but the parent for the column
                        // grand total will have level 0.
                        if (item.parent && item.parent.level === 0)
                            valueIndex = item.levelSourceIndex;
                    }
                    else {
                        // In the single-measure case we can directly check the level of the subtotal to
                        // detect the column grand total (at level 0).
                        if (item.level === 0)
                            valueIndex = item.levelSourceIndex;
                    }
                }
                if (valueIndex !== -1) {
                    // NOTE: if the valueIndex is undefined it implicitly means that it is 0 based on the 
                    //       visual node contract
                    valueIndex = valueIndex ? valueIndex : 0;
                    return dataView.valueSources[valueIndex];
                }
                return null;
            };
            return MatrixBinder;
        }());
        visuals.MatrixBinder = MatrixBinder;
        var Matrix = (function () {
            function Matrix(options) {
                if (options) {
                    this.isTouchEnabled = options.isTouchEnabled;
                }
            }
            Matrix.customizeQuery = function (options) {
                var dataViewMapping = options.dataViewMappings[0];
                if (!dataViewMapping || !dataViewMapping.matrix || !dataViewMapping.metadata)
                    return;
                var dataViewMatrix = dataViewMapping.matrix;
                // If Columns Hierarchy is not empty, set Window DataReduction Count to 100
                if (!_.isEmpty(dataViewMatrix.columns.for.in.items)) {
                    dataViewMatrix.rows.dataReductionAlgorithm.window.count = 100;
                }
                var objects = dataViewMapping.metadata.objects;
                dataViewMatrix.rows.for.in.subtotalType = TablixObjects.shouldShowRowSubtotals(objects) ? 2 /* After */ : 0 /* None */;
                dataViewMatrix.columns.for.in.subtotalType = TablixObjects.shouldShowColumnSubtotals(objects) ? 2 /* After */ : 0 /* None */;
            };
            Matrix.getSortableRoles = function () {
                return ['Rows', 'Values'];
            };
            Matrix.prototype.init = function (options) {
                this.element = options.element;
                this.style = options.style;
                this.updateViewport(options.viewport);
                this.formatter = visuals.valueFormatter.formatValueColumn;
                this.isInteractive = options.interactivity && options.interactivity.selection != null;
                this.hostServices = options.host;
                this.persistingObjects = false;
                this.waitingForData = false;
                this.lastAllowHeaderResize = true;
                this.waitingForSort = false;
            };
            Matrix.converter = function (dataView) {
                debug.assertValue(dataView, 'dataView');
                return TablixObjects.getMatrixObjects(dataView);
            };
            Matrix.prototype.onResizing = function (finalViewport) {
                this.updateViewport(finalViewport);
            };
            /*
            Public for testing
            */
            Matrix.prototype.getColumnWidthManager = function () {
                return this.columnWidthManager;
            };
            Matrix.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0) {
                    var previousDataView = this.dataView;
                    this.dataView = dataViews[0];
                    // We don't check for persisting flag
                    // Any change to the Column Widths need to go through to update all column group instances
                    // ToDo: Consider not resetting scrollbar everytime
                    var formattingProperties = Matrix.converter(this.dataView);
                    var textSize = formattingProperties.general.textSize;
                    if (options.operationKind === powerbi.VisualDataChangeOperationKind.Append) {
                        var rootChanged = previousDataView.matrix.rows.root !== this.dataView.matrix.rows.root;
                        this.hierarchyNavigator.update(this.dataView.matrix, rootChanged);
                        // If Root for Rows or Columns has changed by the DataViewTransform (e.g. when having reorders in values)
                        if (rootChanged)
                            this.tablixControl.updateModels(/*resetScrollOffsets*/ false, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children);
                        this.refreshControl(/*clear*/ false);
                    }
                    else {
                        this.createOrUpdateHierarchyNavigator();
                        this.createColumnWidthManager();
                        this.createTablixControl(textSize);
                        var binder = this.tablixControl.getBinder();
                        binder.onDataViewChanged(formattingProperties);
                        this.updateInternal(textSize, previousDataView);
                    }
                }
                this.waitingForData = false;
                this.waitingForSort = false;
            };
            Matrix.prototype.createColumnWidthManager = function () {
                var _this = this;
                var columnHierarchy = this.hierarchyNavigator.getMatrixColumnHierarchy();
                if (!this.columnWidthManager) {
                    this.columnWidthManager = new visuals.controls.TablixColumnWidthManager(this.dataView, true /* isMatrix */, function (objectInstances) { return _this.persistColumnWidths(objectInstances); }, columnHierarchy.leafNodes);
                }
                else if (!this.persistingObjects) {
                    this.columnWidthManager.updateDataView(this.dataView, columnHierarchy.leafNodes);
                }
            };
            Matrix.prototype.persistColumnWidths = function (objectInstances) {
                this.persistingObjects = true;
                this.hostServices.persistProperties(objectInstances);
            };
            Matrix.prototype.updateViewport = function (newViewport) {
                this.currentViewport = newViewport;
                if (this.tablixControl) {
                    this.tablixControl.viewport = this.currentViewport;
                    this.verifyHeaderResize();
                    this.refreshControl(/*clear*/ false);
                }
            };
            Matrix.prototype.refreshControl = function (clear) {
                if (visuals.visibilityHelper.partiallyVisible(this.element) || this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.refresh(clear);
                }
            };
            Matrix.prototype.getLayoutKind = function () {
                return this.isInteractive ? 0 /* Canvas */ : 1 /* DashboardTile */;
            };
            Matrix.prototype.createOrUpdateHierarchyNavigator = function () {
                if (!this.tablixControl) {
                    var matrixNavigator = createMatrixHierarchyNavigator(this.dataView.matrix, this.formatter);
                    this.hierarchyNavigator = matrixNavigator;
                }
                else {
                    this.hierarchyNavigator.update(this.dataView.matrix);
                }
            };
            Matrix.prototype.createTablixControl = function (textSize) {
                if (!this.tablixControl) {
                    // Create the control
                    this.tablixControl = this.createControl(this.hierarchyNavigator, textSize);
                }
            };
            Matrix.prototype.createControl = function (matrixNavigator, textSize) {
                var _this = this;
                var layoutKind = this.getLayoutKind();
                var matrixBinderOptions = {
                    onBindRowHeader: function (item) { _this.onBindRowHeader(item); },
                    totalLabel: this.hostServices.getLocalizedString(Matrix.TotalLabel),
                    onColumnHeaderClick: function (queryName, sortDirection) { return _this.onColumnHeaderClick(queryName, sortDirection); },
                    showSortIcons: layoutKind === 0 /* Canvas */,
                };
                var matrixBinder = new MatrixBinder(this.hierarchyNavigator, matrixBinderOptions);
                var layoutManager = layoutKind === 1 /* DashboardTile */
                    ? visuals.controls.internal.DashboardTablixLayoutManager.createLayoutManager(matrixBinder)
                    : visuals.controls.internal.CanvasTablixLayoutManager.createLayoutManager(matrixBinder, this.columnWidthManager);
                var tablixContainer = document.createElement('div');
                this.element.append(tablixContainer);
                var tablixOptions = {
                    interactive: this.isInteractive,
                    enableTouchSupport: this.isTouchEnabled,
                    layoutKind: layoutKind,
                    fontSize: TablixObjects.getTextSizeInPx(textSize),
                };
                return new visuals.controls.TablixControl(matrixNavigator, layoutManager, matrixBinder, tablixContainer, tablixOptions);
            };
            Matrix.prototype.updateInternal = function (textSize, previousDataView) {
                var _this = this;
                if (this.getLayoutKind() === 1 /* DashboardTile */) {
                    this.tablixControl.layoutManager.adjustContentSize(visuals.converterHelper.hasImageUrlColumn(this.dataView));
                }
                this.tablixControl.fontSize = TablixObjects.getTextSizeInPx(textSize);
                this.verifyHeaderResize();
                /* To avoid resetting scrollbar every time we persist Objects. If:
                * AutoSizeColumns options was flipped
                * A Column was resized manually
                * A Column was auto-sized
                */
                // Update models before the viewport to make sure column widths are computed correctly
                // if a persisting operation is going, don't reset the scrollbar (column resize)
                this.tablixControl.updateModels(/*resetScrollOffsets*/ !this.persistingObjects, this.dataView.matrix.rows.root.children, this.dataView.matrix.columns.root.children);
                this.tablixControl.viewport = this.currentViewport;
                var shouldClearControl = this.shouldClearControl(previousDataView, this.dataView);
                // We need the layout for the DIV to be done so that the control can measure items correctly.
                setTimeout(function () {
                    // Render
                    _this.refreshControl(shouldClearControl);
                    // At this point, all columns are rendered with proper width, reset the flag if it was raised
                    if (_this.persistingObjects) {
                        _this.persistingObjects = false;
                        return;
                    }
                    // if AutoSize option was set to OFF, persist all columns width
                    if (_this.columnWidthManager.shouldPersistAllColumnWidths()) {
                        _this.columnWidthManager.persistAllColumnWidths(_this.tablixControl.layoutManager.columnWidthsToPersist);
                    }
                }, 0);
            };
            Matrix.prototype.shouldClearControl = function (previousDataView, newDataView) {
                if (!this.waitingForSort || !previousDataView || !newDataView)
                    return true;
                // ToDo: Get better criteria
                return !powerbi.DataViewAnalysis.isMetadataEquivalent(previousDataView.metadata, newDataView.metadata);
            };
            Matrix.prototype.onBindRowHeader = function (item) {
                if (this.needsMoreData(item)) {
                    this.hostServices.loadMoreData();
                    this.waitingForData = true;
                }
            };
            Matrix.prototype.onColumnHeaderClick = function (queryName, sortDirection) {
                this.waitingForSort = true;
                this.hostServices.onCustomSort(TablixUtils.getCustomSortEventArgs(queryName, sortDirection));
            };
            /**
             * Note: Public for testability.
             */
            Matrix.prototype.needsMoreData = function (item) {
                if (this.waitingForData || !this.hierarchyNavigator.isLeaf(item) || !this.dataView.metadata || !this.dataView.metadata.segment)
                    return false;
                var leafCount = this.tablixControl.rowDimension.getItemsCount();
                var loadMoreThreshold = leafCount * Matrix.preferredLoadMoreThreshold;
                return this.hierarchyNavigator.getLeafIndex(item) >= loadMoreThreshold;
            };
            Matrix.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                // Visuals are initialized with an empty data view before queries are run, therefore we need to make sure that
                // we are resilient here when we do not have data view.
                if (this.dataView) {
                    TablixObjects.enumerateObjectInstances(options, enumeration, this.dataView, false, visuals.controls.TablixType.Matrix);
                }
                return enumeration.complete();
            };
            Matrix.prototype.shouldAllowHeaderResize = function () {
                return this.hostServices.getViewMode() === 1 /* Edit */;
            };
            Matrix.prototype.onViewModeChanged = function (viewMode) {
                /* Refreshes the column headers to enable/disable Column resizing */
                this.updateViewport(this.currentViewport);
            };
            Matrix.prototype.verifyHeaderResize = function () {
                var currentAllowHeaderResize = this.shouldAllowHeaderResize();
                if (currentAllowHeaderResize !== this.lastAllowHeaderResize) {
                    this.lastAllowHeaderResize = currentAllowHeaderResize;
                    this.tablixControl.layoutManager.setAllowHeaderResize(currentAllowHeaderResize);
                }
            };
            Matrix.preferredLoadMoreThreshold = 0.8;
            /**
             * Note: Public only for testing.
             */
            Matrix.TotalLabel = 'TableTotalLabel';
            return Matrix;
        }());
        visuals.Matrix = Matrix;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CssConstants = jsCommon.CssConstants;
        /**
         * Renders an interactive treemap visual from categorical data.
         */
        var Treemap = (function () {
            function Treemap(options) {
                this.tooltipsEnabled = options && options.tooltipsEnabled;
                if (options && options.animator) {
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
                    this.behavior = options.behavior;
                }
            }
            Treemap.getLayout = function (labelsSettings, alternativeScale) {
                var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
                var majorLabelsEnabled = labelsSettings.showCategory;
                var minorLabelsEnabled = labelsSettings.show || labelsSettings.showCategory;
                return {
                    shapeClass: function (d) { return Treemap.getNodeClass(d, false); },
                    shapeLayout: Treemap.createTreemapShapeLayout(false),
                    highlightShapeClass: function (d) { return Treemap.getNodeClass(d, true); },
                    highlightShapeLayout: Treemap.createTreemapShapeLayout(true),
                    zeroShapeLayout: Treemap.createTreemapZeroShapeLayout(),
                    majorLabelClass: function (d) { return Treemap.MajorLabelClassName; },
                    majorLabelLayout: {
                        x: function (d) { return d.x + Treemap.TextMargin; },
                        y: function (d) { return d.y + Treemap.TextMargin + Treemap.MajorLabelTextSize; },
                    },
                    majorLabelText: function (d) { return Treemap.createMajorLabelText(d, labelsSettings, alternativeScale, formattersCache); },
                    minorLabelClass: function (d) { return Treemap.MinorLabelClassName; },
                    minorLabelLayout: {
                        x: function (d) { return d.x + Treemap.TextMargin; },
                        y: function (d) { return d.y + d.dy - Treemap.TextMargin; },
                    },
                    minorLabelText: function (d) { return Treemap.createMinorLabelText(d, labelsSettings, alternativeScale, formattersCache); },
                    areMajorLabelsEnabled: function () { return majorLabelsEnabled; },
                    areMinorLabelsEnabled: function () { return minorLabelsEnabled; },
                };
            };
            Treemap.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                // Ensure viewport is empty on init
                element.empty();
                this.svg = d3.select(element.get(0))
                    .append('svg')
                    .style('position', 'absolute')
                    .classed(Treemap.ClassName, true);
                this.shapeGraphicsContext = this.svg
                    .append('g')
                    .classed(Treemap.ShapesClassName, true);
                this.labelGraphicsContext = this.svg
                    .append('g')
                    .classed(Treemap.LabelsGroupClassName, true);
                this.element = element;
                // avoid deep copy
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width,
                };
                this.style = options.style;
                this.treemap = d3.layout.treemap()
                    .sticky(false)
                    .sort(function (a, b) { return a.size - b.size; })
                    .value(function (d) { return d.size; })
                    .round(false);
                if (this.behavior) {
                    this.interactivityService = visuals.createInteractivityService(options.host);
                }
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
                this.colors = this.style.colorPalette.dataColors;
                this.hostService = options.host;
            };
            /**
             * Note: Public for testing purposes.
             */
            Treemap.converter = function (dataView, colors, labelSettings, interactivityService, viewport, legendObjectProperties, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var rootNode = {
                    key: "root",
                    name: "root",
                    children: [],
                    selected: false,
                    highlightMultiplier: 0,
                    identity: visuals.SelectionId.createNull(),
                    color: undefined,
                };
                var allNodes = [];
                var hasHighlights;
                var legendDataPoints = [];
                var legendTitle = "";
                var colorHelper = new visuals.ColorHelper(colors, visuals.treemapProps.dataPoint.fill);
                var dataWasCulled = undefined;
                if (dataView && dataView.metadata && dataView.metadata.objects) {
                    var objects = dataView.metadata.objects;
                    labelSettings.show = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.show, labelSettings.show);
                    labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.treemapProps.labels.color, labelSettings.labelColor);
                    labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelDisplayUnits, labelSettings.displayUnits);
                    labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.labels.labelPrecision, labelSettings.precision);
                    labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.treemapProps.categoryLabels.show, labelSettings.showCategory);
                }
                if (dataView && dataView.categorical && dataView.categorical.values) {
                    var data_9 = dataView.categorical;
                    var valueColumns = data_9.values;
                    hasHighlights = !!(valueColumns.length > 0 && valueColumns[0].highlights);
                    var formatStringProp = visuals.treemapProps.general.formatString;
                    var result = Treemap.getValuesFromCategoricalDataView(data_9, hasHighlights);
                    var values = result.values;
                    var highlights = result.highlights;
                    var totalValue = result.totalValue;
                    if (result.highlightsOverflow) {
                        hasHighlights = false;
                        values = highlights;
                    }
                    var cullableValue = Treemap.getCullableValue(totalValue, viewport);
                    var grouped = valueColumns.grouped();
                    var isMultiSeries = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1;
                    var hasDynamicSeries = !!valueColumns.source;
                    dataWasCulled = false;
                    var shouldCullValue = undefined;
                    var highlight = undefined;
                    var gradientValueColumn = visuals.GradientUtils.getGradientValueColumn(data_9);
                    if ((data_9.categories == null) && !_.isEmpty(values)) {
                        // No categories, sliced by series and measures
                        for (var i = 0, ilen = values[0].length; i < ilen; i++) {
                            var valueColumn = valueColumns[i];
                            if (!powerbi.data.DataRoleHelper.hasRoleInValueColumn(valueColumn, Treemap.ValuesRoleName)) {
                                continue;
                            }
                            var value = values[0][i];
                            if (!Treemap.checkValueForShape(value)) {
                                continue;
                            }
                            if (value < cullableValue) {
                                dataWasCulled = dataWasCulled || shouldCullValue;
                                continue;
                            }
                            var nodeName = visuals.converterHelper.getFormattedLegendLabel(valueColumn.source, valueColumns, formatStringProp);
                            var identity = new visuals.SelectionIdBuilder()
                                .withSeries(valueColumns, hasDynamicSeries ? valueColumns[i] : undefined)
                                .withMeasure(valueColumns[i].source.queryName)
                                .createSelectionId();
                            var key = identity.getKey();
                            var color = hasDynamicSeries
                                ? colorHelper.getColorForSeriesValue(grouped[i] && grouped[i].objects, data_9.values.identityFields, visuals.converterHelper.getSeriesName(valueColumn.source))
                                : colorHelper.getColorForMeasure(valueColumn.source.objects, valueColumn.source.queryName);
                            var highlightedValue = hasHighlights && highlight !== 0 ? highlight : undefined;
                            var categorical = dataView.categorical;
                            var valueIndex = i;
                            var tooltipInfo = void 0;
                            var highlightedTooltipInfo = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, nodeName, value, null, null, valueIndex, i);
                                if (highlightedValue !== undefined) {
                                    highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, nodeName, value, null, null, valueIndex, i, highlightedValue);
                                }
                            }
                            var node = {
                                key: key,
                                name: nodeName,
                                size: value,
                                color: color,
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo,
                                labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp),
                            };
                            if (hasHighlights && highlights) {
                                node.highlightMultiplier = value !== 0 ? highlights[0][i] / value : 0;
                                node.highlightValue = highlights[0][i];
                            }
                            rootNode.children.push(node);
                            allNodes.push(node);
                            legendDataPoints.push({
                                label: nodeName,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                identity: identity,
                                selected: false
                            });
                        }
                    }
                    else if (data_9.categories && data_9.categories.length > 0) {
                        // Count the columns that have the value roles
                        var valueColumnCount = _.filter(valueColumns, function (x) { return x.source && x.source.roles && x.source.roles[Treemap.ValuesRoleName] === true; }).length;
                        // Do not add second level if it's one and only one data point per shape and it's not a group value
                        // e.g. Category/Series group plus only one Value field (excluding the gradient)
                        var omitSecondLevel = valueColumnCount === 1 && (valueColumns[0].source.groupName == null);
                        // Create the first level from categories
                        var categoryColumn = data_9.categories[0];
                        legendTitle = categoryColumn.source ? categoryColumn.source.displayName : "";
                        var categorical = undefined;
                        var categoryFormat = visuals.valueFormatter.getFormatString(categoryColumn.source, formatStringProp);
                        for (var categoryIndex = 0, categoryLen = values.length; categoryIndex < categoryLen; categoryIndex++) {
                            var objects = categoryColumn.objects && categoryColumn.objects[categoryIndex];
                            var color = colorHelper.getColorForSeriesValue(objects, categoryColumn.identityFields, categoryColumn.values[categoryIndex]);
                            var categoryValue = visuals.valueFormatter.format(categoryColumn.values[categoryIndex], categoryFormat);
                            var currentValues = values[categoryIndex];
                            categorical = dataView.categorical;
                            // This section area builds the tooltip for the parent node. It's only displayed if the node doesn't have any children (essentially if omitSecondLevel is true).
                            // seriesIndex is the index of the 1st series with the role Values.
                            var seriesIndex = powerbi.data.DataRoleHelper.getMeasureIndexOfRole(grouped, Treemap.ValuesRoleName);
                            var value = currentValues[seriesIndex];
                            var highlightValue = hasHighlights && highlights ? highlights[categoryIndex][seriesIndex] : undefined;
                            var tooltipInfo = void 0;
                            var highlightedTooltipInfo = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, seriesIndex, categoryIndex, null, omitSecondLevel ? gradientValueColumn : undefined);
                                if (highlightValue !== undefined) {
                                    highlightedTooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value, null, null, seriesIndex, categoryIndex, highlightValue, omitSecondLevel ? gradientValueColumn : undefined);
                                }
                            }
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(categoryColumn, categoryIndex)
                                .withMeasure(omitSecondLevel ? valueColumns[seriesIndex].source.queryName : undefined)
                                .createSelectionId();
                            var key = JSON.stringify({ nodeKey: identity.getKey(), depth: 1 });
                            var node = {
                                key: key,
                                name: categoryValue,
                                color: color,
                                selected: false,
                                identity: identity,
                                tooltipInfo: tooltipInfo,
                                highlightedTooltipInfo: highlightedTooltipInfo,
                                labelFormatString: valueColumnCount === 1 ? visuals.valueFormatter.getFormatString(data_9.values[0].source, formatStringProp) : categoryFormat,
                            };
                            if (hasHighlights) {
                                node.highlightMultiplier = value !== 0 ? highlightValue / value : 0;
                                node.highlightValue = highlightValue;
                            }
                            legendDataPoints.push({
                                label: categoryValue,
                                color: color,
                                icon: visuals.LegendIcon.Box,
                                identity: identity,
                                selected: false
                            });
                            var total = 0;
                            var highlightTotal = 0; // Used if omitting second level
                            for (var j = 0, jlen = currentValues.length; j < jlen; j++) {
                                var valueColumn = valueColumns[j];
                                if (!powerbi.data.DataRoleHelper.hasRoleInValueColumn(valueColumn, Treemap.ValuesRoleName)) {
                                    continue;
                                }
                                var value_1 = currentValues[j];
                                var highlight_1 = void 0;
                                shouldCullValue = value_1 < cullableValue;
                                if (!Treemap.checkValueForShape(value_1) || shouldCullValue) {
                                    dataWasCulled = dataWasCulled || shouldCullValue;
                                    continue;
                                }
                                total += value_1;
                                if (hasHighlights) {
                                    highlight_1 = highlights[categoryIndex][j];
                                    highlightTotal += highlight_1;
                                }
                                if (!omitSecondLevel) {
                                    var childName = null;
                                    if (isMultiSeries) {
                                        // Measure: use name and index
                                        childName = valueColumn.source.displayName;
                                    }
                                    else {
                                        // Series group instance
                                        childName = valueColumn.source.groupName;
                                    }
                                    var categoricalValues = categorical ? categorical.values : null;
                                    var measureId = valueColumn.source.queryName;
                                    var childIdentity = visuals.SelectionIdBuilder.builder()
                                        .withCategory(categoryColumn, categoryIndex)
                                        .withSeries(categoricalValues, valueColumn)
                                        .withMeasure(measureId)
                                        .createSelectionId();
                                    var childKey = JSON.stringify({ nodeKey: childIdentity.getKey(), depth: 2 });
                                    var highlightedValue = hasHighlights && highlight_1 !== 0 ? highlight_1 : undefined;
                                    categorical = dataView.categorical;
                                    var tooltipInfo_4 = void 0;
                                    var highlightedTooltipInfo_1 = void 0;
                                    if (tooltipsEnabled) {
                                        tooltipInfo_4 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value_1, null, null, j, categoryIndex, null, gradientValueColumn);
                                        if (highlightedValue !== undefined) {
                                            highlightedTooltipInfo_1 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, value_1, null, null, j, categoryIndex, highlightedValue, gradientValueColumn);
                                        }
                                    }
                                    var childNode = {
                                        key: childKey,
                                        name: childName,
                                        size: value_1,
                                        color: color,
                                        selected: false,
                                        identity: childIdentity,
                                        tooltipInfo: tooltipInfo_4,
                                        highlightedTooltipInfo: highlightedTooltipInfo_1,
                                        labelFormatString: visuals.valueFormatter.getFormatString(valueColumn.source, formatStringProp),
                                    };
                                    if (hasHighlights) {
                                        childNode.highlightMultiplier = value_1 !== 0 ? highlight_1 / value_1 : 0;
                                        childNode.highlightValue = highlight_1;
                                    }
                                    if (node.children == null)
                                        node.children = [];
                                    node.children.push(childNode);
                                    allNodes.push(childNode);
                                }
                            }
                            if (Treemap.checkValueForShape(total)) {
                                node.size = total;
                                rootNode.children.push(node);
                                allNodes.push(node);
                            }
                            if (hasHighlights)
                                node.highlightMultiplier = total ? highlightTotal / total : 0;
                        }
                    }
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(allNodes);
                    interactivityService.applySelectionStateToData(legendDataPoints);
                }
                return {
                    root: rootNode,
                    hasHighlights: hasHighlights,
                    legendData: { title: legendTitle, dataPoints: legendDataPoints, fontSize: visuals.SVGLegend.DefaultFontSizeInPt },
                    dataLabelsSettings: labelSettings,
                    legendObjectProperties: legendObjectProperties,
                    dataWasCulled: dataWasCulled,
                };
            };
            Treemap.getValuesFromCategoricalDataView = function (data, hasHighlights) {
                var valueColumns = data.values;
                var categoryValueCount;
                if (valueColumns && (data.categories == null)) {
                    categoryValueCount = 1; // We only get the first value out of each valueColumn since we don't have a category
                }
                else if (valueColumns && data.categories && data.categories.length > 0) {
                    categoryValueCount = data.categories[0].values.length;
                }
                var values = [];
                var highlights = [];
                var totalValue = 0;
                for (var i = 0; i < categoryValueCount; i++) {
                    values.push([]);
                    if (hasHighlights)
                        highlights.push([]);
                }
                var highlightsOverflow;
                for (var j = 0; j < valueColumns.length; j++) {
                    var valueColumn = valueColumns[j];
                    for (var i = 0; i < categoryValueCount; i++) {
                        var value = valueColumn.values[i];
                        values[i].push(value);
                        totalValue += isNaN(value) ? 0 : value;
                        if (hasHighlights) {
                            var highlight = valueColumn.highlights[i];
                            if (!highlight)
                                highlight = 0;
                            highlights[i].push(highlight);
                            if (highlight > value)
                                highlightsOverflow = true;
                        }
                    }
                }
                return {
                    values: values,
                    highlights: hasHighlights ? highlights : undefined,
                    highlightsOverflow: hasHighlights ? highlightsOverflow : undefined,
                    totalValue: totalValue,
                };
            };
            Treemap.getCullableValue = function (totalValue, viewport) {
                var totalArea = viewport.width * viewport.height;
                var culledPercent = Treemap.CullableArea / totalArea;
                return culledPercent * totalValue;
            };
            Treemap.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = this.dataViews = options.dataViews;
                this.currentViewport = options.viewport;
                var dataViewCategorical = dataViews && dataViews.length > 0 && dataViews[0].categorical ? dataViews[0].categorical : undefined;
                var labelSettings = visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
                var legendObjectProperties = null;
                if (dataViewCategorical) {
                    var dataView = dataViews[0];
                    var dataViewMetadata = dataView.metadata;
                    var objects = void 0;
                    if (dataViewMetadata)
                        objects = dataViewMetadata.objects;
                    if (objects) {
                        legendObjectProperties = objects['legend'];
                    }
                    this.data = Treemap.converter(dataView, this.colors, labelSettings, this.interactivityService, this.currentViewport, legendObjectProperties, this.tooltipsEnabled);
                }
                else {
                    var rootNode = {
                        key: "root",
                        name: "root",
                        children: [],
                        selected: false,
                        highlightMultiplier: 0,
                        identity: visuals.SelectionId.createNull(),
                        color: undefined,
                    };
                    var legendData = { title: "", dataPoints: [] };
                    var treeMapData = {
                        root: rootNode,
                        hasHighlights: false,
                        legendData: legendData,
                        dataLabelsSettings: labelSettings,
                        dataWasCulled: false,
                    };
                    this.data = treeMapData;
                }
                this.updateInternal(options.suppressAnimations);
                if (dataViews) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                    this.hostService.setWarnings(warnings);
                }
            };
            // TODO: Remove this once all visuals have implemented update.
            Treemap.prototype.onDataChanged = function (options) {
                this.update({
                    suppressAnimations: options.suppressAnimations,
                    dataViews: options.dataViews,
                    viewport: this.currentViewport
                });
            };
            // TODO: Remove this once all visuals have implemented update.
            Treemap.prototype.onResizing = function (viewport) {
                this.update({
                    suppressAnimations: true,
                    dataViews: this.dataViews,
                    viewport: viewport
                });
            };
            Treemap.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            Treemap.prototype.enumerateObjectInstances = function (options) {
                var data = this.data;
                if (!data)
                    return;
                var objectName = options.objectName, enumeration = new visuals.ObjectEnumerationBuilder();
                var dataLabelsSettings = this.data.dataLabelsSettings
                    ? this.data.dataLabelsSettings
                    : visuals.dataLabelUtils.getDefaultTreemapLabelSettings();
                switch (objectName) {
                    case 'dataPoint':
                        var dataViewCat = this.dataViews && this.dataViews.length > 0 && this.dataViews[0] && this.dataViews[0].categorical;
                        var hasGradientRole = visuals.GradientUtils.hasGradientRole(dataViewCat);
                        if (!hasGradientRole)
                            this.enumerateDataPoints(enumeration, data);
                        break;
                    case 'legend':
                        return this.enumerateLegend(data);
                    case 'labels':
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: dataLabelsSettings,
                            show: true,
                            displayUnits: true,
                            precision: true,
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;
                    case 'categoryLabels':
                        visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, dataLabelsSettings, false /* withFill */, true /* isShowCategory */);
                        break;
                }
                return enumeration.complete();
            };
            Treemap.prototype.enumerateDataPoints = function (enumeration, data) {
                var rootChildren = data.root.children;
                if (_.isEmpty(rootChildren))
                    return;
                for (var y = 0; y < rootChildren.length; y++) {
                    var treemapNode = rootChildren[y];
                    enumeration.pushInstance({
                        displayName: treemapNode.name,
                        selector: treemapNode.identity.getSelector(),
                        properties: {
                            fill: { solid: { color: treemapNode.color } }
                        },
                        objectName: 'dataPoint'
                    });
                }
            };
            Treemap.prototype.enumerateLegend = function (data) {
                var legendObjectProperties = { legend: data.legendObjectProperties };
                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.show, this.legend.isVisible());
                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.showTitle, true);
                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.treemapProps.legend.titleText, this.data.legendData.title);
                var labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData ? this.data.legendData.labelColor : visuals.LegendData.DefaultLegendLabelFillColor);
                var labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData && this.data.legendData.fontSize ? this.data.legendData.fontSize : visuals.SVGLegend.DefaultFontSizeInPt);
                return [{
                        selector: null,
                        objectName: 'legend',
                        properties: {
                            show: show,
                            position: visuals.LegendPosition[this.legend.getOrientation()],
                            showTitle: showTitle,
                            titleText: titleText,
                            labelColor: labelColor,
                            fontSize: labelFontSize,
                        }
                    }];
            };
            Treemap.checkValueForShape = function (value) {
                if (!value)
                    return false;
                return value > 0;
            };
            Treemap.prototype.calculateTreemapSize = function () {
                var legendMargins = this.legend.getMargins();
                return {
                    height: this.currentViewport.height - legendMargins.height,
                    width: this.currentViewport.width - legendMargins.width
                };
            };
            Treemap.prototype.initViewportDependantProperties = function (duration) {
                if (duration === void 0) { duration = 0; }
                var viewport = this.calculateTreemapSize();
                this.svg.attr({
                    width: viewport.width,
                    height: viewport.height
                });
                visuals.Legend.positionChartArea(this.svg, this.legend);
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            Treemap.hasChildrenWithIdentity = function (node) {
                var children = node.children;
                if (!children)
                    return false;
                var count = children.length;
                if (count === 0)
                    return false;
                for (var i = count - 1; i >= 0; i--) {
                    if (children[i].identity.hasIdentity())
                        return true;
                }
                return false;
            };
            Treemap.canDisplayMajorLabel = function (node) {
                // Only display major labels for level 1
                if (node.depth !== 1)
                    return false;
                if (_.isEmpty(node.name))
                    return false;
                // Check if the room is enough for text with or without ellipse
                var availableWidth = node.dx - Treemap.TextMargin * 2;
                if (availableWidth < Treemap.MinTextWidthForMajorLabel)
                    return false;
                // Check if the shape is high enough for label
                var textHeightWithMargin = Treemap.MajorLabelTextSize + Treemap.TextMargin * 2;
                if (node.dy < textHeightWithMargin)
                    return false;
                return true;
            };
            Treemap.canDisplayMinorLabel = function (node, labelSettings) {
                // Only display minor labels for level 1 and 2
                if (node.depth < 1 || node.depth > 2)
                    return false;
                // If a depth 1 node has children or is not showing data labels, do not show minor labels
                if (node.depth === 1 && (node.children || !labelSettings.show)) {
                    return false;
                }
                if (_.isEmpty(node.name))
                    return false;
                // Check if the room is enough for text with or without ellipse
                var availableWidth = node.dx - Treemap.TextMargin * 2;
                if (availableWidth < Treemap.MinTextWidthForMinorLabel)
                    return false;
                // Check if the shape is high enough for label
                var textHeightWithMargin = Treemap.MinorLabelTextSize + Treemap.TextMargin * 2;
                if (node.dy < textHeightWithMargin)
                    return false;
                if (node.depth === 1) {
                    var roomTop = node.y + Treemap.MajorLabelTextSize + Treemap.TextMargin * 2;
                    if (node.y + node.dy - roomTop < textHeightWithMargin)
                        return false;
                }
                else if (node.depth === 2) {
                    var parent_1 = node.parent;
                    var roomTop = Math.max(parent_1.y + Treemap.MajorLabelTextSize + Treemap.TextMargin * 2, node.y);
                    // Parent's label needs the room
                    if (node.y + node.dy - roomTop < textHeightWithMargin)
                        return false;
                }
                return true;
            };
            Treemap.createMajorLabelText = function (node, labelsSettings, alternativeScale, formattersCache) {
                var spaceAvaliableForLabels = node.dx - Treemap.TextMargin * 2;
                var baseTextProperties = Treemap.MajorLabelTextProperties;
                var textProperties = {
                    text: node.name,
                    fontFamily: baseTextProperties.fontFamily,
                    fontSize: baseTextProperties.fontSize
                };
                return powerbi.TextMeasurementService.getTailoredTextOrDefault(textProperties, spaceAvaliableForLabels);
            };
            Treemap.createMinorLabelText = function (node, labelsSettings, alternativeScale, formattersCache) {
                var spaceAvaliableForLabels = node.dx - Treemap.TextMargin * 2;
                var label = node.name;
                if (labelsSettings.show) {
                    var measureFormatter = formattersCache.getOrCreate(node.labelFormatString, labelsSettings, alternativeScale);
                    // Create measure label
                    label = visuals.dataLabelUtils.getLabelFormattedText({
                        label: node.highlightValue != null ? node.highlightValue : node.value, maxWidth: spaceAvaliableForLabels, formatter: measureFormatter
                    });
                    // Add category if needed (we're showing category and the node depth is 2)
                    if (labelsSettings.showCategory && node.depth === 2)
                        label = visuals.dataLabelUtils.getLabelFormattedText({
                            label: node.name,
                            maxWidth: spaceAvaliableForLabels
                        }) + " " + label;
                }
                return visuals.dataLabelUtils.getLabelFormattedText({
                    label: label,
                    maxWidth: spaceAvaliableForLabels,
                    fontSize: labelsSettings.fontSize
                });
            };
            Treemap.getFill = function (d, isHighlightRect) {
                // NOTE: only painted shapes will catch click event. We either paint children or their parent but not both.
                // If it's a leaf with no category, parent will be painted instead (and support interactivity)
                if (d.depth > 1 && !d.identity.hasIdentity() && !isHighlightRect)
                    return CssConstants.noneValue;
                // If it's not a leaf and it has children with a category, children will be painted
                if (Treemap.hasChildrenWithIdentity(d))
                    return CssConstants.noneValue;
                return d.color;
            };
            Treemap.getFillOpacity = function (d, hasSelection, hasHighlights, isHighlightRect) {
                if (hasHighlights) {
                    if (isHighlightRect)
                        return null;
                    return Treemap.DimmedShapeOpacity.toString();
                }
                if (!hasSelection || d.selected)
                    return null;
                // Parent node is selected (as an optimization, we only check below level 1 because root node cannot be selected anyway)
                if (d.depth > 1 && d.parent.selected)
                    return null;
                // It's a parent node with interactive children, fall back to default opacity
                if (Treemap.hasChildrenWithIdentity(d))
                    return null;
                return Treemap.DimmedShapeOpacity.toString();
            };
            Treemap.prototype.updateInternal = function (suppressAnimations) {
                var data = this.data;
                var hasHighlights = data && data.hasHighlights;
                var labelSettings = data ? data.dataLabelsSettings : null;
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend) && this.data) {
                    this.renderLegend();
                }
                this.initViewportDependantProperties(duration);
                var viewport = this.calculateTreemapSize();
                this.treemap.size([viewport.width, viewport.height]);
                // Shapes are drawn for all nodes
                var nodes = (data && data.root) ? this.treemap.nodes(data.root) : [];
                // Highlight shapes are drawn only for nodes with non-null/undefed highlightMultipliers that have no children
                var highlightNodes = nodes.filter(function (value) { return value.highlightMultiplier != null && (!value.children || value.children.length === 0); });
                var majorLabeledNodes = [];
                var minorLabeledNodes = [];
                var alternativeScale = null;
                // Only populate major labels if category labels are turned on
                if (labelSettings.showCategory) {
                    majorLabeledNodes = nodes.filter(function (d) { return Treemap.canDisplayMajorLabel(d); });
                }
                // Only populate minor labels if category or data labels are turned on
                if (labelSettings.show || labelSettings.showCategory) {
                    minorLabeledNodes = nodes.filter(function (d) { return Treemap.canDisplayMinorLabel(d, labelSettings); });
                    // If the display unit is 0 we calculate the format scale using the maximum value available
                    if (labelSettings.displayUnits === 0)
                        alternativeScale = d3.max(minorLabeledNodes, function (d) { return Math.abs(d.value); });
                }
                var treemapLayout = Treemap.getLayout(labelSettings, alternativeScale);
                var shapes;
                var highlightShapes;
                var majorLabels;
                var minorLabels;
                var result;
                if (this.animator && !suppressAnimations) {
                    var options = {
                        viewModel: data,
                        nodes: nodes,
                        highlightNodes: highlightNodes,
                        majorLabeledNodes: majorLabeledNodes,
                        minorLabeledNodes: minorLabeledNodes,
                        shapeGraphicsContext: this.shapeGraphicsContext,
                        labelGraphicsContext: this.labelGraphicsContext,
                        interactivityService: this.interactivityService,
                        layout: treemapLayout,
                        labelSettings: labelSettings,
                    };
                    result = this.animator.animate(options);
                    shapes = result.shapes;
                    highlightShapes = result.highlightShapes;
                    majorLabels = result.majorLabels;
                    minorLabels = result.minorLabels;
                }
                if (!this.animator || suppressAnimations || result.failed) {
                    var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                    var shapeGraphicsContext = this.shapeGraphicsContext;
                    shapes = Treemap.drawDefaultShapes(shapeGraphicsContext, nodes, hasSelection, hasHighlights, treemapLayout);
                    highlightShapes = Treemap.drawDefaultHighlightShapes(shapeGraphicsContext, highlightNodes, hasSelection, hasHighlights, treemapLayout);
                    var labelGraphicsContext = this.labelGraphicsContext;
                    majorLabels = Treemap.drawDefaultMajorLabels(labelGraphicsContext, majorLabeledNodes, labelSettings, treemapLayout);
                    minorLabels = Treemap.drawDefaultMinorLabels(labelGraphicsContext, minorLabeledNodes, labelSettings, treemapLayout);
                }
                if (this.interactivityService) {
                    var behaviorOptions = {
                        shapes: shapes,
                        highlightShapes: highlightShapes,
                        majorLabels: majorLabels,
                        minorLabels: minorLabels,
                        nodes: nodes,
                        hasHighlights: data.hasHighlights,
                    };
                    this.interactivityService.bind(nodes, this.behavior, behaviorOptions);
                }
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(shapes, function (tooltipEvent) { return tooltipEvent.data.highlightedTooltipInfo ? tooltipEvent.data.highlightedTooltipInfo : tooltipEvent.data.tooltipInfo; });
                    visuals.TooltipManager.addTooltip(highlightShapes, function (tooltipEvent) { return tooltipEvent.data.highlightedTooltipInfo; });
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            Treemap.prototype.renderLegend = function () {
                var legendObjectProperties = this.data.legendObjectProperties;
                if (legendObjectProperties) {
                    var legendData = this.data.legendData;
                    visuals.LegendData.update(legendData, legendObjectProperties);
                    var position = legendObjectProperties[visuals.legendProps.position];
                    if (position)
                        this.legend.changeOrientation(visuals.LegendPosition[position]);
                    this.legend.drawLegend(legendData, this.currentViewport);
                }
                else {
                    // TODO: Draw should be the only API. Visuals should only call that with orientation, props, etc 
                    // instead of managing state. Will follow up with another change.
                    this.legend.changeOrientation(visuals.LegendPosition.Top);
                    this.legend.drawLegend({ dataPoints: [] }, this.currentViewport);
                }
            };
            Treemap.getNodeClass = function (d, highlight) {
                var nodeClass;
                switch (d.depth) {
                    case 1:
                        nodeClass = Treemap.ParentGroupClassName;
                        break;
                    case 2:
                        nodeClass = Treemap.NodeGroupClassName;
                        break;
                    case 0:
                        nodeClass = Treemap.RootNodeClassName;
                        break;
                    default:
                        debug.assertFail('Treemap only supports 2 levels maxiumum');
                }
                nodeClass += " " + (highlight ? Treemap.HighlightNodeClassName : Treemap.TreemapNodeClassName);
                return nodeClass;
            };
            Treemap.createTreemapShapeLayout = function (isHighlightRect) {
                if (isHighlightRect === void 0) { isHighlightRect = false; }
                return {
                    x: function (d) { return d.x; },
                    y: function (d) { return d.y + (isHighlightRect ? d.dy * (1 - d.highlightMultiplier) : 0); },
                    width: function (d) { return Math.max(0, d.dx); },
                    height: function (d) { return Math.max(0, d.dy * (isHighlightRect ? d.highlightMultiplier : 1)); },
                };
            };
            Treemap.createTreemapZeroShapeLayout = function () {
                return {
                    x: function (d) { return d.x; },
                    y: function (d) { return d.y + d.dy; },
                    width: function (d) { return Math.max(0, d.dx); },
                    height: function (d) { return 0; },
                };
            };
            Treemap.drawDefaultShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = false;
                var shapes = context.selectAll('.' + Treemap.TreemapNodeClassName)
                    .data(nodes, function (d) { return d.key; });
                shapes.enter().append('rect')
                    .attr('class', layout.shapeClass);
                shapes
                    .style("fill", function (d) { return Treemap.getFill(d, isHighlightShape); })
                    .style("fill-opacity", function (d) { return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
                    .attr(layout.shapeLayout);
                shapes.exit().remove();
                return shapes;
            };
            Treemap.drawDefaultHighlightShapes = function (context, nodes, hasSelection, hasHighlights, layout) {
                var isHighlightShape = true;
                var highlightShapes = context.selectAll('.' + Treemap.HighlightNodeClassName)
                    .data(nodes, function (d) { return d.key + "highlight"; });
                highlightShapes.enter().append('rect')
                    .attr('class', layout.highlightShapeClass);
                highlightShapes
                    .style("fill", function (d) { return Treemap.getFill(d, isHighlightShape); })
                    .style("fill-opacity", function (d) { return Treemap.getFillOpacity(d, hasSelection, hasHighlights, isHighlightShape); })
                    .attr(layout.highlightShapeLayout);
                highlightShapes.exit().remove();
                return highlightShapes;
            };
            Treemap.drawDefaultMajorLabels = function (context, nodes, labelSettings, layout) {
                var labels = context
                    .selectAll('.' + Treemap.MajorLabelClassName)
                    .data(nodes, function (d) { return d.key; });
                labels.enter().append('text')
                    .attr('class', layout.majorLabelClass);
                labels
                    .attr(layout.majorLabelLayout)
                    .text(layout.majorLabelText)
                    .style('fill', function () { return labelSettings.labelColor; });
                labels.exit().remove();
                return labels;
            };
            Treemap.drawDefaultMinorLabels = function (context, nodes, labelSettings, layout) {
                var labels = context
                    .selectAll('.' + Treemap.MinorLabelClassName)
                    .data(nodes, function (d) { return d.key; });
                labels.enter().append('text')
                    .attr('class', layout.minorLabelClass);
                labels
                    .attr(layout.minorLabelLayout)
                    .text(layout.minorLabelText)
                    .style('fill', function () { return labelSettings.labelColor; });
                labels.exit().remove();
                return labels;
            };
            Treemap.cleanMinorLabels = function (context) {
                var empty = [];
                var labels = context
                    .selectAll('.' + Treemap.LabelsGroupClassName)
                    .selectAll('.' + Treemap.MinorLabelClassName)
                    .data(empty);
                labels.exit().remove();
            };
            Treemap.DimmedShapeOpacity = 0.4;
            Treemap.ClassName = 'treemap';
            Treemap.LabelsGroupClassName = "labels";
            Treemap.MajorLabelClassName = 'majorLabel';
            Treemap.MinorLabelClassName = 'minorLabel';
            Treemap.ShapesClassName = "shapes";
            Treemap.TreemapNodeClassName = "treemapNode";
            Treemap.RootNodeClassName = 'rootNode';
            Treemap.ParentGroupClassName = 'parentGroup';
            Treemap.NodeGroupClassName = 'nodeGroup';
            Treemap.HighlightNodeClassName = 'treemapNodeHighlight';
            Treemap.TextMargin = 5;
            Treemap.MinorLabelTextSize = 10;
            Treemap.MinTextWidthForMinorLabel = 18;
            Treemap.MajorLabelTextSize = 12;
            Treemap.MinTextWidthForMajorLabel = 22;
            Treemap.MajorLabelTextProperties = {
                fontFamily: 'wf_segoe-ui_normal',
                fontSize: Treemap.MajorLabelTextSize + 'px'
            };
            Treemap.ValuesRoleName = 'Values';
            /**
             * A rect with an area of 9 is a treemap rectangle of only
             * a single pixel in the middle with a 1 pixel stroke on each edge.
             */
            Treemap.CullableArea = 9;
            return Treemap;
        }());
        visuals.Treemap = Treemap;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var getKpiImageMetadata = powerbi.visuals.KpiUtil.getKpiImageMetadata;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var Card = (function (_super) {
            __extends(Card, _super);
            function Card(options) {
                _super.call(this, Card.cardClassName);
                this.isScrollable = false;
                this.displayUnitSystemType = powerbi.DisplayUnitSystemType.WholeUnits;
                if (options) {
                    this.isScrollable = !!options.isScrollable;
                    if (options.animator)
                        this.animator = options.animator;
                    if (options.displayUnitSystemType != null)
                        this.displayUnitSystemType = options.displayUnitSystemType;
                }
            }
            Card.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.animationOptions = options.animation;
                var element = options.element;
                this.kpiImage = d3.select(element.get(0)).append('div')
                    .classed(Card.KPIImage.class, true);
                var svg = this.svg = d3.select(element.get(0)).append('svg');
                this.graphicsContext = svg.append('g');
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.style = options.style;
                this.updateViewportProperties();
                if (this.isScrollable) {
                    svg.attr('class', Card.cardClassName);
                    this.labelContext = svg.append('g');
                }
            };
            Card.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                var dataView = options.dataViews[0];
                var value;
                if (dataView) {
                    this.getMetaDataColumn(dataView);
                    if (dataView.single) {
                        value = dataView.single.value;
                    }
                    // Update settings based on new metadata column
                    this.cardFormatSetting = this.getDefaultFormatSettings();
                    var dataViewMetadata = dataView.metadata;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            var labelSettings = this.cardFormatSetting.labelSettings;
                            labelSettings.labelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.labels.color, labelSettings.labelColor);
                            labelSettings.precision = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelPrecision, labelSettings.precision);
                            labelSettings.fontSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.fontSize, labelSettings.fontSize);
                            // The precision can't go below 0
                            if (labelSettings.precision !== visuals.dataLabelUtils.defaultLabelPrecision && labelSettings.precision < 0) {
                                labelSettings.precision = 0;
                            }
                            labelSettings.displayUnits = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.labels.labelDisplayUnits, labelSettings.displayUnits);
                            //category labels
                            labelSettings.showCategory = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.show, labelSettings.showCategory);
                            labelSettings.categoryLabelColor = powerbi.DataViewObjects.getFillColor(objects, visuals.cardProps.categoryLabels.color, labelSettings.categoryLabelColor);
                            this.cardFormatSetting.wordWrap = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.wordWrap.show, this.cardFormatSetting.wordWrap);
                            this.cardFormatSetting.textSize = powerbi.DataViewObjects.getValue(objects, visuals.cardProps.categoryLabels.fontSize, this.cardFormatSetting.textSize);
                        }
                    }
                }
                this.updateInternal(value, true /* suppressAnimations */, true /* forceUpdate */);
            };
            Card.prototype.onResizing = function (viewport) {
                this.currentViewport = viewport;
                this.updateViewportProperties();
                this.updateInternal(this.value, true /* suppressAnimations */, true /* forceUpdate */);
            };
            Card.prototype.updateViewportProperties = function () {
                var viewport = this.currentViewport;
                this.svg.attr('width', viewport.width)
                    .attr('height', viewport.height);
            };
            Card.prototype.setTextProperties = function (text, fontSize) {
                Card.cardTextProperties.fontSize = jsCommon.PixelConverter.fromPoint(fontSize);
                Card.cardTextProperties.text = text;
            };
            Card.prototype.getCardFormatTextSize = function () {
                return this.cardFormatSetting.textSize;
            };
            Card.prototype.getAdjustedFontHeight = function (availableWidth, textToMeasure, seedFontHeight) {
                var adjustedFontHeight = _super.prototype.getAdjustedFontHeight.call(this, availableWidth, textToMeasure, seedFontHeight);
                return Math.min(adjustedFontHeight, Card.DefaultStyle.card.maxFontSize);
            };
            Card.prototype.clear = function (valueOnly) {
                if (valueOnly === void 0) { valueOnly = false; }
                this.svg.select(Card.Value.selector).text('');
                if (!valueOnly)
                    this.svg.select(Card.Label.selector).text('');
                _super.prototype.clear.call(this);
            };
            Card.prototype.updateInternal = function (target, suppressAnimations, forceUpdate) {
                if (forceUpdate === void 0) { forceUpdate = false; }
                var start = this.value;
                var duration = visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (target === undefined) {
                    if (start !== undefined)
                        this.clear();
                    return;
                }
                var metaDataColumn = this.metaDataColumn;
                var labelSettings = this.cardFormatSetting.labelSettings;
                var isDefaultDisplayUnit = labelSettings.displayUnits === 0;
                var format = this.getFormatString(metaDataColumn);
                var formatter = visuals.valueFormatter.create({
                    format: format,
                    value: isDefaultDisplayUnit ? target : labelSettings.displayUnits,
                    precision: visuals.dataLabelUtils.getLabelPrecision(labelSettings.precision, format),
                    displayUnitSystemType: isDefaultDisplayUnit && labelSettings.precision === visuals.dataLabelUtils.defaultLabelPrecision ? this.displayUnitSystemType : powerbi.DisplayUnitSystemType.WholeUnits,
                    formatSingleValues: isDefaultDisplayUnit ? true : false,
                    allowFormatBeautification: true,
                    columnType: metaDataColumn ? metaDataColumn.type : undefined
                });
                var formatSettings = this.cardFormatSetting;
                var valueTextHeightInPx = jsCommon.PixelConverter.fromPointToPixel(labelSettings.fontSize);
                var valueStyles = Card.DefaultStyle.value;
                this.setTextProperties(target, this.getCardFormatTextSize());
                var labelTextHeightInPx = powerbi.TextMeasurementService.estimateSvgTextHeight(Card.cardTextProperties);
                var labelHeightWithPadding = labelTextHeightInPx + Card.DefaultStyle.label.paddingTop;
                var width = this.currentViewport.width;
                var height = this.currentViewport.height;
                var translateX = this.getTranslateX(width);
                var translateY = (height - labelHeightWithPadding - valueTextHeightInPx) / 2;
                var statusGraphicInfo = getKpiImageMetadata(metaDataColumn, target, 1 /* Big */);
                if (this.isScrollable) {
                    if (!forceUpdate && start === target)
                        return;
                    // We want to format for null/blank/empty string and anything that is not a string
                    if (start !== target && (_.isEmpty(target) || typeof (target) !== "string"))
                        target = formatter.format(target);
                    var label = metaDataColumn ? metaDataColumn.displayName : undefined;
                    var labelData = labelSettings.showCategory
                        ? [label]
                        : [];
                    var translatedLabelY = this.getTranslateY(valueTextHeightInPx + labelHeightWithPadding + translateY);
                    var labelElement = this.labelContext
                        .attr('transform', visuals.SVGUtil.translate(translateX, translatedLabelY))
                        .selectAll('text')
                        .data(labelData);
                    labelElement
                        .enter()
                        .append('text')
                        .attr('class', Card.Label.class);
                    labelElement
                        .text(function (d) { return d; })
                        .style({
                        'font-size': jsCommon.PixelConverter.fromPoint(this.getCardFormatTextSize()),
                        'fill': labelSettings.categoryLabelColor,
                        'text-anchor': this.getTextAnchor()
                    });
                    var labelElementNode = labelElement.node();
                    if (labelElementNode) {
                        if (formatSettings.wordWrap)
                            powerbi.TextMeasurementService.wordBreak(labelElementNode, width / 2, height - translatedLabelY);
                        else
                            labelElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                    }
                    labelElement
                        .append('title')
                        .text(function (d) { return d; });
                    labelElement.exit().remove();
                    if (statusGraphicInfo) {
                        // Display card KPI icon
                        this.graphicsContext.selectAll('text').remove();
                        this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx);
                    }
                    else {
                        // Display card text value
                        this.kpiImage.selectAll('div').remove();
                        var valueElement = this.graphicsContext
                            .attr('transform', visuals.SVGUtil.translate(translateX, this.getTranslateY(valueTextHeightInPx + translateY)))
                            .selectAll('text')
                            .data([target]);
                        valueElement
                            .enter()
                            .append('text')
                            .attr('class', Card.Value.class);
                        valueElement
                            .text(function (d) { return d; })
                            .style({
                            'font-size': jsCommon.PixelConverter.fromPoint(labelSettings.fontSize),
                            'fill': labelSettings.labelColor,
                            'font-family': valueStyles.fontFamily,
                            'text-anchor': this.getTextAnchor(),
                        });
                        valueElement.call(visuals.AxisHelper.LabelLayoutStrategy.clip, width, powerbi.TextMeasurementService.svgEllipsis);
                        valueElement
                            .append('title')
                            .text(function (d) { return d; });
                        valueElement.exit().remove();
                    }
                }
                else {
                    if (statusGraphicInfo) {
                        // Display card KPI icon
                        this.graphicsContext.selectAll('text').remove();
                        this.displayStatusGraphic(statusGraphicInfo, translateX, translateY, valueTextHeightInPx);
                    }
                    else {
                        this.kpiImage.selectAll('div').remove();
                        this.doValueTransition(start, target, this.displayUnitSystemType, this.animationOptions, duration, forceUpdate, formatter);
                        //in order to remove duplicated title values we first remove all and than add a new one
                        this.graphicsContext.call(visuals.tooltipUtils.tooltipUpdate, [target]);
                    }
                }
                this.value = target;
            };
            Card.prototype.displayStatusGraphic = function (statusGraphicInfo, translateX, translateY, labelTextSizeInPx) {
                // Remove existing text
                this.graphicsContext.selectAll('text').remove();
                // Create status graphic, if necessary
                var kpiImageDiv = this.kpiImage.select('div');
                if (!kpiImageDiv || kpiImageDiv.empty())
                    kpiImageDiv = this.kpiImage.append('div');
                // Style status graphic
                kpiImageDiv
                    .attr('class', statusGraphicInfo.class)
                    .style('position', 'absolute')
                    .style('font-size', labelTextSizeInPx + 'px');
                // Layout thrash to get image dimensions (could set as a const in future when icon font is fixed)
                var imageWidth = kpiImageDiv.node().offsetWidth;
                var imageHeight = kpiImageDiv.node().offsetHeight;
                // Position based on image height
                kpiImageDiv.style('transform', visuals.SVGUtil.translateWithPixels((translateX - (imageWidth / 2)), this.getTranslateY(labelTextSizeInPx + translateY) - imageHeight));
            };
            Card.prototype.getDefaultFormatSettings = function () {
                return {
                    labelSettings: visuals.dataLabelUtils.getDefaultCardLabelSettings(Card.DefaultStyle.value.color, Card.DefaultStyle.label.color, Card.DefaultStyle.value.textSize),
                    wordWrap: false,
                    textSize: Card.DefaultStyle.label.textSize,
                };
            };
            Card.prototype.enumerateObjectInstances = function (options) {
                if (!this.cardFormatSetting)
                    this.cardFormatSetting = this.getDefaultFormatSettings();
                var formatSettings = this.cardFormatSetting;
                var enumeration = new visuals.ObjectEnumerationBuilder();
                switch (options.objectName) {
                    case 'categoryLabels':
                        visuals.dataLabelUtils.enumerateCategoryLabels(enumeration, formatSettings.labelSettings, true /* withFill */, true /* isShowCategory */, formatSettings.textSize);
                        break;
                    case 'labels':
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: formatSettings.labelSettings,
                            show: true,
                            displayUnits: true,
                            precision: true,
                            fontSize: true,
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;
                    case 'wordWrap':
                        enumeration.pushInstance({
                            objectName: 'wordWrap',
                            selector: null,
                            properties: {
                                show: formatSettings.wordWrap,
                            },
                        });
                        break;
                }
                return enumeration.complete();
            };
            Card.cardClassName = 'card';
            Card.Label = createClassAndSelector('label');
            Card.Value = createClassAndSelector('value');
            Card.KPIImage = createClassAndSelector('caption');
            Card.cardTextProperties = {
                fontSize: null,
                text: null,
                fontFamily: visuals.dataLabelUtils.LabelTextProperties.fontFamily,
            };
            Card.DefaultStyle = {
                card: {
                    maxFontSize: 200
                },
                label: {
                    textSize: 12,
                    color: '#a6a6a6',
                    paddingTop: 8
                },
                value: {
                    textSize: 27,
                    color: '#333333',
                    fontFamily: 'wf_standard-font'
                }
            };
            return Card;
        }(visuals.AnimatedText));
        visuals.Card = Card;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var OwlHappiness;
        (function (OwlHappiness) {
            OwlHappiness[OwlHappiness["Sad"] = 0] = "Sad";
            OwlHappiness[OwlHappiness["Meh"] = 1] = "Meh";
            OwlHappiness[OwlHappiness["Happy"] = 2] = "Happy";
        })(OwlHappiness || (OwlHappiness = {}));
        var OwlGauge = (function () {
            function OwlGauge() {
            }
            OwlGauge.converter = function (dataView) {
                return {};
            };
            OwlGauge.getGaugeData = function (dataView) {
                var settings = {
                    max: 100,
                    min: 0,
                    target: undefined,
                    total: 0,
                    tooltipItems: []
                };
                if (dataView && dataView.categorical && dataView.categorical.values && dataView.metadata && dataView.metadata.columns) {
                    var values = dataView.categorical.values;
                    var metadataColumns = dataView.metadata.columns;
                    debug.assert(metadataColumns.length >= values.length, 'length');
                    for (var i = 0; i < values.length; i++) {
                        var col = metadataColumns[i], value = values[i].values[0] || 0;
                        if (col && col.roles) {
                            if (col.roles[visuals.gaugeRoleNames.y]) {
                                settings.total = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                            else if (col.roles[visuals.gaugeRoleNames.minValue]) {
                                settings.min = value;
                            }
                            else if (col.roles[visuals.gaugeRoleNames.maxValue]) {
                                settings.max = value;
                            }
                            else if (col.roles[visuals.gaugeRoleNames.targetValue]) {
                                settings.target = value;
                                if (value)
                                    settings.tooltipItems.push({ value: value, metadata: values[i] });
                            }
                        }
                    }
                }
                return settings;
            };
            OwlGauge.prototype.init = function (options) {
                var _this = this;
                this.rootElem = options.element;
                this.rootElem.addClass('owlGaugeVisual');
                this.svgTailElem = $(OwlGauge.owlTailSvg);
                this.svgBgElem = $(OwlGauge.visualBgSvg);
                this.svgBodyElem = $(OwlGauge.owlBodySvg);
                this.rootElem.append(this.svgBgElem).append(this.svgTailElem).append(this.svgBodyElem);
                if (OwlGauge.OwlDemoMode) {
                    window.setInterval(function () {
                        var randomPercentage = Math.random() * 100 + 1;
                        _this.updateGauge(randomPercentage);
                    }, 2000);
                }
                this.updateViewportSize(options.viewport.width, options.viewport.height);
            };
            OwlGauge.prototype.update = function (options) {
                this.updateViewportSize(options.viewport.width, options.viewport.height);
                var dataView = options.dataViews.length > 0 ? options.dataViews[0] : null;
                if (dataView) {
                    var gaugeData = OwlGauge.getGaugeData(options.dataViews[0]);
                    var percentage = (gaugeData.total - gaugeData.min) / (gaugeData.max - gaugeData.min);
                    this.updateGauge(percentage * 100 | 0);
                }
                else
                    this.updateGauge(0);
            };
            OwlGauge.prototype.updateGauge = function (percentage) {
                if (percentage >= 0 && percentage <= 100) {
                    var rotationDeg = -180 + (180 * percentage / 100);
                    this.svgBgElem.css({ transform: 'rotate(' + rotationDeg + 'deg)' });
                    if (percentage >= 66) {
                        this.happinessLevel = OwlHappiness.Happy;
                    }
                    else if (percentage >= 33) {
                        this.happinessLevel = OwlHappiness.Meh;
                    }
                    else {
                        this.happinessLevel = OwlHappiness.Sad;
                    }
                }
            };
            Object.defineProperty(OwlGauge.prototype, "happinessLevel", {
                set: function (level) {
                    this.rootElem.removeClass('sad').removeClass('meh').removeClass('happy');
                    switch (level) {
                        case OwlHappiness.Sad:
                            this.rootElem.addClass('sad');
                            break;
                        case OwlHappiness.Meh:
                            this.rootElem.addClass('meh');
                            break;
                        case OwlHappiness.Happy:
                            this.rootElem.addClass('happy');
                            break;
                        default:
                            console.log('Well, this is interesting...');
                    }
                },
                enumerable: true,
                configurable: true
            });
            OwlGauge.prototype.updateViewportSize = function (width, height) {
                var _this = this;
                var smoothingFn = window.setImmediate || window.requestAnimationFrame;
                smoothingFn(function () {
                    _this.rootElem.css({
                        height: height,
                        width: width
                    });
                    _this.svgBodyElem.height(_this.svgBodyElem.width() * OwlGauge.owlBodyHeightMultiplier);
                    _this.svgBgElem.height(_this.svgBgElem.width() * OwlGauge.visualBgHeightMultiplier);
                    _this.svgTailElem.height(_this.svgTailElem.width() * OwlGauge.owlTailHeightMultiplier);
                });
            };
            OwlGauge.owlBodySvg = '<svg version="1.1" class="owlGaugeBody" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 267.7 291.2" style="enable-background:new 0 0 267.7 291.2;" xml:space="preserve"> <style type="text/css"> .owlGaugeBody .st0{fill:#A87D50;} .owlGaugeBody .st1{fill:#C2B59B;} .owlGaugeBody .st2{fill:#EB2227;} .owlGaugeBody .st3{fill:#FFFFFF;} .owlGaugeBody .st4{fill:#F9D018;} .owlGaugeBody .st5{fill:none;} .owlGaugeBody .st6{fill:#83381B;} .owlGaugeBody .st7{fill:#231F20;} </style> <g id="XMLID_31_"> <g id="XMLID_34_"> <ellipse id="XMLID_21_" transform="matrix(0.9998 1.947640e-02 -1.947640e-02 0.9998 2.8614 -2.5802)" class="st0" cx="133.9" cy="145.6" rx="133.9" ry="145.6"/> <polygon id="XMLID_20_" class="st0" points="199.2,32.8 184,11.3 209,9.7 "/> <polygon id="XMLID_19_" class="st0" points="73.9,31.2 62.1,7.7 87.1,9.8 "/> <circle id="XMLID_18_" class="st1" cx="134.8" cy="189.2" r="89.8"/> <path id="XMLID_17_" class="st2" d="M140.1,88c-2.7,3.8-7.9,4.7-11.7,2c-2.7-1.9-3.9-5.1-3.4-8.1c0,0,9.6-41.8,9.6-41.8l6.9,40.8 C142,83.2,141.6,85.8,140.1,88z"/> <path id="XMLID_16_" class="st3" d="M164.6,16.2c-14.2,0-26.3,9.2-30.6,21.9c-4.1-13.1-16.3-22.6-30.8-22.6 C85.4,15.6,71,30,71,47.8s14.4,32.3,32.3,32.3c14.2,0,26.3-9.2,30.6-21.9c4.1,13.1,16.3,22.6,30.8,22.6 c17.8,0,32.3-14.4,32.3-32.3S182.4,16.2,164.6,16.2z"/> <path id="XMLID_15_" class="st4" d="M122,58.7l23.3-0.1c0,0-9,14.8-10.2,16.6c-1.2,1.9-2.2,0.1-2.2,0.1L122,58.7z"/> <rect id="XMLID_14_" x="-11.4" y="-68.8" class="st5" width="288.3" height="259.7"/> <g id="XMLID_37_"> <path id="XMLID_13_" class="st6" d="M121.6,125.5c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_12_" class="st6" d="M160.1,126.5c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_11_" class="st6" d="M142.4,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_10_" class="st6" d="M183.1,148.8c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_9_" class="st6" d="M160.9,177.4c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_8_" class="st6" d="M201.6,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_7_" class="st6" d="M76.4,177.4c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> <path id="XMLID_6_" class="st6" d="M117,178c0,3.7-3.5,6.6-7.7,6.6s-7.7-3-7.7-6.6"/> <path id="XMLID_5_" class="st6" d="M98.6,148.1c0,3.7-3.5,6.6-7.7,6.6c-4.2,0-7.7-3-7.7-6.6"/> </g> <circle id="XMLID_4_" class="st7" cx="164.1" cy="49" r="6.4"/> <circle id="XMLID_3_" class="st7" cx="102.7" cy="47.7" r="6.4"/> </g> <path id="XMLID_2_" class="st0" d="M160.1,140.9c11.1-8.4,55.6-36,55.6-36l4.7,0.8l10.2,38.8c0,0-3,3-9.2,3.1 c-5.1,0.1-45.9-2.6-60.2-3.5C158.1,143.9,157.7,142.7,160.1,140.9z"/> <path id="XMLID_1_" class="st0" d="M110.6,140.8c-11.1-8.4-55.6-36-55.6-36l-4.7,0.8L40,144.4c0,0,3,3,9.2,3.1 c5.1,0.1,45.9-2.6,60.2-3.5C112.5,143.8,113,142.6,110.6,140.8z"/> </g> </svg>';
            OwlGauge.owlTailSvg = '<svg version="1.1" class="owlGaugeTail" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 587.8 295.5" style="enable-background:new 0 0 587.8 295.5;" xml:space="preserve"> <style type="text/css"> .owlGaugeTail .st0{fill:#3B2416;} .owlGaugeTail .st1{fill:#5B4B43;} .owlGaugeTail .st2{fill:#603A17;} .owlGaugeTail .st3{fill:#726659;} </style> <g id="XMLID_55_"> <path id="XMLID_29_" class="st0" d="M85.2,106.2c-27.1,0-49.2,22-49.2,49.2c0,19.1,10.9,35.7,26.9,43.8c0,0,231.2,95.9,231.2,95.9 l-171-171C114.1,113.2,100.5,106.2,85.2,106.2z"/> <g id="XMLID_56_"> <path id="XMLID_28_" class="st1" d="M482.5,86.4c0-27.1-22-49.2-49.2-49.2c-19.1,0-35.7,10.9-43.8,26.9c0,0-95.9,231.2-95.9,231.2 l171-171C475.5,115.3,482.5,101.7,482.5,86.4z"/> <path id="XMLID_27_" class="st2" d="M573.5,281.3c19.2-19.2,19.2-50.3,0-69.5c-13.5-13.5-33-17.5-50-12c0,0-231.3,95.7-231.3,95.7 l241.8,0C548,296.9,562.6,292.1,573.5,281.3z"/> <path id="XMLID_26_" class="st3" d="M279.9,14.4c-19.2-19.2-50.3-19.2-69.5,0c-13.5,13.5-17.5,33-12,50c0,0,95.7,231.3,95.7,231.3 L294,54C295.4,39.8,290.7,25.2,279.9,14.4z"/> <path id="XMLID_25_" class="st2" d="M105.3,86.4c0-27.1,22-49.2,49.2-49.2c19.1,0,35.7,10.9,43.8,26.9c0,0,95.9,231.2,95.9,231.2 l-171-171C112.3,115.3,105.3,101.7,105.3,86.4z"/> <path id="XMLID_24_" class="st2" d="M14.4,281.4c-19.2-19.2-19.2-50.3,0-69.5c13.5-13.5,33-17.5,50-12c0,0,231.3,95.7,231.3,95.7 l-241.8,0C39.8,297,25.2,292.3,14.4,281.4z"/> <path id="XMLID_23_" class="st2" d="M308.2,14c19.2-19.2,50.3-19.2,69.5,0c13.5,13.5,17.5,33,12,50c0,0-95.7,231.3-95.7,231.3 l0-241.8C292.6,39.4,297.4,24.8,308.2,14z"/> <path id="XMLID_22_" class="st0" d="M503.2,106c27.1,0,49.2,22,49.2,49.2c0,19.1-10.9,35.7-26.9,43.8c0,0-231.2,95.9-231.2,95.9 l171-171C474.2,113,487.8,106,503.2,106z"/> </g> </g> </svg>';
            OwlGauge.visualBgSvg = '<svg version="1.1" class="owlGaugeBg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="123.8 94.9 349.1 175.3" style="enable-background:new 123.8 94.9 349.1 175.3;" xml:space="preserve"> <style type="text/css"> .owlGaugeBg .st0{fill:#EF4137;} .owlGaugeBg .st1{fill:#FAAF42;} .owlGaugeBg .st2{fill:#F15B2A;} .owlGaugeBg .st3{fill:#F69321;} </style> <g id="XMLID_10_"> <path id="XMLID_8_" class="st0" d="M174.3,158c-16.1,0-29.2,13.1-29.2,29.2c0,11.4,6.5,21.2,16,26.1l137.3,57L196.9,168.7 C191.5,162.2,183.4,158,174.3,158z"/> <g id="XMLID_11_"> <path id="XMLID_7_" class="st1" d="M410.2,146.3c0-16.1-13.1-29.2-29.2-29.2c-11.4,0-21.2,6.5-26,16l-57,137.5L399.5,169 C406.1,163.5,410.2,155.4,410.2,146.3z"/> <path id="XMLID_6_" class="st0" d="M464.3,262.2c11.4-11.4,11.4-29.9,0-41.3c-8-8-19.6-10.4-29.7-7.1l-137.4,56.9h143.6 C449.2,271.4,457.9,268.6,464.3,262.2z"/> <path id="XMLID_5_" class="st2" d="M290,103.5c-11.4-11.4-29.9-11.4-41.3,0c-8,8-10.4,19.6-7.1,29.7l56.8,137.5V127 C299.2,118.6,296.4,109.9,290,103.5z"/> <path id="XMLID_4_" class="st3" d="M186.3,146.3c0-16.1,13.1-29.2,29.2-29.2c11.4,0,21.2,6.5,26,16l57,137.5L197,168.8 C190.5,163.5,186.3,155.4,186.3,146.3z"/> <path id="XMLID_3_" class="st2" d="M132.3,262.2c-11.4-11.4-11.4-29.9,0-41.3c8-8,19.6-10.4,29.7-7.1l137.4,56.9H155.8 C147.4,271.5,138.7,268.7,132.3,262.2z"/> <path id="XMLID_2_" class="st3" d="M306.8,103.2c11.4-11.4,29.9-11.4,41.3,0c8,8,10.4,19.6,7.1,29.7l-56.8,137.5V126.7 C297.5,118.3,300.3,109.7,306.8,103.2z"/> <path id="XMLID_1_" class="st2" d="M422.5,157.9c16.1,0,29.2,13.1,29.2,29.2c0,11.4-6.5,21.2-16,26.1l-137.3,57L400,168.6 C405.3,162.1,413.4,157.9,422.5,157.9z"/> </g> </g> </svg>';
            OwlGauge.owlBodyHeightMultiplier = 291.2 / 267.7;
            OwlGauge.owlTailHeightMultiplier = 295.5 / 587.8;
            OwlGauge.visualBgHeightMultiplier = 295.5 / 587.8;
            OwlGauge.OwlDemoMode = false;
            OwlGauge.capabilities = {
                dataRoles: [
                    {
                        name: 'Category',
                        kind: powerbi.VisualDataRoleKind.Grouping,
                    },
                    {
                        name: 'Y',
                        kind: powerbi.VisualDataRoleKind.Measure,
                    },
                ],
                dataViewMappings: [{
                        categories: {
                            for: { in: 'Category' },
                            dataReductionAlgorithm: { top: {} }
                        },
                        values: {
                            select: [{ bind: { to: 'Y' } }]
                        },
                    }]
            };
            return OwlGauge;
        }());
        visuals.OwlGauge = OwlGauge;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var NoMapLocationWarning = (function () {
            function NoMapLocationWarning() {
            }
            Object.defineProperty(NoMapLocationWarning.prototype, "code", {
                get: function () {
                    return 'NoMapLocation';
                },
                enumerable: true,
                configurable: true
            });
            NoMapLocationWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'NoMapLocationMessage';
                var titleKey = 'NoMapLocationKey';
                var detailKey = 'NoMapLocationValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return NoMapLocationWarning;
        }());
        visuals.NoMapLocationWarning = NoMapLocationWarning;
        var FilledMapWithoutValidGeotagCategoryWarning = (function () {
            function FilledMapWithoutValidGeotagCategoryWarning() {
            }
            Object.defineProperty(FilledMapWithoutValidGeotagCategoryWarning.prototype, "code", {
                get: function () {
                    return 'NoValidGeotaggedCategory';
                },
                enumerable: true,
                configurable: true
            });
            FilledMapWithoutValidGeotagCategoryWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'NoValidGeotaggedCategoryMessage';
                var titleKey = 'NoValidGeotaggedCategoryKey';
                var detailKey = 'NoValidGeotaggedCategoryValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return FilledMapWithoutValidGeotagCategoryWarning;
        }());
        visuals.FilledMapWithoutValidGeotagCategoryWarning = FilledMapWithoutValidGeotagCategoryWarning;
        var GeometryCulledWarning = (function () {
            function GeometryCulledWarning() {
            }
            Object.defineProperty(GeometryCulledWarning.prototype, "code", {
                get: function () {
                    return 'GeometryCulledWarning';
                },
                enumerable: true,
                configurable: true
            });
            GeometryCulledWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'GeometryCulledWarningMessage';
                var titleKey = 'GeometryCulledWarningKey';
                var detailKey = 'GeometryCulledWarningVal';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(titleKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return GeometryCulledWarning;
        }());
        visuals.GeometryCulledWarning = GeometryCulledWarning;
        var NegativeValuesNotSupportedWarning = (function () {
            function NegativeValuesNotSupportedWarning() {
            }
            Object.defineProperty(NegativeValuesNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'NegativeValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            NegativeValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_NegativeValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return NegativeValuesNotSupportedWarning;
        }());
        visuals.NegativeValuesNotSupportedWarning = NegativeValuesNotSupportedWarning;
        var AllNegativeValuesWarning = (function () {
            function AllNegativeValuesWarning() {
            }
            Object.defineProperty(AllNegativeValuesWarning.prototype, "code", {
                get: function () {
                    return 'AllNegativeValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            AllNegativeValuesWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_AllNegativeValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return AllNegativeValuesWarning;
        }());
        visuals.AllNegativeValuesWarning = AllNegativeValuesWarning;
        var NaNNotSupportedWarning = (function () {
            function NaNNotSupportedWarning() {
            }
            Object.defineProperty(NaNNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'NaNNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            NaNNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_NanValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return NaNNotSupportedWarning;
        }());
        visuals.NaNNotSupportedWarning = NaNNotSupportedWarning;
        var InfinityValuesNotSupportedWarning = (function () {
            function InfinityValuesNotSupportedWarning() {
            }
            Object.defineProperty(InfinityValuesNotSupportedWarning.prototype, "code", {
                get: function () {
                    return 'InfinityValuesNotSupported';
                },
                enumerable: true,
                configurable: true
            });
            InfinityValuesNotSupportedWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_InfinityValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return InfinityValuesNotSupportedWarning;
        }());
        visuals.InfinityValuesNotSupportedWarning = InfinityValuesNotSupportedWarning;
        var ValuesOutOfRangeWarning = (function () {
            function ValuesOutOfRangeWarning() {
            }
            Object.defineProperty(ValuesOutOfRangeWarning.prototype, "code", {
                get: function () {
                    return 'ValuesOutOfRange';
                },
                enumerable: true,
                configurable: true
            });
            ValuesOutOfRangeWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_VisualizationOutOfRange';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return ValuesOutOfRangeWarning;
        }());
        visuals.ValuesOutOfRangeWarning = ValuesOutOfRangeWarning;
        var ZeroValueWarning = (function () {
            function ZeroValueWarning() {
            }
            Object.defineProperty(ZeroValueWarning.prototype, "code", {
                get: function () {
                    return "ZeroValuesNotSupported";
                },
                enumerable: true,
                configurable: true
            });
            ZeroValueWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'VisualWarning_ZeroValues';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return ZeroValueWarning;
        }());
        visuals.ZeroValueWarning = ZeroValueWarning;
        var VisualKPIDataMissingWarning = (function () {
            function VisualKPIDataMissingWarning() {
            }
            Object.defineProperty(VisualKPIDataMissingWarning.prototype, "code", {
                get: function () {
                    return "VisualKPIDataMissing";
                },
                enumerable: true,
                configurable: true
            });
            VisualKPIDataMissingWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'Visual_KPI_DataMissing';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: '',
                    detail: '',
                };
                return visualMessage;
            };
            return VisualKPIDataMissingWarning;
        }());
        visuals.VisualKPIDataMissingWarning = VisualKPIDataMissingWarning;
        var ScriptVisualRefreshWarning = (function () {
            function ScriptVisualRefreshWarning() {
            }
            Object.defineProperty(ScriptVisualRefreshWarning.prototype, "code", {
                get: function () {
                    return "ScriptVisualNotRefreshed";
                },
                enumerable: true,
                configurable: true
            });
            ScriptVisualRefreshWarning.prototype.getMessages = function (resourceProvider) {
                var messageKey = 'ScriptVisualRefreshWarningMessage';
                var detailKey = 'ScriptVisualRefreshWarningValue';
                var visualMessage = {
                    message: resourceProvider.get(messageKey),
                    title: resourceProvider.get(messageKey),
                    detail: resourceProvider.get(detailKey),
                };
                return visualMessage;
            };
            return ScriptVisualRefreshWarning;
        }());
        visuals.ScriptVisualRefreshWarning = ScriptVisualRefreshWarning;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var PixelConverter = jsCommon.PixelConverter;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        var WaterfallChart = (function () {
            function WaterfallChart(options) {
                this.isScrollable = options.isScrollable;
                this.tooltipsEnabled = options.tooltipsEnabled;
                this.interactivityService = options.interactivityService;
            }
            WaterfallChart.prototype.init = function (options) {
                debug.assertValue(options, 'options');
                this.svg = options.svg;
                this.svg.classed(WaterfallChart.WaterfallClassName, true);
                this.style = options.style;
                this.currentViewport = options.viewport;
                this.hostServices = options.host;
                this.interactivity = options.interactivity;
                this.cartesianVisualHost = options.cartesianHost;
                this.options = options;
                this.element = options.element;
                this.colors = this.style.colorPalette.dataColors;
                this.mainGraphicsSVG = this.svg.append('svg');
                this.mainGraphicsContext = this.mainGraphicsSVG.append('g')
                    .classed(WaterfallChart.MainGraphicsContextClassName, true);
                this.labelGraphicsContext = this.mainGraphicsSVG.append('g')
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
            };
            WaterfallChart.converter = function (dataView, palette, hostServices, dataLabelSettings, sentimentColors, interactivityService, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                debug.assertValue(palette, 'palette');
                var formatStringProp = WaterfallChart.formatStringProp;
                var categories = dataView.categorical.categories || [];
                var increaseColor = sentimentColors.increaseFill.solid.color;
                var decreaseColor = sentimentColors.decreaseFill.solid.color;
                var totalColor = sentimentColors.totalFill.solid.color;
                var totalLabel = hostServices.getLocalizedString(WaterfallChart.TotalLabel);
                var increaseLabel = hostServices.getLocalizedString(WaterfallChart.IncreaseLabel);
                var decreaseLabel = hostServices.getLocalizedString(WaterfallChart.DecreaseLabel);
                var legend = [
                    {
                        label: increaseLabel,
                        color: increaseColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure('increase').createSelectionId(),
                        selected: false,
                    }, {
                        label: decreaseLabel,
                        color: decreaseColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure('decrease').createSelectionId(),
                        selected: false,
                    }, {
                        label: totalLabel,
                        color: totalColor,
                        icon: visuals.LegendIcon.Box,
                        identity: visuals.SelectionIdBuilder.builder().withMeasure('total').createSelectionId(),
                        selected: false,
                    }];
                /**
                 * The position represents the starting point for each bar,
                 * for any value it is the sum of all previous values.
                 * Values > 0 are considered gains, values < 0 are losses.
                 */
                var pos = 0, posMin = 0, posMax = 0;
                var dataPoints = [];
                var categoryValues = [];
                var categoryMetadata;
                var values = dataView.categorical.values;
                var valuesMetadata = undefined;
                if (!_.isEmpty(values)) {
                    var column = values[0];
                    valuesMetadata = column.source;
                    var labelFormatString = valuesMetadata.format;
                    if (_.isEmpty(categories)) {
                        // We have values but no category, just show the total bar.
                        pos = posMax = column.values[0];
                        posMin = 0;
                    }
                    else {
                        var categoryColumn = categories[0];
                        categoryMetadata = categoryColumn.source;
                        categoryValues = categoryColumn.values.slice();
                        categoryValues.push(totalLabel);
                        for (var categoryIndex = 0, catLen = column.values.length; categoryIndex < catLen; categoryIndex++) {
                            var category = categoryValues[categoryIndex];
                            var value = column.values[categoryIndex] || 0;
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(categoryColumn, categoryIndex)
                                .withMeasure(valuesMetadata.queryName)
                                .createSelectionId();
                            var tooltipInfo_5 = void 0;
                            if (tooltipsEnabled) {
                                tooltipInfo_5 = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categorical, category, value);
                            }
                            var color = value > 0 ? increaseColor : decreaseColor;
                            dataPoints.push({
                                value: value,
                                position: pos,
                                color: color,
                                categoryValue: category,
                                categoryIndex: categoryIndex,
                                seriesIndex: 0,
                                selected: false,
                                identity: identity,
                                highlight: false,
                                key: identity.getKey(),
                                tooltipInfo: tooltipInfo_5,
                                labelFill: dataLabelSettings.labelColor,
                                labelFormatString: labelFormatString,
                            });
                            pos += value;
                            if (pos > posMax)
                                posMax = pos;
                            if (pos < posMin)
                                posMin = pos;
                        }
                    }
                    var tooltipInfo = void 0;
                    if (tooltipsEnabled) {
                        tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, dataView.categorical, totalLabel, pos);
                    }
                    var totalIdentity = visuals.SelectionId.createNull();
                    dataPoints.push({
                        value: pos,
                        position: 0,
                        color: totalColor,
                        categoryValue: totalLabel,
                        categoryIndex: categoryIndex,
                        identity: totalIdentity,
                        seriesIndex: 0,
                        selected: false,
                        highlight: false,
                        key: totalIdentity.getKey(),
                        tooltipInfo: tooltipInfo,
                        labelFill: dataLabelSettings.labelColor,
                        labelFormatString: labelFormatString,
                        isTotal: true,
                    });
                }
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(dataPoints);
                }
                var xAxisProperties = visuals.CartesianHelper.getCategoryAxisProperties(dataView.metadata);
                var yAxisProperties = visuals.CartesianHelper.getValueAxisProperties(dataView.metadata);
                var axesLabels = visuals.converterHelper.createAxesLabels(xAxisProperties, yAxisProperties, categoryMetadata, [valuesMetadata]);
                return {
                    series: [{ data: dataPoints }],
                    categories: categoryValues,
                    categoryMetadata: categoryMetadata,
                    valuesMetadata: valuesMetadata,
                    legend: { dataPoints: legend },
                    hasHighlights: false,
                    positionMin: posMin,
                    positionMax: posMax,
                    dataLabelsSettings: dataLabelSettings,
                    sentimentColors: sentimentColors,
                    axesLabels: { x: axesLabels.xAxisLabel, y: axesLabels.yAxisLabel },
                };
            };
            WaterfallChart.prototype.setData = function (dataViews) {
                debug.assertValue(dataViews, "dataViews");
                var sentimentColors = this.getSentimentColorsFromObjects(null);
                var dataView = dataViews.length > 0 ? dataViews[0] : undefined;
                this.data = {
                    series: [{ data: [] }],
                    categories: [],
                    valuesMetadata: null,
                    legend: { dataPoints: [], },
                    hasHighlights: false,
                    categoryMetadata: null,
                    scalarCategoryAxis: false,
                    positionMax: 0,
                    positionMin: 0,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultLabelSettings(/* show */ false, /* labelColor */ undefined),
                    sentimentColors: sentimentColors,
                    axesLabels: { x: null, y: null },
                };
                if (dataView) {
                    if (dataView.metadata && dataView.metadata.objects) {
                        var objects = dataView.metadata.objects;
                        var labelsObj = objects['labels'];
                        if (labelsObj) {
                            visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, this.data.dataLabelsSettings);
                        }
                        sentimentColors = this.getSentimentColorsFromObjects(objects);
                    }
                    if (dataView.categorical) {
                        this.data = WaterfallChart.converter(dataView, this.colors, this.hostServices, this.data.dataLabelsSettings, sentimentColors, this.interactivityService, this.tooltipsEnabled);
                    }
                }
            };
            WaterfallChart.prototype.enumerateObjectInstances = function (enumeration, options) {
                switch (options.objectName) {
                    case 'sentimentColors':
                        this.enumerateSentimentColors(enumeration);
                        break;
                    case 'labels':
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: this.data.dataLabelsSettings,
                            show: true,
                            displayUnits: true,
                            precision: true,
                            fontSize: true,
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;
                }
            };
            WaterfallChart.prototype.enumerateSentimentColors = function (enumeration) {
                var sentimentColors = this.data.sentimentColors;
                enumeration.pushInstance({
                    selector: null,
                    properties: {
                        increaseFill: sentimentColors.increaseFill,
                        decreaseFill: sentimentColors.decreaseFill,
                        totalFill: sentimentColors.totalFill
                    },
                    objectName: 'sentimentColors'
                });
            };
            WaterfallChart.prototype.calculateLegend = function () {
                // TODO: support interactive legend
                return this.data.legend;
            };
            WaterfallChart.prototype.hasLegend = function () {
                // Waterfall legend is more like a color-key, so just return true
                return true;
            };
            WaterfallChart.createClippedDataIfOverflowed = function (data, renderableDataCount) {
                var clipped = data;
                var dataPoints = data.series[0].data;
                if (data && renderableDataCount < dataPoints.length) {
                    clipped = powerbi.Prototype.inherit(data);
                    clipped.series = [{ data: dataPoints.slice(0, renderableDataCount) }];
                    clipped.categories = data.categories.slice(0, renderableDataCount);
                }
                return clipped;
            };
            WaterfallChart.prototype.calculateAxesProperties = function (options) {
                var _this = this;
                debug.assertValue(options, 'options');
                this.currentViewport = options.viewport;
                this.margin = options.margin;
                var data = this.clippedData = this.data;
                var categoryCount = data.categories.length;
                var preferredPlotArea = this.getPreferredPlotArea(false, categoryCount, visuals.CartesianChart.MinOrdinalRectThickness);
                var cartesianLayout = visuals.CartesianChart.getLayout(null, {
                    availableWidth: preferredPlotArea.width,
                    categoryCount: categoryCount,
                    domain: null,
                    isScalar: false,
                    isScrollable: this.isScrollable,
                    trimOrdinalDataOnOverflow: options.trimOrdinalDataOnOverflow
                });
                // In the case that we have overflowed horizontally we want to clip the data and use that to calculate the axes on the dashboard.           
                if (!this.isScrollable) {
                    data = this.clippedData = WaterfallChart.createClippedDataIfOverflowed(data, cartesianLayout.categoryCount);
                }
                var xAxisCreationOptions = WaterfallChart.getXAxisCreationOptions(data, preferredPlotArea.width, cartesianLayout, options);
                var yAxisCreationOptions = WaterfallChart.getYAxisCreationOptions(data, preferredPlotArea.height, options);
                var xAxisProperties = this.xAxisProperties = visuals.AxisHelper.createAxis(xAxisCreationOptions);
                var yAxisProperties = this.yAxisProperties = visuals.AxisHelper.createAxis(yAxisCreationOptions);
                var categoryWidth = this.xAxisProperties.categoryThickness * (1 - visuals.CartesianChart.InnerPaddingRatio);
                var formattersCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
                var labelSettings = data.dataLabelsSettings;
                var value2 = WaterfallChart.getDisplayUnitValueFromAxisFormatter(yAxisProperties, labelSettings);
                this.layout = {
                    categoryCount: cartesianLayout.categoryCount,
                    categoryThickness: cartesianLayout.categoryThickness,
                    isScalar: cartesianLayout.isScalar,
                    outerPaddingRatio: cartesianLayout.outerPaddingRatio,
                    categoryWidth: categoryWidth,
                    labelText: function (d) {
                        //total value has no identity
                        var formatter = formattersCache.getOrCreate(d.labelFormatString, labelSettings, value2);
                        return visuals.dataLabelUtils.getLabelFormattedText({ label: formatter.format(d.value) });
                    },
                    labelLayout: visuals.dataLabelUtils.getLabelLayoutXYForWaterfall(xAxisProperties, categoryWidth, yAxisProperties, yAxisCreationOptions.dataDomain),
                    filter: function (d) {
                        return visuals.dataLabelUtils.doesDataLabelFitInShape(d, yAxisProperties, _this.layout);
                    },
                    style: {
                        'fill': function (d) {
                            if (d.isLabelInside)
                                return visuals.dataLabelUtils.defaultInsideLabelColor;
                            return d.labelFill;
                        },
                    },
                };
                this.xAxisProperties.axisLabel = options.showCategoryAxisLabel ? data.axesLabels.x : null;
                this.yAxisProperties.axisLabel = options.showValueAxisLabel ? data.axesLabels.y : null;
                return [xAxisProperties, yAxisProperties];
            };
            WaterfallChart.getDisplayUnitValueFromAxisFormatter = function (yAxisProperties, labelSettings) {
                return (yAxisProperties.formatter && yAxisProperties.formatter.displayUnit && labelSettings.displayUnits === 0) ? yAxisProperties.formatter.displayUnit.value : null;
            };
            WaterfallChart.lookupXValue = function (data, index, type) {
                var dataPoints = data.series[0].data;
                if (index === dataPoints.length - 1)
                    // Total
                    return dataPoints[index].categoryValue;
                else
                    return visuals.CartesianHelper.lookupXValue(data, index, type, false);
            };
            WaterfallChart.getXAxisCreationOptions = function (data, width, layout, options) {
                debug.assertValue(data, 'data');
                debug.assertValue(options, 'options');
                var categoryDataType = visuals.AxisHelper.getCategoryValueType(data.categoryMetadata);
                var domain = visuals.AxisHelper.createDomain(data.series, categoryDataType, /* isScalar */ false, options.forcedXDomain, options.ensureXDomain);
                var categoryThickness = layout.categoryThickness;
                var outerPadding = categoryThickness * layout.outerPaddingRatio;
                return {
                    pixelSpan: width,
                    dataDomain: domain,
                    metaDataColumn: data.categoryMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.categoryMetadata, WaterfallChart.formatStringProp),
                    isScalar: false,
                    outerPadding: outerPadding,
                    categoryThickness: categoryThickness,
                    getValueFn: function (index, type) { return WaterfallChart.lookupXValue(data, index, type); },
                    forcedTickCount: options.forcedTickCount,
                    isCategoryAxis: true,
                    axisDisplayUnits: options.categoryAxisDisplayUnits,
                    axisPrecision: options.categoryAxisPrecision
                };
            };
            WaterfallChart.getYAxisCreationOptions = function (data, height, options) {
                debug.assertValue(data, 'data');
                debug.assertValue(options, 'options');
                var combinedDomain = visuals.AxisHelper.combineDomain(options.forcedYDomain, [data.positionMin, data.positionMax], options.ensureYDomain);
                return {
                    pixelSpan: height,
                    dataDomain: combinedDomain,
                    isScalar: true,
                    isVertical: true,
                    metaDataColumn: data.valuesMetadata,
                    formatString: visuals.valueFormatter.getFormatString(data.valuesMetadata, WaterfallChart.formatStringProp),
                    outerPadding: 0,
                    forcedTickCount: options.forcedTickCount,
                    useTickIntervalForDisplayUnits: true,
                    isCategoryAxis: false,
                    axisDisplayUnits: options.valueAxisDisplayUnits,
                    axisPrecision: options.valueAxisPrecision
                };
            };
            WaterfallChart.prototype.getPreferredPlotArea = function (isScalar, categoryCount, categoryThickness) {
                return visuals.CartesianChart.getPreferredPlotArea(categoryCount, categoryThickness, this.currentViewport, this.isScrollable, isScalar, this.margin);
            };
            WaterfallChart.prototype.getVisualCategoryAxisIsScalar = function () {
                return false;
            };
            WaterfallChart.prototype.overrideXScale = function (xProperties) {
                this.xAxisProperties = xProperties;
            };
            WaterfallChart.prototype.setFilteredData = function (startIndex, endIndex) {
                var data = this.clippedData = powerbi.Prototype.inherit(this.data);
                data.series = [{ data: data.series[0].data.slice(startIndex, endIndex) }];
                data.categories = data.categories.slice(startIndex, endIndex);
                return data;
            };
            WaterfallChart.prototype.createRects = function (data) {
                var mainGraphicsContext = this.mainGraphicsContext;
                var colsSelection = mainGraphicsContext.selectAll(WaterfallChart.CategoryValueClasses.selector);
                var cols = colsSelection.data(data, function (d) { return d.key; });
                cols
                    .enter()
                    .append('rect')
                    .attr('class', function (d) { return WaterfallChart.CategoryValueClasses.class.concat(d.highlight ? 'highlight' : ''); });
                cols.exit().remove();
                return cols;
            };
            WaterfallChart.prototype.createConnectors = function (data) {
                var mainGraphicsContext = this.mainGraphicsContext;
                var connectorSelection = mainGraphicsContext.selectAll(WaterfallChart.WaterfallConnectorClasses.selector);
                var connectors = connectorSelection.data(data.slice(0, data.length - 1), function (d) { return d.key; });
                connectors
                    .enter()
                    .append('line')
                    .classed(WaterfallChart.WaterfallConnectorClasses.class, true);
                connectors.exit().remove();
                return connectors;
            };
            WaterfallChart.prototype.render = function (suppressAnimations) {
                var _this = this;
                var dataPoints = this.clippedData.series[0].data;
                var bars = this.createRects(dataPoints);
                var connectors = this.createConnectors(dataPoints);
                if (this.tooltipsEnabled)
                    visuals.TooltipManager.addTooltip(bars, function (tooltipEvent) { return tooltipEvent.data.tooltipInfo; });
                var hasSelection = this.interactivityService && this.interactivityService.hasSelection();
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var y0 = yScale(0);
                this.mainGraphicsSVG.attr('height', this.getAvailableHeight())
                    .attr('width', this.getAvailableWidth());
                /**
                 * The y-value is always at the top of the rect. If the data value is negative then we can
                 * use the scaled position directly since we are drawing down. If the data value is positive
                 * we have to calculate the top of the rect and use that as the y-value. Since the y-value
                 * is always the top of the rect, height should always be positive.
                 */
                bars
                    .style('fill', function (d) { return d.color; })
                    .style('fill-opacity', function (d) { return d.isTotal ? visuals.ColumnUtil.DefaultOpacity : visuals.ColumnUtil.getFillOpacity(d.selected, d.highlight, hasSelection, _this.data.hasHighlights); })
                    .attr('width', this.layout.categoryWidth)
                    .attr('x', function (d) { return xScale(d.categoryIndex); })
                    .attr('y', function (d) { return WaterfallChart.getRectTop(yScale, d.position, d.value); })
                    .attr('height', function (d) { return y0 - yScale(Math.abs(d.value)); });
                connectors
                    .attr({
                    'x1': function (d) { return xScale(d.categoryIndex); },
                    'y1': function (d) { return yScale(d.position + d.value); },
                    'x2': function (d) { return xScale(d.categoryIndex + 1) + _this.layout.categoryWidth; },
                    'y2': function (d) { return yScale(d.position + d.value); },
                });
                var labelSettings = this.data.dataLabelsSettings;
                var labelDataPoints = [];
                if (labelSettings && labelSettings.show || labelSettings.showCategory) {
                    labelDataPoints = this.createLabelDataPoints();
                }
                var behaviorOptions = undefined;
                if (this.interactivityService) {
                    behaviorOptions = {
                        bars: bars,
                        datapoints: dataPoints,
                    };
                }
                // This should always be the last line in the render code.
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                return { dataPoints: dataPoints, behaviorOptions: behaviorOptions, labelDataPoints: labelDataPoints, labelsAreNumeric: true };
            };
            WaterfallChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            WaterfallChart.prototype.getSupportedCategoryAxisType = function () {
                return visuals.axisType.categorical;
            };
            WaterfallChart.getRectTop = function (scale, pos, value) {
                if (value < 0)
                    return scale(pos);
                else
                    return scale(pos) - (scale(0) - scale(value));
            };
            WaterfallChart.prototype.getAvailableWidth = function () {
                return this.currentViewport.width - (this.margin.left + this.margin.right);
            };
            WaterfallChart.prototype.getAvailableHeight = function () {
                return this.currentViewport.height - (this.margin.top + this.margin.bottom);
            };
            WaterfallChart.prototype.getSentimentColorsFromObjects = function (objects) {
                var defaultSentimentColors = this.colors.getSentimentColors();
                var increaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.increaseFill, defaultSentimentColors[2].value);
                var decreaseColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.decreaseFill, defaultSentimentColors[0].value);
                var totalColor = powerbi.DataViewObjects.getFillColor(objects, visuals.waterfallChartProps.sentimentColors.totalFill, WaterfallChart.defaultTotalColor);
                return {
                    increaseFill: { solid: { color: increaseColor } },
                    decreaseFill: { solid: { color: decreaseColor } },
                    totalFill: { solid: { color: totalColor } }
                };
            };
            // Public for testing
            WaterfallChart.prototype.createLabelDataPoints = function () {
                var labelDataPoints = [];
                var data = this.data;
                var xScale = this.xAxisProperties.scale;
                var yScale = this.yAxisProperties.scale;
                var y0 = yScale(0);
                var series = data.series;
                var formattersCache = visuals.NewDataLabelUtils.createColumnFormatterCacheManager();
                var axisFormatter = visuals.NewDataLabelUtils.getDisplayUnitValueFromAxisFormatter(this.yAxisProperties.formatter, data.dataLabelsSettings);
                var labelSettings = this.data.dataLabelsSettings;
                for (var _i = 0, series_6 = series; _i < series_6.length; _i++) {
                    var currentSeries = series_6[_i];
                    for (var _a = 0, _b = currentSeries.data; _a < _b.length; _a++) {
                        var dataPoint = _b[_a];
                        // Calculate parent rectangle
                        var parentRect = {
                            left: xScale(dataPoint.categoryIndex),
                            top: WaterfallChart.getRectTop(yScale, dataPoint.position, dataPoint.value),
                            width: this.layout.categoryWidth,
                            height: y0 - yScale(Math.abs(dataPoint.value)),
                        };
                        // Calculate label text
                        var formatString = dataPoint.labelFormatString;
                        var formatter = formattersCache.getOrCreate(formatString, this.data.dataLabelsSettings, axisFormatter);
                        var text = visuals.NewDataLabelUtils.getLabelFormattedText(formatter.format(dataPoint.value));
                        // Calculate text size
                        var properties = {
                            text: text,
                            fontFamily: visuals.NewDataLabelUtils.LabelTextProperties.fontFamily,
                            fontSize: PixelConverter.fromPoint(labelSettings.fontSize || visuals.NewDataLabelUtils.DefaultLabelFontSizeInPt),
                            fontWeight: visuals.NewDataLabelUtils.LabelTextProperties.fontWeight,
                        };
                        var textWidth = powerbi.TextMeasurementService.measureSvgTextWidth(properties);
                        var textHeight = powerbi.TextMeasurementService.estimateSvgTextHeight(properties, true /* tightFitForNumeric */);
                        labelDataPoints.push({
                            isPreferred: true,
                            text: text,
                            textSize: {
                                width: textWidth,
                                height: textHeight,
                            },
                            outsideFill: labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor,
                            insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                            parentType: 1 /* Rectangle */,
                            parentShape: {
                                rect: parentRect,
                                orientation: dataPoint.value >= 0 ? 1 /* VerticalBottomBased */ : 2 /* VerticalTopBased */,
                                validPositions: dataPoint.value === 0 ? WaterfallChart.validZeroLabelPosition : WaterfallChart.validLabelPositions,
                            },
                            fontSize: labelSettings.fontSize,
                            identity: undefined,
                        });
                    }
                }
                return labelDataPoints;
            };
            WaterfallChart.formatStringProp = { objectName: 'general', propertyName: 'formatString' };
            WaterfallChart.WaterfallClassName = 'waterfallChart';
            WaterfallChart.MainGraphicsContextClassName = 'mainGraphicsContext';
            WaterfallChart.IncreaseLabel = "Waterfall_IncreaseLabel";
            WaterfallChart.DecreaseLabel = "Waterfall_DecreaseLabel";
            WaterfallChart.TotalLabel = "Waterfall_TotalLabel";
            WaterfallChart.CategoryValueClasses = createClassAndSelector('column');
            WaterfallChart.WaterfallConnectorClasses = createClassAndSelector('waterfall-connector');
            WaterfallChart.defaultTotalColor = "#00b8aa";
            WaterfallChart.validLabelPositions = [16 /* OutsideEnd */, 4 /* InsideEnd */];
            WaterfallChart.validZeroLabelPosition = [16 /* OutsideEnd */, 8 /* OutsideBase */];
            return WaterfallChart;
        }());
        visuals.WaterfallChart = WaterfallChart;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var TouchUtils = powerbi.visuals.controls.TouchUtils;
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        ;
        var ContainerClassName = createClassAndSelector("tooltip-container");
        var ContentContainerClassName = createClassAndSelector("tooltip-content-container");
        var ArrowClassName = createClassAndSelector("arrow");
        var TooltipHeaderClassName = createClassAndSelector("tooltip-header");
        var TooltipRowClassName = createClassAndSelector("tooltip-row");
        var TooltipColorCellClassName = createClassAndSelector("tooltip-color-cell");
        var TooltipTitleCellClassName = createClassAndSelector("tooltip-title-cell");
        var TooltipValueCellClassName = createClassAndSelector("tooltip-value-cell");
        var ToolTipComponent = (function () {
            function ToolTipComponent(tooltipOptions) {
                this.tooltipOptions = tooltipOptions;
                this.isTooltipVisible = false;
                if (!tooltipOptions) {
                    this.tooltipOptions = ToolTipComponent.DefaultTooltipOptions;
                }
            }
            ToolTipComponent.prototype.isTooltipComponentVisible = function () {
                return this.isTooltipVisible;
            };
            /** Note: For tests only */
            ToolTipComponent.prototype.setTestScreenSize = function (width, height) {
                this.customScreenWidth = width;
                this.customScreenHeight = height;
            };
            ToolTipComponent.prototype.show = function (tooltipData, clickedArea) {
                this.isTooltipVisible = true;
                if (!this.tooltipContainer) {
                    this.tooltipContainer = this.createTooltipContainer();
                }
                this.setTooltipContent(tooltipData);
                this.tooltipContainer
                    .style("visibility", "visible")
                    .transition()
                    .duration(0) // Cancel previous transitions
                    .style("opacity", this.tooltipOptions.opacity);
                this.setPosition(clickedArea);
            };
            ToolTipComponent.prototype.move = function (tooltipData, clickedArea) {
                if (this.isTooltipVisible) {
                    if (tooltipData) {
                        this.setTooltipContent(tooltipData);
                    }
                    this.setPosition(clickedArea);
                }
            };
            ToolTipComponent.prototype.hide = function () {
                if (this.isTooltipVisible) {
                    this.isTooltipVisible = false;
                    this.tooltipContainer
                        .transition()
                        .duration(this.tooltipOptions.animationDuration)
                        .style("opacity", 0)
                        .each('end', function () { this.style.visibility = "hidden"; });
                }
            };
            ToolTipComponent.prototype.createTooltipContainer = function () {
                var container = d3.select(ToolTipComponent.parentContainerSelector)
                    .append("div")
                    .attr("class", ContainerClassName.class);
                container.append("div").attr("class", ArrowClassName.class);
                container.append("div").attr("class", ContentContainerClassName.class);
                return container;
            };
            ToolTipComponent.prototype.setTooltipContent = function (tooltipData) {
                if (_.isEqual(tooltipData, this.currentTooltipData))
                    return;
                this.currentTooltipData = tooltipData;
                var rowsSelector = TooltipRowClassName.selector;
                var contentContainer = this.tooltipContainer.select(ContentContainerClassName.selector);
                // Clear existing content
                contentContainer.selectAll(TooltipHeaderClassName.selector).remove();
                contentContainer.selectAll(TooltipRowClassName.selector).remove();
                if (tooltipData.length === 0)
                    return;
                if (tooltipData[0].header) {
                    contentContainer.append("div").attr("class", TooltipHeaderClassName.class).text(tooltipData[0].header);
                }
                var tooltipRow = contentContainer.selectAll(rowsSelector).data(tooltipData);
                var newRow = tooltipRow.enter().append("div").attr("class", TooltipRowClassName.class);
                if (tooltipData[0].color) {
                    var newColorCell = newRow.append("div").attr("class", TooltipColorCellClassName.class);
                    newColorCell
                        .append('svg')
                        .attr({
                        'width': '100%',
                        'height': '15px'
                    })
                        .append('circle')
                        .attr({
                        'cx': '5',
                        'cy': '8',
                        'r': '5'
                    })
                        .style({
                        'fill': function (d) { return d.color; }
                    });
                }
                var newTitleCell = newRow.append("div").attr("class", TooltipTitleCellClassName.class);
                var newValueCell = newRow.append("div").attr("class", TooltipValueCellClassName.class);
                newTitleCell.text(function (d) { return d.displayName; });
                newValueCell.text(function (d) { return d.value; });
            };
            ToolTipComponent.prototype.getTooltipPosition = function (clickedArea, clickedScreenArea) {
                var tooltipContainerBounds = this.tooltipContainer.node().getBoundingClientRect();
                var centerPointOffset = Math.floor(clickedArea.width / 2);
                var offsetX = 0;
                var offsetY = 0;
                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
                var arrowOffset = 7;
                if (clickedScreenArea === 0 /* TopLeft */) {
                    offsetX += 3 * arrowOffset + centerPointOffset;
                    offsetY -= 2 * arrowOffset + centerPointOffset;
                }
                else if (clickedScreenArea === 1 /* TopRight */) {
                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset);
                    offsetY -= 2 * arrowOffset + centerPointOffset;
                }
                else if (clickedScreenArea === 3 /* BottomLeft */) {
                    offsetX += 3 * arrowOffset + centerPointOffset;
                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset);
                }
                else if (clickedScreenArea === 2 /* BottomRight */) {
                    offsetX -= (2 * arrowOffset + tooltipContainerBounds.width + centerPointOffset);
                    offsetY -= (tooltipContainerBounds.height - 2 * arrowOffset + centerPointOffset);
                }
                centerPoint.offset(offsetX, offsetY);
                return centerPoint;
            };
            ToolTipComponent.prototype.setPosition = function (clickedArea) {
                var clickedScreenArea = this.getClickedScreenArea(clickedArea);
                var tooltipPosition = this.getTooltipPosition(clickedArea, clickedScreenArea);
                this.tooltipContainer.style({ "left": tooltipPosition.x + "px", "top": tooltipPosition.y + "px" });
                this.setArrowPosition(clickedArea, clickedScreenArea);
            };
            ToolTipComponent.prototype.setArrowPosition = function (clickedArea, clickedScreenArea) {
                var arrow = this.getArrowElement();
                var arrowClassName;
                if (clickedScreenArea === 0 /* TopLeft */) {
                    arrowClassName = "top left";
                }
                else if (clickedScreenArea === 1 /* TopRight */) {
                    arrowClassName = "top right";
                }
                else if (clickedScreenArea === 3 /* BottomLeft */) {
                    arrowClassName = "bottom left";
                }
                else if (clickedScreenArea === 2 /* BottomRight */) {
                    arrowClassName = "bottom right";
                }
                arrow
                    .attr('class', 'arrow') // Reset all classes
                    .classed(arrowClassName, true);
            };
            ToolTipComponent.prototype.getArrowElement = function () {
                return this.tooltipContainer.select(ArrowClassName.selector);
            };
            ToolTipComponent.prototype.getClickedScreenArea = function (clickedArea) {
                var screenWidth = this.customScreenWidth || window.innerWidth;
                var screenHeight = this.customScreenHeight || window.innerHeight;
                var centerPointOffset = clickedArea.width / 2;
                var centerPoint = new TouchUtils.Point(clickedArea.x + centerPointOffset, clickedArea.y + centerPointOffset);
                var halfWidth = screenWidth / 2;
                var halfHeight = screenHeight / 2;
                if (centerPoint.x < halfWidth && centerPoint.y < halfHeight) {
                    return 0 /* TopLeft */;
                }
                else if (centerPoint.x >= halfWidth && centerPoint.y < halfHeight) {
                    return 1 /* TopRight */;
                }
                else if (centerPoint.x < halfWidth && centerPoint.y >= halfHeight) {
                    return 3 /* BottomLeft */;
                }
                else if (centerPoint.x >= halfWidth && centerPoint.y >= halfHeight) {
                    return 2 /* BottomRight */;
                }
            };
            ToolTipComponent.DefaultTooltipOptions = {
                opacity: 1,
                animationDuration: 250,
                offsetX: 10,
                offsetY: 10
            };
            ToolTipComponent.parentContainerSelector = "body";
            ToolTipComponent.highlightedValueDisplayNameResorceKey = "Tooltip_HighlightedValueDisplayName";
            return ToolTipComponent;
        }());
        visuals.ToolTipComponent = ToolTipComponent;
        var TooltipManager;
        (function (TooltipManager) {
            TooltipManager.ShowTooltips = true;
            TooltipManager.ToolTipInstance = new ToolTipComponent();
            var GlobalTooltipEventsAttached = false;
            var tooltipMouseOverDelay = 350;
            var tooltipMouseOutDelay = 500;
            var tooltipTouchDelay = 350;
            var tooltipTimeoutId;
            var handleTouchDelay = 1000;
            var handleTouchTimeoutId = 0;
            var mouseCoordinates;
            var tooltipData;
            function addTooltip(selection, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove, onMouseOutDelegate) {
                if (!TooltipManager.ShowTooltips) {
                    return;
                }
                debug.assertValue(selection, "selection");
                var rootNode = d3.select(ToolTipComponent.parentContainerSelector).node();
                // Mouse events
                selection.on("mouseover", function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    // Ignore mouseover while handling touch events
                    if (handleTouchTimeoutId || !canDisplayTooltip(d3.event))
                        return;
                    mouseCoordinates = getCoordinates(rootNode, true);
                    var elementCoordinates = getCoordinates(target, true);
                    var tooltipEvent = {
                        data: data,
                        coordinates: mouseCoordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: false
                    };
                    clearTooltipTimeout();
                    // if it is already visible, change contents immediately (use 16ms minimum perceivable frame rate to prevent thrashing)
                    var delay = TooltipManager.ToolTipInstance.isTooltipComponentVisible() ? 16 : tooltipMouseOverDelay;
                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delay);
                });
                selection.on("mouseout", function () {
                    if (!handleTouchTimeoutId) {
                        clearTooltipTimeout();
                        tooltipTimeoutId = hideDelayedTooltip(tooltipMouseOutDelay);
                    }
                    if (onMouseOutDelegate) {
                        onMouseOutDelegate();
                    }
                });
                selection.on("mousemove", function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    // Ignore mousemove while handling touch events
                    if (handleTouchTimeoutId || !canDisplayTooltip(d3.event))
                        return;
                    mouseCoordinates = getCoordinates(rootNode, true);
                    var elementCoordinates = getCoordinates(target, true);
                    var tooltipEvent = {
                        data: data,
                        coordinates: mouseCoordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: false
                    };
                    moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove);
                });
                // --- Touch events ---
                // TODO: static?
                var touchStartEventName = getTouchStartEventName();
                var touchEndEventName = getTouchEndEventName();
                var isPointerEvent = touchStartEventName === "pointerdown" || touchStartEventName === "MSPointerDown";
                if (!GlobalTooltipEventsAttached) {
                    // Add root container hide tooltip event
                    attachGlobalEvents(touchStartEventName);
                    GlobalTooltipEventsAttached = true;
                }
                selection.on(touchStartEventName, function () {
                    var target = d3.event.target;
                    var data = d3.select(target).datum();
                    hideTooltipEventHandler();
                    var coordinates = getCoordinates(rootNode, isPointerEvent);
                    var elementCoordinates = getCoordinates(target, isPointerEvent);
                    var tooltipEvent = {
                        data: data,
                        coordinates: coordinates,
                        elementCoordinates: elementCoordinates,
                        context: target,
                        isTouchEvent: true
                    };
                    clearTooltipTimeout();
                    tooltipTimeoutId = showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, tooltipTouchDelay);
                });
                selection.on(touchEndEventName, function () {
                    clearTooltipTimeout();
                    if (handleTouchTimeoutId)
                        clearTimeout(handleTouchTimeoutId);
                    // At the end of touch action, set a timeout that will let us ignore the incoming mouse events for a small amount of time
                    handleTouchTimeoutId = setTimeout(function () {
                        handleTouchTimeoutId = 0;
                    }, handleTouchDelay);
                });
            }
            TooltipManager.addTooltip = addTooltip;
            function showDelayedTooltip(tooltipEvent, getTooltipInfoDelegate, delayInMs) {
                return setTimeout(function () { return showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate); }, delayInMs);
            }
            TooltipManager.showDelayedTooltip = showDelayedTooltip;
            function hideDelayedTooltip(delayInMs) {
                return setTimeout(function () { return hideTooltipEventHandler(); }, delayInMs);
            }
            TooltipManager.hideDelayedTooltip = hideDelayedTooltip;
            function setLocalizedStrings(localizationOptions) {
                ToolTipComponent.localizationOptions = localizationOptions;
            }
            TooltipManager.setLocalizedStrings = setLocalizedStrings;
            function showTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate) {
                var tooltipInfo = tooltipData || getTooltipInfoDelegate(tooltipEvent);
                if (!_.isEmpty(tooltipInfo)) {
                    var coordinates = mouseCoordinates || tooltipEvent.coordinates;
                    var clickedArea = getClickedArea(coordinates[0], coordinates[1], tooltipEvent.isTouchEvent);
                    TooltipManager.ToolTipInstance.show(tooltipInfo, clickedArea);
                }
            }
            function moveTooltipEventHandler(tooltipEvent, getTooltipInfoDelegate, reloadTooltipDataOnMouseMove) {
                tooltipData = undefined;
                if (reloadTooltipDataOnMouseMove) {
                    tooltipData = getTooltipInfoDelegate(tooltipEvent);
                }
                var clickedArea = getClickedArea(tooltipEvent.coordinates[0], tooltipEvent.coordinates[1], tooltipEvent.isTouchEvent);
                TooltipManager.ToolTipInstance.move(tooltipData, clickedArea);
            }
            ;
            function hideTooltipEventHandler() {
                TooltipManager.ToolTipInstance.hide();
            }
            ;
            function clearTooltipTimeout() {
                if (tooltipTimeoutId) {
                    clearTimeout(tooltipTimeoutId);
                }
            }
            function canDisplayTooltip(d3Event) {
                var cadDisplay = true;
                var mouseEvent = d3Event;
                if (mouseEvent.buttons !== undefined) {
                    // Check mouse buttons state
                    var hasMouseButtonPressed = mouseEvent.buttons !== 0;
                    cadDisplay = !hasMouseButtonPressed;
                }
                return cadDisplay;
            }
            function getTouchStartEventName() {
                var eventName = "touchstart";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointerdown";
                }
                else if (window["MSPointerEvent"]) {
                    // IE10
                    eventName = "MSPointerDown";
                }
                return eventName;
            }
            function getTouchEndEventName() {
                var eventName = "touchend";
                if (window["PointerEvent"]) {
                    // IE11
                    eventName = "pointerup";
                }
                else if (window["MSPointerEvent"]) {
                    // IE10
                    eventName = "MSPointerUp";
                }
                return eventName;
            }
            function getCoordinates(rootNode, isPointerEvent) {
                var coordinates;
                if (isPointerEvent) {
                    // DO NOT USE - WebKit bug in getScreenCTM with nested SVG results in slight negative coordinate shift
                    // Also, IE will incorporate transform scale but WebKit does not, forcing us to detect browser and adjust appropriately.
                    // Just use non-scaled coordinates for all browsers, and adjust for the transform scale later (see lineChart.findIndex)
                    //coordinates = d3.mouse(rootNode);
                    // copied from d3_eventSource (which is not exposed)
                    var e = d3.event, s = void 0;
                    while (s = e.sourceEvent)
                        e = s;
                    var rect = rootNode.getBoundingClientRect();
                    coordinates = [e.clientX - rect.left - rootNode.clientLeft, e.clientY - rect.top - rootNode.clientTop];
                }
                else {
                    var touchCoordinates = d3.touches(rootNode);
                    if (touchCoordinates && touchCoordinates.length > 0) {
                        coordinates = touchCoordinates[0];
                    }
                }
                return coordinates;
            }
            function attachGlobalEvents(touchStartEventName) {
                d3.select(ToolTipComponent.parentContainerSelector).on(touchStartEventName, function (d, i) {
                    TooltipManager.ToolTipInstance.hide();
                });
            }
            function getClickedArea(x, y, isTouchEvent) {
                var width = 0;
                var pointX = x;
                var pointY = y;
                if (isTouchEvent) {
                    width = 12;
                    var offset = width / 2;
                    pointX = Math.max(x - offset, 0);
                    pointY = Math.max(y - offset, 0);
                }
                return new TouchUtils.Rectangle(pointX, pointY, width, width);
            }
        })(TooltipManager = visuals.TooltipManager || (visuals.TooltipManager = {}));
        var TooltipBuilder;
        (function (TooltipBuilder) {
            // TODO: implement options bag as input parameter
            function createTooltipInfo(formatStringProp, dataViewCat, categoryValue, value, categories, seriesData, seriesIndex, categoryIndex, highlightedValue, gradientValueColumn) {
                var categorySource;
                var seriesSource = [];
                var valuesSource = undefined;
                seriesIndex = seriesIndex | 0;
                var categoriesData = dataViewCat ? dataViewCat.categories : categories;
                if (categoriesData && categoriesData.length > 0) {
                    if (categoriesData.length > 1) {
                        var compositeCategoriesData = [];
                        for (var i = 0, ilen = categoriesData.length; i < ilen; i++) {
                            compositeCategoriesData.push(categoriesData[i].source);
                        }
                        categorySource = { value: categoryValue, metadata: compositeCategoriesData };
                    }
                    else {
                        categorySource = { value: categoryValue, metadata: [categoriesData[0].source] };
                    }
                }
                if (dataViewCat && dataViewCat.values) {
                    if (categorySource && categorySource.metadata[0] === dataViewCat.values.source) {
                    }
                    else {
                        valuesSource = dataViewCat.values.source;
                    }
                    if (dataViewCat.values.length > 0) {
                        var valueColumn = dataViewCat.values[seriesIndex];
                        var isAutoGeneratedColumn = !!(valueColumn && valueColumn.source && valueColumn.source.isAutoGeneratedColumn);
                        if (!isAutoGeneratedColumn) {
                            seriesSource.push({ value: value, highlightedValue: highlightedValue, metadata: valueColumn });
                        }
                    }
                    //Create Gradient tooltip value
                    var gradientToolTipData = createGradientToolTipData(gradientValueColumn, categoryIndex);
                    if (gradientToolTipData != null)
                        seriesSource.push(gradientToolTipData);
                }
                if (seriesData) {
                    for (var i = 0, len = seriesData.length; i < len; i++) {
                        var singleSeriesData = seriesData[i];
                        if (categorySource && categorySource.metadata[0] === singleSeriesData.metadata.source)
                            continue;
                        seriesSource.push({ value: singleSeriesData.value, metadata: singleSeriesData.metadata });
                    }
                }
                var tooltipInfo = createTooltipData(formatStringProp, categorySource, valuesSource, seriesSource);
                return tooltipInfo;
            }
            TooltipBuilder.createTooltipInfo = createTooltipInfo;
            function createGradientToolTipData(gradientValueColumn, categoryIndex) {
                if (gradientValueColumn) {
                    // Saturation color
                    return { value: gradientValueColumn.values[categoryIndex], metadata: { source: gradientValueColumn.source, values: [] } };
                }
                return null;
            }
            TooltipBuilder.createGradientToolTipData = createGradientToolTipData;
            function createTooltipData(formatStringProp, categoryValue, valuesSource, seriesValues) {
                debug.assertValue(seriesValues, "seriesSource");
                debug.assertValue(ToolTipComponent.localizationOptions, "ToolTipComponent.localizationOptions");
                debug.assertAnyValue(formatStringProp, 'formatStringProp');
                var items = [];
                if (categoryValue) {
                    if (categoryValue.metadata.length > 1) {
                        var displayName = '';
                        // This is being done simply for lat/long for now, as that's the only composite category we use.  If we ever have tooltips
                        //   involving other composite categories, we need to do a more thorough design and be more careful here.
                        for (var i = 0, ilen = categoryValue.metadata.length; i < ilen; i++) {
                            if (i !== 0)
                                displayName += '/';
                            displayName += categoryValue.metadata[i].displayName;
                        }
                        var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                        items.push({ displayName: displayName, value: categoryFormattedValue });
                    }
                    else {
                        var categoryFormattedValue = getFormattedValue(categoryValue.metadata[0], formatStringProp, categoryValue.value);
                        items.push({ displayName: categoryValue.metadata[0].displayName, value: categoryFormattedValue });
                    }
                }
                if (valuesSource) {
                    // Dynamic series value
                    var dynamicValue = void 0;
                    if (seriesValues.length > 0) {
                        var dynamicValueMetadata = seriesValues[0].metadata.source;
                        dynamicValue = getFormattedValue(valuesSource, formatStringProp, dynamicValueMetadata.groupName);
                    }
                    items.push({ displayName: valuesSource.displayName, value: dynamicValue });
                }
                for (var i = 0; i < seriesValues.length; i++) {
                    var seriesData = seriesValues[i];
                    if (seriesData && seriesData.metadata) {
                        var seriesMetadataColumn = seriesData.metadata.source;
                        var value = seriesData.value;
                        var highlightedValue = seriesData.highlightedValue;
                        if (value || value === 0) {
                            var formattedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, value);
                            items.push({ displayName: seriesMetadataColumn.displayName, value: formattedValue });
                        }
                        if (highlightedValue || highlightedValue === 0) {
                            var formattedHighlightedValue = getFormattedValue(seriesMetadataColumn, formatStringProp, highlightedValue);
                            var displayName = ToolTipComponent.localizationOptions.highlightedValueDisplayName;
                            items.push({ displayName: displayName, value: formattedHighlightedValue });
                        }
                    }
                }
                return items;
            }
            function getFormattedValue(column, formatStringProp, value) {
                var formatString = getFormatStringFromColumn(column, formatStringProp);
                return visuals.valueFormatter.format(value, formatString);
            }
            function getFormatStringFromColumn(column, formatStringProp) {
                if (column) {
                    var formatString = visuals.valueFormatter.getFormatString(column, formatStringProp, true);
                    return formatString || column.format;
                }
                return null;
            }
        })(TooltipBuilder = visuals.TooltipBuilder || (visuals.TooltipBuilder = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var visualStyles;
        (function (visualStyles) {
            function create(dataColors) {
                if (dataColors === undefined)
                    dataColors = new visuals.DataColorPalette();
                return {
                    titleText: {
                        color: { value: 'rgba(51,51,51,1)' }
                    },
                    subTitleText: {
                        color: { value: 'rgba(145,145,145,1)' }
                    },
                    colorPalette: {
                        dataColors: dataColors,
                    },
                    labelText: {
                        color: {
                            value: 'rgba(51,51,51,1)',
                        },
                        fontSize: '11px'
                    },
                    isHighContrast: false,
                };
            }
            visualStyles.create = create;
        })(visualStyles = visuals.visualStyles || (visuals.visualStyles = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var createClassAndSelector = jsCommon.CssConstants.createClassAndSelector;
        /**
         * Renders a donut chart.
         */
        var DonutChart = (function () {
            function DonutChart(options) {
                if (options) {
                    this.sliceWidthRatio = options.sliceWidthRatio;
                    this.animator = options.animator;
                    this.isScrollable = options.isScrollable ? options.isScrollable : false;
                    this.disableGeometricCulling = options.disableGeometricCulling ? options.disableGeometricCulling : false;
                    this.behavior = options.behavior;
                    this.tooltipsEnabled = options.tooltipsEnabled;
                    if (options.smallViewPortProperties) {
                        this.maxHeightToScaleDonutLegend = options.smallViewPortProperties.maxHeightToScaleDonutLegend;
                    }
                }
                if (this.sliceWidthRatio == null) {
                    this.sliceWidthRatio = DonutChart.defaultSliceWidthRatio;
                }
            }
            DonutChart.converter = function (dataView, colors, defaultDataPointColor, viewport, disableGeometricCulling, interactivityService, tooltipsEnabled) {
                if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                var converter = new DonutChartConversion.DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled);
                converter.convert();
                var d3PieLayout = d3.layout.pie()
                    .sort(null)
                    .value(function (d) {
                    return d.percentage;
                });
                if (interactivityService) {
                    interactivityService.applySelectionStateToData(converter.dataPoints);
                    interactivityService.applySelectionStateToData(converter.legendData.dataPoints);
                }
                var culledDataPoints = (!disableGeometricCulling && viewport) ? DonutChart.cullDataByViewport(converter.dataPoints, converter.maxValue, viewport) : converter.dataPoints;
                return {
                    dataPointsToDeprecate: culledDataPoints,
                    dataPoints: d3PieLayout(culledDataPoints),
                    unCulledDataPoints: converter.dataPoints,
                    dataPointsToEnumerate: converter.legendData.dataPoints,
                    legendData: converter.legendData,
                    hasHighlights: converter.hasHighlights,
                    dataLabelsSettings: converter.dataLabelsSettings,
                    legendObjectProperties: converter.legendObjectProperties,
                    maxValue: converter.maxValue,
                    visibleGeometryCulled: converter.dataPoints.length !== culledDataPoints.length,
                };
            };
            DonutChart.prototype.init = function (options) {
                this.options = options;
                var element = options.element;
                // Ensure viewport is empty on init
                element.empty();
                this.parentViewport = options.viewport;
                // avoid deep copy
                this.currentViewport = {
                    height: options.viewport.height,
                    width: options.viewport.width,
                };
                this.formatter = visuals.valueFormatter.format;
                this.data = {
                    dataPointsToDeprecate: [],
                    dataPointsToEnumerate: [],
                    dataPoints: [],
                    unCulledDataPoints: [],
                    legendData: { title: "", dataPoints: [], fontSize: visuals.SVGLegend.DefaultFontSizeInPt },
                    hasHighlights: false,
                    dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                };
                this.drilled = false;
                // Leaving this false for now, will depend on the datacategory in the future
                this.allowDrilldown = false;
                this.style = options.style;
                this.colors = this.style.colorPalette.dataColors;
                this.radius = 0;
                this.isInteractive = options.interactivity && options.interactivity.isInteractiveLegend;
                var donutChartSettings = this.settings;
                if (this.behavior) {
                    this.interactivityService = visuals.createInteractivityService(options.host);
                }
                this.legend = visuals.createLegend(element, options.interactivity && options.interactivity.isInteractiveLegend, this.interactivityService, this.isScrollable);
                this.hostService = options.host;
                if (this.isInteractive) {
                    this.chartRotationAnimationDuration = (donutChartSettings && donutChartSettings.chartRotationAnimationDuration) ? donutChartSettings.chartRotationAnimationDuration : 0;
                    // Create interactive legend
                    var legendContainer = this.legendContainer = d3.select(element.get(0))
                        .append('div')
                        .classed(DonutChart.InteractiveLegendClassName, true);
                    this.interactivityState = {
                        interactiveLegend: new DonutChartInteractiveLegend(this, legendContainer, this.colors, options, this.settings),
                        valueToAngleFactor: 0,
                        sliceAngles: [],
                        currentRotate: 0,
                        interactiveChosenSliceFinishedSetting: false,
                        lastChosenInteractiveSliceIndex: 0,
                        totalDragAngleDifference: 0,
                        currentIndexDrag: 0,
                        previousIndexDrag: 0,
                        previousDragAngle: 0,
                        donutCenter: { x: 0, y: 0 },
                    };
                }
                this.svg = d3.select(element.get(0))
                    .append('svg')
                    .style('position', 'absolute')
                    .classed(DonutChart.ClassName, true);
                if (this.behavior)
                    this.clearCatcher = visuals.appendClearCatcher(this.svg);
                this.mainGraphicsContext = this.svg.append('g');
                this.mainGraphicsContext.append("g")
                    .classed('slices', true);
                this.labelGraphicsContext = this.svg
                    .append("g")
                    .classed(visuals.NewDataLabelUtils.labelGraphicsContextClass.class, true);
                this.pie = d3.layout.pie()
                    .sort(null)
                    .value(function (d) {
                    return d.percentage;
                });
            };
            DonutChart.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                // Viewport resizing
                var viewport = options.viewport;
                this.parentViewport = viewport;
                var dataViews = this.dataViews = options.dataViews;
                if (dataViews && dataViews.length > 0 && dataViews[0].categorical) {
                    var dataViewMetadata = dataViews[0].metadata;
                    var defaultDataPointColor = undefined;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            defaultDataPointColor = powerbi.DataViewObjects.getFillColor(objects, visuals.donutChartProps.dataPoint.defaultColor);
                        }
                    }
                    this.data = DonutChart.converter(dataViews[0], this.colors, defaultDataPointColor, this.currentViewport, this.disableGeometricCulling, this.interactivityService, this.tooltipsEnabled);
                    this.data.defaultDataPointColor = defaultDataPointColor;
                    if (!(this.options.interactivity && this.options.interactivity.isInteractiveLegend))
                        this.renderLegend();
                }
                else {
                    this.data = {
                        dataPointsToDeprecate: [],
                        dataPointsToEnumerate: [],
                        dataPoints: [],
                        unCulledDataPoints: [],
                        legendData: { title: "", dataPoints: [] },
                        hasHighlights: false,
                        dataLabelsSettings: visuals.dataLabelUtils.getDefaultDonutLabelSettings(),
                    };
                }
                this.initViewportDependantProperties();
                this.initDonutProperties();
                this.updateInternal(this.data, options.suppressAnimations);
                this.hasSetData = true;
                if (dataViews) {
                    var warnings = visuals.getInvalidValueWarnings(dataViews, false /*supportsNaN*/, false /*supportsNegativeInfinity*/, false /*supportsPositiveInfinity*/);
                    this.hostService.setWarnings(warnings);
                }
            };
            DonutChart.prototype.onDataChanged = function (options) {
                debug.assertValue(options, 'options');
                this.update({
                    dataViews: options.dataViews,
                    suppressAnimations: options.suppressAnimations,
                    viewport: this.currentViewport,
                });
            };
            DonutChart.prototype.onResizing = function (viewport) {
                this.update({
                    dataViews: this.dataViews,
                    suppressAnimations: true,
                    viewport: viewport,
                });
            };
            DonutChart.prototype.enumerateObjectInstances = function (options) {
                var enumeration = new visuals.ObjectEnumerationBuilder();
                var dataLabelsSettings = this.data && this.data.dataLabelsSettings
                    ? this.data.dataLabelsSettings
                    : visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                switch (options.objectName) {
                    case 'legend':
                        this.enumerateLegend(enumeration);
                        break;
                    case 'dataPoint':
                        this.enumerateDataPoints(enumeration);
                        break;
                    case 'labels':
                        var labelSettingOptions = {
                            enumeration: enumeration,
                            dataLabelsSettings: dataLabelsSettings,
                            show: true,
                            displayUnits: true,
                            precision: true,
                            fontSize: true,
                            labelStyle: true,
                        };
                        visuals.dataLabelUtils.enumerateDataLabels(labelSettingOptions);
                        break;
                }
                return enumeration.complete();
            };
            DonutChart.prototype.enumerateDataPoints = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var dataPoints = data.dataPointsToEnumerate;
                var dataPointsLength = dataPoints.length;
                for (var i = 0; i < dataPointsLength; i++) {
                    var dataPoint = dataPoints[i];
                    enumeration.pushInstance({
                        objectName: 'dataPoint',
                        displayName: dataPoint.label,
                        selector: visuals.ColorHelper.normalizeSelector(dataPoint.identity.getSelector()),
                        properties: {
                            fill: { solid: { color: dataPoint.color } }
                        },
                    });
                }
            };
            DonutChart.prototype.enumerateLegend = function (enumeration) {
                var data = this.data;
                if (!data)
                    return;
                var legendObjectProperties = { legend: data.legendObjectProperties };
                var show = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.show, this.legend.isVisible());
                var showTitle = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.showTitle, true);
                var titleText = powerbi.DataViewObjects.getValue(legendObjectProperties, visuals.donutChartProps.legend.titleText, this.data.legendData.title);
                var labelColor = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.labelColor, this.data.legendData.labelColor);
                var labelFontSize = powerbi.DataViewObject.getValue(legendObjectProperties, visuals.legendProps.fontSize, this.data.legendData.fontSize);
                enumeration.pushInstance({
                    selector: null,
                    objectName: 'legend',
                    properties: {
                        show: show,
                        position: visuals.LegendPosition[this.legend.getOrientation()],
                        showTitle: showTitle,
                        titleText: titleText,
                        labelColor: labelColor,
                        fontSize: labelFontSize
                    }
                });
            };
            DonutChart.prototype.setInteractiveChosenSlice = function (sliceIndex) {
                var _this = this;
                if (this.interactivityState.sliceAngles.length === 0)
                    return;
                this.interactivityState.lastChosenInteractiveSliceIndex = sliceIndex;
                this.interactivityState.interactiveChosenSliceFinishedSetting = false;
                var viewport = this.currentViewport;
                var moduledIndex = sliceIndex % this.data.dataPoints.length;
                var angle = this.interactivityState.sliceAngles[moduledIndex];
                this.svg.select('g')
                    .transition()
                    .duration(this.chartRotationAnimationDuration)
                    .ease('elastic')
                    .attr('transform', visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, angle))
                    .each('end', function () { _this.interactivityState.interactiveChosenSliceFinishedSetting = true; });
                this.interactivityState.currentRotate = angle;
                this.interactivityState.interactiveLegend.updateLegend(moduledIndex);
                // Set the opacity of chosen slice to full and the others to semi-transparent
                this.svg.selectAll('.slice').attr('opacity', function (d, index) {
                    return index === moduledIndex ? 1 : 0.6;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.calculateRadius = function () {
                var viewport = this.currentViewport;
                if (!this.isInteractive && this.data && this.data.dataLabelsSettings.show) {
                    // if we have category or data labels, use a sigmoid to blend the desired denominator from 2 to 3.
                    // if we are taller than we are wide, we need to use a larger denominator to leave horizontal room for the labels.
                    var hw = viewport.height / viewport.width;
                    var denom = 2 + (1 / (1 + Math.exp(-5 * (hw - 1))));
                    return Math.min(viewport.height, viewport.width) / denom;
                }
                // no labels (isInteractive does not have labels since the interactive legend shows extra info)
                return Math.min(viewport.height, viewport.width) / 2;
            };
            DonutChart.prototype.getScaleForLegendArrow = function () {
                var ratio = 1.0;
                if (this.maxHeightToScaleDonutLegend && this.currentViewport.height < this.maxHeightToScaleDonutLegend) {
                    ratio = this.currentViewport.height / this.maxHeightToScaleDonutLegend;
                }
                return ratio;
            };
            DonutChart.prototype.initViewportDependantProperties = function (duration) {
                if (duration === void 0) { duration = 0; }
                this.currentViewport.height = this.parentViewport.height;
                this.currentViewport.width = this.parentViewport.width;
                var viewport = this.currentViewport;
                if (this.isInteractive) {
                    viewport.height -= DonutChart.InteractiveLegendContainerHeight; // leave space for the legend
                }
                else {
                    var legendMargins = this.legend.getMargins();
                    viewport.height -= legendMargins.height;
                    viewport.width -= legendMargins.width;
                }
                this.svg.attr({
                    'width': viewport.width,
                    'height': viewport.height
                });
                if (this.isInteractive) {
                    this.legendContainer
                        .style({
                        'width': '100%',
                        'height': DonutChart.InteractiveLegendContainerHeight + 'px',
                        'overflow': 'hidden',
                        'top': 0
                    });
                    this.svg
                        .style('top', DonutChart.InteractiveLegendContainerHeight);
                }
                else {
                    visuals.Legend.positionChartArea(this.svg, this.legend);
                }
                this.previousRadius = this.radius;
                var radius = this.radius = this.calculateRadius();
                var halfViewportWidth = viewport.width / 2;
                var halfViewportHeight = viewport.height / 2;
                this.arc = d3.svg.arc();
                this.outerArc = d3.svg.arc()
                    .innerRadius(radius * DonutChart.OuterArcRadiusRatio)
                    .outerRadius(radius * DonutChart.OuterArcRadiusRatio);
                if (this.isInteractive) {
                    this.mainGraphicsContext.attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
                    this.labelGraphicsContext.attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
                }
                else {
                    this.mainGraphicsContext.transition().duration(duration).attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
                    this.labelGraphicsContext.transition().duration(duration).attr('transform', visuals.SVGUtil.translate(halfViewportWidth, halfViewportHeight));
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.initDonutProperties = function () {
                this.donutProperties = {
                    viewport: this.currentViewport,
                    radius: this.radius,
                    arc: this.arc.innerRadius(0).outerRadius(this.radius * DonutChart.InnerArcRadiusRatio),
                    outerArc: this.outerArc,
                    innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio,
                    outerArcRadiusRatio: DonutChart.OuterArcRadiusRatio,
                    dataLabelsSettings: this.data.dataLabelsSettings,
                };
            };
            DonutChart.prototype.mergeDatasets = function (first, second) {
                var secondSet = d3.set();
                second.forEach(function (d) {
                    secondSet.add(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                });
                var onlyFirst = first.filter(function (d) {
                    return !secondSet.has(d.identity ? d.identity.getKey() : d.data.identity.getKey());
                }).map(function (d) {
                    var derived = powerbi.Prototype.inherit(d);
                    derived.percentage === undefined ? derived.data.percentage = 0 : derived.percentage = 0;
                    return derived;
                });
                return d3.merge([second, onlyFirst]);
            };
            DonutChart.prototype.updateInternal = function (data, suppressAnimations, duration) {
                if (duration === void 0) { duration = 0; }
                var viewport = this.currentViewport;
                duration = duration || visuals.AnimatorCommon.GetAnimationDuration(this.animator, suppressAnimations);
                if (this.animator) {
                    var layout = DonutChart.getLayout(this.radius, this.sliceWidthRatio, viewport);
                    var result = void 0;
                    var shapes_1;
                    var highlightShapes = void 0;
                    var labelSettings = data.dataLabelsSettings;
                    var labels = [];
                    if (labelSettings && labelSettings.show) {
                        labels = this.createLabels();
                    }
                    if (!suppressAnimations) {
                        var animationOptions = {
                            viewModel: data,
                            colors: this.colors,
                            graphicsContext: this.mainGraphicsContext,
                            labelGraphicsContext: this.labelGraphicsContext,
                            interactivityService: this.interactivityService,
                            layout: layout,
                            radius: this.radius,
                            sliceWidthRatio: this.sliceWidthRatio,
                            viewport: viewport,
                            labels: labels,
                            innerArcRadiusRatio: DonutChart.InnerArcRadiusRatio,
                        };
                        result = this.animator.animate(animationOptions);
                        shapes_1 = result.shapes;
                        highlightShapes = result.highlightShapes;
                    }
                    if (suppressAnimations || result.failed) {
                        shapes_1 = DonutChart.drawDefaultShapes(this.svg, data, layout, this.colors, this.radius, this.interactivityService && this.interactivityService.hasSelection(), this.sliceWidthRatio, this.data.defaultDataPointColor);
                        highlightShapes = DonutChart.drawDefaultHighlightShapes(this.svg, data, layout, this.colors, this.radius, this.sliceWidthRatio);
                        visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, true, true /*has tooltip */);
                        visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels);
                    }
                    this.assignInteractions(shapes_1, highlightShapes, data);
                    if (this.tooltipsEnabled) {
                        visuals.TooltipManager.addTooltip(shapes_1, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                        visuals.TooltipManager.addTooltip(highlightShapes, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    }
                }
                else {
                    this.updateInternalToMove(data, duration);
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
            };
            DonutChart.prototype.createLabels = function () {
                var labelLayout = new powerbi.DonutLabelLayout({
                    maximumOffset: visuals.NewDataLabelUtils.maxLabelOffset,
                    startingOffset: visuals.NewDataLabelUtils.startingLabelOffset
                }, this.donutProperties);
                var labelDataPoints = this.createLabelDataPoints();
                return labelLayout.layout(labelDataPoints);
            };
            DonutChart.prototype.createLabelDataPoints = function () {
                var data = this.data;
                var labelDataPoints = [];
                var measureFormatterCache = visuals.dataLabelUtils.createColumnFormatterCacheManager();
                var alternativeScale = null;
                if (data.dataLabelsSettings.displayUnits === 0)
                    alternativeScale = d3.max(data.dataPoints, function (d) { return Math.abs(d.data.measure); });
                for (var i = 0; i < this.data.dataPoints.length; i++) {
                    var label = this.createLabelDataPoint(data.dataPoints[i], alternativeScale, measureFormatterCache);
                    labelDataPoints.push(label);
                }
                return labelDataPoints;
            };
            DonutChart.prototype.createLabelDataPoint = function (d, alternativeScale, measureFormatterCache) {
                var labelPoint = this.outerArc.centroid(d);
                var labelX = visuals.DonutLabelUtils.getXPositionForDonutLabel(labelPoint[0]);
                var labelY = labelPoint[1];
                var labelSettings = this.data.dataLabelsSettings;
                var measureFormatter = measureFormatterCache.getOrCreate(d.data.labelFormatString, labelSettings, alternativeScale);
                var position = labelX < 0 ? 4 /* Left */ : 8 /* Right */;
                var pointPosition = {
                    point: {
                        x: labelX,
                        y: labelY,
                    },
                    validPositions: [position],
                    radius: 0,
                };
                var outsideFill = labelSettings.labelColor ? labelSettings.labelColor : visuals.NewDataLabelUtils.defaultLabelColor;
                var dataLabel;
                var dataLabelSize;
                var categoryLabel;
                var categoryLabelSize;
                var textSize;
                var labelSettingsStyle = labelSettings.labelStyle;
                var fontSize = labelSettings.fontSize;
                var tooltip = "";
                if (labelSettingsStyle === visuals.labelStyle.both || labelSettingsStyle === visuals.labelStyle.data) {
                    dataLabel = measureFormatter.format(d.data.highlightValue != null ? d.data.highlightValue : d.data.measure);
                    dataLabelSize = visuals.NewDataLabelUtils.getTextSize(dataLabel, fontSize);
                }
                if (labelSettingsStyle === visuals.labelStyle.both || labelSettingsStyle === visuals.labelStyle.category) {
                    categoryLabel = d.data.label;
                    categoryLabelSize = visuals.NewDataLabelUtils.getTextSize(categoryLabel, fontSize);
                }
                switch (labelSettingsStyle) {
                    case visuals.labelStyle.both:
                        var text = categoryLabel + " (" + dataLabel + ")";
                        tooltip = text;
                        textSize = visuals.NewDataLabelUtils.getTextSize(text, fontSize);
                        break;
                    case visuals.labelStyle.category:
                        textSize = _.clone(categoryLabelSize);
                        tooltip = categoryLabel;
                        break;
                    case visuals.labelStyle.data:
                        textSize = _.clone(dataLabelSize);
                        tooltip = dataLabel;
                        break;
                }
                var leaderLinePoints = visuals.DonutLabelUtils.getLabelLeaderLineForDonutChart(d, this.donutProperties, pointPosition.point);
                var leaderLinesSize = visuals.DonutLabelUtils.getLabelLeaderLinesSizeForDonutChart(leaderLinePoints);
                return {
                    isPreferred: true,
                    text: "",
                    tooltip: tooltip,
                    textSize: textSize,
                    outsideFill: outsideFill,
                    fontSize: fontSize,
                    identity: d.data.identity,
                    parentShape: pointPosition,
                    insideFill: visuals.NewDataLabelUtils.defaultInsideLabelColor,
                    parentType: 0 /* Point */,
                    alternativeScale: alternativeScale,
                    donutArcDescriptor: d,
                    angle: (d.startAngle + d.endAngle) / 2 - (Math.PI / 2),
                    dataLabel: dataLabel,
                    dataLabelSize: dataLabelSize,
                    categoryLabel: categoryLabel,
                    categoryLabelSize: categoryLabelSize,
                    leaderLinePoints: leaderLinePoints,
                    linesSize: leaderLinesSize,
                };
            };
            DonutChart.prototype.renderLegend = function () {
                if (!this.isInteractive) {
                    var legendObjectProperties = this.data.legendObjectProperties;
                    if (legendObjectProperties) {
                        var legendData = this.data.legendData;
                        visuals.LegendData.update(legendData, legendObjectProperties);
                        var position = legendObjectProperties[visuals.legendProps.position];
                        if (position)
                            this.legend.changeOrientation(visuals.LegendPosition[position]);
                        this.legend.drawLegend(legendData, this.parentViewport);
                    }
                    else {
                        this.legend.changeOrientation(visuals.LegendPosition.Top);
                        this.legend.drawLegend({ dataPoints: [] }, this.parentViewport);
                    }
                }
            };
            DonutChart.prototype.addInteractiveLegendArrow = function () {
                if (!this.data || !this.data.dataPoints || this.data.dataPoints.length === 0)
                    return;
                var arrowHeightOffset = 11;
                var arrowWidthOffset = 33 / 2;
                if (!this.interactiveLegendArrow) {
                    var interactiveLegendArrow = this.svg.append('g');
                    interactiveLegendArrow.append('path')
                        .classed(DonutChart.InteractiveLegendArrowClassName, true)
                        .attr('d', 'M1.5,2.6C0.65,1.15,1.85,0,3,0l27,0c1.65,0,2.35,1.15,1.5,2.6L18,26.45c-0.8,1.45-2.15,1.45-2.95,0L1.95,2.6z');
                    this.interactiveLegendArrow = interactiveLegendArrow;
                }
                var viewport = this.currentViewport;
                // Calculate the offsets from the legend container to the arrow.
                var scaleRatio = this.getScaleForLegendArrow();
                var distanceBetweenLegendAndArrow = (viewport.height - 2 * this.radius) / 2 + (arrowHeightOffset * scaleRatio);
                var middleOfChart = viewport.width / 2 - (arrowWidthOffset * scaleRatio);
                this.interactiveLegendArrow.attr('transform', visuals.SVGUtil.translateAndScale(middleOfChart, distanceBetweenLegendAndArrow, scaleRatio));
            };
            DonutChart.prototype.calculateSliceAngles = function () {
                var angles = [];
                var data = this.data.dataPoints;
                if (data.length === 0) {
                    this.interactivityState.valueToAngleFactor = 0;
                    this.interactivityState.sliceAngles = [];
                    return;
                }
                var sum = 0;
                for (var i = 0, ilen = data.length; i < ilen; i++) {
                    sum += data[i].data.percentage; // value is an absolute number
                }
                debug.assert(sum !== 0, 'sum of slices values cannot be zero');
                this.interactivityState.valueToAngleFactor = 360 / sum; // Calculate the ratio between 360 and the sum to know the angles to rotate by
                var currentAngle = 0;
                for (var i = 0, ilen = data.length; i < ilen; i++) {
                    var relativeAngle = data[i].data.percentage * this.interactivityState.valueToAngleFactor;
                    currentAngle += relativeAngle;
                    angles.push((relativeAngle / 2) - currentAngle);
                }
                this.interactivityState.sliceAngles = angles;
            };
            DonutChart.prototype.assignInteractions = function (slices, highlightSlices, data) {
                // assign interactions according to chart interactivity type
                if (this.isInteractive) {
                    this.assignInteractiveChartInteractions(slices);
                }
                else if (this.interactivityService) {
                    var dataPoints = data.dataPoints.map(function (value) { return value.data; });
                    var behaviorOptions = {
                        clearCatcher: this.clearCatcher,
                        slices: slices,
                        highlightSlices: highlightSlices,
                        allowDrilldown: this.allowDrilldown,
                        visual: this,
                        hasHighlights: data.hasHighlights,
                        svg: this.svg,
                    };
                    this.interactivityService.bind(dataPoints, this.behavior, behaviorOptions);
                }
            };
            DonutChart.prototype.setDrilldown = function (selection) {
                if (selection) {
                    var d3PieLayout = d3.layout.pie()
                        .sort(null)
                        .value(function (d) {
                        return d.percentage;
                    });
                    // Drill into the current selection.
                    var legendDataPoints = [{ label: selection.label, color: selection.color, icon: visuals.LegendIcon.Box, identity: selection.identity, selected: selection.selected }];
                    var legendData = { title: "", dataPoints: legendDataPoints };
                    var drilledDataPoints = d3PieLayout(selection.internalDataPoints);
                    this.updateInternal({
                        dataPointsToDeprecate: selection.internalDataPoints,
                        dataPoints: drilledDataPoints,
                        unCulledDataPoints: drilledDataPoints.map(function (value) { return value.data; }),
                        legendData: legendData,
                        hasHighlights: false,
                        dataLabelsSettings: this.data.dataLabelsSettings,
                    }, false /* suppressAnimations */, DonutChart.DrillDownAnimationDuration);
                }
                else {
                    // Pop out of drill down to view the "outer" data.
                    this.updateInternal(this.data, false /* suppressAnimations */, DonutChart.DrillDownAnimationDuration);
                }
            };
            DonutChart.prototype.assignInteractiveChartInteractions = function (slice) {
                var _this = this;
                var svg = this.svg;
                this.interactivityState.interactiveChosenSliceFinishedSetting = true;
                var svgRect = svg.node().getBoundingClientRect();
                this.interactivityState.donutCenter = { x: svgRect.left + svgRect.width / 2, y: svgRect.top + svgRect.height / 2 }; // Center of the donut chart
                this.interactivityState.totalDragAngleDifference = 0;
                this.interactivityState.currentRotate = 0;
                this.calculateSliceAngles();
                // Set the on click method for the slices so thsete pie chart will turn according to each slice's corresponding angle [the angle its on top]
                slice.on('click', function (d, clickedIndex) {
                    if (d3.event.defaultPrevented)
                        return; // click was suppressed, for example from drag event
                    _this.setInteractiveChosenSlice(clickedIndex);
                });
                // Set the drag events
                var drag = d3.behavior.drag()
                    .origin(Object)
                    .on('dragstart', function () { return _this.interactiveDragStart(); })
                    .on('drag', function () { return _this.interactiveDragMove(); })
                    .on('dragend', function () { return _this.interactiveDragEnd(); });
                svg
                    .style('touch-action', 'none')
                    .call(drag);
            };
            /**
             * Get the angle (in degrees) of the drag event coordinates.
             * The angle is calculated against the plane of the center of the donut
             * (meaning, when the center of the donut is at (0,0) coordinates).
             */
            DonutChart.prototype.getAngleFromDragEvent = function () {
                var interactivityState = this.interactivityState;
                // get pageX and pageY (coordinates of the drag event) according to event type
                var pageX, pageY;
                var sourceEvent = d3.event.sourceEvent;
                // check if that's a touch event or not
                if (sourceEvent.type.toLowerCase().indexOf('touch') !== -1) {
                    if (sourceEvent.touches.length !== 1)
                        return null; // in case there isn't a single touch - return null and do nothing.
                    // take the first, single, touch surface.
                    var touch = sourceEvent.touches[0];
                    pageX = touch.pageX;
                    pageY = touch.pageY;
                }
                else {
                    pageX = sourceEvent.pageX;
                    pageY = sourceEvent.pageY;
                }
                // Adjust the coordinates, putting the donut center as the (0,0) coordinates
                var adjustedCoordinates = { x: pageX - interactivityState.donutCenter.x, y: -pageY + interactivityState.donutCenter.y };
                // Move to polar axis - take only the angle (theta), and convert to degrees
                var angleToThePlane = Math.atan2(adjustedCoordinates.y, adjustedCoordinates.x) * 180 / Math.PI;
                return angleToThePlane;
            };
            DonutChart.prototype.interactiveDragStart = function () {
                this.interactivityState.totalDragAngleDifference = 0;
                this.interactivityState.previousDragAngle = this.getAngleFromDragEvent();
            };
            DonutChart.prototype.interactiveDragMove = function () {
                var data = this.data.dataPoints;
                var viewport = this.currentViewport;
                var interactivityState = this.interactivityState;
                if (interactivityState.interactiveChosenSliceFinishedSetting === true) {
                    // get current angle from the drag event
                    var currentDragAngle = this.getAngleFromDragEvent();
                    if (!currentDragAngle)
                        return; // if no angle was returned, do nothing
                    // compare it to the previous drag event angle
                    var angleDragDiff = interactivityState.previousDragAngle - currentDragAngle;
                    interactivityState.totalDragAngleDifference += angleDragDiff;
                    interactivityState.previousDragAngle = currentDragAngle;
                    // Rotate the chart by the difference in angles
                    interactivityState.currentRotate += angleDragDiff;
                    // Rotate the chart to the current rotate angle
                    this.svg.select('g')
                        .attr('transform', visuals.SVGUtil.translateAndRotate(viewport.width / 2, viewport.height / 2, 0, 0, this.interactivityState.currentRotate));
                    var currentHigherLimit = data[0].data.percentage * interactivityState.valueToAngleFactor;
                    var currentAngle = interactivityState.currentRotate <= 0 ? (interactivityState.currentRotate * -1) % 360 : (360 - (interactivityState.currentRotate % 360));
                    interactivityState.currentIndexDrag = 0;
                    //consider making this  ++interactivityState.currentIndexDrag ? then you don't need the if statement, the interactivityState.currentIndexDrag +1 and interactivityState.currentIndexDrag++
                    // Check the current index according to the angle 
                    var dataLength = data.length;
                    while ((interactivityState.currentIndexDrag < dataLength) && (currentAngle > currentHigherLimit)) {
                        if (interactivityState.currentIndexDrag < (dataLength - 1)) {
                            currentHigherLimit += (data[interactivityState.currentIndexDrag + 1].data.percentage * interactivityState.valueToAngleFactor);
                        }
                        interactivityState.currentIndexDrag++;
                    }
                    // If the index changed update the legend and opacity
                    if (interactivityState.currentIndexDrag !== interactivityState.previousIndexDrag) {
                        interactivityState.interactiveLegend.updateLegend(interactivityState.currentIndexDrag);
                        // set the opacticity of the top slice to full and the others to semi-transparent
                        this.svg.selectAll('.slice').attr('opacity', function (d, index) {
                            return index === interactivityState.currentIndexDrag ? DonutChart.OpaqueOpacity : DonutChart.SemiTransparentOpacity;
                        });
                        interactivityState.previousIndexDrag = interactivityState.currentIndexDrag;
                    }
                }
            };
            DonutChart.prototype.interactiveDragEnd = function () {
                // If totalDragDifference was changed, means we have a drag event (compared to a click event)
                if (this.interactivityState.totalDragAngleDifference !== 0) {
                    this.setInteractiveChosenSlice(this.interactivityState.currentIndexDrag);
                    // drag happened - disable click event
                    d3.event.sourceEvent.stopPropagation();
                }
            };
            DonutChart.prototype.updateInternalToMove = function (data, duration) {
                if (duration === void 0) { duration = 0; }
                // Cache for performance
                var svg = this.svg;
                var pie = this.pie;
                var key = this.key;
                var arc = this.arc;
                var radius = this.radius;
                var previousRadius = this.previousRadius;
                var sliceWidthRatio = this.sliceWidthRatio;
                var existingData = this.svg.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data().map(function (d) { return d.data; });
                if (existingData.length === 0) {
                    existingData = data.dataPointsToDeprecate;
                }
                var is = this.mergeDatasets(existingData, data.dataPointsToDeprecate);
                var slice = svg.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data(pie(data.dataPointsToDeprecate), key);
                slice.enter()
                    .insert('path')
                    .classed(DonutChart.sliceClass.class, true)
                    .each(function (d) { this._current = d; });
                slice = svg.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data(pie(is), key);
                var innerRadius = radius * sliceWidthRatio;
                DonutChart.isSingleColor(data.dataPoints);
                slice
                    .style('fill', function (d) { return d.data.color; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, false, data.hasHighlights); })
                    .style('stroke', 'white')
                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio); })
                    .style('stroke-width', function (d) { return d.data.strokeWidth; })
                    .transition().duration(duration)
                    .attrTween('d', function (d) {
                    var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, radius * DonutChart.InnerArcRadiusRatio);
                    this._current = i(0);
                    return function (t) {
                        return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                    };
                });
                slice = svg.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data(pie(data.dataPointsToDeprecate), key);
                slice.exit()
                    .transition()
                    .delay(duration)
                    .duration(0)
                    .remove();
                // For interactive chart, there shouldn't be slice labels (as you have the legend).
                if (!this.isInteractive) {
                    var labelSettings = data.dataLabelsSettings;
                    var labels = [];
                    if (labelSettings && labelSettings.show) {
                        labels = this.createLabels();
                    }
                    visuals.NewDataLabelUtils.drawDefaultLabels(this.labelGraphicsContext, labels, false, true);
                    visuals.NewDataLabelUtils.drawLabelLeaderLines(this.labelGraphicsContext, labels);
                }
                var highlightSlices = undefined;
                if (data.hasHighlights) {
                    // Draw partial highlight slices.
                    highlightSlices = svg
                        .select('.slices')
                        .selectAll('path' + DonutChart.sliceHighlightClass.selector)
                        .data(pie(data.dataPointsToDeprecate), key);
                    highlightSlices
                        .enter()
                        .insert('path')
                        .classed(DonutChart.sliceHighlightClass.class, true)
                        .each(function (d) { this._current = d; });
                    DonutChart.isSingleColor(data.dataPoints);
                    highlightSlices
                        .style('fill', function (d) { return d.data.color; })
                        .style('fill-opacity', 1.0)
                        .style('stroke', 'white')
                        .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio); })
                        .style('stroke-width', function (d) { return d.data.highlightRatio === 0 ? 0 : d.data.strokeWidth; })
                        .transition().duration(duration)
                        .attrTween('d', function (d) {
                        var i = d3.interpolate(this._current, d), k = d3.interpolate(previousRadius * DonutChart.InnerArcRadiusRatio, DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                        this._current = i(0);
                        return function (t) {
                            return arc.innerRadius(innerRadius).outerRadius(k(t))(i(t));
                        };
                    });
                    highlightSlices
                        .exit()
                        .transition()
                        .delay(duration)
                        .duration(0)
                        .remove();
                }
                else {
                    svg
                        .selectAll('path' + DonutChart.sliceHighlightClass.selector)
                        .transition()
                        .delay(duration)
                        .duration(0)
                        .remove();
                }
                this.assignInteractions(slice, highlightSlices, data);
                if (this.tooltipsEnabled) {
                    visuals.TooltipManager.addTooltip(slice, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    if (data.hasHighlights) {
                        visuals.TooltipManager.addTooltip(highlightSlices, function (tooltipEvent) { return tooltipEvent.data.data.tooltipInfo; });
                    }
                }
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.options);
                if (this.isInteractive) {
                    this.addInteractiveLegendArrow();
                    this.interactivityState.interactiveLegend.drawLegend(this.data.dataPointsToDeprecate);
                    this.setInteractiveChosenSlice(this.interactivityState.lastChosenInteractiveSliceIndex ? this.interactivityState.lastChosenInteractiveSliceIndex : 0);
                }
            };
            DonutChart.drawDefaultShapes = function (graphicsContext, donutData, layout, colors, radius, hasSelection, sliceWidthRatio, defaultColor) {
                var shapes = graphicsContext.select('.slices')
                    .selectAll('path' + DonutChart.sliceClass.selector)
                    .data(donutData.dataPoints, function (d) { return d.data.identity.getKey(); });
                shapes.enter()
                    .insert('path')
                    .classed(DonutChart.sliceClass.class, true);
                DonutChart.isSingleColor(donutData.dataPoints);
                shapes
                    .style('fill', function (d) { return d.data.color; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, false, hasSelection, donutData.hasHighlights); })
                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio); })
                    .style('stroke-width', function (d) { return d.data.strokeWidth; })
                    .attr(layout.shapeLayout);
                shapes.exit()
                    .remove();
                return shapes;
            };
            DonutChart.drawDefaultHighlightShapes = function (graphicsContext, donutData, layout, colors, radius, sliceWidthRatio) {
                var shapes = graphicsContext.select('.slices')
                    .selectAll('path' + DonutChart.sliceHighlightClass.selector)
                    .data(donutData.dataPoints.filter(function (value) { return value.data.highlightRatio != null; }), function (d) { return d.data.identity.getKey(); });
                shapes.enter()
                    .insert('path')
                    .classed(DonutChart.sliceHighlightClass.class, true)
                    .each(function (d) { this._current = d; });
                DonutChart.isSingleColor(donutData.dataPoints);
                shapes
                    .style('fill', function (d) { return d.data.color; })
                    .style('fill-opacity', function (d) { return visuals.ColumnUtil.getFillOpacity(d.data.selected, true, false, donutData.hasHighlights); })
                    .style('stroke', 'white')
                    .style('stroke-dasharray', function (d) { return DonutChart.drawStrokeForDonutChart(radius, DonutChart.InnerArcRadiusRatio, d, sliceWidthRatio, d.data.highlightRatio); })
                    .style('stroke-width', function (d) { return d.data.highlightRatio === 0 ? 0 : d.data.strokeWidth; })
                    .attr(layout.highlightShapeLayout);
                shapes.exit()
                    .remove();
                return shapes;
            };
            /**
                Set true to the last data point when all slices have the same color
            */
            DonutChart.isSingleColor = function (dataPoints) {
                if (dataPoints.length > 1) {
                    var lastPoint = dataPoints.length - 1;
                    dataPoints[lastPoint].data.isLastInDonut = dataPoints[lastPoint].data.color === dataPoints[0].data.color;
                }
            };
            DonutChart.drawStrokeForDonutChart = function (radius, innerArcRadiusRatio, d, sliceWidthRatio, highlightRatio) {
                if (highlightRatio === void 0) { highlightRatio = 1; }
                var sliceRadius = radius * innerArcRadiusRatio * highlightRatio;
                var sliceArc = (d.endAngle - d.startAngle) * sliceRadius;
                var sectionWithoutStroke;
                var sectionWithStroke;
                /*Donut chart*/
                if (sliceWidthRatio) {
                    var innerRadius = radius * sliceWidthRatio;
                    var outerRadius = highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
                    var innerSliceArc = (d.endAngle - d.startAngle) * innerRadius;
                    if (d.data.highlightRatio)
                        sliceArc = (d.endAngle - d.startAngle) * (outerRadius + innerRadius);
                    if (d.data.isLastInDonut) {
                        //if all slices have the same color, the stroke of the last slice needs to be drawn on both radiuses
                        return 0 + " " + sliceArc + " " + outerRadius + " " + innerSliceArc + " " + outerRadius;
                    }
                    sectionWithoutStroke = sliceArc + outerRadius + innerSliceArc;
                    sectionWithStroke = outerRadius;
                }
                else {
                    if (d.data.isLastInDonut) {
                        //if all slices have the same color, the stroke of the last slice needs to be drawn on both radiuses
                        sectionWithoutStroke = sliceArc;
                        sectionWithStroke = sliceRadius * 2;
                    }
                    else {
                        sectionWithoutStroke = sliceArc + sliceRadius;
                        sectionWithStroke = sliceRadius;
                    }
                }
                return 0 + " " + sectionWithoutStroke + " " + sectionWithStroke;
            };
            DonutChart.prototype.onClearSelection = function () {
                if (this.interactivityService)
                    this.interactivityService.clearSelection();
            };
            DonutChart.getLayout = function (radius, sliceWidthRatio, viewport) {
                var innerRadius = radius * sliceWidthRatio;
                var arc = d3.svg.arc().innerRadius(innerRadius);
                var arcWithRadius = arc.outerRadius(radius * DonutChart.InnerArcRadiusRatio);
                return {
                    shapeLayout: {
                        d: function (d) {
                            return arcWithRadius(d);
                        }
                    },
                    highlightShapeLayout: {
                        d: function (d) {
                            var highlightArc = arc.outerRadius(DonutChart.getHighlightRadius(radius, sliceWidthRatio, d.data.highlightRatio));
                            return highlightArc(d);
                        }
                    },
                    zeroShapeLayout: {
                        d: function (d) {
                            var zeroWithZeroRadius = arc.outerRadius(innerRadius || DonutChart.EffectiveZeroValue);
                            return zeroWithZeroRadius(d);
                        }
                    },
                };
            };
            DonutChart.getHighlightRadius = function (radius, sliceWidthRatio, highlightRatio) {
                var innerRadius = radius * sliceWidthRatio;
                return innerRadius + highlightRatio * radius * (DonutChart.InnerArcRadiusRatio - sliceWidthRatio);
            };
            DonutChart.cullDataByViewport = function (dataPoints, maxValue, viewport) {
                var estimatedRadius = Math.min(viewport.width, viewport.height) / 2;
                // Ratio of slice too small to show (invisible) = invisbleArcLength / circumference
                var cullRatio = this.invisibleArcLengthInPixels / (estimatedRadius * DonutChart.twoPi);
                var cullableValue = cullRatio * maxValue;
                var culledDataPoints = [];
                var prevPointColor;
                for (var _i = 0, dataPoints_5 = dataPoints; _i < dataPoints_5.length; _i++) {
                    var datapoint = dataPoints_5[_i];
                    if (datapoint.measure >= cullableValue) {
                        //updates the stroke width
                        datapoint.strokeWidth = prevPointColor === datapoint.color ? 1 : 0;
                        prevPointColor = datapoint.color;
                        culledDataPoints.push(datapoint);
                    }
                }
                return culledDataPoints;
            };
            DonutChart.ClassName = 'donutChart';
            DonutChart.InteractiveLegendClassName = 'donutLegend';
            DonutChart.InteractiveLegendArrowClassName = 'donutLegendArrow';
            DonutChart.DrillDownAnimationDuration = 1000;
            DonutChart.OuterArcRadiusRatio = 0.9;
            DonutChart.InnerArcRadiusRatio = 0.8;
            DonutChart.OpaqueOpacity = 1.0;
            DonutChart.SemiTransparentOpacity = 0.6;
            DonutChart.defaultSliceWidthRatio = 0.48;
            DonutChart.invisibleArcLengthInPixels = 3;
            DonutChart.sliceClass = createClassAndSelector('slice');
            DonutChart.sliceHighlightClass = createClassAndSelector('slice-highlight');
            DonutChart.twoPi = 2 * Math.PI;
            DonutChart.InteractiveLegendContainerHeight = 70;
            DonutChart.EffectiveZeroValue = 0.000000001; // Very small multiplier so that we have a properly shaped zero arc to animate to/from.
            DonutChart.PolylineOpacity = 0.5;
            return DonutChart;
        }());
        visuals.DonutChart = DonutChart;
        /**
        * This class is an interactive legend for the Donut Chart.
         *
         * Features: It is scrollable indefinitely, using drag gesture
         * when you interact with it, it updates the donut chart itself.
        */
        var DonutChartInteractiveLegend = (function () {
            function DonutChartInteractiveLegend(donutChart, legendContainer, colors, visualInitOptions, settings) {
                this.legendContainerParent = legendContainer;
                this.colors = colors;
                this.donutChart = donutChart;
                this.visualInitOptions = visualInitOptions;
                this.legendItemsPositions = [];
                this.legendTransitionAnimationDuration = settings && settings.legendTransitionAnimationDuration ? settings.legendTransitionAnimationDuration : 0;
            }
            DonutChartInteractiveLegend.prototype.drawLegend = function (data) {
                var _this = this;
                this.data = data;
                this.currentNumberOfLegendItems = data.length;
                this.currentIndex = 0;
                this.leftMostIndex = 0;
                this.rightMostIndex = data.length - 1;
                if (this.legendContainerParent.select(DonutChartInteractiveLegend.LegendContainerSelector).empty()) {
                    this.legendContainer = this.legendContainerParent.append('div').classed(DonutChartInteractiveLegend.LegendContainerClassName, true);
                }
                var legendItems = this.legendContainer.selectAll(DonutChartInteractiveLegend.LegendItemSelector).data(data);
                var legendContainerWidth = this.legendContainerWidth = this.legendContainer.node().getBoundingClientRect().width;
                var initialXOffset = legendContainerWidth / 2 - (legendContainerWidth * 0.4 / 2) + DonutChartInteractiveLegend.ItemMargin;
                var currX = initialXOffset;
                this.currentXOffset = initialXOffset;
                // Given the legend item div, create the item values (category, percentage and measure) on top of it.
                var createLegendItem = function (itemDiv, datum) {
                    // position the legend item
                    itemDiv
                        .attr('data-legend-index', datum.index) // assign index for later use
                        .css({
                        'position': 'absolute',
                        'left': currX,
                    });
                    // Add the category, percentage and value
                    var itemCategory = visuals.valueFormatter.format(datum.label);
                    var itemValue = visuals.valueFormatter.format(datum.measure, datum.measureFormat);
                    var itemPercentage = visuals.valueFormatter.format(datum.percentage, '0.00 %;-0.00 %;0.00 %');
                    var itemColor = datum.color;
                    // Create basic spans for width calculations
                    var itemValueSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemValueClassName, itemValue, 11);
                    var itemCategorySpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemCategoryClassName, itemCategory, 11);
                    var itemPercentageSpan = DonutChartInteractiveLegend.createBasicLegendItemSpan(DonutChartInteractiveLegend.LegendItemPercentageClassName, itemPercentage, 20);
                    // Calculate Legend Box size according to widths and set the width accordingly
                    var valueSpanWidth = DonutChartInteractiveLegend.spanWidth(itemValueSpan);
                    var categorySpanWidth = DonutChartInteractiveLegend.spanWidth(itemCategorySpan);
                    var precentageSpanWidth = DonutChartInteractiveLegend.spanWidth(itemPercentageSpan);
                    var currentLegendBoxWidth = DonutChartInteractiveLegend.legendBoxSize(valueSpanWidth, categorySpanWidth, precentageSpanWidth);
                    itemDiv.css('width', currentLegendBoxWidth);
                    // Calculate margins so that all the spans will be placed in the middle
                    var getLeftValue = function (spanWidth) {
                        return currentLegendBoxWidth - spanWidth > 0 ? (currentLegendBoxWidth - spanWidth) / 2 : 0;
                    };
                    var marginLeftValue = getLeftValue(valueSpanWidth);
                    var marginLeftCategory = getLeftValue(categorySpanWidth);
                    var marginLeftPrecentage = getLeftValue(precentageSpanWidth);
                    // Create the actual spans with the right styling and margins so it will be center aligned and add them
                    DonutChartInteractiveLegend.createLegendItemSpan(itemCategorySpan, marginLeftCategory);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemValueSpan, marginLeftValue);
                    DonutChartInteractiveLegend.createLegendItemSpan(itemPercentageSpan, marginLeftPrecentage).css('color', itemColor);
                    itemDiv.append(itemCategorySpan);
                    itemDiv.append(itemPercentageSpan);
                    itemDiv.append(itemValueSpan);
                    _this.legendItemsPositions.push({
                        startX: currX,
                        boxWidth: currentLegendBoxWidth,
                    });
                    currX += currentLegendBoxWidth + DonutChartInteractiveLegend.ItemMargin;
                };
                // Create the Legend Items
                legendItems.enter()
                    .insert('div')
                    .classed(DonutChartInteractiveLegend.LegendItemClassName, true)
                    .each(function (d) {
                    createLegendItem($(this), d);
                });
                legendItems.exit().remove();
                // Assign interactions on the legend
                this.assignInteractions();
            };
            DonutChartInteractiveLegend.prototype.updateLegend = function (sliceIndex) {
                var _this = this;
                var legendContainerWidth = this.legendContainerWidth;
                this.currentIndex = sliceIndex;
                // "rearrange" legend items if needed, so we would have contnious endless scrolling
                this.updateLabelBlocks(sliceIndex);
                var legendTransitionAnimationDuration = this.legendTransitionAnimationDuration;
                // Transform the legend so that the selected slice would be in the middle
                var nextXOffset = (this.legendItemsPositions[sliceIndex].startX + (this.legendItemsPositions[sliceIndex].boxWidth / 2) - (legendContainerWidth / 2)) * (-1);
                this.legendContainer
                    .transition()
                    .styleTween('-webkit-transform', function (d, i, a) {
                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                })
                    .styleTween('transform', function (d, i, a) {
                    return d3.interpolate(visuals.SVGUtil.translateWithPixels(_this.currentXOffset, 0), visuals.SVGUtil.translateWithPixels(nextXOffset, 0));
                })
                    .duration(legendTransitionAnimationDuration)
                    .ease('bounce')
                    .each('end', function () {
                    _this.currentXOffset = nextXOffset;
                });
                visuals.SVGUtil.flushAllD3TransitionsIfNeeded(this.visualInitOptions);
            };
            DonutChartInteractiveLegend.prototype.assignInteractions = function () {
                var _this = this;
                var currentDX = 0; // keep how much drag had happened
                var hasChanged = false; // flag to indicate if we changed the "center" value in the legend. We only change it once per swipe.
                var dragStart = function () {
                    currentDX = 0; // start of drag gesture
                    hasChanged = false;
                };
                var dragMove = function () {
                    currentDX += d3.event.dx;
                    // Detect if swipe occured and if the index already changed in this drag
                    if (hasChanged || Math.abs(currentDX) < DonutChartInteractiveLegend.MinimumSwipeDX)
                        return;
                    var dragDirectionLeft = (currentDX < 0);
                    _this.dragLegend(dragDirectionLeft);
                    hasChanged = true;
                };
                var drag = d3.behavior.drag()
                    .origin(Object)
                    .on('drag', dragMove)
                    .on('dragstart', dragStart);
                this.legendContainer
                    .style({
                    'touch-action': 'none',
                    'cursor': 'pointer'
                })
                    .call(drag);
            };
            DonutChartInteractiveLegend.prototype.dragLegend = function (dragDirectionLeft) {
                if (this.currentNumberOfLegendItems > (DonutChartInteractiveLegend.MinimumItemsInLegendForCycled - 1)) {
                    this.currentIndex = this.getCyclingCurrentIndex(dragDirectionLeft);
                }
                else {
                    if (this.shouldChangeIndexInNonCycling(dragDirectionLeft)) {
                        if (dragDirectionLeft) {
                            this.currentIndex++;
                        }
                        else {
                            this.currentIndex--;
                        }
                    }
                }
                this.donutChart.setInteractiveChosenSlice(this.currentIndex);
            };
            DonutChartInteractiveLegend.prototype.shouldChangeIndexInNonCycling = function (dragDirectionLeft) {
                if ((this.currentIndex === 0 && !dragDirectionLeft) || (this.currentIndex === (this.currentNumberOfLegendItems - 1) && dragDirectionLeft)) {
                    return false;
                }
                return true;
            };
            DonutChartInteractiveLegend.prototype.getCyclingCurrentIndex = function (dragDirectionLeft) {
                var dataLen = this.data.length;
                var delta = dragDirectionLeft ? 1 : -1;
                var newIndex = (this.currentIndex + delta) % (dataLen || 1); // modolu of negative number stays negative on javascript
                return (newIndex < 0) ? newIndex + dataLen : newIndex;
            };
            DonutChartInteractiveLegend.prototype.updateLegendItemsBlocks = function (rightSidedShift, numberOfLegendItemsBlocksToShift) {
                var legendContainer$ = $(this.legendContainer[0]);
                if (rightSidedShift) {
                    var smallestItem = legendContainer$.find('[data-legend-index=' + this.leftMostIndex + ']');
                    smallestItem.remove().insertAfter(legendContainer$.find('[data-legend-index=' + this.rightMostIndex + ']'));
                    var newX = this.legendItemsPositions[this.rightMostIndex].startX + this.legendItemsPositions[this.rightMostIndex].boxWidth + DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.leftMostIndex].startX = newX;
                    smallestItem.css('left', newX);
                    this.rightMostIndex = this.leftMostIndex;
                    this.leftMostIndex = (this.leftMostIndex + 1) % this.data.length;
                }
                else {
                    var highestItem = legendContainer$.find('[data-legend-index=' + this.rightMostIndex + ']');
                    highestItem.remove().insertBefore(legendContainer$.find('[data-legend-index=' + this.leftMostIndex + ']'));
                    var newX = this.legendItemsPositions[this.leftMostIndex].startX - this.legendItemsPositions[this.rightMostIndex].boxWidth - DonutChartInteractiveLegend.ItemMargin;
                    this.legendItemsPositions[this.rightMostIndex].startX = newX;
                    highestItem.css('left', newX);
                    this.leftMostIndex = this.rightMostIndex;
                    this.rightMostIndex = (this.rightMostIndex - 1) === -1 ? (this.legendItemsPositions.length - 1) : (this.rightMostIndex - 1);
                }
                if ((numberOfLegendItemsBlocksToShift - 1) !== 0) {
                    this.updateLegendItemsBlocks(rightSidedShift, (numberOfLegendItemsBlocksToShift - 1));
                }
            };
            /** Update the legend items, allowing for endless rotation */
            DonutChartInteractiveLegend.prototype.updateLabelBlocks = function (index) {
                if (this.currentNumberOfLegendItems > DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
                    // The idea of the four if's is to keep two labels before and after the current one so it will fill the screen.
                    // If the index of the slice is the highest currently availble add 2 labels "ahead" of it
                    if (this.rightMostIndex === index)
                        this.updateLegendItemsBlocks(true, 2);
                    // If the index of the slice is the lowest currently availble add 2 labels "before" it
                    if (this.leftMostIndex === index)
                        this.updateLegendItemsBlocks(false, 2);
                    // If the index of the slice is the second highest currently availble add a labels "ahead" of it
                    if (this.rightMostIndex === (index + 1) || ((this.rightMostIndex === 0) && (index === (this.currentNumberOfLegendItems - 1))))
                        this.updateLegendItemsBlocks(true, 1);
                    // If the index of the slice is the second lowest currently availble add a labels "before" it
                    if (this.leftMostIndex === (index - 1) || ((this.leftMostIndex === (this.currentNumberOfLegendItems - 1) && (index === 0))))
                        this.updateLegendItemsBlocks(false, 1);
                }
                else {
                    if (this.currentNumberOfLegendItems === DonutChartInteractiveLegend.MinimumItemsInLegendForCycled) {
                        // If the index of the slice is the highest currently availble add a label "ahead" of it
                        if (this.rightMostIndex === index)
                            this.updateLegendItemsBlocks(true, 1);
                        // If the index of the slice is the lowest currently availble add a label "before" it
                        if (this.leftMostIndex === index)
                            this.updateLegendItemsBlocks(false, 1);
                    }
                }
            };
            DonutChartInteractiveLegend.createBasicLegendItemSpan = function (spanClass, text, fontSize) {
                return $('<span/>')
                    .addClass(spanClass)
                    .css({
                    'white-space': 'nowrap',
                    'font-size': fontSize + 'px',
                })
                    .text(text);
            };
            /** This method alters the given span and sets it to the final legen item span style. */
            DonutChartInteractiveLegend.createLegendItemSpan = function (existingSpan, marginLeft) {
                existingSpan
                    .css({
                    'overflow': 'hidden',
                    'text-overflow': 'ellipsis',
                    'display': 'inline-block',
                    'width': '100%',
                    'margin-left': marginLeft
                });
                return existingSpan;
            };
            /** Caclulte entire legend box size according to its building spans */
            DonutChartInteractiveLegend.legendBoxSize = function (valueSpanWidth, categorySpanWidth, precentageSpanWidth) {
                var boxSize = valueSpanWidth > categorySpanWidth ? valueSpanWidth : categorySpanWidth;
                boxSize = boxSize > precentageSpanWidth ? boxSize : precentageSpanWidth;
                boxSize = boxSize > DonutChartInteractiveLegend.MaxLegendItemBoxSize ? DonutChartInteractiveLegend.MaxLegendItemBoxSize : (boxSize + 2);
                return boxSize;
            };
            DonutChartInteractiveLegend.spanWidth = function (span) {
                if (!this.FakeElementSpan) {
                    this.FakeElementSpan = $('<span>').hide().appendTo(document.body);
                }
                this.FakeElementSpan.empty();
                this.FakeElementSpan.append(span);
                return this.FakeElementSpan.width();
            };
            DonutChartInteractiveLegend.LegendContainerClassName = 'legend-container';
            DonutChartInteractiveLegend.LegendContainerSelector = '.legend-container';
            DonutChartInteractiveLegend.LegendItemClassName = 'legend-item';
            DonutChartInteractiveLegend.LegendItemSelector = '.legend-item';
            DonutChartInteractiveLegend.LegendItemCategoryClassName = 'category';
            DonutChartInteractiveLegend.LegendItemPercentageClassName = 'percentage';
            DonutChartInteractiveLegend.LegendItemValueClassName = 'value';
            DonutChartInteractiveLegend.MaxLegendItemBoxSize = 160;
            DonutChartInteractiveLegend.ItemMargin = 30; // Margin between items
            DonutChartInteractiveLegend.MinimumSwipeDX = 15; // Minimup swipe gesture to create a change in the legend
            DonutChartInteractiveLegend.MinimumItemsInLegendForCycled = 3; // Minimum items in the legend before we cycle it
            return DonutChartInteractiveLegend;
        }());
        var DonutChartConversion;
        (function (DonutChartConversion) {
            ;
            var DonutChartConverter = (function () {
                function DonutChartConverter(dataView, colors, defaultDataPointColor, tooltipsEnabled) {
                    if (tooltipsEnabled === void 0) { tooltipsEnabled = true; }
                    var dataViewCategorical = dataView.categorical;
                    this.dataViewCategorical = dataViewCategorical;
                    this.dataViewMetadata = dataView.metadata;
                    this.tooltipsEnabled = tooltipsEnabled;
                    this.seriesCount = dataViewCategorical.values ? dataViewCategorical.values.length : 0;
                    this.colorHelper = new visuals.ColorHelper(colors, visuals.donutChartProps.dataPoint.fill, defaultDataPointColor);
                    this.maxValue = 0;
                    if (dataViewCategorical.categories && dataViewCategorical.categories.length > 0) {
                        var category = dataViewCategorical.categories[0];
                        this.categoryIdentities = category.identity;
                        this.categoryValues = category.values;
                        this.allCategoryObjects = category.objects;
                        this.categoryColumnRef = category.identityFields;
                        this.categoryFormatString = visuals.valueFormatter.getFormatString(category.source, visuals.donutChartProps.general.formatString);
                    }
                    var grouped = this.grouped = dataViewCategorical && dataViewCategorical.values ? dataViewCategorical.values.grouped() : undefined;
                    this.isMultiMeasure = grouped && grouped.length > 0 && grouped[0].values && grouped[0].values.length > 1;
                    this.isSingleMeasure = grouped && grouped.length === 1 && grouped[0].values && grouped[0].values.length === 1;
                    this.isDynamicSeries = !!(dataViewCategorical.values && dataViewCategorical.values.source);
                    this.hasHighlights = this.seriesCount > 0 && !_.isEmpty(dataViewCategorical.values) && !!dataViewCategorical.values[0].highlights;
                    this.highlightsOverflow = false;
                    this.total = 0;
                    this.highlightTotal = 0;
                    this.dataPoints = [];
                    this.legendDataPoints = [];
                    this.dataLabelsSettings = null;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex];
                        for (var measureIndex = 0; measureIndex < seriesData.values.length; measureIndex++) {
                            this.total += Math.abs(seriesData.values[measureIndex]);
                            this.highlightTotal += this.hasHighlights ? Math.abs(seriesData.highlights[measureIndex]) : 0;
                        }
                    }
                    this.total = visuals.AxisHelper.normalizeNonFiniteNumber(this.total);
                    this.highlightTotal = visuals.AxisHelper.normalizeNonFiniteNumber(this.highlightTotal);
                }
                DonutChartConverter.normalizedMeasureAndValue = function (measureAndValue) {
                    var normalized = $.extend(true, {}, measureAndValue);
                    normalized.measure = visuals.AxisHelper.normalizeNonFiniteNumber(normalized.measure);
                    normalized.value = visuals.AxisHelper.normalizeNonFiniteNumber(normalized.value);
                    return normalized;
                };
                DonutChartConverter.prototype.convert = function () {
                    var convertedData;
                    if (this.total !== 0) {
                        // We render based on categories, series, or measures in that order of preference
                        if (this.categoryValues) {
                            convertedData = this.convertCategoricalWithSlicing();
                        }
                        else if (this.isDynamicSeries) {
                            // Series but no category.
                            convertedData = this.convertSeries();
                        }
                        else {
                            // No category or series; only measures.
                            convertedData = this.convertMeasures();
                        }
                    }
                    else {
                        convertedData = [];
                    }
                    // Check if any of the highlight values are > non-highlight values
                    var highlightsOverflow = false;
                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount && !highlightsOverflow; i++) {
                        var point = convertedData[i];
                        if (Math.abs(point.highlightMeasureValue.measure) > Math.abs(point.measureValue.measure)) {
                            highlightsOverflow = true;
                        }
                    }
                    // Create data labels settings
                    this.dataLabelsSettings = this.convertDataLabelSettings();
                    var dataViewMetadata = this.dataViewMetadata;
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            this.legendObjectProperties = objects['legend'];
                        }
                    }
                    this.dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    var prevPointColor;
                    var pctFormatString = visuals.valueFormatter.getLocalizedString('Percentage');
                    for (var i = 0, dataPointCount = convertedData.length; i < dataPointCount; i++) {
                        var point = convertedData[i];
                        // Normalize the values here and then handle tooltip value as infinity
                        var normalizedHighlight = DonutChartConverter.normalizedMeasureAndValue(point.highlightMeasureValue);
                        var normalizedNonHighlight = DonutChartConverter.normalizedMeasureAndValue(point.measureValue);
                        var measure = normalizedNonHighlight.measure;
                        var percentage = (this.total > 0) ? normalizedNonHighlight.value / this.total : 0.0;
                        var highlightRatio = void 0;
                        var highlightPercentage = void 0;
                        if (normalizedNonHighlight.value > this.maxValue)
                            this.maxValue = normalizedNonHighlight.value;
                        if (normalizedHighlight.value > this.maxValue)
                            this.maxValue = normalizedHighlight.value;
                        if (this.hasHighlights) {
                            // When any highlight value is greater than the corresponding non-highlight value
                            // we just render all of the highlight values and discard the non-highlight values.
                            if (highlightsOverflow) {
                                measure = normalizedHighlight.measure;
                                percentage = (this.highlightTotal > 0) ? normalizedHighlight.value / this.highlightTotal : 0.0;
                                highlightRatio = 1;
                            }
                            else {
                                highlightRatio = normalizedNonHighlight.value !== 0 ? normalizedHighlight.value / normalizedNonHighlight.value : 0;
                            }
                            if (!highlightRatio) {
                                highlightRatio = DonutChart.EffectiveZeroValue;
                            }
                            highlightPercentage = percentage * highlightRatio;
                        }
                        var categoryValue = point.categoryLabel;
                        var categorical = this.dataViewCategorical;
                        var valueIndex = void 0;
                        if (point.seriesIndex != null) {
                            valueIndex = point.seriesIndex;
                        }
                        else if (_.isEmpty(categorical.categories)) {
                            // Static series with no categories
                            valueIndex = i;
                        }
                        var valuesMetadata = categorical.values[valueIndex].source;
                        var value = this.hasHighlights && highlightsOverflow ? point.highlightMeasureValue.measure : point.measureValue.measure;
                        var highlightValue = this.hasHighlights && !highlightsOverflow ? point.highlightMeasureValue.measure : undefined;
                        var formatString = visuals.valueFormatter.getFormatString(valuesMetadata, formatStringProp);
                        var valueAndPct = void 0;
                        if (value != null) {
                            var pct = visuals.valueFormatter.format(percentage, pctFormatString);
                            valueAndPct = visuals.valueFormatter.format(value, formatString) + ' (' + pct + ')';
                        }
                        var highlightValueAndPct = void 0;
                        if (this.hasHighlights && highlightValue != null && highlightPercentage != null) {
                            var highlightedPct = visuals.valueFormatter.format(highlightPercentage, pctFormatString);
                            highlightValueAndPct = visuals.valueFormatter.format(highlightValue, formatString) + ' (' + highlightedPct + ')';
                        }
                        var tooltipInfo = void 0;
                        if (this.tooltipsEnabled) {
                            tooltipInfo = visuals.TooltipBuilder.createTooltipInfo(formatStringProp, categorical, categoryValue, valueAndPct, null, null, valueIndex, i, highlightValueAndPct);
                        }
                        var strokeWidth = prevPointColor === point.color && value && value > 0 ? 1 : 0;
                        prevPointColor = value && value > 0 ? point.color : prevPointColor;
                        this.dataPoints.push({
                            identity: point.identity,
                            measure: measure,
                            measureFormat: point.measureFormat,
                            percentage: percentage,
                            index: point.index,
                            label: point.label,
                            highlightRatio: highlightRatio,
                            highlightValue: highlightValue,
                            selected: false,
                            tooltipInfo: tooltipInfo,
                            color: point.color,
                            strokeWidth: strokeWidth,
                            labelFormatString: valuesMetadata.format,
                        });
                    }
                    this.legendData = this.convertLegendData();
                };
                DonutChartConverter.prototype.getLegendTitle = function () {
                    if (this.total !== 0) {
                        // If category exists, we render title using category source. If not, we render title
                        // using measure.
                        var dvValuesSourceName = this.dataViewCategorical.values && this.dataViewCategorical.values.source
                            ? this.dataViewCategorical.values.source.displayName : "";
                        var dvCategorySourceName = this.dataViewCategorical.categories && this.dataViewCategorical.categories.length > 0 && this.dataViewCategorical.categories[0].source
                            ? this.dataViewCategorical.categories[0].source.displayName : "";
                        if (this.categoryValues) {
                            return dvCategorySourceName;
                        }
                        else {
                            return dvValuesSourceName;
                        }
                    }
                    else {
                        return "";
                    }
                };
                DonutChartConverter.prototype.convertCategoricalWithSlicing = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    var dataPoints = [];
                    for (var categoryIndex = 0, categoryCount = this.categoryValues.length; categoryIndex < categoryCount; categoryIndex++) {
                        var categoryValue = this.categoryValues[categoryIndex];
                        var thisCategoryObjects = this.allCategoryObjects ? this.allCategoryObjects[categoryIndex] : undefined;
                        var legendIdentity = visuals.SelectionId.createWithId(this.categoryIdentities[categoryIndex]);
                        var color = this.colorHelper.getColorForSeriesValue(thisCategoryObjects, this.categoryColumnRef, categoryValue);
                        var categoryLabel = visuals.valueFormatter.format(categoryValue, this.categoryFormatString);
                        // Series are either measures in the multi-measure case, or the single series otherwise
                        for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                            var seriesData = dataViewCategorical.values[seriesIndex];
                            var label = this.isSingleMeasure
                                ? categoryLabel
                                : visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                            var nonHighlight = seriesData.values[categoryIndex] || 0;
                            var highlight = void 0;
                            if (this.hasHighlights) {
                                highlight = seriesData.highlights[categoryIndex] != null ? seriesData.highlights[categoryIndex] : null;
                            }
                            var measure = seriesData.source.queryName;
                            var identity = visuals.SelectionIdBuilder.builder()
                                .withCategory(dataViewCategorical.categories[0], categoryIndex)
                                .withSeries(dataViewCategorical.values, this.isDynamicSeries ? seriesData : undefined)
                                .withMeasure(measure)
                                .createSelectionId();
                            var dataPoint = {
                                identity: identity,
                                measureFormat: visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, true),
                                measureValue: {
                                    measure: nonHighlight,
                                    value: Math.abs(nonHighlight),
                                },
                                highlightMeasureValue: {
                                    measure: highlight,
                                    value: highlight != null ? Math.abs(highlight) : null,
                                },
                                index: categoryIndex * this.seriesCount + seriesIndex,
                                label: label,
                                categoryLabel: categoryLabel,
                                color: color,
                                seriesIndex: seriesIndex
                            };
                            dataPoints.push(dataPoint);
                        }
                        this.legendDataPoints.push({
                            label: categoryLabel,
                            color: color,
                            icon: visuals.LegendIcon.Box,
                            identity: legendIdentity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertMeasures = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    for (var measureIndex = 0; measureIndex < this.seriesCount; measureIndex++) {
                        var measureData = dataViewCategorical.values[measureIndex];
                        var measureFormat = visuals.valueFormatter.getFormatString(measureData.source, formatStringProp, true);
                        var measureLabel = measureData.source.displayName;
                        var identity = visuals.SelectionId.createWithMeasure(measureData.source.queryName);
                        debug.assert(measureData.values.length > 0, 'measure should have data points');
                        debug.assert(!this.hasHighlights || measureData.highlights.length > 0, 'measure with highlights should have highlight data points');
                        var nonHighlight = measureData.values[0] || 0;
                        var highlight = this.hasHighlights ? measureData.highlights[0] || 0 : 0;
                        var color = this.colorHelper.getColorForMeasure(measureData.source.objects, measureData.source.queryName);
                        var dataPoint = {
                            identity: identity,
                            measureFormat: measureFormat,
                            measureValue: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight),
                            },
                            highlightMeasureValue: {
                                measure: highlight,
                                value: Math.abs(highlight),
                            },
                            index: measureIndex,
                            label: measureLabel,
                            categoryLabel: measureLabel,
                            color: color
                        };
                        dataPoints.push(dataPoint);
                        this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: visuals.LegendIcon.Box,
                            identity: dataPoint.identity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertSeries = function () {
                    var dataViewCategorical = this.dataViewCategorical;
                    var dataPoints = [];
                    var formatStringProp = visuals.donutChartProps.general.formatString;
                    for (var seriesIndex = 0; seriesIndex < this.seriesCount; seriesIndex++) {
                        var seriesData = dataViewCategorical.values[seriesIndex];
                        var seriesFormat = visuals.valueFormatter.getFormatString(seriesData.source, formatStringProp, true);
                        var label = visuals.converterHelper.getFormattedLegendLabel(seriesData.source, dataViewCategorical.values, formatStringProp);
                        var identity = new visuals.SelectionIdBuilder()
                            .withSeries(dataViewCategorical.values, seriesData)
                            .withMeasure(seriesData.source.queryName)
                            .createSelectionId();
                        var seriesName = visuals.converterHelper.getSeriesName(seriesData.source);
                        var objects = this.grouped && this.grouped[seriesIndex] && this.grouped[seriesIndex].objects;
                        debug.assert(seriesData.values.length > 0, 'measure should have data points');
                        debug.assert(!this.hasHighlights || seriesData.highlights.length > 0, 'measure with highlights should have highlight data points');
                        var nonHighlight = seriesData.values[0] || 0;
                        var highlight = this.hasHighlights ? seriesData.highlights[0] || 0 : 0;
                        var color = this.colorHelper.getColorForSeriesValue(objects, dataViewCategorical.values.identityFields, seriesName);
                        var dataPoint = {
                            identity: identity,
                            measureFormat: seriesFormat,
                            measureValue: {
                                measure: nonHighlight,
                                value: Math.abs(nonHighlight),
                            },
                            highlightMeasureValue: {
                                measure: highlight,
                                value: Math.abs(highlight),
                            },
                            index: seriesIndex,
                            label: label,
                            categoryLabel: label,
                            color: color,
                            seriesIndex: seriesIndex
                        };
                        dataPoints.push(dataPoint);
                        this.legendDataPoints.push({
                            label: dataPoint.label,
                            color: dataPoint.color,
                            icon: visuals.LegendIcon.Box,
                            identity: dataPoint.identity,
                            selected: false
                        });
                    }
                    return dataPoints;
                };
                DonutChartConverter.prototype.convertDataLabelSettings = function () {
                    var dataViewMetadata = this.dataViewMetadata;
                    var dataLabelsSettings = visuals.dataLabelUtils.getDefaultDonutLabelSettings();
                    if (dataViewMetadata) {
                        var objects = dataViewMetadata.objects;
                        if (objects) {
                            // Handle lables settings
                            var labelsObj = objects['labels'];
                            if (labelsObj) {
                                visuals.dataLabelUtils.updateLabelSettingsFromLabelsObject(labelsObj, dataLabelsSettings);
                            }
                        }
                    }
                    return dataLabelsSettings;
                };
                DonutChartConverter.prototype.convertLegendData = function () {
                    return {
                        dataPoints: this.legendDataPoints,
                        labelColor: visuals.LegendData.DefaultLegendLabelFillColor,
                        title: this.getLegendTitle(),
                        fontSize: visuals.SVGLegend.DefaultFontSizeInPt,
                    };
                };
                return DonutChartConverter;
            }());
            DonutChartConversion.DonutChartConverter = DonutChartConverter;
        })(DonutChartConversion || (DonutChartConversion = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var Utility = jsCommon.Utility;
        var ScriptVisual = (function () {
            function ScriptVisual(options) {
                this.canRefresh = options.canRefresh;
            }
            ScriptVisual.prototype.init = function (options) {
                this.element = options.element;
                this.hostServices = options.host;
                if (!this.canRefresh) {
                    this.hostServices.setWarnings([new visuals.ScriptVisualRefreshWarning()]);
                }
            };
            ScriptVisual.prototype.update = function (options) {
                debug.assertValue(options, 'options');
                var dataViews = options.dataViews;
                if (!dataViews || dataViews.length === 0)
                    return;
                var dataView = dataViews[0];
                if (!dataView || !dataView.metadata)
                    return;
                var imageUrl = this.getImageUrl(dataView);
                var div = this.ensureHtmlElement();
                if (imageUrl && Utility.isValidImageDataUrl(imageUrl)) {
                    var viewport = options.viewport;
                    div.css({ height: viewport.height, width: viewport.width, backgroundImage: 'url(' + imageUrl + ')' });
                }
                else {
                    div.css({ backgroundImage: 'none' });
                }
            };
            ScriptVisual.prototype.onResizing = function (finalViewport) {
                var div = this.ensureHtmlElement();
                div.css({ height: finalViewport.height, width: finalViewport.width });
            };
            ScriptVisual.prototype.getImageUrl = function (dataView) {
                debug.assertValue(dataView, 'dataView');
                if (dataView.scriptResult && dataView.scriptResult.imageBase64) {
                    return "data:image/png;base64," + dataView.scriptResult.imageBase64;
                }
                return null;
            };
            ScriptVisual.prototype.ensureHtmlElement = function () {
                var div = this.imageBackgroundElement;
                if (!div) {
                    div = $("<div class='imageBackground' />");
                    this.imageBackgroundElement = div;
                    this.imageBackgroundElement.appendTo(this.element);
                }
                return div;
            };
            return ScriptVisual;
        }());
        visuals.ScriptVisual = ScriptVisual;
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var plugins;
        (function (plugins) {
            // This file registers the built-in visualizations
            plugins.animatedNumber = {
                name: 'animatedNumber',
                capabilities: visuals.capabilities.animatedNumber,
                create: function () { return new visuals.AnimatedNumber(); }
            };
            plugins.areaChart = {
                name: 'areaChart',
                watermarkKey: 'area',
                capabilities: visuals.capabilities.lineChart,
                create: function () { return new visuals.CartesianChart({ chartType: 1 /* Area */ }); },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.barChart = {
                name: 'barChart',
                watermarkKey: 'bar',
                capabilities: visuals.capabilities.barChart,
                create: function () { return new visuals.CartesianChart({ chartType: 6 /* StackedBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.basicShape = {
                name: 'basicShape',
                capabilities: visuals.basicShapeCapabilities,
                create: function () { return new visuals.BasicShapeVisual(); }
            };
            plugins.card = {
                name: 'card',
                watermarkKey: 'card',
                capabilities: visuals.capabilities.card,
                create: function () { return new visuals.Card(); }
            };
            plugins.multiRowCard = {
                name: 'multiRowCard',
                watermarkKey: 'multiRowCard',
                capabilities: visuals.capabilities.multiRowCard,
                create: function () { return new visuals.MultiRowCard(); },
                getSortableRoles: function (visualSortableOptions) { return visuals.MultiRowCard.getSortableRoles(visualSortableOptions); },
            };
            plugins.clusteredBarChart = {
                name: 'clusteredBarChart',
                watermarkKey: 'clusteredBar',
                capabilities: visuals.capabilities.clusteredBarChart,
                create: function () { return new visuals.CartesianChart({ chartType: 5 /* ClusteredBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.clusteredColumnChart = {
                name: 'clusteredColumnChart',
                watermarkKey: 'clusteredColumn',
                capabilities: visuals.capabilities.clusteredColumnChart,
                create: function () { return new visuals.CartesianChart({ chartType: 3 /* ClusteredColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.columnChart = {
                name: 'columnChart',
                watermarkKey: 'column',
                capabilities: visuals.capabilities.columnChart,
                create: function () { return new visuals.CartesianChart({ chartType: 4 /* StackedColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.comboChart = {
                name: 'comboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.comboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 10 /* ComboChart */ }); },
                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.dataDotChart = {
                name: 'dataDotChart',
                capabilities: visuals.capabilities.dataDotChart,
                create: function () { return new visuals.CartesianChart({ chartType: 11 /* DataDot */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.dataDotClusteredColumnComboChart = {
                name: 'dataDotClusteredColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.dataDotClusteredColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 15 /* DataDotClusteredColumnCombo */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.dataDotStackedColumnComboChart = {
                name: 'dataDotStackedColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.dataDotStackedColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 16 /* DataDotStackedColumnCombo */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.donutChart = {
                name: 'donutChart',
                watermarkKey: 'donut',
                capabilities: visuals.capabilities.donutChart,
                create: function () { return new visuals.DonutChart(); }
            };
            plugins.funnel = {
                name: 'funnel',
                watermarkKey: 'funnel',
                capabilities: visuals.capabilities.funnel,
                create: function () { return new visuals.FunnelChart(); }
            };
            plugins.gauge = {
                name: 'gauge',
                watermarkKey: 'gauge',
                capabilities: visuals.capabilities.gauge,
                create: function () { return new visuals.Gauge(); }
            };
            plugins.hundredPercentStackedBarChart = {
                name: 'hundredPercentStackedBarChart',
                watermarkKey: '100stackedbar',
                capabilities: visuals.capabilities.hundredPercentStackedBarChart,
                create: function () { return new visuals.CartesianChart({ chartType: 7 /* HundredPercentStackedBar */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.hundredPercentStackedColumnChart = {
                name: 'hundredPercentStackedColumnChart',
                watermarkKey: '100stackedcolumn',
                capabilities: visuals.capabilities.hundredPercentStackedColumnChart,
                create: function () { return new visuals.CartesianChart({ chartType: 8 /* HundredPercentStackedColumn */ }); },
                customizeQuery: visuals.ColumnChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.image = {
                name: 'image',
                capabilities: visuals.capabilities.image,
                create: function () { return new visuals.ImageVisual(); }
            };
            plugins.lineChart = {
                name: 'lineChart',
                watermarkKey: 'line',
                capabilities: visuals.capabilities.lineChart,
                create: function () { return new visuals.CartesianChart({ chartType: 0 /* Line */ }); },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.LineChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.lineStackedColumnComboChart = {
                name: 'lineStackedColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.lineStackedColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 14 /* LineStackedColumnCombo */ }); },
                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.lineClusteredColumnComboChart = {
                name: 'lineClusteredColumnComboChart',
                watermarkKey: 'combo',
                capabilities: visuals.capabilities.lineClusteredColumnComboChart,
                customizeQuery: visuals.ComboChart.customizeQuery,
                create: function () { return new visuals.CartesianChart({ chartType: 13 /* LineClusteredColumnCombo */ }); },
                getSortableRoles: function (visualSortableOptions) { return visuals.ComboChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.map = {
                name: 'map',
                watermarkKey: 'map',
                capabilities: visuals.capabilities.map,
                create: function () { return new visuals.Map({ filledMap: false }); }
            };
            plugins.filledMap = {
                name: 'filledMap',
                watermarkKey: 'filledMap',
                capabilities: visuals.capabilities.filledMap,
                create: function () { return new visuals.Map({ filledMap: true }); }
            };
            plugins.treemap = {
                name: 'treemap',
                watermarkKey: 'tree',
                capabilities: visuals.capabilities.treemap,
                create: function () { return new visuals.Treemap(); }
            };
            plugins.pieChart = {
                name: 'pieChart',
                watermarkKey: 'pie',
                capabilities: visuals.capabilities.donutChart,
                create: function () { return new visuals.DonutChart({ sliceWidthRatio: 0 }); }
            };
            plugins.scatterChart = {
                name: 'scatterChart',
                watermarkKey: 'scatterplot',
                capabilities: visuals.capabilities.scatterChart,
                create: function () { return new visuals.CartesianChart({ chartType: 9 /* Scatter */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.ScatterChart.getAdditionalTelemetry(dataView); },
            };
            plugins.stackedAreaChart = {
                name: 'stackedAreaChart',
                watermarkKey: 'stackedarea',
                capabilities: visuals.capabilities.lineChart,
                create: function () { return new visuals.CartesianChart({ chartType: 2 /* StackedArea */ }); },
                customizeQuery: visuals.LineChart.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.ColumnChart.getSortableRoles(visualSortableOptions); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.table = {
                name: 'table',
                watermarkKey: 'table',
                capabilities: visuals.capabilities.table,
                create: function () { return new visuals.Table(); },
                customizeQuery: visuals.Table.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.Table.getSortableRoles(); },
            };
            plugins.matrix = {
                name: 'matrix',
                watermarkKey: 'matrix',
                capabilities: visuals.capabilities.matrix,
                create: function () { return new visuals.Matrix(); },
                customizeQuery: visuals.Matrix.customizeQuery,
                getSortableRoles: function (visualSortableOptions) { return visuals.Matrix.getSortableRoles(); },
            };
            plugins.slicer = {
                name: 'slicer',
                watermarkKey: 'slicer',
                capabilities: visuals.capabilities.slicer,
                create: function () { return new visuals.Slicer(); }
            };
            plugins.textbox = {
                name: 'textbox',
                capabilities: visuals.capabilities.textbox,
                create: function () { return new visuals.Textbox(); }
            };
            plugins.waterfallChart = {
                name: 'waterfallChart',
                watermarkKey: 'waterfall',
                capabilities: visuals.capabilities.waterfallChart,
                create: function () { return new visuals.CartesianChart({ chartType: 12 /* Waterfall */ }); },
                getAdditionalTelemetry: function (dataView) { return visuals.CartesianChart.getAdditionalTelemetry(dataView); },
            };
            plugins.cheerMeter = {
                name: 'cheerMeter',
                capabilities: visuals.CheerMeter.capabilities,
                create: function () { return new visuals.CheerMeter(); }
            };
            plugins.consoleWriter = {
                name: 'consoleWriter',
                capabilities: visuals.samples.consoleWriterCapabilities,
                create: function () { return new visuals.samples.ConsoleWriter(); }
            };
            plugins.helloIVisual = {
                name: 'helloIVisual',
                capabilities: visuals.samples.HelloIVisual.capabilities,
                create: function () { return new visuals.samples.HelloIVisual(); }
            };
            plugins.owlGauge = {
                name: 'owlGauge',
                watermarkKey: 'gauge',
                capabilities: visuals.OwlGauge.capabilities,
                create: function () { return new visuals.OwlGauge(); }
            };
            plugins.scriptVisual = {
                name: 'scriptVisual',
                watermarkKey: 'scriptvisual',
                capabilities: visuals.capabilities.scriptVisual,
                create: function () { return new visuals.ScriptVisual({ canRefresh: false }); }
            };
            plugins.kpi = {
                name: 'kpi',
                watermarkKey: 'kpi',
                capabilities: visuals.capabilities.kpi,
                create: function () { return new visuals.KPIStatusWithHistory(); }
            };
        })(plugins = visuals.plugins || (visuals.plugins = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));
/*
 *  Power BI Visualizations
 *
 *  Copyright (c) Microsoft Corporation
 *  All rights reserved.
 *  MIT License
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the ""Software""), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
var powerbi;
(function (powerbi) {
    var visuals;
    (function (visuals) {
        var CanvasBackgroundHelper;
        (function (CanvasBackgroundHelper) {
            function getDefaultColor() {
                return '#FFFFFF';
            }
            CanvasBackgroundHelper.getDefaultColor = getDefaultColor;
            function getDefaultValues() {
                return {
                    color: getDefaultColor(),
                };
            }
            CanvasBackgroundHelper.getDefaultValues = getDefaultValues;
        })(CanvasBackgroundHelper = visuals.CanvasBackgroundHelper || (visuals.CanvasBackgroundHelper = {}));
    })(visuals = powerbi.visuals || (powerbi.visuals = {}));
})(powerbi || (powerbi = {}));



//# sourceMappingURL=powerbi-visuals.js.map
